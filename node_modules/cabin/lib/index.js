"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          {{ req.ip }}\xA0\n          [{{ req.id ? req.id : new Date().toUTCString() }}]\xA0\n          \"\n          {{ req.method }}\xA0\n          {{ req.url }}\xA0\n          HTTP/{{ req.httpVersionMajor }}.{{ req.httpVersionMinor }}\n          \"\xA0\n          {{ res.statusCode }}\xA0\n          {{ res.get('X-Response-Time') }}\n        "], ["\n          {{ req.ip }}\\u00A0\n          [{{ req.id ? req.id : new Date().toUTCString() }}]\\u00A0\n          \"\n          {{ req.method }}\\u00A0\n          {{ req.url }}\\u00A0\n          HTTP/{{ req.httpVersionMajor }}.{{ req.httpVersionMinor }}\n          \"\\u00A0\n          {{ res.statusCode }}\\u00A0\n          {{ res.get('X-Response-Time') }}\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Axe = require('axe');

var parseRequest = require('parse-request');

var parseErr = require('parse-err');

var onFinished = require('on-finished');

var safeStringify = require('fast-safe-stringify'); // <https://lacke.mn/reduce-your-bundle-js-file-size/>
// <https://github.com/lodash/babel-plugin-lodash/issues/221>


var isUndefined = require('lodash/isUndefined');

var isNull = require('lodash/isNull');

var isFunction = require('lodash/isFunction');

var isError = require('lodash/isError');

var isArray = require('lodash/isArray');

var isString = require('lodash/isString');

var isNumber = require('lodash/isNumber');

var isObject = require('lodash/isObject');

var isEmpty = require('lodash/isEmpty');

var tmpl = require('lodash/template');

var _require = require('common-tags'),
    oneLineTrim = _require.oneLineTrim;

var appInfo = require('./app-info');

var Cabin =
/*#__PURE__*/
function () {
  function Cabin(config) {
    var _this = this;

    _classCallCheck(this, Cabin);

    this.config = _objectSpread({
      key: '',
      axe: {},
      logger: null,
      meta: {},
      // <https://github.com/niftylettuce/parse-request>
      userFields: undefined,
      // <https://github.com/niftylettuce/parse-err>
      fields: [],
      message: oneLineTrim(_templateObject()),
      // <https://lodash.com/docs#template>
      templateSettings: {
        interpolate: /{{([\s\S]+?)}}/g
      }
    }, config); // override key with root key in case user forgot

    if (!isEmpty(this.config.axe) && this.config.key) this.config.axe.key = this.config.key;
    if (!isEmpty(this.config.axe)) this.config.logger = new Axe(this.config.axe);else if (this.config.key) this.config.logger = new Axe({
      key: this.config.key
    });
    if (!isObject(this.config.logger)) this.config.logger = new Axe(); // bind the logger

    this.logger = this.config.logger; // parse arg helper

    this.parseArg = this.parseArg.bind(this); // bind helper functions for each log level

    Object.keys(this.logger).filter(function (key) {
      return isFunction(_this.logger[key]);
    }).forEach(function (level) {
      _this[level] = function () {
        var _this$logger;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        args[1] = _this.parseArg(args[1]);

        (_this$logger = _this.logger)[level].apply(_this$logger, _toConsumableArray([].slice.call(args)));
      };
    }); // aliases

    this.err = this.error;
    this.warning = this.warn; // we'd use `auto-bind` package but unfortunately it
    // doesn't have a compiled version without `const` etc

    this.setMeta = this.setMeta.bind(this);
    this.setUser = this.setUser.bind(this);
    this.middleware = this.middleware.bind(this); // backwards compatibility with older `getMeta` method

    this.getMeta = parseRequest; // expose parseRequest and parseErr

    this.parseRequest = parseRequest;
    this.parseErr = parseErr;
  }

  _createClass(Cabin, [{
    key: "parseArg",
    value: function parseArg(arg) {
      if (isUndefined(arg) || isNull(arg)) arg = {};
      if (isError(arg)) arg = {
        err: parseErr(arg, this.config.fields)
      };
      if (isArray(arg)) arg = {
        value: arg
      };
      if (isString(arg)) arg = {
        value: arg
      };
      if (isNumber(arg)) arg = {
        value: arg
      };
      if (isFunction(arg)) arg = {
        value: arg.toString()
      };
      if (!isObject(arg)) arg = {};
      Object.assign(arg, this.config.meta);
      return arg;
    }
  }, {
    key: "setMeta",
    value: function setMeta() {
      var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.config.meta = meta;
    }
  }, {
    key: "setUser",
    value: function setUser() {
      var user = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.config.meta.user = user;
    } // TODO: this should probably not be in the browser bundled version
    // and we should do some `require('./middleware')` with a
    // `"browser": { "./middleware": }` rewrite that includes
    // something else that can be consumed by xhook or something

  }, {
    key: "middleware",
    value: function middleware() {
      var _this2 = this;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var isExpress = !isUndefined(args[2]) && isFunction(args[2]);
      var req = isExpress ? args[0] : args[0].req;
      var res = isExpress ? args[1] : args[0].res;
      var next = isExpress ? args[2] : args[1];
      var logger = {};
      Object.keys(this.logger).filter(function (key) {
        return isFunction(_this2.logger[key]);
      }).forEach(function (key) {
        logger[key] = function () {
          var _this2$logger;

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          args[1] = _this2.parseArg(args[1]); // add `app` object to metadata

          Object.assign(args[1], appInfo); // add `request` object to metadata

          Object.assign(args[1], parseRequest(req, _this2.config.userFields));

          (_this2$logger = _this2.logger)[key].apply(_this2$logger, _toConsumableArray([].slice.call(args)));
        };
      }); // store a copy of the request body
      // in case we modified it in our middleware
      // (a common practice unfortunately)

      var body = safeStringify(req.body); // upon completion of a response we need to log it

      onFinished(res, function (err, res) {
        if (err) return logger.error(err);
        var level = 'info';
        if (res.statusCode >= 500) level = 'error';else if (res.statusCode >= 400) level = 'warn';
        logger[level](tmpl(_this2.config.message, _objectSpread({}, _this2.config.templateSettings))({
          req: _objectSpread({}, req, {
            body: body
          }),
          res: isExpress ? res : args[0].response
        }).trim());
      }); // add `log` (shorthand) and `logger` methods
      // `req.log`
      // `res.log`
      // `ctx.req`
      // `ctx.res`
      // `ctx.request`
      // `ctx.response`
      // <https://github.com/pinojs/koa-pino-logger/issues/14>
      // <https://github.com/pinojs/koa-pino-logger/blob/master/logger.js#L11>
      // <https://github.com/pinojs/pino-http/blob/master/logger.js#L55>

      req.log = logger;
      res.log = logger;
      req.logger = logger;
      res.logger = logger;

      if (!isExpress) {
        var ctx = args[0];
        ctx.log = logger;
        ctx.logger = logger;
        ctx.request.log = logger;
        ctx.request.logger = logger;
        ctx.response.log = logger;
        ctx.response.logger = logger;
      }

      return next();
    }
  }]);

  return Cabin;
}();

Cabin.Axe = Axe;
Cabin.parseRequest = parseRequest;
Cabin.parseErr = parseErr;
module.exports = Cabin;