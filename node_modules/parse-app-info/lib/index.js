"use strict";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const readPkgUp = require('read-pkg-up');

const LastCommitLog = require('last-commit-log');
/**
 * A safe way to query for git infos.
 *
 * @return {object|undefined} Returns {hash, gitTag} or undefined in case of an error
 */


function getLastCommit() {
  return _getLastCommit.apply(this, arguments);
}
/**
 * Information about the app.
 *
 * The git infos can be missing if the project has no commit yet
 * or is not connected to a git repo.
 *
 * @typedef {Object} AppInfo
 * @property {string} name The name of the app
 * @property {string} version The version of the app
 * @property {string} node NodeJS version
 * @property {string} hash Last git commit hash
 * @property {string} tag Last git tag, if any
 * @property {string} environment Nodejs environment the app is run in
 * @property {string} hostname Name of the computer the app is run on
 * @property {number} pid Process ID of the app
 */

/**
 * Retrieves informations about the current running app.
 *
 * @async
 * @return {Promise<AppInfo>} A promise that resolves the app info
 */


function _getLastCommit() {
  _getLastCommit = _asyncToGenerator(function* () {
    try {
      const lastCommitLog = new LastCommitLog();

      const _ref = yield lastCommitLog.getLastCommit(),
            hash = _ref.hash,
            gitTag = _ref.gitTag; // Add gitTag only when it exists


      const result = {
        hash
      };

      if (gitTag) {
        result.tag = gitTag;
      }

      return result;
    } catch (err) {}
  });
  return _getLastCommit.apply(this, arguments);
}

function parseAppInfo() {
  return _parseAppInfo.apply(this, arguments);
}

function _parseAppInfo() {
  _parseAppInfo = _asyncToGenerator(function* () {
    const _ref2 = yield Promise.all([readPkgUp(), getLastCommit()]),
          _ref3 = _slicedToArray(_ref2, 2),
          packageInfo = _ref3[0],
          lastCommit = _ref3[1];

    const _process$env = process.env,
          NODE_ENV = _process$env.NODE_ENV,
          HOSTNAME = _process$env.HOSTNAME;
    return _objectSpread({
      name: packageInfo.pkg.name,
      version: packageInfo.pkg.version,
      node: process.version
    }, lastCommit, {
      environment: NODE_ENV || 'development',
      hostname: HOSTNAME || require('os').hostname(),
      pid: process.pid
    });
  });
  return _parseAppInfo.apply(this, arguments);
}

module.exports = parseAppInfo;