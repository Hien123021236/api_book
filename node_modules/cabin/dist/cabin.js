(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Cabin = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function Agent() {
  this._defaults = [];
}

['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert'].forEach(function (fn) {
  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._defaults.push({
      fn: fn,
      args: args
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, _toConsumableArray(def.args));
  });
};

module.exports = Agent;
},{}],2:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Root reference for iframes.
 */
var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self !== 'undefined') {
  // Web Worker
  root = self;
} else {
  // Other environments
  console.warn('Using browser-only version of superagent in non-browser environment');
  root = void 0;
}

var Emitter = require('component-emitter');

var RequestBase = require('./request-base');

var isObject = require('./is-object');

var ResponseBase = require('./response-base');

var Agent = require('./agent-base');
/**
 * Noop.
 */


function noop() {}
/**
 * Expose `request`.
 */


var request = exports = module.exports = function (method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (arguments.length == 1) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || root.location.protocol != 'file:' || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  }

  try {
    return new ActiveXObject('Microsoft.XMLHTTP');
  } catch (e) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.6.0');
  } catch (e) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.3.0');
  } catch (e) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP');
  } catch (e) {}

  throw new Error('Browser-only version of superagent could not find XHR');
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */


var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];

  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */


function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function (v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for (var subkey in val) {
        pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}
/**
 * Expose serialization method.
 */


request.serializeObject = serialize;
/**
 * Parse the given x-www-form-urlencoded `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}
/**
 * Expose parser.
 */


request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  form: 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};
/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(str){
 *       return { object parsed from str };
 *     };
 *
 */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */


function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders()); // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (this.text === null && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
  }
}

ResponseBase(Response.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, str);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var msg = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;
  return err;
};
/**
 * Expose `Response`.
 */


request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType === 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);
    var new_err;

    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (custom_err) {
      new_err = custom_err; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */


Emitter(Request.prototype);
RequestBase(Request.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: typeof btoa === 'function' ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if (typeof btoa === 'function') {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (val) {
  if (typeof val !== 'string') val = serialize(val);
  if (val) this._query.push(val);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */


Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;
  err.status = this.status;
  err.method = this.method;
  err.url = this.url;
  this.callback(err);
}; // This only warns, because the request is still likely to work


Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
  console.warn('This is not supported in browser version of superagent');
  return this;
}; // This throws, because it can't send/receive data as expected


Request.prototype.pipe = Request.prototype.write = function () {
  throw new Error('Streaming is not supported in browser version of superagent');
};
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */


Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && _typeof(obj) === 'object' && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn('Warning: .end() was called twice. This is not supported in superagent');
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function () {
  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (readyState != 4) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (e) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }; // progress


  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.addEventListener('progress', handleProgress.bind(null, 'download'));

      if (xhr.upload) {
        xhr.upload.addEventListener('progress', handleProgress.bind(null, 'upload'));
      }
    } catch (e) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && this.method != 'GET' && this.method != 'HEAD' && typeof data !== 'string' && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];

    var _serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!_serialize && isJSON(contentType)) {
      _serialize = request.serialize['application/json'];
    }

    if (_serialize) data = _serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (this.header[field] == null) continue;
    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = function () {
  return new Agent();
};

['GET', 'POST', 'OPTIONS', 'PATCH', 'PUT', 'DELETE'].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);

    this._setDefaults(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype.delete;
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.head = function (url, data, fn) {
  var req = request('HEAD', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


function del(url, data, fn) {
  var req = request('DELETE', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request.del = del;
request.delete = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.post = function (url, data, fn) {
  var req = request('POST', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.put = function (url, data, fn) {
  var req = request('PUT', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
},{"./agent-base":1,"./is-object":3,"./request-base":4,"./response-base":5,"component-emitter":93}],3:[function(require,module,exports){
'use strict';
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isObject(obj) {
  return obj !== null && _typeof(obj) === 'object';
}

module.exports = isObject;
},{}],4:[function(require,module,exports){
'use strict';
/**
 * Module of mixed-in functions shared between node and client code
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isObject = require('./is-object');
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }

  return obj;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function _clearTimeout() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function parse(fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function serialize(fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function timeout(options) {
  if (!options || _typeof(options) !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for (var option in options) {
    switch (option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;

      case 'response':
        this._responseTimeout = options.response;
        break;

      default:
        console.warn('Unknown timeout option', option);
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function retry(count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];
/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (e) {
      console.error(e);
    }
  }

  if (res && res.status && res.status >= 500 && res.status != 501) return true;

  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true; // Superagent timeout

    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }

    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
      self.on('error', innerReject);
      self.end(function (err, res) {
        if (err) innerReject(err);else innerResolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if (typeof cb !== 'function') throw new Error('Callback required');
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};
/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }

    return this;
  } // val should be defined now


  if (val === null || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if (typeof val === 'boolean') {
    val = String(val);
  }

  this._getFormData().append(name, val);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser

  this.req && this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', "Bearer ".concat(user));
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  } // merge


  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];

    if (type == 'application/x-www-form-urlencoded') {
      this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');

      if (typeof this._sort === 'function') {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }

      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.trace('Unsupported');
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error("".concat(reason + timeout, "ms exceeded"));
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};
},{"./is-object":3}],5:[function(require,module,exports){
'use strict';
/**
 * Module dependencies.
 */

var utils = require('./utils');
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.status = this.statusCode = status;
  this.statusType = type; // basics

  this.info = type == 1;
  this.ok = type == 2;
  this.redirect = type == 3;
  this.clientError = type == 4;
  this.serverError = type == 5;
  this.error = type == 4 || type == 5 ? this.toError() : false; // sugar

  this.created = status == 201;
  this.accepted = status == 202;
  this.noContent = status == 204;
  this.badRequest = status == 400;
  this.unauthorized = status == 401;
  this.notAcceptable = status == 406;
  this.forbidden = status == 403;
  this.notFound = status == 404;
  this.unprocessableEntity = status == 422;
};
},{"./utils":6}],6:[function(require,module,exports){
'use strict';
/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();
    if (key && val) obj[key] = val;
    return obj;
  }, {});
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host; // secuirty

  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }

  return header;
};
},{}],7:[function(require,module,exports){
/**
 * @file Creates an array with all elements that pass the test by the provided function.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-filter-x
 */

'use strict';

var toObject = require('to-object-x');
var assertIsFunction = require('assert-is-function-x');
var some = require('array-some-x');

var $filter = function filter(array, callBack /* , thisArg */) {
  var object = toObject(array);
  // If no callback function or if callback is not a callable function
  assertIsFunction(callBack);
  var result = [];
  var wrapped = function _wrapped(item, idx, obj) {
    // eslint-disable-next-line no-invalid-this
    if (callBack.call(this, item, idx, obj)) {
      result[result.length] = item;
    }
  };

  var args = [object, wrapped];
  if (arguments.length > 2) {
    args[2] = arguments[2];
  }

  some.apply(void 0, args);
  return result;
};

/**
 * This method creates a new array with all elements that pass the test
 * implemented by the provided function.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function is a predicate, to test each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {array} A new array with the elements that pass the test.
 * @example
 * var filter = require('array-filter-x');
 *
 * function isBigEnough(value) {
 *   return value >= 10;
 * }
 *
 * var filtered = filter([12, 5, 8, 130, 44], isBigEnough);
 * // filtered is [12, 130, 44]
 */
module.exports = $filter;

},{"array-some-x":25,"assert-is-function-x":30,"to-object-x":446}],8:[function(require,module,exports){
/**
 * @file Executes a provided function once for each array element.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-for-each-x
 */

'use strict';

var toObject = require('to-object-x');
var assertIsFunction = require('assert-is-function-x');
var some = require('array-some-x');

var $forEach = function forEach(array, callBack /* , thisArg */) {
  var object = toObject(array);
  // If no callback function or if callback is not a callable function
  assertIsFunction(callBack);
  var wrapped = function _wrapped(item, idx, obj) {
    // eslint-disable-next-line no-invalid-this
    callBack.call(this, item, idx, obj);
  };

  var args = [object, wrapped];
  if (arguments.length > 2) {
    args[2] = arguments[2];
  }

  some.apply(void 0, args);
};

/**
 * This method executes a provided function once for each array element.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to execute for each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @example
 * var forEach = require('array-for-each-x');
 *
 * var items = ['item1', 'item2', 'item3'];
 * var copy = [];
 *
 * forEach(items, function(item){
 *   copy.push(item)
 * });
 */
module.exports = $forEach;

},{"array-some-x":25,"assert-is-function-x":30,"to-object-x":446}],9:[function(require,module,exports){
/**
 * @file Determines whether an array includes a certain element.
 * @version 1.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-includes-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeIncludes = Array.prototype.includes;
var $includes;

if (nativeIncludes) {
  var arr = {
    1: 'a',
    2: NaN,
    3: -0,
    length: 5
  };

  try {
    if (nativeIncludes.call(arr, void 0, -1) && nativeIncludes.call(arr, NaN) && nativeIncludes.call('abc', 'c')) {
      $includes = function includes(array, searchElement) {
        var object = toObject(array);
        var args = [searchElement];
        if (arguments.length > 2) {
          args[1] = arguments[2];
        }

        return nativeIncludes.apply(object, args);
      };
    }
  } catch (ignore) {}
}

if (Boolean($includes) === false) {
  var isString = require('is-string');
  var isUndefined = require('validate.io-undefined');
  var toLength = require('to-length-x');
  var sameValueZero = require('same-value-zero-x');
  var findIndex = require('find-index-x');
  var splitString = require('has-boxed-string-x') === false;
  var indexOf = require('index-of-x');
  var calcFromIndex = require('calculate-from-index-x');

  /*
   * This method returns an index in the array, if an element in the array
   * satisfies the provided testing function. Otherwise -1 is returned.
   *
   * @private
   * @param {Array} object - The array to search.
   * @param {*} searchElement - Element to locate in the array.
   * @param {number} fromIndex - The index to start the search at.
   * @returns {number} Returns index of found element, otherwise -1.
   */
  var findIdxFrom = function findIndexFrom(object, searchElement, fromIndex) {
    var fIdx = fromIndex;
    var length = toLength(object.length);
    while (fIdx < length) {
      if (sameValueZero(object[fIdx], searchElement)) {
        return fIdx;
      }

      fIdx += 1;
    }

    return -1;
  };

  $includes = function includes(array, searchElement) {
    var object = toObject(array);
    var iterable = splitString && isString(object) ? object.split('') : object;
    var length = toLength(iterable.length);
    if (length < 1) {
      return -1;
    }

    if (isUndefined(searchElement)) {
      var fromIndex = calcFromIndex(iterable, arguments[2]);
      if (fromIndex >= length) {
        return -1;
      }

      if (fromIndex < 0) {
        fromIndex = 0;
      }

      if (fromIndex > 0) {
        return findIdxFrom(iterable, searchElement, fromIndex) > -1;
      }

      return findIndex(iterable, function (element) {
        return sameValueZero(searchElement, element);
      }) > -1;
    }

    return indexOf(iterable, searchElement, arguments[2], 'samevaluezero') > -1;
  };
}

/**
 * This method determines whether an array includes a certain element,
 * returning true or false as appropriate.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If `array` is `null` or `undefined`.
 * @param {*} searchElement - Element to locate in the `array`.
 * @param {number} [fromIndex] - The position in this array at which to begin
 *  searching for searchElement. A negative value searches from the index of
 *  array.length + fromIndex by asc. Defaults to 0.
 * @returns {boolean} `true` if searched element is included; otherwise `false`.
 * @example
 * var includes = require('array-includes-x');
 *
 * var subject = [2, 3, undefined, true, 'hej', null, 2, false, 0, -0, NaN];
 * includes(subject, undefined); // true
 * includes(subject, undefined, 3); // false
 * includes(subject, NaN); // true
 * includes(subject, 10); // false
 *
 */
module.exports = $includes;

},{"calculate-from-index-x":37,"find-index-x":105,"has-boxed-string-x":121,"index-of-x":129,"is-string":186,"same-value-zero-x":434,"to-length-x":13,"to-object-x":446,"validate.io-undefined":459}],10:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Number.isFinite.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-number.isfinite|20.1.2.2 Number.isFinite ( number )}
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-finite-x
 */

'use strict';

var $isNaN = require('is-nan');

var $isFinite;
if (typeof Number.isFinite === 'function') {
  var MAX_SAFE_INTEGER = require('max-safe-integer');
  try {
    if (Number.isFinite(MAX_SAFE_INTEGER) && Number.isFinite(Infinity) === false) {
      $isFinite = Number.isFinite;
    }
  } catch (ignore) {}
}

/**
 * This method determines whether the passed value is a finite number.
 *
 * @param {*} number - The value to be tested for finiteness.
 * @returns {boolean} A Boolean indicating whether or not the given value is a finite number.
 * @example
 * var numIsFinite = require('is-finite-x');
 *
 * numIsFinite(Infinity);  // false
 * numIsFinite(NaN);       // false
 * numIsFinite(-Infinity); // false
 *
 * numIsFinite(0);         // true
 * numIsFinite(2e64);      // true
 *
 * numIsFinite('0');       // false, would've been true with
 *                         // global isFinite('0')
 * numIsFinite(null);      // false, would've been true with
 */
module.exports = $isFinite || function isFinite(number) {
  return !(typeof number !== 'number' || $isNaN(number) || number === Infinity || number === -Infinity);
};

},{"is-nan":170,"max-safe-integer":397}],11:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Math.sign.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-math.sign|20.2.2.29 Math.sign(x)}
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-sign-x
 */

'use strict';

var $isNaN = require('is-nan');

var $sign;
if (typeof Math.sign === 'function') {
  try {
    if (Math.sign(10) === 1 && Math.sign(-10) === -1 && Math.sign(0) === 0) {
      $sign = Math.sign;
    }
  } catch (ignore) {}
}

/**
 * This method returns the sign of a number, indicating whether the number is positive,
 * negative or zero.
 *
 * @param {*} x - A number.
 * @returns {number} A number representing the sign of the given argument. If the argument
 * is a positive number, negative number, positive zero or negative zero, the function will
 * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
 * @example
 * var mathSign = require('math-sign-x');
 *
 * mathSign(3);     //  1
 * mathSign(-3);    // -1
 * mathSign('-3');  // -1
 * mathSign(0);     //  0
 * mathSign(-0);    // -0
 * mathSign(NaN);   // NaN
 * mathSign('foo'); // NaN
 * mathSign();      // NaN
 */
module.exports = $sign || function sign(x) {
  var n = Number(x);
  if (n === 0 || $isNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

},{"is-nan":170}],12:[function(require,module,exports){
/**
 * @file ToInteger converts 'argument' to an integral numeric value.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger|7.1.4 ToInteger ( argument )}
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-integer-x
 */

'use strict';

var $isNaN = require('is-nan');
var $isFinite = require('is-finite-x');
var $sign = require('math-sign-x');

/**
 * Converts `value` to an integer.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 *
 * @example
 * var toInteger = require('to-integer-x');
 * toInteger(3); // 3
 * toInteger(Number.MIN_VALUE); // 0
 * toInteger(Infinity); // 1.7976931348623157e+308
 * toInteger('3'); // 3
 */
module.exports = function ToInteger(value) {
  var number = Number(value);
  if ($isNaN(number)) {
    return 0;
  }

  if (number === 0 || $isFinite(number) === false) {
    return number;
  }

  return $sign(number) * Math.floor(Math.abs(number));
};

},{"is-finite-x":10,"is-nan":170,"math-sign-x":11}],13:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToLength.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tolength|7.1.15 ToLength ( argument )}
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-length-x
 */

'use strict';

var toInteger = require('to-integer-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 * var toLength = require('to-length-x');
 * toLength(3); // 3
 * toLength(Number.MIN_VALUE); // 0
 * toLength(Infinity); // Number.MAX_SAFE_INTEGER
 * toLength('3'); // 3
 */
module.exports = function ToLength(value) {
  var len = toInteger(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

},{"max-safe-integer":397,"to-integer-x":12}],14:[function(require,module,exports){
/**
 * @file Cross-browser array-like slicer.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-like-slice-x
 */

'use strict';

var toObject = require('to-object-x');
var toInteger = require('to-integer-x').toInteger2018;
var toLength = require('to-length-x').toLength2018;
var isUndefined = require('validate.io-undefined');
var splitIfBoxedBug = require('split-if-boxed-bug-x');

var getMax = function _getMax(a, b) {
  return a >= b ? a : b;
};

var getMin = function _getMin(a, b) {
  return a <= b ? a : b;
};

var setRelative = function _setRelative(value, length) {
  return value < 0 ? getMax(length + value, 0) : getMin(value, length);
};

/**
 * The slice() method returns a shallow copy of a portion of an array into a new
 * array object selected from begin to end (end not included). The original
 * array will not be modified.
 *
 * @param {!Object} argsObject - The `arguments` to slice.
 * @param {number} [start] - Zero-based index at which to begin extraction.
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(-2) extracts the last two elements in the sequence.
 *  If begin is undefined, slice begins from index 0.
 * @param {number} [end] - Zero-based index before which to end extraction.
 *  Slice extracts up to but not including end. For example, slice([0,1,2,3,4],1,4)
 *  extracts the second element through the fourth element (elements indexed
 *  1, 2, and 3).
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(2,-1) extracts the third element through the second-to-last
 *  element in the sequence.
 *  If end is omitted, slice extracts through the end of the sequence (arr.length).
 *  If end is greater than the length of the sequence, slice extracts through
 *  the end of the sequence (arr.length).
 * @returns {Array} A new array containing the extracted elements.
 * @example
 * var arrayLikeSlice = require('array-like-slice-x');
 * var args = (function () {
    return arguments;
 * }('Banana', 'Orange', 'Lemon', 'Apple', 'Mango'));
 *
 * var citrus = arrayLikeSlice(args, 1, 3);
 *
 * // args contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
 * // citrus contains ['Orange','Lemon']
 */
module.exports = function slice(arrayLike, start, end) {
  var iterable = splitIfBoxedBug(toObject(arrayLike));
  var length = toLength(iterable.length);
  var k = setRelative(toInteger(start), length);
  var relativeEnd = isUndefined(end) ? length : toInteger(end);
  var finalEnd = setRelative(relativeEnd, length);
  var val = [];
  val.length = getMax(finalEnd - k, 0);
  var next = 0;
  while (k < finalEnd) {
    if (k in iterable) {
      val[next] = iterable[k];
    }

    next += 1;
    k += 1;
  }

  return val;
};

},{"split-if-boxed-bug-x":435,"to-integer-x":439,"to-length-x":441,"to-object-x":446,"validate.io-undefined":459}],15:[function(require,module,exports){
/**
 * @file Creates an array with the results of calling a function on every element.
 * @version 2.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-map-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var ArrayCtr = cachedCtrs.Array;
var castObject = cachedCtrs.Object;
var nativeMap = typeof ArrayCtr.prototype.map === 'function' && ArrayCtr.prototype.map;

var isWorking;
if (nativeMap) {
  var attempt = require('attempt-x');
  var spy = 0;
  var res = attempt.call([1, 2], nativeMap, function (item) {
    return item;
  });

  isWorking = res.threw === false && res.value && res.value.length === 2 && res.value[0] === 1 && res.value[1] === 2;

  if (isWorking) {
    spy = '';
    res = attempt.call(castObject('ab'), nativeMap, function (item) {
      return item;
    });

    isWorking = res.threw === false && res.value && res.value.length === 2 && res.value[0] === 'a' && res.value[1] === 'b';
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call((function () {
      return arguments;
    }(1, 2)), nativeMap, function (item) {
      return item;
    });

    isWorking = res.threw === false && res.value && res.value.length === 2 && res.value[0] === 1 && res.value[1] === 2;
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call({
      0: 1,
      2: 2,
      length: 3
    }, nativeMap, function (item) {
      return item;
    });

    isWorking = res.threw === false && res.value && res.value.length === 3 && (1 in res.value) === false;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      spy = null;
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativeMap, function (item) {
        return item;
      });

      isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === div;
    }
  }

  if (isWorking) {
    var isStrict = (function () {
      // eslint-disable-next-line no-invalid-this
      return Boolean(this) === false;
    }());

    if (isStrict) {
      spy = null;
      res = attempt.call([1], nativeMap, function () {
        // eslint-disable-next-line no-invalid-this
        spy = typeof this === 'string';
      }, 'x');

      isWorking = res.threw === false && res.value && res.value.length === 1 && spy === true;
    }
  }

  if (isWorking) {
    spy = {};
    var fn = [
      'return nativeMap.call("foo", function (_, __, context) {',
      'if (Boolean(context) === false || typeof context !== "object") {',
      'spy.value = true;}});'
    ].join('');

    // eslint-disable-next-line no-new-func
    res = attempt(Function('nativeMap', 'spy', fn), nativeMap, spy);

    isWorking = res.threw === false && res.value && res.value.length === 3 && spy.value !== true;
  }
}

var $map;
if (nativeMap) {
  $map = function map(array, callBack /* , thisArg */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativeMap.apply(array, args);
  };
} else {
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x').toLength2018;
  var isUndefined = require('validate.io-undefined');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $map = function map(array, callBack /* , thisArg */) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var noThis = isUndefined(thisArg);
    var result = [];
    result.length = length;
    for (var i = 0; i < length; i += 1) {
      if (i in iterable) {
        var item = iterable[i];
        result[i] = noThis ? callBack(item, i, object) : callBack.call(thisArg, item, i, object);
      }
    }

    return result;
  };
}

/**
 * This method creates a new array with the results of calling a provided
 * function on every element in the calling array.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function that produces an element of the Array.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {array} A new array with each element being the result of the
 * callback function.
 * @example
 * var map = require('array-map-x');
 *
 * var numbers = [1, 4, 9];
 * var roots = map(numbers, Math.sqrt);
 * // roots is now [1, 2, 3]
 * // numbers is still [1, 4, 9]
 */
module.exports = $map;

},{"assert-is-function-x":16,"attempt-x":32,"cached-constructors-x":36,"split-if-boxed-bug-x":435,"to-length-x":441,"to-object-x":446,"validate.io-undefined":459}],16:[function(require,module,exports){
/**
 * @file If isFunction(callbackfn) is false, throw a TypeError exception.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-function-x
 */

'use strict';

var isFunction = require('is-function-x');
var safeToString = require('to-string-symbols-supported-x');
var isPrimitive = require('is-primitive');

/**
 * Tests `callback` to see if it is a function, throws a `TypeError` if it is
 * not. Otherwise returns the `callback`.
 *
 * @param {*} callback - The argument to be tested.
 * @throws {TypeError} Throws if `callback` is not a function.
 * @returns {*} Returns `callback` if it is function.
 * @example
 * var assertIsFunction = require('assert-is-function-x');
 * var primitive = true;
 * var mySymbol = Symbol('mySymbol');
 * var symObj = Object(mySymbol);
 * var object = {};
 * function fn () {}
 *
 * assertIsFunction(primitive);
 *    // TypeError 'true is not a function'.
 * assertIsFunction(object);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(mySymbol);
 *    // TypeError 'Symbol(mySymbol) is not a function'.
 * assertIsFunction(symObj);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(fn);
 *    // Returns fn.
 */
module.exports = function assertIsFunction(callback) {
  if (isFunction(callback) === false) {
    var msg = isPrimitive(callback) ? safeToString(callback) : '#<Object>';
    throw new TypeError(msg + ' is not a function');
  }

  return callback;
};

},{"is-function-x":162,"is-primitive":178,"to-string-symbols-supported-x":449}],17:[function(require,module,exports){
/**
 * @file Reduce an array (from left to right) to a single value.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-reduce-x
 */

'use strict';

var attempt = require('attempt-x');
var nativeReduce = typeof Array.prototype.reduce === 'function' && Array.prototype.reduce;

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
var isWorking;
if (nativeReduce) {
  isWorking = attempt.call([], nativeReduce, function (acc) {
    return acc;
  }).threw;

  var res;
  if (isWorking) {
    res = attempt.call(Object('abc'), nativeReduce, function (acc, c) {
      return acc + c;
    }, 'x');

    isWorking = res.threw === false && res.value === 'xabc';
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }(1, 2, 3)), nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 1);

    isWorking = res.threw === false && res.value === 7;
  }

  if (isWorking) {
    res = attempt.call({
      0: 1,
      1: 2,
      3: 3,
      4: 4,
      length: 4
    }, nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 2);

    isWorking = res.threw === false && res.value === 8;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativeReduce, function (acc, node) {
        acc[acc.length] = node;
        return acc;
      }, []);

      isWorking = res.threw === false && res.value.length === 1 && res.value[0] === div;
    }
  }

  if (isWorking) {
    // eslint-disable-next-line max-params
    res = attempt.call('ab', nativeReduce, function (_, __, ___, list) {
      return list;
    });

    isWorking = res.threw === false && typeof res.value === 'object';
  }
}

var $reduce;
if (nativeReduce && isWorking) {
  $reduce = function reduce(array, callBack /* , initialValue */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativeReduce.apply(array, args);
  };
} else {
  // Check failure of by-index access of string characters (IE < 9)
  // and failure of `0 in boxedString` (Rhino)
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $reduce = function reduce(array, callBack /* , initialValue*/) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var argsLength = arguments.length;
    // no value to return if no initial value and an empty array
    if (length === 0 && argsLength < 3) {
      throw new TypeError('reduce of empty array with no initial value');
    }

    var i = 0;
    var result;
    if (argsLength > 2) {
      result = arguments[2];
    } else {
      // eslint-disable-next-line no-constant-condition
      do {
        if (i in iterable) {
          result = iterable[i];
          i += 1;
          // eslint-disable-next-line no-restricted-syntax
          break;
        }

        // if array contains no values, no initial value to return
        i += 1;
        if (i >= length) {
          throw new TypeError('reduce of empty array with no initial value');
        }
      } while (true);
    }

    while (i < length) {
      if (i in iterable) {
        result = callBack(result, iterable[i], i, object);
      }

      i += 1;
    }

    return result;
  };
}

/**
 * This method applies a function against an accumulator and each element in the
 * array (from left to right) to reduce it to a single value.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to execute for each element.
 * @param {*} [initialValue] - Value to use as the first argument to the first
 *  call of the callback. If no initial value is supplied, the first element in
 *  the array will be used. Calling reduce on an empty array without an initial
 *  value is an error.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @throws {TypeError} If called on an empty array without an initial value.
 * @returns {*} The value that results from the reduction.
 * @example
 * var reduce = require('array-reduce-x');
 *
 * var sum = reduce([0, 1, 2, 3], function (a, b) {
 *   return a + b;
 * }, 0);
 * // sum is 6
 */
module.exports = $reduce;

},{"assert-is-function-x":18,"attempt-x":32,"split-if-boxed-bug-x":435,"to-length-x":22,"to-object-x":446}],18:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":162,"is-primitive":178,"to-string-symbols-supported-x":449}],19:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Math.sign.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-math.sign|20.2.2.29 Math.sign(x)}
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-sign-x
 */

'use strict';

var toNumber = require('to-number-x');
var numberIsNaN = require('is-nan-x');

/**
 * This method returns the sign of a number, indicating whether the number is positive,
 * negative or zero.
 *
 * @param {*} x - A number.
 * @returns {number} A number representing the sign of the given argument. If the argument
 * is a positive number, negative number, positive zero or negative zero, the function will
 * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
 * @example
 * var mathSign = require('math-sign-x');
 *
 * mathSign(3);     //  1
 * mathSign(-3);    // -1
 * mathSign('-3');  // -1
 * mathSign(0);     //  0
 * mathSign(-0);    // -0
 * mathSign(NaN);   // NaN
 * mathSign('foo'); // NaN
 * mathSign();      // NaN
 */
module.exports = function sign(x) {
  var n = toNumber(x);
  if (n === 0 || numberIsNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

},{"is-nan-x":168,"to-number-x":23}],20:[function(require,module,exports){
/**
 * @file Parses a string argument and returns an integer of the specified radix.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module parse-int-x
 */

'use strict';

var nativeParseInt = parseInt;
var ws = require('white-space-x').string;
var toStr = require('to-string-x');

var $parseInt;
if (nativeParseInt(ws + '08') === 8 && nativeParseInt(ws + '0x16') === 22) {
  $parseInt = function parseInteger(string, radix) {
    return nativeParseInt(toStr(string), radix);
  };
} else {
  var trim = require('trim-x');
  var castNumber = require('cached-constructors-x').Number;
  var hexRegex = /^[-+]?0[xX]/;
  var test = hexRegex.test;

  $parseInt = function parseInteger(string, radix) {
    var str = trim(toStr(string));

    return nativeParseInt(str, castNumber(radix) || (test.call(hexRegex, str) ? 16 : 10));
  };
}

/**
 * This method parses a string argument and returns an integer of the specified
 * radix (the base in mathematical numeral systems).
 *
 * @param {string} string - The value to parse. If the string argument is not a
 *  string, then it is converted to a string (using the ToString abstract
 *  operation). Leading whitespace in the string argument is ignored.
 * @param {number} radix - An integer between 2 and 36 that represents the radix
 *  (the base in mathematical numeral systems) of the above mentioned string.
 *  Specify 10 for the decimal numeral system commonly used by humans. Always
 *  specify this parameter to eliminate reader confusion and to guarantee
 *  predictable behavior. Different implementations produce different results
 *  when a radix is not specified, usually defaulting the value to 10.
 * @throws {TypeError} If target is a Symbol or is not coercible.
 * @returns {number} An integer number parsed from the given string. If the first
 *  character cannot be converted to a number, NaN is returned.
 * @example
 * var $parseInt = require('parse-int-x');
 *
 * // The following examples all return 15
 * $parseInt(' 0xF', 16);
 * $parseInt(' F', 16);
 * $parseInt('17', 8);
 * $parseInt(021, 8);
 * $parseInt('015', 10);   // $parseInt(015, 10); will return 15
 * $parseInt(15.99, 10);
 * $parseInt('15,123', 10);
 * $parseInt('FXX123', 16);
 * $parseInt('1111', 2);
 * $parseInt('15 * 3', 10);
 * $parseInt('15e2', 10);
 * $parseInt('15px', 10);
 * $parseInt('12', 13);
 *
 * //The following examples all return NaN:
 * $parseInt('Hello', 8); // Not a number at all
 * $parseInt('546', 2);   // Digits are not valid for binary representations
 */
module.exports = $parseInt;

},{"cached-constructors-x":36,"to-string-x":451,"trim-x":455,"white-space-x":460}],21:[function(require,module,exports){
/**
 * @file ToInteger converts 'argument' to an integral numeric value.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger|7.1.4 ToInteger ( argument )}
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-integer-x
 */

'use strict';

var toNumber = require('to-number-x');
var numberIsNaN = require('is-nan-x');
var numberIsFinite = require('is-finite-x');
var mathSign = require('math-sign-x');

/**
 * Converts `value` to an integer.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 *
 * @example
 * var toInteger = require('to-integer-x');
 * toInteger(3); // 3
 * toInteger(Number.MIN_VALUE); // 0
 * toInteger(Infinity); // 1.7976931348623157e+308
 * toInteger('3'); // 3
 */
module.exports = function toInteger(value) {
  var number = toNumber(value);
  if (numberIsNaN(number)) {
    return 0;
  }

  if (number === 0 || numberIsFinite(number) === false) {
    return number;
  }

  return mathSign(number) * Math.floor(Math.abs(number));
};

},{"is-finite-x":161,"is-nan-x":168,"math-sign-x":19,"to-number-x":23}],22:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToLength.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tolength|7.1.15 ToLength ( argument )}
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-length-x
 */

'use strict';

var toInteger = require('to-integer-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 * var toLength = require('to-length-x');
 * toLength(3); // 3
 * toLength(Number.MIN_VALUE); // 0
 * toLength(Infinity); // Number.MAX_SAFE_INTEGER
 * toLength('3'); // 3
 */
module.exports = function toLength(value) {
  var len = toInteger(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

},{"max-safe-integer":397,"to-integer-x":21}],23:[function(require,module,exports){
/**
 * @file Converts argument to a value of type Number.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-number-x
 */

'use strict';

var constructors = require('cached-constructors-x');
var castNumber = require('cached-constructors-x').Number;
var Rx = constructors.RegExp;
var toPrimitive = require('to-primitive-x');
var trim = require('trim-x');
var $parseInt = require('parse-int-x');
var pStrSlice = ''.slice;
var NAN = require('nan-x');

var binaryRegex = /^0b[01]+$/i;
// Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
var test = binaryRegex.test;
var isBinary = function _isBinary(value) {
  return test.call(binaryRegex, value);
};

var octalRegex = /^0o[0-7]+$/i;
var isOctal = function _isOctal(value) {
  return test.call(octalRegex, value);
};

var nonWSregex = new Rx('[\u0085\u200b\ufffe]', 'g');
var hasNonWS = function _hasNonWS(value) {
  return test.call(nonWSregex, value);
};

var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = function _isInvalidHexLiteral(value) {
  return test.call(invalidHexLiteral, value);
};

/**
 * This method converts argument to a value of type Number.

 * @param {*} argument - The argument to convert to a number.
 * @throws {TypeError} - If argument is a Symbol or not coercible.
 * @returns {*} The argument converted to a number.
 * @example
 * var toNumber = require('to-number-x');
 *
 * toNumber('1'); // 1
 * toNumber(null); // 0
 * toNumber(true); // 1
 * toNumber('0o10'); // 8
 * toNumber('0b10'); // 2
 * toNumber('0xF'); // 16
 *
 * toNumber(' 1 '); // 1
 *
 * toNumber(Symbol('')) // TypeError
 * toNumber(Object.create(null)) // TypeError
 */
module.exports = function toNumber(argument) {
  var value = toPrimitive(argument, Number);
  if (typeof value === 'symbol') {
    throw new TypeError('Cannot convert a Symbol value to a number');
  }

  if (typeof value === 'string') {
    if (isBinary(value)) {
      return toNumber($parseInt(pStrSlice.call(value, 2), 2));
    }

    if (isOctal(value)) {
      return toNumber($parseInt(pStrSlice.call(value, 2), 8));
    }

    if (hasNonWS(value) || isInvalidHexLiteral(value)) {
      return NAN;
    }

    var trimmed = trim(value);
    if (trimmed !== value) {
      return toNumber(trimmed);
    }
  }

  return castNumber(value);
};

},{"cached-constructors-x":36,"nan-x":404,"parse-int-x":20,"to-primitive-x":447,"trim-x":455}],24:[function(require,module,exports){
/**
 * @file Cross-browser array slicer.
 * @version 3.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-slice-x
 */

'use strict';

var toObject = require('to-object-x');
var isArguments = require('is-arguments');
var isArray = require('is-array-x');
var arrayLikeSlice = require('array-like-slice-x');
var nativeSlice = require('cached-constructors-x').Array.prototype.slice;
var isString;
var failArr;
var failDOM;
if (nativeSlice) {
  var attempt = require('attempt-x');
  var res = attempt.call([
    1,
    2,
    3
  ], nativeSlice, 1, 2);

  failArr = res.threw || isArray(res.value) === false || res.value.length !== 1 || res.value[0] !== 2;
  if (failArr === false) {
    res = attempt.call('abc', nativeSlice, 1, 2);
    isString = (res.threw || res.value.length !== 1 || res.value[0] !== 'b') && require('is-string');
    var doc = typeof document !== 'undefined' && document;
    failDOM = doc && attempt.call(doc.documentElement, nativeSlice).threw;
  }
} else {
  failArr = true;
}

/**
 * The slice() method returns a shallow copy of a portion of an array into a new
 * array object selected from begin to end (end not included). The original
 * array will not be modified.
 *
 * @param {Array|Object} array - The array to slice.
 * @param {number} [start] - Zero-based index at which to begin extraction.
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(-2) extracts the last two elements in the sequence.
 *  If begin is undefined, slice begins from index 0.
 * @param {number} [end] - Zero-based index before which to end extraction.
 *  Slice extracts up to but not including end. For example, slice(1,4)
 *  extracts the second element through the fourth element (elements indexed
 *  1, 2, and 3).
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(2,-1) extracts the third element through the second-to-last
 *  element in the sequence.
 *  If end is omitted, slice extracts through the end of the
 *  sequence (arr.length).
 *  If end is greater than the length of the sequence, slice extracts through
 *  the end of the sequence (arr.length).
 * @returns {Array} A new array containing the extracted elements.
 * @example
 * var slice = require('array-slice-x');
 * var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
 * var citrus = slice(fruits, 1, 3);
 *
 * // fruits contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
 * // citrus contains ['Orange','Lemon']
 */
module.exports = function slice(array, start, end) {
  var object = toObject(array);
  if (failArr || (failDOM && isArray(object) === false) || (isString && isString(object)) || isArguments(object)) {
    return arrayLikeSlice(object, start, end);
  }

  return nativeSlice.apply(object, arrayLikeSlice(arguments, 1));
};

},{"array-like-slice-x":14,"attempt-x":32,"cached-constructors-x":36,"is-arguments":150,"is-array-x":153,"is-string":186,"to-object-x":446}],25:[function(require,module,exports){
/**
 * @file Tests whether some element passes the provided function.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-some-x
 */

'use strict';

var toObject = require('to-object-x');
var assertIsFunction = require('assert-is-function-x');

var tests = {
  // Check node 0.6.21 bug where third parameter is not boxed
  properlyBoxesNonStrict: true,
  properlyBoxesStrict: true
};

var nativeSome = Array.prototype.some;
if (nativeSome) {
  try {
    nativeSome.call([1], function () {
      // eslint-disable-next-line no-invalid-this
      tests.properlyBoxesStrict = typeof this === 'string';
    }, 'x');

    var fn = [
      'return nativeSome.call("foo", function (_, __, context) {',
      'if (Boolean(context) === false || typeof context !== "object") {',
      'tests.properlyBoxesNonStrict = false;}});'
    ].join('');

    // eslint-disable-next-line no-new-func
    Function('nativeSome', 'tests', fn)(nativeSome, tests);
  } catch (e) {
    nativeSome = null;
  }
}

var $some;
if (nativeSome && tests.properlyBoxesNonStrict && tests.properlyBoxesStrict) {
  $some = function some(array, callBack /* , thisArg */) {
    var object = toObject(array);
    var args = [assertIsFunction(callBack)];
    if (arguments.length > 2) {
      args.push(arguments[2]);
    }

    return nativeSome.apply(object, args);
  };
} else {
  // ES5 15.4.4.17
  // http://es5.github.com/#x15.4.4.17
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
  var isString = require('is-string');
  var toLength = require('to-length-x');
  var isUndefined = require('validate.io-undefined');
  var splitString = require('has-boxed-string-x') === false;
  $some = function some(array, callBack /* , thisArg */) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitString && isString(object) ? object.split('') : object;
    var length = toLength(iterable.length);
    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    for (var i = 0; i < length; i += 1) {
      if (i in iterable) {
        var result;
        if (isUndefined(thisArg)) {
          result = callBack(iterable[i], i, object);
        } else {
          result = callBack.call(thisArg, iterable[i], i, object);
        }

        if (result) {
          return true;
        }
      }
    }

    return false;
  };
}

/**
 * This method tests whether some element in the array passes the test
 * implemented by the provided function.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to test for each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {boolean} `true` if the callback function returns a truthy value for
 *  any array element; otherwise, `false`.
 * @example
 * var some = require('array-some-x');
 *
 * function isBiggerThan10(element, index, array) {
 *   return element > 10;
 * }
 *
 * some([2, 5, 8, 1, 4], isBiggerThan10);  // false
 * some([12, 5, 8, 1, 4], isBiggerThan10); // true
 */
module.exports = $some;

},{"assert-is-function-x":30,"has-boxed-string-x":121,"is-string":186,"to-length-x":29,"to-object-x":446,"validate.io-undefined":459}],26:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"is-nan":170,"max-safe-integer":397}],27:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11,"is-nan":170}],28:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12,"is-finite-x":26,"is-nan":170,"math-sign-x":27}],29:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"max-safe-integer":397,"to-integer-x":28}],30:[function(require,module,exports){
/**
 * @file If isFunction(callbackfn) is false, throw a TypeError exception.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-function-x
 */

'use strict';

var isFunction = require('is-function-x');
var safeToString = require('safe-to-string-x');
var isPrimitive = require('is-primitive');

/**
 * Tests `callback` to see if it is a function, throws a `TypeError` if it is
 * not. Otherwise returns the `callback`.
 *
 * @param {*} callback - The argument to be tested.
 * @throws {TypeError} Throws if `callback` is not a function.
 * @returns {*} Returns `callback` if it is function.
 * @example
 * var assertIsFunction = require('assert-is-function-x');
 * var primitive = true;
 * var mySymbol = Symbol('mySymbol');
 * var symObj = Object(mySymbol);
 * var object = {};
 * function fn () {}
 *
 * assertIsFunction(primitive);
 *    // TypeError 'true is not a function'.
 * assertIsFunction(object);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(mySymbol);
 *    // TypeError 'Symbol(mySymbol) is not a function'.
 * assertIsFunction(symObj);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(fn);
 *    // Returns fn.
 */
module.exports = function assertIsFunction(callback) {
  if (isFunction(callback) === false) {
    var msg = isPrimitive(callback) ? safeToString(callback) : '#<Object>';
    throw new TypeError(msg + ' is not a function');
  }
  return callback;
};

},{"is-function-x":162,"is-primitive":178,"safe-to-string-x":432}],31:[function(require,module,exports){
/**
 * @file If IsObject(value) is false, throw a TypeError exception.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-object-x
 */

'use strict';

var safeToString = require('safe-to-string-x');
var isPrimitive = require('is-primitive');

/**
   * Tests `value` to see if it is an object, throws a `TypeError` if it is
   * not. Otherwise returns the `value`.
   *
   * @param {*} value - The argument to be tested.
   * @throws {TypeError} Throws if `value` is not an object.
   * @returns {*} Returns `value` if it is an object.
   * @example
   * var assertIsObject = require('assert-is-object-x');
   * var primitive = true;
   * var mySymbol = Symbol('mySymbol');
   * var symObj = Object(mySymbol);
   * var object = {};
   * function fn () {}
   *
   * assertIsObject(primitive); // TypeError 'true is not an object'
   * assertIsObject(mySymbol); // TypeError 'Symbol(mySymbol) is not an object'
   * assertIsObject(symObj); // Returns symObj.
   * assertIsObject(object); // Returns object.
   * assertIsObject(fn); // Returns fn.
   */
module.exports = function assertIsObject(value) {
  if (isPrimitive(value)) {
    throw new TypeError(safeToString(value) + ' is not an object');
  }
  return value;
};

},{"is-primitive":178,"safe-to-string-x":432}],32:[function(require,module,exports){
/**
 * @file Invokes function, returning an object of the results.
 * @version 1.1.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module attempt-x
 */

'use strict';

var getArgs = function _getArgs(args) {
  var length = args.length >>> 0;
  var array = [];
  var argLength = length - 1;
  if (argLength < 1) {
    return array;
  }

  array.length = argLength;
  for (var index = 1; index < length; index += 1) {
    array[index - 1] = args[index];
  }

  return array;
};

/**
 * This method attempts to invoke the function, returning either the result or
 * the caught error object. Any additional arguments are provided to the
 * function when it's invoked.
 *
 * @param {Function} fn - The function to attempt.
 * @param {...*} [args] - The arguments to invoke the function with.
 * @returns {Object} Returns an object of the result.
 * @example
 * var attempt = require('attempt-x');
 *
 * function thrower() {
 *   throw new Error('Threw');
 * }
 *
 * attempt(thrower, 1, 2);
 * // {
 * //   threw: true,
 * //   value: // Error('Threw') object
 * // }
 *
 * function sumArgs(a, b) {
 *   return a + b;
 * }
 *
 * attempt(sumArgs, 1, 2);
 * // {
 * //   threw: false,
 * //   value: 3
 * // }
 *
 * var thisArg = [];
 * function pusher(a, b) {
 *   return this.push(a, b);
 * }
 *
 * attempt.call(thisArg, pusher, 1, 2);
 * // {
 * //   threw: false,
 * //   value: 2
 * // }
 * // thisArg => [1, 2];
 */
module.exports = function attempt(fn) {
  try {
    return {
      threw: false,
      value: fn.apply(this, getArgs(arguments))
    };
  } catch (e) {
    return {
      threw: true,
      value: e
    };
  }
};

},{}],33:[function(require,module,exports){
(function (process){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var format = require('util-format-x');

var superagent = require('@ladjs/superagent');

var cuid = require('cuid');

var parseErr = require('parse-err');

var safeStringify = require('fast-safe-stringify'); // <https://lacke.mn/reduce-your-bundle-js-file-size/>
// <https://github.com/lodash/babel-plugin-lodash/issues/221>


var isError = require('lodash/isError');

var isObject = require('lodash/isObject');

var isString = require('lodash/isString');

var includes = require('lodash/includes');

var omit = require('lodash/omit');

var isEmpty = require('lodash/isEmpty');

var isPlainObject = require('lodash/isPlainObject');

var isUndefined = require('lodash/isUndefined');

var isNull = require('lodash/isNull');

var boolean = require('boolean');

var _require = require('message-headers'),
    standard = _require.standard;

var formatSpecifiers = require('format-specifiers');

var standardHeaders = standard.map(function (o) {
  return o['Header Field Name'].toLowerCase();
});
var hasWindow = typeof window !== 'undefined' && typeof window.document !== 'undefined'; // eslint-disable-next-line import/no-unassigned-import

require('console-polyfill');

var levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
var endpoint = 'https://api.cabinjs.com';
var env = process.env.NODE_ENV || 'development';

var Axe =
/*#__PURE__*/
function () {
  function Axe() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Axe);

    this.config = _objectSpread({
      key: '',
      endpoint: endpoint,
      headers: {},
      timeout: 5000,
      retry: 3,
      showStack: boolean(process.env.SHOW_STACK || env !== 'production'),
      showMeta: boolean(process.env.SHOW_META),
      silent: false,
      logger: console,
      levels: ['info', 'warn', 'error', 'fatal'],
      capture: env === 'production'
    }, config);
    Object.assign(this, omit(this.config.logger, ['config', 'log'])); // we could have used `auto-bind` but it's not compiled for browser

    this.log = this.log.bind(this); // bind helper functions for each log level

    levels.forEach(function (level) {
      _this[level] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this.log.apply(_this, _toConsumableArray([level].concat([].slice.call(args))));
      };
    }); // aliases

    this.err = this.error;
    this.warning = this.warn;
  } // eslint-disable-next-line complexity


  _createClass(Axe, [{
    key: "log",
    value: function log(level, message, meta) {
      var _this2 = this;

      var originalArgs = [level, message];
      if (!isUndefined(meta)) originalArgs.push(meta);

      for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        args[_key2 - 3] = arguments[_key2];
      }

      originalArgs = originalArgs.concat([].slice.call(args));
      var config = this.config;
      var modifier = 0;
      if (level === 'warning') level = 'warn';
      if (level === 'err') level = 'error';

      if (isError(level)) {
        meta = message;
        message = level;
        level = 'error';
      } else if (!isString(level) || !includes(levels, level)) {
        meta = message;
        message = level;
        level = 'info';
        modifier = -1;
      } // if there are four or more args
      // then infer to use util.format on everything


      if (originalArgs.length >= 4 + modifier) {
        message = format.apply(void 0, _toConsumableArray(originalArgs.slice(1 + modifier)));
        meta = {};
      } else if (originalArgs.length === 3 + modifier && isString(message) && formatSpecifiers.some(function (t) {
        return includes(message, t);
      })) {
        // otherwise if there are three args and if the `message` contains
        // a placeholder token (e.g. '%s' or '%d' - see above `formatSpecifiers` variable)
        // then we can infer that the `meta` arg passed is used for formatting
        message = format(message, meta);
        meta = {};
      } else if (!isError(message)) {
        if (isError(meta)) {
          meta = {
            err: parseErr(meta)
          };
        } else if (!isPlainObject(meta) && !isUndefined(meta) && !isNull(meta)) {
          // if the `meta` variable passed was not an Object then convert it
          message = format(message, meta);
          meta = {};
        } else if (!isString(message)) {
          // if the message is not a string then we should run `util.format` on it
          // assuming we're formatting it like it was another argument
          // (as opposed to using something like fast-json-stringify)
          message = format(message);
        }
      }

      if (!isPlainObject(meta)) meta = {};
      var err;

      if (isError(message)) {
        err = message;
        if (!isObject(meta.err)) meta.err = parseErr(err);
        var _message = message;
        message = _message.message;
      } // set default level on meta


      meta.level = level; // set the body used for returning with and sending logs
      // (and also remove circular references)

      var body = safeStringify({
        message: message,
        meta: meta
      }); // send to Cabin or other logging service here the `message` and `meta`

      if (config.capture && includes(config.levels, level) && (!isError(err) || !err._captureFailed)) {
        // if the user didn't specify a key
        // and they are using the default endpoint
        // then we should throw an error to them
        if (config.endpoint === endpoint && !config.key) throw new Error("Cabin API key required (e.g. `{ key: 'YOUR-CABIN-API-KEY' })`)\n<https://cabinjs.com>"); // capture the log over HTTP

        var req = superagent.post(config.endpoint).set('X-Request-Id', cuid()).timeout(config.timeout); // basic auth (e.g. Cabin API key)

        if (config.key) req.auth(config.key); // set headers if any

        if (!isEmpty(config.headers)) {
          var headers = config.headers;
          if (hasWindow) headers = Object.keys(config.headers).reduce(function (memo, header) {
            if (!includes(standardHeaders, config.headers[header].toLowerCase())) memo[header] = config.headers[header];
            return memo;
          }, {});
          req.set(headers);
        }

        req.retry(config.retry).send(body).end(function (err) {
          if (err) {
            err._captureFailed = true;

            _this2.config.logger.error(err);
          }
        });
      } // Suppress logs if it was silent


      if (config.silent) return body; // if there was meta information then output it

      var omitted = omit(meta, ['level', 'err']); // fatal should use error (e.g. in browser)

      if (level === 'fatal') level = 'error'; // if we didn't pass a level as a method
      // (e.g. console.info), then we should still
      // use the logger's `log` method to output

      if (modifier === -1) level = 'log'; // show stack trace if necessary (along with any metadata)

      if (level === 'error' && isError(err) && config.showStack) {
        if (!config.showMeta || isEmpty(omitted)) this.config.logger.error(err);else this.config.logger.error(err, omitted);
      } else if (!config.showMeta || isEmpty(omitted)) {
        this.config.logger[level](message);
      } else {
        this.config.logger[level](message, omitted);
      } // return the parsed body in case we need it


      return body;
    }
  }]);

  return Axe;
}();

module.exports = Axe;
}).call(this,require('_process'))

},{"@ladjs/superagent":2,"_process":424,"boolean":35,"console-polyfill":94,"cuid":96,"fast-safe-stringify":104,"format-specifiers":111,"lodash/includes":358,"lodash/isEmpty":363,"lodash/isError":364,"lodash/isNull":368,"lodash/isObject":370,"lodash/isPlainObject":372,"lodash/isString":374,"lodash/isUndefined":377,"lodash/omit":383,"message-headers":400,"parse-err":421,"util-format-x":458}],34:[function(require,module,exports){
/**
* @file A big counter.
* @version 2.0.1
* @author Xotic750 <Xotic750@gmail.com>
* @copyright  Xotic750
* @license {@link <https://opensource.org/licenses/MIT> MIT}
* @module big-counter-x
*/

'use strict';

var defineProperties = require('object-define-properties-x');

/**
 * Serialise the counters current value.
 *
 * @private
 * @this BigCounter
 * @return {string} A string representation of an integer.
 */
var counterToString = function ToString() {
  return this.count.slice().reverse().join('');
};

/**
 * The BigCounter class.
 *
 * @private
 * @class
 */
var BigC = function BigCounter() {
  if (Boolean(this) === false || (this instanceof BigC) === false) {
    return new BigC();
  }

  defineProperties(this, {
    count: {
      value: [0]
    }
  });
};

defineProperties(BigC.prototype, {
  /**
   * Gets the counters current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  get: {
    value: counterToString
  },
  /**
   * Increments the counters value by `1`.
   *
   * @function
   * @returns {Object} The counter object.
   */
  next: {
    value: function next() {
      var clone = this.count.slice();
      this.count.length = 0;
      var length = clone.length;
      var howMany = Math.max(length, 1);
      var carry = 0;
      var index = 0;
      while (index < howMany || carry) {
        var zi = carry + (index < length ? clone[index] : 0) + (index === 0 ? 1 : 0);
        this.count.push(zi % 10);
        carry = Math.floor(zi / 10);
        index += 1;
      }

      return this;
    }
  },
  /**
   * Resets the counter back to `0`.
   *
   * @function
   * @returns {Object} The counter object.
   */
  reset: {
    value: function reset() {
      this.count.length = 0;
      this.count.push(0);
      return this;
    }
  },
  /**
   * Gets the counters current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  toJSON: {
    value: counterToString
  },
  /**
   * Gets the counters current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  toString: {
    value: counterToString
  },
  /**
   * Gets the counters current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  valueOf: {
    value: counterToString
  }
});

/**
 * Incremental integer counter. Counts from `0` to very big intergers.
 * Javascripts number type allows you to count in integer steps
 * from `0` to `9007199254740991`. As of ES5, Strings can contain
 * approximately 65000 characters and ES6 is supposed to handle
 * the `MAX_SAFE_INTEGER` (though I dont believe any environments supports
 * this). This counter represents integer values as strings and can therefore
 * count in integer steps from `0` to the maximum string length (thats some
 * 65000 digits). In the lower range, upto `9007199254740991`, the strings can
 * be converted to safe Javascript integers `Number(value)` or `+value`. This
 * counter is great for any applications that need a really big count
 * represented as a string, (an ID string).
 *
 * @class
 * @example
 * var BigCounter = require('big-counter-x');
 * var counter = new BigCounter();
 *
 * counter.get(); // '0'
 * counter.next(); // counter object
 * counter.get(); // '1'
 *
 * // Methods are chainable.
 * counter.next().next(); // counter object
 * counter.get(); // '3'
 *
 * counter.reset(); // counter object
 * counter.get(); // '0'
 * counter.toString(); // '0'
 * counter.valueOf(); // '0'
 * counter.toJSON(); // '0'
 *
 * // Values upto `9007199254740991` convert to numbers.
 * Number(counter); // 0
 * +counter; // 0
 */
module.exports = BigC;

},{"object-define-properties-x":414}],35:[function(require,module,exports){
'use strict';

var boolean = function boolean(value) {
  if (typeof value === 'string') {
    return (/^(true|t|yes|y|1)$/i.test(value.trim())
    );
  }

  if (typeof value === 'number') {
    return value !== 0;
  }

  if (typeof value === 'boolean') {
    return value;
  }

  return false;
};

module.exports = boolean;
},{}],36:[function(require,module,exports){
/**
 * @file Constructors cached from literals.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module cached-constructors-x
 */

'use strict';

/**
 * Constructors cached from literals.
 *
 * @type Object
 * @example
 * var constructors = require('cached-constructors-x');
 */
module.exports = {
  Array: [].constructor,
  Boolean: true.constructor,
  Function: function () {}.constructor,
  Number: (0).constructor,
  Object: {}.constructor,
  RegExp: (/(?:)/).constructor,
  String: ''.constructor
};

},{}],37:[function(require,module,exports){
/**
 * @file Calculates a fromIndex of a given value for an array.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module calculate-from-index-x
 */

'use strict';

var toObject = require('to-object-x');
var toLength = require('to-length-x');
var toInteger = require('to-integer-x');
var isArrayLike = require('is-array-like-x');

var $calcFromIndex = function calcFromIndex(array, fromIndex) {
  var object = toObject(array);
  if (isArrayLike(object) === false) {
    return 0;
  }

  var length = toLength(object.length);
  var index = toInteger(fromIndex);
  return index >= 0 ? index : Math.max(0, length + index);
};

/**
 * This method calculates a fromIndex of a given value for an array.
 *
 * @param {array} array The array on which to calculate the starting index.
 * @throws {TypeError} If array is null or undefined.
 * @param {number} fromIndex The position in this array at which to begin. A
 *  negative value gives the index of array.length + fromIndex by asc.
 * @return {number} The calculated fromIndex. Default is 0.
 * @example
 * var calcFromIndex = require('calculate-from-index-x');
 *
 * calcFromIndex([1, 2, 3], 1); // 1
 * calcFromIndex([1, 2, 3], Infinity); // Infinity
 * calcFromIndex([1, 2, 3], -Infinity); // 0
 * calcFromIndex([1, 2, 3], -1); // 2
 */
module.exports = $calcFromIndex;

},{"is-array-like-x":152,"to-integer-x":40,"to-length-x":41,"to-object-x":446}],38:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"is-nan":170,"max-safe-integer":397}],39:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11,"is-nan":170}],40:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12,"is-finite-x":38,"is-nan":170,"math-sign-x":39}],41:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"max-safe-integer":397,"to-integer-x":40}],42:[function(require,module,exports){
/**
 * @file ES6 collections fallback library: Map and Set.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module collections-x
 */

'use strict';

var hasOwn = require('has-own-property-x');
var isFunction = require('is-function-x');
var defineProperty = require('object-define-property-x');
var defineProperties = require('object-define-properties-x');
var isString = require('is-string');
var isArrayLike = require('is-array-like-x');
var isPrimitive = require('is-primitive');
var isSurrogatePair = require('is-surrogate-pair-x');
var indexOf = require('index-of-x');
var assertIsFunction = require('assert-is-function-x');
var assertIsObject = require('assert-is-object-x');
var IdGenerator = require('big-counter-x');
var isNil = require('is-nil-x');
var isMap = require('is-map-x');
var isSet = require('is-set-x');
var isObjectLike = require('is-object-like-x');
var isArray = require('is-array-x');
var isBoolean = require('is-boolean-object');
var isUndefined = require('validate.io-undefined');
var some = require('array-some-x');
var getPrototypeOf = require('get-prototype-of-x');
var hasSymbolSupport = require('has-symbol-support-x');
var hasRealSymbolIterator = hasSymbolSupport && typeof Symbol.iterator === 'symbol';
var hasFakeSymbolIterator = typeof Symbol === 'object' && typeof Symbol.iterator === 'string';
var symIt;

if (hasRealSymbolIterator || hasFakeSymbolIterator) {
  symIt = Symbol.iterator;
} else if (isFunction(Array.prototype['_es6-shim iterator_'])) {
  symIt = '_es6-shim iterator_';
} else {
  symIt = '@@iterator';
}

var isNumberType = function _isNumberType(value) {
  return typeof value === 'number';
};

/**
 * Detect an interator function.
 *
 * @private
 * @param {*} iterable - Value to detect iterator function.
 * @returns {Symbol|string|undefined} The iterator property identifier.
 */
var getSymbolIterator = function _getSymbolIterator(iterable) {
  if (isNil(iterable) === false) {
    if ((hasRealSymbolIterator || hasFakeSymbolIterator) && iterable[symIt]) {
      return symIt;
    }

    if (iterable['_es6-shim iterator_']) {
      return '_es6-shim iterator_';
    }

    if (iterable['@@iterator']) {
      return '@@iterator';
    }
  }

  return void 0;
};

/**
 * If an iterable object is passed, all of its elements will be added to the
 * new Map/Set, null is treated as undefined.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {*} iterable - Value to parsed.
 */
// eslint-disable-next-line complexity
var parseIterable = function _parseIterable(kind, context, iterable) {
  var symbolIterator = getSymbolIterator(iterable);
  if (kind === 'map') {
    defineProperty(context, '[[value]]', {
      value: []
    });
  }

  defineProperties(context, {
    '[[changed]]': {
      value: false
    },
    '[[id]]': {
      value: new IdGenerator()
    },
    '[[key]]': {
      value: []
    },
    '[[order]]': {
      value: []
    }
  });

  var next;
  var key;
  var indexof;
  if (iterable && isFunction(iterable[symbolIterator])) {
    var iterator = iterable[symbolIterator]();
    next = iterator.next();
    if (kind === 'map') {
      if (isArrayLike(next.value) === false || next.value.length < 2) {
        throw new TypeError(
          'Iterator value ' + isArrayLike(next.value) + ' is not an entry object'
        );
      }
    }

    while (next.done === false) {
      key = kind === 'map' ? next.value[0] : next.value;
      indexof = indexOf(
        assertIsObject(context)['[[key]]'],
        key,
        'SameValueZero'
      );

      if (indexof < 0) {
        if (kind === 'map') {
          context['[[value]]'].push(next.value[1]);
        }

        context['[[key]]'].push(key);
        context['[[order]]'].push(context['[[id]]'].get());
        context['[[id]]'].next();
      } else if (kind === 'map') {
        context['[[value]]'][indexof] = next.value[1];
      }

      next = iterator.next();
    }
  }

  if (isString(iterable)) {
    if (kind === 'map') {
      throw new TypeError(
        'Iterator value ' + iterable.charAt(0) + ' is not an entry object'
      );
    }

    next = 0;
    while (next < iterable.length) {
      var char1 = iterable.charAt(next);
      var char2 = iterable.charAt(next + 1);
      if (isSurrogatePair(char1, char2)) {
        key = char1 + char2;
        next += 1;
      } else {
        key = char1;
      }

      indexof = indexOf(
        assertIsObject(context)['[[key]]'],
        key,
        'SameValueZero'
      );

      if (indexof < 0) {
        context['[[key]]'].push(key);
        context['[[order]]'].push(context['[[id]]'].get());
        context['[[id]]'].next();
      }

      next += 1;
    }
  } else if (isArrayLike(iterable)) {
    next = 0;
    while (next < iterable.length) {
      if (kind === 'map') {
        if (isPrimitive(iterable[next])) {
          throw new TypeError(
            'Iterator value ' + isArrayLike(next.value) + ' is not an entry object'
          );
        }

        key = iterable[next][0];
      } else {
        key = iterable[next];
      }

      key = kind === 'map' ? iterable[next][0] : iterable[next];
      indexof = indexOf(
        assertIsObject(context)['[[key]]'],
        key,
        'SameValueZero'
      );

      if (indexof < 0) {
        if (kind === 'map') {
          context['[[value]]'].push(iterable[next][1]);
        }

        context['[[key]]'].push(key);
        context['[[order]]'].push(context['[[id]]'].get());
        context['[[id]]'].next();
      } else if (kind === 'map') {
        context['[[value]]'][indexof] = iterable[next][1];
      }

      next += 1;
    }
  }

  defineProperty(context, 'size', {
    value: context['[[key]]'].length,
    writable: true
  });
};

/**
 * The base forEach method executes a provided function once per each value
 * in the Map/Set object, in insertion order.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {Function} callback - Function to execute for each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @returns {Object} The Map/Set object.
 */
// eslint-disable-next-line max-params
var baseForEach = function _baseForEach(kind, context, callback, thisArg) {
  assertIsObject(context);
  assertIsFunction(callback);
  var pointers = {
    index: 0,
    order: context['[[order]]'][0]
  };

  context['[[change]]'] = false;
  var length = context['[[key]]'].length;
  while (pointers.index < length) {
    if (hasOwn(context['[[key]]'], pointers.index)) {
      var key = context['[[key]]'][pointers.index];
      var value = kind === 'map' ? context['[[value]]'][pointers.index] : key;
      callback.call(thisArg, value, key, context);
    }

    if (context['[[change]]']) {
      length = context['[[key]]'].length;
      some(context['[[order]]'], function _some1(id, count) {
        pointers.index = count;
        return id > pointers.order;
      });

      context['[[change]]'] = false;
    } else {
      pointers.index += 1;
    }

    pointers.order = context['[[order]]'][pointers.index];
  }

  return context;
};

/**
 * The base has method returns a boolean indicating whether an element with
 * the specified key/value exists in a Map/Set object or not.
 *
 * @private
 * @param {*} key - The key/value to test for presence in the Map/Set object.
 * @returns {boolean} Returns true if an element with the specified key/value
 *  exists in the Map/Set object; otherwise false.
 */
var baseHas = function has(key) {
  // eslint-disable-next-line no-invalid-this
  return indexOf(assertIsObject(this)['[[key]]'], key, 'SameValueZero') > -1;
};

/**
 * The base clear method removes all elements from a Map/Set object.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @returns {Object} The Map/Set object.
 */
var baseClear = function _baseClear(kind, context) {
  assertIsObject(context);
  context['[[id]]'].reset();
  context['[[change]]'] = true;
  context.size = 0;
  context['[[order]]'].length = 0;
  context['[[key]]'].length = 0;
  if (kind === 'map') {
    context['[[value]]'].length = 0;
  }

  return context;
};

/**
 * The base delete method removes the specified element from a Map/Set object.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {*} key - The key/value of the element to remove from Map/Set object.
 * @returns {Object} The Map/Set object.
 */
var baseDelete = function _baseDelete(kind, context, key) {
  var indexof = indexOf(
    assertIsObject(context)['[[key]]'],
    key,
    'SameValueZero'
  );

  var result = false;
  if (indexof > -1) {
    if (kind === 'map') {
      context['[[value]]'].splice(indexof, 1);
    }

    context['[[key]]'].splice(indexof, 1);
    context['[[order]]'].splice(indexof, 1);
    context['[[change]]'] = true;
    context.size = context['[[key]]'].length;
    result = true;
  }

  return result;
};

/**
 * The base set and add method.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {*} key - The key or value of the element to add/set on the object.
 * @param {*} value - The value of the element to add to the Map object.
 * @returns {Object} The Map/Set object.
 */
// eslint-disable-next-line max-params
var baseAddSet = function _baseAddSet(kind, context, key, value) {
  var index = indexOf(
    assertIsObject(context)['[[key]]'],
    key,
    'SameValueZero'
  );

  if (index > -1) {
    if (kind === 'map') {
      context['[[value]]'][index] = value;
    }
  } else {
    if (kind === 'map') {
      context['[[value]]'].push(value);
    }

    context['[[key]]'].push(key);
    context['[[order]]'].push(context['[[id]]'].get());
    context['[[id]]'].next();
    context['[[change]]'] = true;
    context.size = context['[[key]]'].length;
  }

  return context;
};

/**
 * An object is an iterator when it knows how to access items from a
 * collection one at a time, while keeping track of its current position
 * within that sequence. In JavaScript an iterator is an object that provides
 * a next() method which returns the next item in the sequence. This method
 * returns an object with two properties: done and value. Once created,
 * an iterator object can be used explicitly by repeatedly calling next().
 *
 * @private
 * @class
 * @param {Object} context - The Set object.
 * @param {string} iteratorKind - Values are `value`, `key` or `key+value`.
 */
var SetIt = function SetIterator(context, iteratorKind) {
  defineProperties(this, {
    '[[IteratorHasMore]]': {
      value: true,
      writable: true
    },
    '[[Set]]': {
      value: assertIsObject(context)
    },
    '[[SetIterationKind]]': {
      value: iteratorKind || 'value'
    },
    '[[SetNextIndex]]': {
      value: 0,
      writable: true
    }
  });
};

/**
 * Once initialized, the next() method can be called to access key-value
 * pairs from the object in turn.
 *
 * @private
 * @function next
 * @returns {Object} Returns an object with two properties: done and value.
 */
defineProperty(SetIt.prototype, 'next', {
  value: function next() {
    var context = assertIsObject(this['[[Set]]']);
    var index = this['[[SetNextIndex]]'];
    var iteratorKind = this['[[SetIterationKind]]'];
    var more = this['[[IteratorHasMore]]'];
    var object;
    if (index < context['[[key]]'].length && more) {
      object = { done: false };
      if (iteratorKind === 'key+value') {
        object.value = [context['[[key]]'][index], context['[[key]]'][index]];
      } else {
        object.value = context['[[key]]'][index];
      }

      this['[[SetNextIndex]]'] += 1;
    } else {
      this['[[IteratorHasMore]]'] = false;
      object = {
        done: true,
        value: void 0
      };
    }

    return object;
  }
});

/**
 * The @@iterator property is the same Iterator object.
 *
 * @private
 * @function symIt
 * @memberof SetIterator.prototype
 * @returns {Object} This Iterator object.
 */
defineProperty(SetIt.prototype, symIt, {
  value: function iterator() {
    return this;
  }
});

/**
 * This method returns a new Iterator object that contains the
 * values for each element in the Set object in insertion order.
 *
 * @private
 * @this Set
 * @returns {Object} A new Iterator object.
 */
var setValuesIterator = function values() {
  return new SetIt(this);
};

/**
 * The Set object lets you store unique values of any type, whether primitive
 * values or object references.
 *
 * @class Set
 * @private
 * @param {*} [iterable] - If an iterable object is passed, all of its elements
 * will be added to the new Set. null is treated as undefined.
 * @example
 * var mySet = new Set();
 *
 * mySet.add(1);
 * mySet.add(5);
 * mySet.add("some text");
 * var o = {a: 1, b: 2};
 * mySet.add(o);
 *
 * mySet.has(1); // true
 * mySet.has(3); // false, 3 has not been added to the set
 * mySet.has(5);              // true
 * mySet.has(Math.sqrt(25));  // true
 * mySet.has("Some Text".toLowerCase()); // true
 * mySet.has(o); // true
 *
 * mySet.size; // 4
 *
 * mySet.delete(5); // removes 5 from the set
 * mySet.has(5);    // false, 5 has been removed
 *
 * mySet.size; // 3, we just removed one value
 *
 * // Relation with Array objects
 *
 * var myArray = ["value1", "value2", "value3"];
 *
 * // Use the regular Set constructor to transform an Array into a Set
 * var mySet = new Set(myArray);
 *
 * mySet.has("value1"); // returns true
 *
 * // Use the spread operator to transform a set into an Array.
 * console.log(uneval([...mySet])); // Will show you exactly the same Array
 *                                  // as myArray
 */
var SetObject = function Set() {
  if (Boolean(this) === false || (this instanceof SetObject) === false) {
    throw new TypeError('Constructor Set requires \'new\'');
  }

  parseIterable('set', this, arguments.length ? arguments[0] : void 0);
};

defineProperties(SetObject.prototype, /** @lends module:collections-x.Set.prototype */ {
  /**
   * The add() method appends a new element with a specified value to the end
   * of a Set object.
   *
   * @param {*} value - Required. The value of the element to add to the Set
   *  object.
   * @returns {Object} The Set object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   *
   * mySet.add(1);
   * mySet.add(5).add("some text"); // chainable
   *
   * console.log(mySet);
   * // Set [1, 5, "some text"]
   */
  add: {
    value: function add(value) {
      return baseAddSet('set', this, value);
    }
  },
  /**
   * The clear() method removes all elements from a Set object.
   *
   * @returns {Object} The Set object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add(1);
   * mySet.add("foo");
   *
   * mySet.size;       // 2
   * mySet.has("foo"); // true
   *
   * mySet.clear();
   *
   * mySet.size;       // 0
   * mySet.has("bar")  // false
   */
  clear: {
    value: function clear() {
      return baseClear('set', this);
    }
  },
  /**
   * The delete() method removes the specified element from a Set object.
   *
   * @param {*} value - The value of the element to remove from the Set object.
   * @returns {boolean} Returns true if an element in the Set object has been
   *  removed successfully; otherwise false.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foo");
   *
   * mySet.delete("bar"); // Returns false. No "bar" element found
   *                      //to be deleted.
   * mySet.delete("foo"); // Returns true.  Successfully removed.
   *
   * mySet.has("foo");    // Returns false. The "foo" element is no
   *                      //longer present.
   */
  'delete': {
    value: function de1ete(value) {
      return baseDelete('set', this, value);
    }
  },
  /**
   * The entries() method returns a new Iterator object that contains an
   * array of [value, value] for each element in the Set object, in
   * insertion order. For Set objects there is no key like in Map objects.
   * However, to keep the API similar to the Map object, each entry has the
   * same value for its key and value here, so that an array [value, value]
   * is returned.
   *
   * @function
   * @returns {Object} A new Iterator object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foobar");
   * mySet.add(1);
   * mySet.add("baz");
   *
   * var setIter = mySet.entries();
   *
   * console.log(setIter.next().value); // ["foobar", "foobar"]
   * console.log(setIter.next().value); // [1, 1]
   * console.log(setIter.next().value); // ["baz", "baz"]
   */
  entries: {
    value: function entries() {
      return new SetIt(this, 'key+value');
    }
  },
  /**
   * The forEach() method executes a provided function once per each value
   * in the Set object, in insertion order.
   *
   * @param {Function} callback - Function to execute for each element.
   * @param {*} [thisArg] - Value to use as this when executing callback.
   * @returns {Object} The Set object.
   * @example
   * function logSetElements(value1, value2, set) {
   *     console.log("s[" + value1 + "] = " + value2);
   * }
   *
   * new Set(["foo", "bar", undefined]).forEach(logSetElements);
   *
   * // logs:
   * // "s[foo] = foo"
   * // "s[bar] = bar"
   * // "s[undefined] = undefined"
   */
  forEach: {
    value: function forEach(callback, thisArg) {
      return baseForEach('set', this, callback, thisArg);
    }
  },
  /**
   * The has() method returns a boolean indicating whether an element with the
   * specified value exists in a Set object or not.
   *
   * @function
   * @param {*} value - The value to test for presence in the Set object.
   * @returns {boolean} Returns true if an element with the specified value
   *  exists in the Set object; otherwise false.
   * @example
   * var Set = require('collections-x').Set;
   * var mySet = new Set();
   * mySet.add("foo");
   *
   * mySet.has("foo");  // returns true
   * mySet.has("bar");  // returns false
   */
  has: {
    value: baseHas
  },
  /**
   * The keys() method is an alias for the `values` method (for similarity
   * with Map objects); it behaves exactly the same and returns values of
   * Set elements.
   *
   * @function
   * @returns {Object} A new Iterator object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foo");
   * mySet.add("bar");
   * mySet.add("baz");
   *
   * var setIter = mySet.keys();
   *
   * console.log(setIter.next().value); // "foo"
   * console.log(setIter.next().value); // "bar"
   * console.log(setIter.next().value); // "baz"
   */
  keys: {
    value: setValuesIterator
  },
  /**
   * The value of size is an integer representing how many entries the Set
   * object has.
   *
   * @name size
   * @memberof module:collections-x.Set
   * @instance
   * @type {number}
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add(1);
   * mySet.add(5);
   * mySet.add("some text");
   *
   * mySet.size; // 3
   */
  size: {
    value: 0,
    writable: true
  },
  /**
   * The values() method returns a new Iterator object that contains the
   * values for each element in the Set object in insertion order.
   *
   * @function
   * @returns {Object} A new Iterator object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foo");
   * mySet.add("bar");
   * mySet.add("baz");
   *
   * var setIter = mySet.values();
   *
   * console.log(setIter.next().value); // "foo"
   * console.log(setIter.next().value); // "bar"
   * console.log(setIter.next().value); // "baz"
   */
  values: {
    value: setValuesIterator
  }
});

/**
 * The initial value of the @@iterator property is the same function object
 * as the initial value of the values property.
 *
 * @function symIt
 * @memberof module:collections-x.Set.prototype
 * @returns {Object} A new Iterator object.
 * @example
 * var Set = require('collections-x').Set,
 * var symIt = var Set = require('collections-x').symIt;
 * var mySet = new Set();
 * mySet.add("0");
 * mySet.add(1);
 * mySet.add({});
 *
 * var setIter = mySet[symIt]();
 *
 * console.log(setIter.next().value); // "0"
 * console.log(setIter.next().value); // 1
 * console.log(setIter.next().value); // Object
 */
defineProperty(SetObject.prototype, symIt, {
  value: setValuesIterator
});

/**
 * An object is an iterator when it knows how to access items from a
 * collection one at a time, while keeping track of its current position
 * within that sequence. In JavaScript an iterator is an object that provides
 * a next() method which returns the next item in the sequence. This method
 * returns an object with two properties: done and value. Once created,
 * an iterator object can be used explicitly by repeatedly calling next().
 *
 * @private
 * @class
 * @param {Object} context - The Map object.
 * @param {string} iteratorKind - Values are `value`, `key` or `key+value`.
 */
var MapIt = function MapIterator(context, iteratorKind) {
  defineProperties(this, {
    '[[IteratorHasMore]]': {
      value: true,
      writable: true
    },
    '[[Map]]': {
      value: assertIsObject(context)
    },
    '[[MapIterationKind]]': {
      value: iteratorKind
    },
    '[[MapNextIndex]]': {
      value: 0,
      writable: true
    }
  });
};

/**
 * Once initialized, the next() method can be called to access key-value
 * pairs from the object in turn.
 *
 * @private
 * @function next
 * @returns {Object} Returns an object with two properties: done and value.
 */
defineProperty(MapIt.prototype, 'next', {
  value: function next() {
    var context = assertIsObject(this['[[Map]]']);
    var index = this['[[MapNextIndex]]'];
    var iteratorKind = this['[[MapIterationKind]]'];
    var more = this['[[IteratorHasMore]]'];
    var object;
    assertIsObject(context);
    if (index < context['[[key]]'].length && more) {
      object = { done: false };
      if (iteratorKind === 'key+value') {
        object.value = [context['[[key]]'][index], context['[[value]]'][index]];
      } else {
        object.value = context['[[' + iteratorKind + ']]'][index];
      }

      this['[[MapNextIndex]]'] += 1;
    } else {
      this['[[IteratorHasMore]]'] = false;
      object = {
        done: true,
        value: void 0
      };
    }

    return object;
  }
});

/**
 * The @@iterator property is the same Iterator object.
 *
 * @private
 * @function symIt
 * @memberof MapIterator.prototype
 * @returns {Object} This Iterator object.
 */
defineProperty(MapIt.prototype, symIt, {
  value: function iterator() {
    return this;
  }
});

/**
 * The Map object is a simple key/value map. Any value (both objects and
 * primitive values) may be used as either a key or a value.
 *
 * @class Map
 * @private
 * @param {*} [iterable] - Iterable is an Array or other iterable object whose
 *  elements are key-value pairs (2-element Arrays). Each key-value pair is
 *  added to the new Map. null is treated as undefined.
 * @example
 * var Map = require('collections-x').Map;
 * var myMap = new Map();
 *
 * var keyString = "a string",
 *     keyObj = {},
 *     keyFunc = function () {};
 *
 * // setting the values
 * myMap.set(keyString, "value associated with 'a string'");
 * myMap.set(keyObj, "value associated with keyObj");
 * myMap.set(keyFunc, "value associated with keyFunc");
 *
 * myMap.size; // 3
 *
 * // getting the values
 * myMap.get(keyString);    // "value associated with 'a string'"
 * myMap.get(keyObj);       // "value associated with keyObj"
 * myMap.get(keyFunc);      // "value associated with keyFunc"
 *
 * myMap.get("a string");   // "value associated with 'a string'"
 *                          // because keyString === 'a string'
 * myMap.get({});           // undefined, because keyObj !== {}
 * myMap.get(function() {}) // undefined, because keyFunc !== function () {}
 *
 * // Using NaN as Map keys
 * var myMap = new Map();
 * myMap.set(NaN, "not a number");
 *
 * myMap.get(NaN); // "not a number"
 *
 * var otherNaN = Number("foo");
 * myMap.get(otherNaN); // "not a number"
 *
 * // Relation with Array objects
 * var kvArray = [["key1", "value1"], ["key2", "value2"]];
 *
 * // Use the regular Map constructor to transform a
 * // 2D key-value Array into a map
 * var myMap = new Map(kvArray);
 *
 * myMap.get("key1"); // returns "value1"
 */
var MapObject = function Map() {
  if (Boolean(this) === false || (this instanceof MapObject) === false) {
    throw new TypeError('Constructor Map requires \'new\'');
  }

  parseIterable('map', this, arguments.length ? arguments[0] : void 0);
};

defineProperties(MapObject.prototype, /** @lends module:collections-x.Map.prototype */ {
  /**
   * The clear() method removes all elements from a Map object.
   *
   * @returns {Object} The Map object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "baz");
   * myMap.set(1, "foo");
   *
   * myMap.size;       // 2
   * myMap.has("bar"); // true
   *
   * myMap.clear();
   *
   * myMap.size;       // 0
   * myMap.has("bar")  // false
   */
  clear: {
    value: function clear() {
      return baseClear('map', this);
    }
  },
  /**
   * The delete() method removes the specified element from a Map object.
   *
   * @param {*} key - The key of the element to remove from the Map object.
   * @returns {boolean} Returns true if an element in the Map object has been
   *  removed successfully.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "foo");
   *
   * myMap.delete("bar"); // Returns true. Successfully removed.
   * myMap.has("bar");    // Returns false.
   *                      // The "bar" element is no longer present.
   */
  'delete': {
    value: function de1ete(key) {
      return baseDelete('map', this, key);
    }
  },
  /**
   * The entries() method returns a new Iterator object that contains the
   * [key, value] pairs for each element in the Map object in insertion order.
   *
   * @returns {Object} A new Iterator object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("0", "foo");
   * myMap.set(1, "bar");
   * myMap.set({}, "baz");
   *
   * var mapIter = myMap.entries();
   *
   * console.log(mapIter.next().value); // ["0", "foo"]
   * console.log(mapIter.next().value); // [1, "bar"]
   * console.log(mapIter.next().value); // [Object, "baz"]
   */
  entries: {
    value: function entries() {
      return new MapIt(this, 'key+value');
    }
  },
  /**
   * The forEach() method executes a provided function once per each
   * key/value pair in the Map object, in insertion order.
   *
   * @param {Function} callback - Function to execute for each element..
   * @param {*} [thisArg] - Value to use as this when executing callback.
   * @returns {Object} The Map object.
   * @example
   * var Map = require('collections-x').Map;
   * function logElements(value, key, map) {
   *      console.log("m[" + key + "] = " + value);
   * }
   * var myMap = new Map([["foo", 3], ["bar", {}], ["baz", undefined]]);
   * myMap.forEach(logElements);
   * // logs:
   * // "m[foo] = 3"
   * // "m[bar] = [object Object]"
   * // "m[baz] = undefined"
   */
  forEach: {
    value: function forEach(callback, thisArg) {
      return baseForEach('map', this, callback, thisArg);
    }
  },
  /**
   * The get() method returns a specified element from a Map object.
   *
   * @param {*} key - The key of the element to return from the Map object.
   * @returns {*} Returns the element associated with the specified key or
   *  undefined if the key can't be found in the Map object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "foo");
   *
   * myMap.get("bar");  // Returns "foo".
   * myMap.get("baz");  // Returns undefined.
   */
  get: {
    value: function get(key) {
      var index = indexOf(
        assertIsObject(this)['[[key]]'],
        key,
        'SameValueZero'
      );

      return index > -1 ? this['[[value]]'][index] : void 0;
    }
  },
  /**
   * The has() method returns a boolean indicating whether an element with
   * the specified key exists or not.
   *
   * @function
   * @param {*} key - The key of the element to test for presence in the
   *  Map object.
   * @returns {boolean} Returns true if an element with the specified key
   *  exists in the Map object; otherwise false.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "foo");
   *
   * myMap.has("bar");  // returns true
   * myMap.has("baz");  // returns false
   */
  has: {
    value: baseHas
  },
  /**
   * The keys() method returns a new Iterator object that contains the keys
   * for each element in the Map object in insertion order.
   *
   * @returns {Object} A new Iterator object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("0", "foo");
   * myMap.set(1, "bar");
   * myMap.set({}, "baz");
   *
   * var mapIter = myMap.keys();
   *
   * console.log(mapIter.next().value); // "0"
   * console.log(mapIter.next().value); // 1
   * console.log(mapIter.next().value); // Object
   */
  keys: {
    value: function keys() {
      return new MapIt(this, 'key');
    }
  },
  /**
   * The set() method adds a new element with a specified key and value to
   * a Map object.
   *
   * @param {*} key - The key of the element to add to the Map object.
   * @param {*} value - The value of the element to add to the Map object.
   * @returns {Object} The Map object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   *
   * // Add new elements to the map
   * myMap.set("bar", "foo");
   * myMap.set(1, "foobar");
   *
   * // Update an element in the map
   * myMap.set("bar", "fuuu");
   */
  set: {
    value: function set(key, value) {
      return baseAddSet('map', this, key, value);
    }
  },
  /**
   * The value of size is an integer representing how many entries the Map
   * object has.
   *
   * @name size
   * @memberof module:collections-x.Map
   * @instance
   * @type {number}
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set(1, true);
   * myMap.set(5, false);
   * myMap.set("some text", 1);
   *
   * myMap.size; // 3
   */
  size: {
    value: 0,
    writable: true
  },
  /**
   * The values() method returns a new Iterator object that contains the
   * values for each element in the Map object in insertion order.
   *
   * @returns {Object} A new Iterator object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("0", "foo");
   * myMap.set(1, "bar");
   * myMap.set({}, "baz");
   *
   * var mapIter = myMap.values();
   *
   * console.log(mapIter.next().value); // "foo"
   * console.log(mapIter.next().value); // "bar"
   * console.log(mapIter.next().value); // "baz"
   */
  values: {
    value: function values() {
      return new MapIt(this, 'value');
    }
  }
});

/**
 * The initial value of the @@iterator property is the same function object
 * as the initial value of the entries property.
 *
 * @function symIt
 * @memberof module:collections-x.Map.prototype
 * @returns {Object} A new Iterator object.
 * @example
 * var Map = require('collections-x').Map;
 * var symIt = require('collections-x').symIt;
 * var myMap = new Map();
 * myMap.set("0", "foo");
 * myMap.set(1, "bar");
 * myMap.set({}, "baz");
 *
 * var mapIter = myMap[symIt]();
 *
 * console.log(mapIter.next().value); // ["0", "foo"]
 * console.log(mapIter.next().value); // [1, "bar"]
 * console.log(mapIter.next().value); // [Object, "baz"]
 */
defineProperty(MapObject.prototype, symIt, {
  value: MapObject.prototype.entries
});

/*
 * Determine whether to use shim or native.
 */

var ExportMap = MapObject;
try {
  ExportMap = new Map() ? Map : MapObject;
} catch (ignore) {}

var ExportSet = SetObject;
try {
  ExportSet = new Set() ? Set : SetObject;
} catch (ignore) {}

var testMap;

if (ExportMap !== MapObject) {
  testMap = new ExportMap();
  if (isNumberType(testMap.size) === false || testMap.size !== 0) {
    ExportMap = MapObject;
  } else {
    var propsMap = [
      'has',
      'set',
      'clear',
      'delete',
      'forEach',
      'values',
      'entries',
      'keys',
      symIt
    ];

    var failedMap = some(propsMap, function (method) {
      return isFunction(testMap[method]) === false;
    });

    if (failedMap) {
      ExportMap = MapObject;
    }
  }
}

if (ExportMap !== MapObject) {
  // Safari 8, for example, doesn't accept an iterable.
  var mapAcceptsArguments = false;
  try {
    mapAcceptsArguments = new ExportMap([[1, 2]]).get(1) === 2;
  } catch (ignore) {}

  if (mapAcceptsArguments === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  testMap = new ExportMap();
  var mapSupportsChaining = testMap.set(1, 2) === testMap;
  if (mapSupportsChaining === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4
  testMap = new ExportMap([
    [1, 0],
    [2, 0],
    [3, 0],
    [4, 0]
  ]);
  testMap.set(-0, testMap);
  var gets = testMap.get(0) === testMap && testMap.get(-0) === testMap;
  var mapUsesSameValueZero = gets && testMap.has(0) && testMap.has(-0);

  if (mapUsesSameValueZero === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  if (Object.setPrototypeOf) {
    var MyMap = function (arg) {
      testMap = new ExportMap(arg);
      Object.setPrototypeOf(testMap, MyMap.prototype);
      return testMap;
    };
    Object.setPrototypeOf(MyMap, ExportMap);
    MyMap.prototype = Object.create(ExportMap.prototype, { constructor: { value: MyMap } });

    var mapSupportsSubclassing = false;
    try {
      testMap = new MyMap([]);
      // Firefox 32 is ok with the instantiating the subclass but will
      // throw when the map is used.
      testMap.set(42, 42);
      mapSupportsSubclassing = testMap instanceof MyMap;
    } catch (ignore) {}

    if (mapSupportsSubclassing === false) {
      ExportMap = MapObject;
    }
  }
}

if (ExportMap !== MapObject) {
  var mapRequiresNew;
  try {
    // eslint-disable-next-line new-cap
    mapRequiresNew = (ExportMap() instanceof ExportMap) === false;
  } catch (e) {
    mapRequiresNew = e instanceof TypeError;
  }

  if (mapRequiresNew === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  testMap = new ExportMap();
  // eslint-disable-next-line id-length
  var mapIterationThrowsStopIterator;
  try {
    mapIterationThrowsStopIterator = testMap.keys().next().done === false;
  } catch (ignore) {
    mapIterationThrowsStopIterator = true;
  }

  if (mapIterationThrowsStopIterator) {
    ExportMap = MapObject;
  }
}

// Safari 8
if (ExportMap !== MapObject && isFunction(new ExportMap().keys().next) === false) {
  ExportMap = MapObject;
}

if (hasRealSymbolIterator && ExportMap !== MapObject) {
  var testMapProto = getPrototypeOf(new ExportMap().keys());
  var hasBuggyMapIterator = true;
  if (testMapProto) {
    hasBuggyMapIterator = isFunction(testMapProto[symIt]) === false;
  }

  if (hasBuggyMapIterator) {
    ExportMap = MapObject;
  }
}

var testSet;

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  if (isNumberType(testSet.size) === false || testSet.size !== 0) {
    ExportMap = MapObject;
  } else {
    var propsSet = [
      'has',
      'add',
      'clear',
      'delete',
      'forEach',
      'values',
      'entries',
      'keys',
      symIt
    ];

    var failedSet = some(propsSet, function (method) {
      return isFunction(testSet[method]) === false;
    });

    if (failedSet) {
      ExportSet = SetObject;
    }
  }
}

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  testSet['delete'](0);
  testSet.add(-0);
  var setUsesSameValueZero = testSet.has(0) && testSet.has(-0);
  if (setUsesSameValueZero === false) {
    ExportSet = SetObject;
  }
}

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  var setSupportsChaining = testSet.add(1) === testSet;
  if (setSupportsChaining === false) {
    ExportSet = SetObject;
  }
}

if (ExportSet !== SetObject) {
  if (Object.setPrototypeOf) {
    var MySet = function (arg) {
      testSet = new ExportSet(arg);
      Object.setPrototypeOf(testSet, MySet.prototype);
      return testSet;
    };
    Object.setPrototypeOf(MySet, ExportSet);
    MySet.prototype = Object.create(ExportSet.prototype, { constructor: { value: MySet } });

    var setSupportsSubclassing = false;
    try {
      testSet = new MySet([]);
      testSet.add(42, 42);
      setSupportsSubclassing = testSet instanceof MySet;
    } catch (ignore) {}

    if (setSupportsSubclassing === false) {
      ExportSet = SetObject;
    }
  }
}

if (ExportSet !== SetObject) {
  var setRequiresNew;
  try {
    // eslint-disable-next-line new-cap
    setRequiresNew = (ExportSet() instanceof ExportSet) === false;
  } catch (e) {
    setRequiresNew = e instanceof TypeError;
  }

  if (setRequiresNew === false) {
    ExportSet = SetObject;
  }
}

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  // eslint-disable-next-line id-length
  var setIterationThrowsStopIterator;
  try {
    setIterationThrowsStopIterator = testSet.keys().next().done === false;
  } catch (ignore) {
    setIterationThrowsStopIterator = true;
  }

  if (setIterationThrowsStopIterator) {
    ExportSet = SetObject;
  }
}

// Safari 8
if (ExportSet !== SetObject && isFunction(new ExportSet().keys().next) === false) {
  ExportSet = SetObject;
}

if (hasRealSymbolIterator && ExportSet !== SetObject) {
  var testSetProto = getPrototypeOf(new ExportSet().keys());
  var hasBuggySetIterator = true;
  if (testSetProto) {
    hasBuggySetIterator = isFunction(testSetProto[symIt]) === false;
  }

  if (hasBuggySetIterator) {
    ExportSet = SetObject;
  }
}

var hasCommon = function _hasCommon(object) {
  return isObjectLike(object) && isFunction(object[symIt]) && isBoolean(object['[[changed]]']) && isObjectLike(object['[[id]]']) && isArray(object['[[key]]']) && isArray(object['[[order]]']) && isNumberType(object.size);
};

var $isMap;
if (ExportMap === MapObject) {
  $isMap = function _isMap(object) {
    if (isMap(object)) {
      return true;
    }

    return hasCommon(object) && isArray(object['[[value]]']);
  };
} else {
  $isMap = isMap;
}

var $isSet;
if (ExportSet === SetObject) {
  $isSet = function _isSet(object) {
    if (isSet(object)) {
      return true;
    }

    return hasCommon(object) && isUndefined(object['[[value]]']);
  };
} else {
  $isSet = isSet;
}

/*
 * Exports.
 */

module.exports = {
  /**
   * Determine if an `object` is a `Map`.
   *
   * @param {*} object - The object to test.
   * @returns {boolean} `true` if the `object` is a `Map`,
   *  else `false`.
   * @example
   * var isMap = require('collections-x').isMap;
   * var m = new Map();
   *
   * isMap([]); // false
   * isMap(true); // false
   * isMap(m); // true
   */
  isMap: $isMap,
  /**
   * Determine if an `object` is a `Set`.
   *
   * @param {*} object - The object to test.
   * @returns {boolean} `true` if the `object` is a `Set`,
   *  else `false`.
   * @example
   * var isSet = require('collections-x');
   * var s = new Set();
   *
   * isSet([]); // false
   * isSet(true); // false
   * isSet(s); // true
   */
  isSet: $isSet,
  /** @borrows Map as Map */
  Map: ExportMap,
  /** @borrows Set as Set */
  Set: ExportSet,
  /**
   * The iterator identifier that is in use.
   *
   * type {Symbol|string}
   */
  symIt: symIt
};

},{"array-some-x":25,"assert-is-function-x":30,"assert-is-object-x":31,"big-counter-x":34,"get-prototype-of-x":120,"has-own-property-x":43,"has-symbol-support-x":124,"index-of-x":129,"is-array-like-x":152,"is-array-x":153,"is-boolean-object":155,"is-function-x":162,"is-map-x":167,"is-nil-x":174,"is-object-like-x":176,"is-primitive":178,"is-set-x":185,"is-string":186,"is-surrogate-pair-x":187,"object-define-properties-x":414,"object-define-property-x":415,"validate.io-undefined":459}],43:[function(require,module,exports){
/**
 * @file Used to determine whether an object has an own property with the specified property key.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-hasownproperty|7.3.11 HasOwnProperty (O, P)}
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-own-property-x
 */

'use strict';

var toObject = require('to-object-x');
var toPrimitive = require('es-to-primitive/es6');
var safeToString = require('safe-to-string-x');
var isSymbol = require('is-symbol');
var hop = Object.prototype.hasOwnProperty;

/**
 * The `hasOwnProperty` method returns a boolean indicating whether
 * the `object` has the specified `property`. Does not attempt to fix known
 * issues in older browsers, but does ES6ify the method.
 *
 * @param {!Object} object - The object to test.
 * @param {string|Symbol} property - The name or Symbol of the property to test.
 * @returns {boolean} `true` if the property is set on `object`, else `false`.
 * @example
 * var hasOwnProperty = require('has-own-property-x');
 * var o = {
 *   foo: 'bar'
 * };
 *
 *
 * hasOwnProperty(o, 'bar'); // false
 * hasOwnProperty(o, 'foo'); // true
 * hasOwnProperty(undefined, 'foo');
 *                   // TypeError: Cannot convert undefined or null to object
 */
module.exports = function hasOwnProperty(object, property) {
  var prop = isSymbol(property) ? property : safeToString(toPrimitive(property, String));

  return hop.call(toObject(object), prop);
};

},{"es-to-primitive/es6":102,"is-symbol":188,"safe-to-string-x":432,"to-object-x":446}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _templateObject = _taggedTemplateLiteral(['', ''], ['', '']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class TemplateTag
 * @classdesc Consumes a pipeline of composable transformer plugins and produces a template tag.
 */
var TemplateTag = function () {
  /**
   * constructs a template tag
   * @constructs TemplateTag
   * @param  {...Object} [...transformers] - an array or arguments list of transformers
   * @return {Function}                    - a template tag
   */
  function TemplateTag() {
    var _this = this;

    for (var _len = arguments.length, transformers = Array(_len), _key = 0; _key < _len; _key++) {
      transformers[_key] = arguments[_key];
    }

    _classCallCheck(this, TemplateTag);

    this.tag = function (strings) {
      for (var _len2 = arguments.length, expressions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        expressions[_key2 - 1] = arguments[_key2];
      }

      if (typeof strings === 'function') {
        // if the first argument passed is a function, assume it is a template tag and return
        // an intermediary tag that processes the template using the aforementioned tag, passing the
        // result to our tag
        return _this.interimTag.bind(_this, strings);
      }

      if (typeof strings === 'string') {
        // if the first argument passed is a string, just transform it
        return _this.transformEndResult(strings);
      }

      // else, return a transformed end result of processing the template with our tag
      strings = strings.map(_this.transformString.bind(_this));
      return _this.transformEndResult(strings.reduce(_this.processSubstitutions.bind(_this, expressions)));
    };

    // if first argument is an array, extrude it as a list of transformers
    if (transformers.length > 0 && Array.isArray(transformers[0])) {
      transformers = transformers[0];
    }

    // if any transformers are functions, this means they are not initiated - automatically initiate them
    this.transformers = transformers.map(function (transformer) {
      return typeof transformer === 'function' ? transformer() : transformer;
    });

    // return an ES2015 template tag
    return this.tag;
  }

  /**
   * Applies all transformers to a template literal tagged with this method.
   * If a function is passed as the first argument, assumes the function is a template tag
   * and applies it to the template, returning a template tag.
   * @param  {(Function|String|Array<String>)} strings        - Either a template tag or an array containing template strings separated by identifier
   * @param  {...*}                            ...expressions - Optional list of substitution values.
   * @return {(String|Function)}                              - Either an intermediary tag function or the results of processing the template.
   */


  _createClass(TemplateTag, [{
    key: 'interimTag',


    /**
     * An intermediary template tag that receives a template tag and passes the result of calling the template with the received
     * template tag to our own template tag.
     * @param  {Function}        nextTag          - the received template tag
     * @param  {Array<String>}   template         - the template to process
     * @param  {...*}            ...substitutions - `substitutions` is an array of all substitutions in the template
     * @return {*}                                - the final processed value
     */
    value: function interimTag(previousTag, template) {
      for (var _len3 = arguments.length, substitutions = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        substitutions[_key3 - 2] = arguments[_key3];
      }

      return this.tag(_templateObject, previousTag.apply(undefined, [template].concat(substitutions)));
    }

    /**
     * Performs bulk processing on the tagged template, transforming each substitution and then
     * concatenating the resulting values into a string.
     * @param  {Array<*>} substitutions - an array of all remaining substitutions present in this template
     * @param  {String}   resultSoFar   - this iteration's result string so far
     * @param  {String}   remainingPart - the template chunk after the current substitution
     * @return {String}                 - the result of joining this iteration's processed substitution with the result
     */

  }, {
    key: 'processSubstitutions',
    value: function processSubstitutions(substitutions, resultSoFar, remainingPart) {
      var substitution = this.transformSubstitution(substitutions.shift(), resultSoFar);
      return ''.concat(resultSoFar, substitution, remainingPart);
    }

    /**
     * Iterate through each transformer, applying the transformer's `onString` method to the template
     * strings before all substitutions are processed.
     * @param {String}  str - The input string
     * @return {String}     - The final results of processing each transformer
     */

  }, {
    key: 'transformString',
    value: function transformString(str) {
      var cb = function cb(res, transform) {
        return transform.onString ? transform.onString(res) : res;
      };
      return this.transformers.reduce(cb, str);
    }

    /**
     * When a substitution is encountered, iterates through each transformer and applies the transformer's
     * `onSubstitution` method to the substitution.
     * @param  {*}      substitution - The current substitution
     * @param  {String} resultSoFar  - The result up to and excluding this substitution.
     * @return {*}                   - The final result of applying all substitution transformations.
     */

  }, {
    key: 'transformSubstitution',
    value: function transformSubstitution(substitution, resultSoFar) {
      var cb = function cb(res, transform) {
        return transform.onSubstitution ? transform.onSubstitution(res, resultSoFar) : res;
      };
      return this.transformers.reduce(cb, substitution);
    }

    /**
     * Iterates through each transformer, applying the transformer's `onEndResult` method to the
     * template literal after all substitutions have finished processing.
     * @param  {String} endResult - The processed template, just before it is returned from the tag
     * @return {String}           - The final results of processing each transformer
     */

  }, {
    key: 'transformEndResult',
    value: function transformEndResult(endResult) {
      var cb = function cb(res, transform) {
        return transform.onEndResult ? transform.onEndResult(res) : res;
      };
      return this.transformers.reduce(cb, endResult);
    }
  }]);

  return TemplateTag;
}();

exports.default = TemplateTag;
module.exports = exports['default'];

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _TemplateTag = require('./TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _TemplateTag2.default;
module.exports = exports['default'];

},{"./TemplateTag":44}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _html = require('../html');

var _html2 = _interopRequireDefault(_html);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _html2.default;
module.exports = exports['default'];

},{"../html":54}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var commaLists = new _TemplateTag2.default((0, _inlineArrayTransformer2.default)({ separator: ',' }), _stripIndentTransformer2.default, _trimResultTransformer2.default);

exports.default = commaLists;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../stripIndentTransformer":87,"../trimResultTransformer":91}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _commaLists = require('./commaLists');

var _commaLists2 = _interopRequireDefault(_commaLists);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _commaLists2.default;
module.exports = exports['default'];

},{"./commaLists":47}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var commaListsAnd = new _TemplateTag2.default((0, _inlineArrayTransformer2.default)({ separator: ',', conjunction: 'and' }), _stripIndentTransformer2.default, _trimResultTransformer2.default);

exports.default = commaListsAnd;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../stripIndentTransformer":87,"../trimResultTransformer":91}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _commaListsAnd = require('./commaListsAnd');

var _commaListsAnd2 = _interopRequireDefault(_commaListsAnd);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _commaListsAnd2.default;
module.exports = exports['default'];

},{"./commaListsAnd":49}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var commaListsOr = new _TemplateTag2.default((0, _inlineArrayTransformer2.default)({ separator: ',', conjunction: 'or' }), _stripIndentTransformer2.default, _trimResultTransformer2.default);

exports.default = commaListsOr;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../stripIndentTransformer":87,"../trimResultTransformer":91}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _commaListsOr = require('./commaListsOr');

var _commaListsOr2 = _interopRequireDefault(_commaListsOr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _commaListsOr2.default;
module.exports = exports['default'];

},{"./commaListsOr":51}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _splitStringTransformer = require('../splitStringTransformer');

var _splitStringTransformer2 = _interopRequireDefault(_splitStringTransformer);

var _removeNonPrintingValuesTransformer = require('../removeNonPrintingValuesTransformer');

var _removeNonPrintingValuesTransformer2 = _interopRequireDefault(_removeNonPrintingValuesTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var html = new _TemplateTag2.default((0, _splitStringTransformer2.default)('\n'), _removeNonPrintingValuesTransformer2.default, _inlineArrayTransformer2.default, _stripIndentTransformer2.default, _trimResultTransformer2.default);

exports.default = html;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../removeNonPrintingValuesTransformer":72,"../splitStringTransformer":83,"../stripIndentTransformer":87,"../trimResultTransformer":91}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _html = require('./html');

var _html2 = _interopRequireDefault(_html);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _html2.default;
module.exports = exports['default'];

},{"./html":53}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stripIndents = exports.stripIndent = exports.oneLineInlineLists = exports.inlineLists = exports.oneLineCommaListsAnd = exports.oneLineCommaListsOr = exports.oneLineCommaLists = exports.oneLineTrim = exports.oneLine = exports.safeHtml = exports.source = exports.codeBlock = exports.html = exports.commaListsOr = exports.commaListsAnd = exports.commaLists = exports.removeNonPrintingValuesTransformer = exports.splitStringTransformer = exports.inlineArrayTransformer = exports.replaceStringTransformer = exports.replaceSubstitutionTransformer = exports.replaceResultTransformer = exports.stripIndentTransformer = exports.trimResultTransformer = exports.TemplateTag = undefined;

var _TemplateTag2 = require('./TemplateTag');

var _TemplateTag3 = _interopRequireDefault(_TemplateTag2);

var _trimResultTransformer2 = require('./trimResultTransformer');

var _trimResultTransformer3 = _interopRequireDefault(_trimResultTransformer2);

var _stripIndentTransformer2 = require('./stripIndentTransformer');

var _stripIndentTransformer3 = _interopRequireDefault(_stripIndentTransformer2);

var _replaceResultTransformer2 = require('./replaceResultTransformer');

var _replaceResultTransformer3 = _interopRequireDefault(_replaceResultTransformer2);

var _replaceSubstitutionTransformer2 = require('./replaceSubstitutionTransformer');

var _replaceSubstitutionTransformer3 = _interopRequireDefault(_replaceSubstitutionTransformer2);

var _replaceStringTransformer2 = require('./replaceStringTransformer');

var _replaceStringTransformer3 = _interopRequireDefault(_replaceStringTransformer2);

var _inlineArrayTransformer2 = require('./inlineArrayTransformer');

var _inlineArrayTransformer3 = _interopRequireDefault(_inlineArrayTransformer2);

var _splitStringTransformer2 = require('./splitStringTransformer');

var _splitStringTransformer3 = _interopRequireDefault(_splitStringTransformer2);

var _removeNonPrintingValuesTransformer2 = require('./removeNonPrintingValuesTransformer');

var _removeNonPrintingValuesTransformer3 = _interopRequireDefault(_removeNonPrintingValuesTransformer2);

var _commaLists2 = require('./commaLists');

var _commaLists3 = _interopRequireDefault(_commaLists2);

var _commaListsAnd2 = require('./commaListsAnd');

var _commaListsAnd3 = _interopRequireDefault(_commaListsAnd2);

var _commaListsOr2 = require('./commaListsOr');

var _commaListsOr3 = _interopRequireDefault(_commaListsOr2);

var _html2 = require('./html');

var _html3 = _interopRequireDefault(_html2);

var _codeBlock2 = require('./codeBlock');

var _codeBlock3 = _interopRequireDefault(_codeBlock2);

var _source2 = require('./source');

var _source3 = _interopRequireDefault(_source2);

var _safeHtml2 = require('./safeHtml');

var _safeHtml3 = _interopRequireDefault(_safeHtml2);

var _oneLine2 = require('./oneLine');

var _oneLine3 = _interopRequireDefault(_oneLine2);

var _oneLineTrim2 = require('./oneLineTrim');

var _oneLineTrim3 = _interopRequireDefault(_oneLineTrim2);

var _oneLineCommaLists2 = require('./oneLineCommaLists');

var _oneLineCommaLists3 = _interopRequireDefault(_oneLineCommaLists2);

var _oneLineCommaListsOr2 = require('./oneLineCommaListsOr');

var _oneLineCommaListsOr3 = _interopRequireDefault(_oneLineCommaListsOr2);

var _oneLineCommaListsAnd2 = require('./oneLineCommaListsAnd');

var _oneLineCommaListsAnd3 = _interopRequireDefault(_oneLineCommaListsAnd2);

var _inlineLists2 = require('./inlineLists');

var _inlineLists3 = _interopRequireDefault(_inlineLists2);

var _oneLineInlineLists2 = require('./oneLineInlineLists');

var _oneLineInlineLists3 = _interopRequireDefault(_oneLineInlineLists2);

var _stripIndent2 = require('./stripIndent');

var _stripIndent3 = _interopRequireDefault(_stripIndent2);

var _stripIndents2 = require('./stripIndents');

var _stripIndents3 = _interopRequireDefault(_stripIndents2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.TemplateTag = _TemplateTag3.default;

// transformers
// core

exports.trimResultTransformer = _trimResultTransformer3.default;
exports.stripIndentTransformer = _stripIndentTransformer3.default;
exports.replaceResultTransformer = _replaceResultTransformer3.default;
exports.replaceSubstitutionTransformer = _replaceSubstitutionTransformer3.default;
exports.replaceStringTransformer = _replaceStringTransformer3.default;
exports.inlineArrayTransformer = _inlineArrayTransformer3.default;
exports.splitStringTransformer = _splitStringTransformer3.default;
exports.removeNonPrintingValuesTransformer = _removeNonPrintingValuesTransformer3.default;

// tags

exports.commaLists = _commaLists3.default;
exports.commaListsAnd = _commaListsAnd3.default;
exports.commaListsOr = _commaListsOr3.default;
exports.html = _html3.default;
exports.codeBlock = _codeBlock3.default;
exports.source = _source3.default;
exports.safeHtml = _safeHtml3.default;
exports.oneLine = _oneLine3.default;
exports.oneLineTrim = _oneLineTrim3.default;
exports.oneLineCommaLists = _oneLineCommaLists3.default;
exports.oneLineCommaListsOr = _oneLineCommaListsOr3.default;
exports.oneLineCommaListsAnd = _oneLineCommaListsAnd3.default;
exports.inlineLists = _inlineLists3.default;
exports.oneLineInlineLists = _oneLineInlineLists3.default;
exports.stripIndent = _stripIndent3.default;
exports.stripIndents = _stripIndents3.default;

},{"./TemplateTag":45,"./codeBlock":46,"./commaLists":48,"./commaListsAnd":50,"./commaListsOr":52,"./html":54,"./inlineArrayTransformer":56,"./inlineLists":58,"./oneLine":60,"./oneLineCommaLists":62,"./oneLineCommaListsAnd":64,"./oneLineCommaListsOr":66,"./oneLineInlineLists":68,"./oneLineTrim":70,"./removeNonPrintingValuesTransformer":72,"./replaceResultTransformer":74,"./replaceStringTransformer":76,"./replaceSubstitutionTransformer":78,"./safeHtml":80,"./source":82,"./splitStringTransformer":83,"./stripIndent":85,"./stripIndentTransformer":87,"./stripIndents":89,"./trimResultTransformer":91}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _inlineArrayTransformer = require('./inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _inlineArrayTransformer2.default;
module.exports = exports['default'];

},{"./inlineArrayTransformer":57}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var defaults = {
  separator: '',
  conjunction: '',
  serial: false
};

/**
 * Converts an array substitution to a string containing a list
 * @param  {String} [opts.separator = ''] - the character that separates each item
 * @param  {String} [opts.conjunction = '']  - replace the last separator with this
 * @param  {Boolean} [opts.serial = false] - include the separator before the conjunction? (Oxford comma use-case)
 *
 * @return {Object}                     - a TemplateTag transformer
 */
var inlineArrayTransformer = function inlineArrayTransformer() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults;
  return {
    onSubstitution: function onSubstitution(substitution, resultSoFar) {
      // only operate on arrays
      if (Array.isArray(substitution)) {
        var arrayLength = substitution.length;
        var separator = opts.separator;
        var conjunction = opts.conjunction;
        var serial = opts.serial;
        // join each item in the array into a string where each item is separated by separator
        // be sure to maintain indentation
        var indent = resultSoFar.match(/(\n?[^\S\n]+)$/);
        if (indent) {
          substitution = substitution.join(separator + indent[1]);
        } else {
          substitution = substitution.join(separator + ' ');
        }
        // if conjunction is set, replace the last separator with conjunction, but only if there is more than one substitution
        if (conjunction && arrayLength > 1) {
          var separatorIndex = substitution.lastIndexOf(separator);
          substitution = substitution.slice(0, separatorIndex) + (serial ? separator : '') + ' ' + conjunction + substitution.slice(separatorIndex + 1);
        }
      }
      return substitution;
    }
  };
};

exports.default = inlineArrayTransformer;
module.exports = exports['default'];

},{}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _inlineLists = require('./inlineLists');

var _inlineLists2 = _interopRequireDefault(_inlineLists);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _inlineLists2.default;
module.exports = exports['default'];

},{"./inlineLists":59}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inlineLists = new _TemplateTag2.default(_inlineArrayTransformer2.default, _stripIndentTransformer2.default, _trimResultTransformer2.default);

exports.default = inlineLists;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../stripIndentTransformer":87,"../trimResultTransformer":91}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _oneLine = require('./oneLine');

var _oneLine2 = _interopRequireDefault(_oneLine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _oneLine2.default;
module.exports = exports['default'];

},{"./oneLine":61}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _replaceResultTransformer = require('../replaceResultTransformer');

var _replaceResultTransformer2 = _interopRequireDefault(_replaceResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var oneLine = new _TemplateTag2.default((0, _replaceResultTransformer2.default)(/(?:\n(?:\s*))+/g, ' '), _trimResultTransformer2.default);

exports.default = oneLine;
module.exports = exports['default'];

},{"../TemplateTag":45,"../replaceResultTransformer":74,"../trimResultTransformer":91}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _oneLineCommaLists = require('./oneLineCommaLists');

var _oneLineCommaLists2 = _interopRequireDefault(_oneLineCommaLists);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _oneLineCommaLists2.default;
module.exports = exports['default'];

},{"./oneLineCommaLists":63}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _replaceResultTransformer = require('../replaceResultTransformer');

var _replaceResultTransformer2 = _interopRequireDefault(_replaceResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var oneLineCommaLists = new _TemplateTag2.default((0, _inlineArrayTransformer2.default)({ separator: ',' }), (0, _replaceResultTransformer2.default)(/(?:\s+)/g, ' '), _trimResultTransformer2.default);

exports.default = oneLineCommaLists;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../replaceResultTransformer":74,"../trimResultTransformer":91}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _oneLineCommaListsAnd = require('./oneLineCommaListsAnd');

var _oneLineCommaListsAnd2 = _interopRequireDefault(_oneLineCommaListsAnd);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _oneLineCommaListsAnd2.default;
module.exports = exports['default'];

},{"./oneLineCommaListsAnd":65}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _replaceResultTransformer = require('../replaceResultTransformer');

var _replaceResultTransformer2 = _interopRequireDefault(_replaceResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var oneLineCommaListsAnd = new _TemplateTag2.default((0, _inlineArrayTransformer2.default)({ separator: ',', conjunction: 'and' }), (0, _replaceResultTransformer2.default)(/(?:\s+)/g, ' '), _trimResultTransformer2.default);

exports.default = oneLineCommaListsAnd;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../replaceResultTransformer":74,"../trimResultTransformer":91}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _oneLineCommaListsOr = require('./oneLineCommaListsOr');

var _oneLineCommaListsOr2 = _interopRequireDefault(_oneLineCommaListsOr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _oneLineCommaListsOr2.default;
module.exports = exports['default'];

},{"./oneLineCommaListsOr":67}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _replaceResultTransformer = require('../replaceResultTransformer');

var _replaceResultTransformer2 = _interopRequireDefault(_replaceResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var oneLineCommaListsOr = new _TemplateTag2.default((0, _inlineArrayTransformer2.default)({ separator: ',', conjunction: 'or' }), (0, _replaceResultTransformer2.default)(/(?:\s+)/g, ' '), _trimResultTransformer2.default);

exports.default = oneLineCommaListsOr;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../replaceResultTransformer":74,"../trimResultTransformer":91}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _oneLineInlineLists = require('./oneLineInlineLists');

var _oneLineInlineLists2 = _interopRequireDefault(_oneLineInlineLists);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _oneLineInlineLists2.default;
module.exports = exports['default'];

},{"./oneLineInlineLists":69}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _replaceResultTransformer = require('../replaceResultTransformer');

var _replaceResultTransformer2 = _interopRequireDefault(_replaceResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var oneLineInlineLists = new _TemplateTag2.default(_inlineArrayTransformer2.default, (0, _replaceResultTransformer2.default)(/(?:\s+)/g, ' '), _trimResultTransformer2.default);

exports.default = oneLineInlineLists;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../replaceResultTransformer":74,"../trimResultTransformer":91}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _oneLineTrim = require('./oneLineTrim');

var _oneLineTrim2 = _interopRequireDefault(_oneLineTrim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _oneLineTrim2.default;
module.exports = exports['default'];

},{"./oneLineTrim":71}],71:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _replaceResultTransformer = require('../replaceResultTransformer');

var _replaceResultTransformer2 = _interopRequireDefault(_replaceResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var oneLineTrim = new _TemplateTag2.default((0, _replaceResultTransformer2.default)(/(?:\n\s*)/g, ''), _trimResultTransformer2.default);

exports.default = oneLineTrim;
module.exports = exports['default'];

},{"../TemplateTag":45,"../replaceResultTransformer":74,"../trimResultTransformer":91}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _removeNonPrintingValuesTransformer = require('./removeNonPrintingValuesTransformer');

var _removeNonPrintingValuesTransformer2 = _interopRequireDefault(_removeNonPrintingValuesTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _removeNonPrintingValuesTransformer2.default;
module.exports = exports['default'];

},{"./removeNonPrintingValuesTransformer":73}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var isValidValue = function isValidValue(x) {
  return x != null && !Number.isNaN(x) && typeof x !== 'boolean';
};

var removeNonPrintingValuesTransformer = function removeNonPrintingValuesTransformer() {
  return {
    onSubstitution: function onSubstitution(substitution) {
      if (Array.isArray(substitution)) {
        return substitution.filter(isValidValue);
      }
      if (isValidValue(substitution)) {
        return substitution;
      }
      return '';
    }
  };
};

exports.default = removeNonPrintingValuesTransformer;
module.exports = exports['default'];

},{}],74:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _replaceResultTransformer = require('./replaceResultTransformer');

var _replaceResultTransformer2 = _interopRequireDefault(_replaceResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _replaceResultTransformer2.default;
module.exports = exports['default'];

},{"./replaceResultTransformer":75}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Replaces tabs, newlines and spaces with the chosen value when they occur in sequences
 * @param  {(String|RegExp)} replaceWhat - the value or pattern that should be replaced
 * @param  {*}               replaceWith - the replacement value
 * @return {Object}                      - a TemplateTag transformer
 */
var replaceResultTransformer = function replaceResultTransformer(replaceWhat, replaceWith) {
  return {
    onEndResult: function onEndResult(endResult) {
      if (replaceWhat == null || replaceWith == null) {
        throw new Error('replaceResultTransformer requires at least 2 arguments.');
      }
      return endResult.replace(replaceWhat, replaceWith);
    }
  };
};

exports.default = replaceResultTransformer;
module.exports = exports['default'];

},{}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _replaceStringTransformer = require('./replaceStringTransformer');

var _replaceStringTransformer2 = _interopRequireDefault(_replaceStringTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _replaceStringTransformer2.default;
module.exports = exports['default'];

},{"./replaceStringTransformer":77}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var replaceStringTransformer = function replaceStringTransformer(replaceWhat, replaceWith) {
  return {
    onString: function onString(str) {
      if (replaceWhat == null || replaceWith == null) {
        throw new Error('replaceStringTransformer requires at least 2 arguments.');
      }

      return str.replace(replaceWhat, replaceWith);
    }
  };
};

exports.default = replaceStringTransformer;
module.exports = exports['default'];

},{}],78:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _replaceSubstitutionTransformer = require('./replaceSubstitutionTransformer');

var _replaceSubstitutionTransformer2 = _interopRequireDefault(_replaceSubstitutionTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _replaceSubstitutionTransformer2.default;
module.exports = exports['default'];

},{"./replaceSubstitutionTransformer":79}],79:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var replaceSubstitutionTransformer = function replaceSubstitutionTransformer(replaceWhat, replaceWith) {
  return {
    onSubstitution: function onSubstitution(substitution, resultSoFar) {
      if (replaceWhat == null || replaceWith == null) {
        throw new Error('replaceSubstitutionTransformer requires at least 2 arguments.');
      }

      // Do not touch if null or undefined
      if (substitution == null) {
        return substitution;
      } else {
        return substitution.toString().replace(replaceWhat, replaceWith);
      }
    }
  };
};

exports.default = replaceSubstitutionTransformer;
module.exports = exports['default'];

},{}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _safeHtml = require('./safeHtml');

var _safeHtml2 = _interopRequireDefault(_safeHtml);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _safeHtml2.default;
module.exports = exports['default'];

},{"./safeHtml":81}],81:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _inlineArrayTransformer = require('../inlineArrayTransformer');

var _inlineArrayTransformer2 = _interopRequireDefault(_inlineArrayTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

var _splitStringTransformer = require('../splitStringTransformer');

var _splitStringTransformer2 = _interopRequireDefault(_splitStringTransformer);

var _replaceSubstitutionTransformer = require('../replaceSubstitutionTransformer');

var _replaceSubstitutionTransformer2 = _interopRequireDefault(_replaceSubstitutionTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var safeHtml = new _TemplateTag2.default((0, _splitStringTransformer2.default)('\n'), _inlineArrayTransformer2.default, _stripIndentTransformer2.default, _trimResultTransformer2.default, (0, _replaceSubstitutionTransformer2.default)(/&/g, '&amp;'), (0, _replaceSubstitutionTransformer2.default)(/</g, '&lt;'), (0, _replaceSubstitutionTransformer2.default)(/>/g, '&gt;'), (0, _replaceSubstitutionTransformer2.default)(/"/g, '&quot;'), (0, _replaceSubstitutionTransformer2.default)(/'/g, '&#x27;'), (0, _replaceSubstitutionTransformer2.default)(/`/g, '&#x60;'));

exports.default = safeHtml;
module.exports = exports['default'];

},{"../TemplateTag":45,"../inlineArrayTransformer":56,"../replaceSubstitutionTransformer":78,"../splitStringTransformer":83,"../stripIndentTransformer":87,"../trimResultTransformer":91}],82:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _html = require('../html');

var _html2 = _interopRequireDefault(_html);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _html2.default;
module.exports = exports['default'];

},{"../html":54}],83:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _splitStringTransformer = require('./splitStringTransformer');

var _splitStringTransformer2 = _interopRequireDefault(_splitStringTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _splitStringTransformer2.default;
module.exports = exports['default'];

},{"./splitStringTransformer":84}],84:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var splitStringTransformer = function splitStringTransformer(splitBy) {
  return {
    onSubstitution: function onSubstitution(substitution, resultSoFar) {
      if (splitBy != null && typeof splitBy === 'string') {
        if (typeof substitution === 'string' && substitution.includes(splitBy)) {
          substitution = substitution.split(splitBy);
        }
      } else {
        throw new Error('You need to specify a string character to split by.');
      }
      return substitution;
    }
  };
};

exports.default = splitStringTransformer;
module.exports = exports['default'];

},{}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stripIndent = require('./stripIndent');

var _stripIndent2 = _interopRequireDefault(_stripIndent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _stripIndent2.default;
module.exports = exports['default'];

},{"./stripIndent":86}],86:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stripIndent = new _TemplateTag2.default(_stripIndentTransformer2.default, _trimResultTransformer2.default);

exports.default = stripIndent;
module.exports = exports['default'];

},{"../TemplateTag":45,"../stripIndentTransformer":87,"../trimResultTransformer":91}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stripIndentTransformer = require('./stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _stripIndentTransformer2.default;
module.exports = exports['default'];

},{"./stripIndentTransformer":88}],88:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * strips indentation from a template literal
 * @param  {String} type = 'initial' - whether to remove all indentation or just leading indentation. can be 'all' or 'initial'
 * @return {Object}                  - a TemplateTag transformer
 */
var stripIndentTransformer = function stripIndentTransformer() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'initial';
  return {
    onEndResult: function onEndResult(endResult) {
      if (type === 'initial') {
        // remove the shortest leading indentation from each line
        var match = endResult.match(/^[^\S\n]*(?=\S)/gm);
        var indent = match && Math.min.apply(Math, _toConsumableArray(match.map(function (el) {
          return el.length;
        })));
        if (indent) {
          var regexp = new RegExp('^.{' + indent + '}', 'gm');
          return endResult.replace(regexp, '');
        }
        return endResult;
      }
      if (type === 'all') {
        // remove all indentation from each line
        return endResult.replace(/^[^\S\n]+/gm, '');
      }
      throw new Error('Unknown type: ' + type);
    }
  };
};

exports.default = stripIndentTransformer;
module.exports = exports['default'];

},{}],89:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stripIndents = require('./stripIndents');

var _stripIndents2 = _interopRequireDefault(_stripIndents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _stripIndents2.default;
module.exports = exports['default'];

},{"./stripIndents":90}],90:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TemplateTag = require('../TemplateTag');

var _TemplateTag2 = _interopRequireDefault(_TemplateTag);

var _stripIndentTransformer = require('../stripIndentTransformer');

var _stripIndentTransformer2 = _interopRequireDefault(_stripIndentTransformer);

var _trimResultTransformer = require('../trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stripIndents = new _TemplateTag2.default((0, _stripIndentTransformer2.default)('all'), _trimResultTransformer2.default);

exports.default = stripIndents;
module.exports = exports['default'];

},{"../TemplateTag":45,"../stripIndentTransformer":87,"../trimResultTransformer":91}],91:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _trimResultTransformer = require('./trimResultTransformer');

var _trimResultTransformer2 = _interopRequireDefault(_trimResultTransformer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _trimResultTransformer2.default;
module.exports = exports['default'];

},{"./trimResultTransformer":92}],92:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * TemplateTag transformer that trims whitespace on the end result of a tagged template
 * @param  {String} side = '' - The side of the string to trim. Can be 'start' or 'end' (alternatively 'left' or 'right')
 * @return {Object}           - a TemplateTag transformer
 */
var trimResultTransformer = function trimResultTransformer() {
  var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    onEndResult: function onEndResult(endResult) {
      if (side === '') {
        return endResult.trim();
      }

      side = side.toLowerCase();

      if (side === 'start' || side === 'left') {
        return endResult.replace(/^\s*/, '');
      }

      if (side === 'end' || side === 'right') {
        return endResult.replace(/\s*$/, '');
      }

      throw new Error('Side not supported: ' + side);
    }
  };
};

exports.default = trimResultTransformer;
module.exports = exports['default'];

},{}],93:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],94:[function(require,module,exports){
// Console-polyfill. MIT license.
// https://github.com/paulmillr/console-polyfill
// Make it safe to do console.log() always.
(function(global) {
  'use strict';
  if (!global.console) {
    global.console = {};
  }
  var con = global.console;
  var prop, method;
  var dummy = function() {};
  var properties = ['memory'];
  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +
     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
  while (method = methods.pop()) if (!con[method]) con[method] = dummy;
  // Using `this` for web workers & supports Browserify / Webpack.
})(typeof window === 'undefined' ? this : window);

},{}],95:[function(require,module,exports){
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;
var pairSplitRegExp = /; */;

/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {}
  var opt = options || {};
  var pairs = str.split(pairSplitRegExp);
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    // skip things that don't look like key=value
    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim()
    var val = pair.substr(++eq_idx, pair.length).trim();

    // quoted values
    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    // only assign once
    if (undefined == obj[key]) {
      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */

function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}

},{}],96:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

var fingerprint = require('./lib/fingerprint.js');
var pad = require('./lib/pad.js');

var c = 0,
  blockSize = 4,
  base = 36,
  discreteValues = Math.pow(base, blockSize);

function randomBlock () {
  return pad((Math.random() *
    discreteValues << 0)
    .toString(base), blockSize);
}

function safeCounter () {
  c = c < discreteValues ? c : 0;
  c++; // this is not subliminal
  return c - 1;
}

function cuid () {
  // Starting with a lowercase letter makes
  // it HTML element ID friendly.
  var letter = 'c', // hard-coded allows for sequential access

    // timestamp
    // warning: this exposes the exact date and time
    // that the uid was created.
    timestamp = (new Date().getTime()).toString(base),

    // Prevent same-machine collisions.
    counter = pad(safeCounter().toString(base), blockSize),

    // A few chars to generate distinct ids for different
    // clients (so different computers are far less
    // likely to generate the same id)
    print = fingerprint(),

    // Grab some more chars from Math.random()
    random = randomBlock() + randomBlock();

  return letter + timestamp + counter + print + random;
}

cuid.slug = function slug () {
  var date = new Date().getTime().toString(36),
    counter = safeCounter().toString(36).slice(-4),
    print = fingerprint().slice(0, 1) +
      fingerprint().slice(-1),
    random = randomBlock().slice(-2);

  return date.slice(-2) +
    counter + print + random;
};

cuid.isCuid = function isCuid (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  if (stringToCheck.startsWith('c')) return true;
  return false;
};

cuid.isSlug = function isSlug (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  var stringLength = stringToCheck.length;
  if (stringLength >= 7 && stringLength <= 10) return true;
  return false;
};

cuid.fingerprint = fingerprint;

module.exports = cuid;

},{"./lib/fingerprint.js":97,"./lib/pad.js":98}],97:[function(require,module,exports){
var pad = require('./pad.js');

var env = typeof window === 'object' ? window : self;
var globalCount = Object.keys(env).length;
var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
var clientId = pad((mimeTypesLength +
  navigator.userAgent.length).toString(36) +
  globalCount.toString(36), 4);

module.exports = function fingerprint () {
  return clientId;
};

},{"./pad.js":98}],98:[function(require,module,exports){
module.exports = function pad (num, size) {
  var s = '000000000' + num;
  return s.substr(s.length - size);
};

},{}],99:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"object-keys":418}],100:[function(require,module,exports){
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

module.exports = first

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = []

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i]

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0]

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j]
      var fn = listener(event, callback)

      // listen to the event
      ee.on(event, fn)
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      })
    }
  }

  function callback() {
    cleanup()
    done.apply(null, arguments)
  }

  function cleanup() {
    var x
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i]
      x.ee.removeListener(x.event, x.fn)
    }
  }

  function thunk(fn) {
    done = fn
  }

  thunk.cancel = cleanup

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length)
    var ee = this
    var err = event === 'error'
      ? arg1
      : null

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }

    done(err, ee, event, args)
  }
}

},{}],101:[function(require,module,exports){
'use strict';

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');
var isCallable = require('is-callable');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"./helpers/isPrimitive":103,"is-callable":156,"is-date-object":158,"is-symbol":188}],102:[function(require,module,exports){
'use strict';

module.exports = require('./es2015');

},{"./es2015":101}],103:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],104:[function(require,module,exports){
module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var arr = []

// Regular stringify
function stringify (obj, replacer, spacer) {
  decirc(obj, '', [], undefined)
  var res = JSON.stringify(obj, replacer, spacer)
  while (arr.length !== 0) {
    var part = arr.pop()
    part[0][part[1]] = part[2]
  }
  return res
}
function decirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]'
        arr.push([parent, k, val])
        return
      }
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, stack, val)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, stack, val)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer) {
  var tmp = deterministicDecirc(obj, '', [], undefined) || obj
  var res = JSON.stringify(tmp, replacer, spacer)
  while (arr.length !== 0) {
    var part = arr.pop()
    part[0][part[1]] = part[2]
  }
  return res
}

function deterministicDecirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]'
        arr.push([parent, k, val])
        return
      }
    }
    if (typeof val.toJSON === 'function') {
      return
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, stack, val)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, stack, val)
        tmp[key] = val[key]
      }
      if (parent !== undefined) {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

},{}],105:[function(require,module,exports){
/**
 * @file This method returns the index of the first element in the array that satisfies the provided testing function.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module find-index-x
 */

'use strict';

var pFindIndex = Array.prototype.findIndex;

// eslint-disable-next-line no-sparse-arrays
var implemented = pFindIndex && ([, 1].findIndex(function (item, idx) {
  return idx === 0;
}) === 0);

var findIdx;
if (implemented) {
  findIdx = function findIndex(array, callback) {
    var args = [callback];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return pFindIndex.apply(array, args);
  };
} else {
  var toLength = require('to-length-x');
  var toObject = require('to-object-x');
  var isString = require('is-string');
  var assertIsFunction = require('assert-is-function-x');
  var splitString = require('has-boxed-string-x') === false;

  findIdx = function findIndex(array, callback) {
    var object = toObject(array);
    assertIsFunction(callback);
    var iterable = splitString && isString(object) ? object.split('') : object;
    var length = toLength(iterable.length);
    if (length < 1) {
      return -1;
    }

    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var index = 0;
    while (index < length) {
      if (callback.call(thisArg, iterable[index], index, object)) {
        return index;
      }

      index += 1;
    }

    return -1;
  };
}

/**
 * Like `findIndex`, this method returns an index in the array, if an element
 * in the array satisfies the provided testing function. Otherwise -1 is returned.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If array is `null` or `undefined`-
 * @param {Function} callback - Function to execute on each value in the array,
 *  taking three arguments: `element`, `index` and `array`.
 * @throws {TypeError} If `callback` is not a function.
 * @param {*} [thisArg] - Object to use as `this` when executing `callback`.
 * @returns {number} Returns index of positively tested element, otherwise -1.
 * @example
 * var findIndex = require('find-index-x');
 *
 * function isPrime(element, index, array) {
 *   var start = 2;
 *   while (start <= Math.sqrt(element)) {
 *     if (element % start++ < 1) {
 *       return false;
 *     }
 *   }
 *   return element > 1;
 * }
 *
 * console.log(findIndex([4, 6, 8, 12, 14], isPrime)); // -1, not found
 * console.log(findIndex([4, 6, 7, 12, 13], isPrime)); // 2
 */
module.exports = findIdx;

},{"assert-is-function-x":30,"has-boxed-string-x":121,"is-string":186,"to-length-x":109,"to-object-x":446}],106:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"is-nan":170,"max-safe-integer":397}],107:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11,"is-nan":170}],108:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12,"is-finite-x":106,"is-nan":170,"math-sign-x":107}],109:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"max-safe-integer":397,"to-integer-x":108}],110:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],111:[function(require,module,exports){
// these are known as "placeholder tokens", see this link for more info:
// <https://nodejs.org/api/util.html#util_util_format_format_args>
//
// since they aren't exposed (or don't seem to be) by node (at least not yet)
// we just define an array that contains them for now
// <https://github.com/nodejs/node/issues/17601>
// <https://github.com/nodejs/node/blob/7af1ad0ec15546761233c2e90008316551db2bbd/doc/api/util.md#utilformatformat-args>
module.exports = ['%s', '%d', '%i', '%f', '%j', '%o', '%O', '%%'];

},{}],112:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],113:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":112}],114:[function(require,module,exports){
/**
 * @file Get the name of the function.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-function-name-x
 */

'use strict';

var isFunction = require('is-function-x');
var functionCtr = function () {}.constructor;

var getName;
var t = function test1() {};
if (t.name === 'test1') {
  var createsAnonymous = functionCtr().name === 'anonymous';
  getName = function _getName(fn) {
    return createsAnonymous && fn.name === 'anonymous' ? '' : fn.name;
  };
} else {
  var replaceComments = require('replace-comments-x');
  var fToString = functionCtr.prototype.toString;
  var normalise = require('normalize-space-x').normalizeSpace2018;
  var reName = /^(?:async )?(?:function|class) ?(?:\* )?([\w$]+)/i;
  var stringMatch = require('cached-constructors-x').String.prototype.match;
  getName = function _getName(fn) {
    var match;
    try {
      match = stringMatch.call(normalise(replaceComments(fToString.call(fn), ' ')), reName);
      if (match) {
        var name = match[1];
        return name === 'anonymous' ? '' : name;
      }
    } catch (ignore) {}

    return '';
  };
}

/**
 * This method returns the name of the function, or `undefined` if not
 * a function.
 *
 * @param {Function} fn - The function to get the name of.
 * @returns {undefined|string} The name of the function,  or `undefined` if
 *  not a function.
 * @example
 * var getFunctionName = require('get-function-name-x');
 *
 * getFunctionName(); // undefined
 * getFunctionName(Number.MIN_VALUE); // undefined
 * getFunctionName('abc'); // undefined
 * getFunctionName(true); // undefined
 * getFunctionName({ name: 'abc' }); // undefined
 * getFunctionName(function () {}); // ''
 * getFunctionName(new Function ()); // ''
 * getFunctionName(function test1() {}); // 'test1'
 * getFunctionName(function* test2() {}); // 'test2'
 * getFunctionName(class Test {}); // 'Test'
 */
module.exports = function getFunctionName(fn) {
  return isFunction(fn, true) ? getName(fn) : void 0;
};

},{"cached-constructors-x":36,"is-function-x":162,"normalize-space-x":405,"replace-comments-x":428}],115:[function(require,module,exports){
/**
 * @file Like Object.getOwnPropertySymbols but gets only enumerable properties.
 * @version 1.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-enumerable-property-symbols-x
 */

'use strict';

var toObject = require('to-object-x');
var filter = require('array-filter-x');
var getOPS = require('get-own-property-symbols-x');
var propertyIsEnumerable = require('property-is-enumerable-x');

/**
 * This method returns only the enumerable own property symbols of an object.
 *
 * @param {Object} target - The target.
 * @throws {typeError} - If target is null or undefined.
 * @returns {Array} The enumerable own property symbols.
 * @example
 * var getOwnEnumerablePropertySymbols = require('get-own-enumerable-property-symbols-x');
 *
 * var obj = { bar: 1, foo: 2 };
 *
 * var symbol1 = Symbol('first');
 * Object.defineProperty(obj, symbo1l, {
 *   enumerable: false,
 *   value: 'first'
 * });
 *
 * var symbol2 = Symbol('second');
 * Object.defineProperty(obj, symbol2, {
 *   enumerable: true,
 *   value: 'second'
 * });
 *
 * getOwnEnumerablePropertySymbols(obj); // [symbol2]
 */
// eslint-disable-next-line id-length
module.exports = function getOwnEnumerablePropertySymbols(target) {
  var object = toObject(target);
  return filter(getOPS(object), function (symbol) {
    return propertyIsEnumerable(object, symbol);
  });
};

},{"array-filter-x":116,"get-own-property-symbols-x":119,"property-is-enumerable-x":425,"to-object-x":446}],116:[function(require,module,exports){
/**
 * @file Creates an array with all elements that pass the test by the provided function.
 * @version 2.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-filter-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var ArrayCtr = cachedCtrs.Array;
var castObject = cachedCtrs.Object;
var nativFilter = typeof ArrayCtr.prototype.filter === 'function' && ArrayCtr.prototype.filter;

var isWorking;
if (nativFilter) {
  var attempt = require('attempt-x');
  var spy = 0;
  var res = attempt.call([1, 2], nativFilter, function (item) {
    spy += item;
    return false;
  });

  isWorking = res.threw === false && res.value && res.value.length === 0 && spy === 3;

  if (isWorking) {
    spy = '';
    res = attempt.call(castObject('abc'), nativFilter, function (item, index) {
      spy += item;
      return index === 1;
    });

    isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === 'b' && spy === 'abc';
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call((function () {
      return arguments;
    }(1, 2, 3)), nativFilter, function (item, index) {
      spy += item;
      return index === 2;
    });

    isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === 3 && spy === 6;
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call({
      0: 1,
      1: 2,
      3: 3,
      4: 4,
      length: 4
    }, nativFilter, function (item) {
      spy += item;
      return false;
    });

    isWorking = res.threw === false && res.value && res.value.length === 0 && spy === 6;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      spy = null;
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativFilter, function (item) {
        spy = item;
        return item;
      });

      isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === div && spy === div;
    }
  }

  if (isWorking) {
    var isStrict = (function () {
      // eslint-disable-next-line no-invalid-this
      return Boolean(this) === false;
    }());

    if (isStrict) {
      spy = null;
      res = attempt.call([1], nativFilter, function () {
        // eslint-disable-next-line no-invalid-this
        spy = typeof this === 'string';
      }, 'x');

      isWorking = res.threw === false && res.value && res.value.length === 0 && spy === true;
    }
  }

  if (isWorking) {
    spy = {};
    var fn = [
      'return nativFilter.call("foo", function (_, __, context) {',
      'if (Boolean(context) === false || typeof context !== "object") {',
      'spy.value = true;}});'
    ].join('');

    // eslint-disable-next-line no-new-func
    res = attempt(Function('nativFilter', 'spy', fn), nativFilter, spy);

    isWorking = res.threw === false && res.value && res.value.length === 0 && spy.value !== true;
  }
}

var $filter;
if (nativFilter) {
  $filter = function filter(array, callBack /* , thisArg */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativFilter.apply(array, args);
  };
} else {
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x').toLength2018;
  var isUndefined = require('validate.io-undefined');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $filter = function filter(array, callBack /* , thisArg */) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var noThis = isUndefined(thisArg);
    var result = [];
    for (var i = 0; i < length; i += 1) {
      if (i in iterable) {
        var item = iterable[i];
        if (noThis ? callBack(item, i, object) : callBack.call(thisArg, item, i, object)) {
          result[result.length] = item;
        }
      }
    }

    return result;
  };
}

/**
 * This method creates a new array with all elements that pass the test
 * implemented by the provided function.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function is a predicate, to test each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {array} A new array with the elements that pass the test.
 * @example
 * var filter = require('array-filter-x');
 *
 * function isBigEnough(value) {
 *   return value >= 10;
 * }
 *
 * var filtered = filter([12, 5, 8, 130, 44], isBigEnough);
 * // filtered is [12, 130, 44]
 */
module.exports = $filter;

},{"assert-is-function-x":117,"attempt-x":32,"cached-constructors-x":36,"split-if-boxed-bug-x":435,"to-length-x":441,"to-object-x":446,"validate.io-undefined":459}],117:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":162,"is-primitive":178,"to-string-symbols-supported-x":449}],118:[function(require,module,exports){
/**
 * @file Creates an array of all properties (enumerable or not) found directly upon a given object.
 * @version 1.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-property-names-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeGOPN = Object.getOwnPropertyNames;

var $gopn;
if (typeof nativeGOPN === 'function') {
  // eslint-disable-next-line id-length
  var objectGOPNAcceptsPrimitives;
  try {
    nativeGOPN('foo');
    objectGOPNAcceptsPrimitives = true;
  } catch (ignore) {}

  if (objectGOPNAcceptsPrimitives) {
    $gopn = nativeGOPN;
  } else {
    var toStringTag = require('to-string-tag-x');
    var concat = Array.prototype.concat;
    var cachedWindowNames = typeof window === 'object' ? nativeGOPN(window) : [];

    $gopn = function getOwnPropertyNames(obj) {
      var val = toObject(obj);
      if (toStringTag(val) === '[object Window]') {
        try {
          return nativeGOPN(val);
        } catch (ignore) {
          // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
          return concat.call([], cachedWindowNames);
        }
      }

      return nativeGOPN(val);
    };
  }
} else {
  var objectKeys = require('object-keys-x');
  $gopn = function getOwnPropertyNames(obj) {
    return objectKeys(obj);
  };
}

/**
 * This method creates an array of all properties (enumerable or not) found
 * directly upon a given object.
 *
 * @param {object} obj - The object whose enumerable and non-enumerable own
 *  properties are to be returned.
 * @throws {TypeError} If target is null or undefined.
 * @returns {array} An array of strings that correspond to the properties found
 *  directly upon the given object.
 * @example
 * var getOwnPropertyName = require('get-own-property-name-x');
 *
 * getOwnPropertyNames('foo'); // ["0", "1", "2", "length"]
 */
module.exports = $gopn;

},{"object-keys-x":417,"to-object-x":446,"to-string-tag-x":450}],119:[function(require,module,exports){
/**
 * @file Creates an array of all symbol properties found directly upon a given object.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-property-symbols-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeGOPS = Object.getOwnPropertySymbols;
var isWorking;
if (require('has-symbol-support-x') && nativeGOPS && typeof nativeGOPS === 'function') {
  var symbol = Symbol('');
  var testObj = { a: 1 };
  testObj[symbol] = 2;
  var r = require('attempt-x')(nativeGOPS, testObj);
  isWorking = r.threw === false && r.value && r.value.length === 1 && r.value[0] === symbol;
}

/**
 * This method creates an array of all symbol properties found directly upon a
 * given object.
 *
 * @param {object} obj - The object whose symbol properties are to be returned.
 * @throws {TypeError} If target is null or undefined.
 * @returns {array} An array of all symbol properties found directly upon the
 *  given object.
 * @example
 * var getOwnPropertySymbols = require('get-own-property-isWorking-x');
 *
 * var symbol = Symbol('');
 * var testObj = { a: 1 };
 * testObj[symbol] = 2;
 * getOwnPropertySymbols(testObj); // [symbol]
 */
module.exports = function getOwnPropertySymbols(obj) {
  var object = toObject(obj);
  return isWorking ? nativeGOPS(object) : [];
};

},{"attempt-x":32,"has-symbol-support-x":124,"to-object-x":446}],120:[function(require,module,exports){
/**
 * @file Sham for Object.getPrototypeOf
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-prototype-of-x
 */

'use strict';

var isFunction = require('is-function-x');
var isNull = require('lodash.isnull');
var toObject = require('to-object-x');
var gpo = require('cached-constructors-x').Object.getPrototypeOf;

if (gpo) {
  try {
    gpo = gpo(Object) === Object.prototype && gpo;
  } catch (ignore) {
    gpo = null;
  }
}

if (gpo) {
  try {
    gpo(1);
  } catch (ignore) {
    var $getPrototypeOf = gpo;
    gpo = function getPrototypeOf(obj) {
      return $getPrototypeOf(toObject(obj));
    };
  }
} else {
  gpo = function getPrototypeOf(obj) {
    var object = toObject(obj);
    // eslint-disable-next-line no-proto
    var proto = object.__proto__;
    if (proto || isNull(proto)) {
      return proto;
    }

    if (isFunction(object.constructor)) {
      return object.constructor.prototype;
    }

    if (object instanceof Object) {
      return Object.prototype;
    }

    return null;
  };
}

/**
 * This method returns the prototype (i.e. the value of the internal [[Prototype]] property)
 * of the specified object.
 *
 * @param {*} obj - The object whose prototype is to be returned.
 * @returns {Object} The prototype of the given object. If there are no inherited properties, null is returned.
 * @example
 * var getPrototypeOf = require('get-prototype-of-x');
 * getPrototypeOf('foo'); // String.prototype
 */
module.exports = gpo;

},{"cached-constructors-x":36,"is-function-x":162,"lodash.isnull":191,"to-object-x":446}],121:[function(require,module,exports){
/**
 * @file Check support of by-index access of string characters.
 * @version 1.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-boxed-string-x
 */

'use strict';

var boxedString = require('cached-constructors-x').Object('a');

/**
 * Check failure of by-index access of string characters (IE < 9)
 * and failure of `0 in boxedString` (Rhino).
 *
 * `true` if no failure; otherwise `false`.
 *
 * @type boolean
 */
module.exports = boxedString[0] === 'a' && (0 in boxedString);

},{"cached-constructors-x":36}],122:[function(require,module,exports){
/**
 * @file Used to determine whether an object has an own property with the specified property key.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-hasownproperty|7.3.11 HasOwnProperty (O, P)}
 * @version 3.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-own-property-x
 */

'use strict';

var toObject = require('to-object-x');
var toPropertyKey = require('to-property-key-x');
var hop = require('cached-constructors-x').Object.prototype.hasOwnProperty;

/**
 * The `hasOwnProperty` method returns a boolean indicating whether
 * the `object` has the specified `property`. Does not attempt to fix known
 * issues in older browsers, but does ES6ify the method.
 *
 * @param {!Object} object - The object to test.
 * @throws {TypeError} If object is null or undefined.
 * @param {string|Symbol} property - The name or Symbol of the property to test.
 * @returns {boolean} `true` if the property is set on `object`, else `false`.
 * @example
 * var hasOwnProperty = require('has-own-property-x');
 * var o = {
 *   foo: 'bar'
 * };
 *
 *
 * hasOwnProperty(o, 'bar'); // false
 * hasOwnProperty(o, 'foo'); // true
 * hasOwnProperty(undefined, 'foo');
 *                   // TypeError: Cannot convert undefined or null to object
 */
module.exports = function hasOwnProperty(object, property) {
  return hop.call(toObject(object), toPropertyKey(property));
};

},{"cached-constructors-x":36,"to-object-x":446,"to-property-key-x":448}],123:[function(require,module,exports){
/**
 * @file Tests if ES6 Reflect is supported.
 * @version 1.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-reflect-support-x
 */

'use strict';

/**
 * Indicates if `Reflect`exists.
 * `true`, if it exists and creates the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = typeof Reflect === 'object' && Reflect !== null;

},{}],124:[function(require,module,exports){
/**
 * @file Tests if ES6 Symbol is supported.
 * @version 1.4.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-symbol-support-x
 */

'use strict';

/**
 * Indicates if `Symbol`exists and creates the correct type.
 * `true`, if it exists and creates the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = typeof Symbol === 'function' && typeof Symbol('') === 'symbol';

},{}],125:[function(require,module,exports){
(function (global){
'use strict';

var origSymbol = global.Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./shams":126}],126:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 17], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],127:[function(require,module,exports){
/**
 * @file Tests if ES6 @@toStringTag is supported.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-@@tostringtag|26.3.1 @@toStringTag}
 * @version 1.4.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-to-string-tag-x
 */

'use strict';

/**
 * Indicates if `Symbol.toStringTag`exists and is the correct type.
 * `true`, if it exists and is the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = require('has-symbol-support-x') && typeof Symbol.toStringTag === 'symbol';

},{"has-symbol-support-x":124}],128:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":113}],129:[function(require,module,exports){
/**
 * @file An extended ES6 indexOf.
 * @version 2.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module index-of-x
 */

'use strict';

var numberIsNaN = require('is-nan-x');
var isString = require('is-string');
var isFalsey = require('is-falsey-x');
var toObject = require('to-object-x');
var toLength = require('to-length-x');
var sameValueZero = require('same-value-zero-x');
var sameValue = require('same-value-x');
var findIndex = require('find-index-x');
var calcFromIndex = require('calculate-from-index-x');
var splitIfBoxedBug = require('split-if-boxed-bug-x');
var pIndexOf = typeof Array.prototype.indexOf === 'function' && Array.prototype.indexOf;

var isWorking;
if (pIndexOf) {
  var attempt = require('attempt-x');
  var res = attempt.call([0, 1], pIndexOf, 1, 2);
  isWorking = res.threw === false && res.value === -1;

  if (isWorking) {
    res = attempt.call([0, 1], pIndexOf, 1);
    isWorking = res.threw === false && res.value === 1;
  }

  if (isWorking) {
    res = attempt.call([0, -0], pIndexOf, -0);
    isWorking = res.threw === false && res.value === 0;
  }

  if (isWorking) {
    var testArr = [];
    testArr.length = 2;
    testArr[1] = void 0;
    res = attempt.call(testArr, pIndexOf, void 0);
    isWorking = res.threw === false && res.value === 1;
  }

  if (isWorking) {
    res = attempt.call('abc', pIndexOf, 'c');
    isWorking = res.threw === false && res.value === 2;
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }('a', 'b', 'c')), pIndexOf, 'c');
    isWorking = res.threw === false && res.value === 2;
  }
}

if (isWorking !== true) {
  pIndexOf = function indexOf(searchElement) {
    // eslint-disable-next-line no-invalid-this
    var length = toLength(this.length);
    if (length < 1) {
      return -1;
    }

    var i = arguments[1];
    while (i < length) {
      // eslint-disable-next-line no-invalid-this
      if (i in this && this[i] === searchElement) {
        return i;
      }

      i += 1;
    }

    return -1;
  };
}

/**
 * This method returns an index in the array, if an element in the array
 * satisfies the provided testing function. Otherwise -1 is returned.
 *
 * @private
 * @param {Array} array - The array to search.
 * @param {*} searchElement - Element to locate in the array.
 * @param {number} fromIndex - The index to start the search at.
 * @param {Function} extendFn - The comparison function to use.
 * @returns {number} Returns index of found element, otherwise -1.
 */
// eslint-disable-next-line max-params
var findIdxFrom = function findIndexFrom(array, searchElement, fromIndex, extendFn) {
  var fIdx = fromIndex;
  var length = toLength(array.length);
  while (fIdx < length) {
    if (fIdx in array && extendFn(array[fIdx], searchElement)) {
      return fIdx;
    }

    fIdx += 1;
  }

  return -1;
};

/**
 * This method returns the first index at which a given element can be found
 * in the array, or -1 if it is not present.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If `array` is `null` or `undefined`.
 * @param {*} searchElement - Element to locate in the `array`.
 * @param {number} [fromIndex] - The index to start the search at. If the
 *  index is greater than or equal to the array's length, -1 is returned,
 *  which means the array will not be searched. If the provided index value is
 *  a negative number, it is taken as the offset from the end of the array.
 *  Note: if the provided index is negative, the array is still searched from
 *  front to back. If the calculated index is less than 0, then the whole
 *  array will be searched. Default: 0 (entire array is searched).
 * @param {string} [extend] - Extension type: `SameValue` or `SameValueZero`.
 * @returns {number} Returns index of found element, otherwise -1.
 * @example
 * var indexOf = require('index-of-x');
 * var subject = [2, 3, undefined, true, 'hej', null, 2, false, 0, -0, NaN];
 *
 * // Standard mode, operates just like `Array.prototype.indexOf`.
 * indexOf(subject, null); // 5
 * indexOf(testSubject, '2'); // -1
 * indexOf(testSubject, NaN); // -1
 * indexOf(testSubject, -0); // 8
 * indexOf(testSubject, 2, 2); //6
 *
 * // `SameValueZero` mode extends `indexOf` to match `NaN`.
 * indexOf(subject, null, 'SameValueZero'); // 5
 * indexOf(testSubject, '2', 'SameValueZero'); // -1
 * indexOf(testSubject, NaN, 'SameValueZero'); // 10
 * indexOf(testSubject, -0, 'SameValueZero'); // 8
 * indexOf(testSubject, 2, 2, 'SameValueZero'); //6
 *
 * // `SameValue` mode extends `indexOf` to match `NaN` and signed `0`.
 * indexOf(subject, null, 'SameValue'); // 5
 * indexOf(testSubject, '2', 'SameValue'); // -1
 * indexOf(testSubject, NaN, 'SameValue'); // 10
 * indexOf(testSubject, -0, 'SameValue'); // 9
 * indexOf(testSubject, 2, 2, 'SameValue'); //6
 */
module.exports = function indexOf(array, searchElement) {
  var object = toObject(array);
  var iterable = splitIfBoxedBug(object);
  var length = toLength(iterable.length);
  if (length < 1) {
    return -1;
  }

  var argLength = arguments.length;
  var extend = argLength > 2 && argLength > 3 ? arguments[3] : arguments[2];
  var extendFn;
  if (isString(extend)) {
    extend = extend.toLowerCase();
    if (extend === 'samevalue') {
      extendFn = sameValue;
    } else if (extend === 'samevaluezero') {
      extendFn = sameValueZero;
    }
  }

  var fromIndex = 0;
  if (extendFn && (searchElement === 0 || numberIsNaN(searchElement))) {
    if (argLength > 3) {
      fromIndex = calcFromIndex(iterable, arguments[2]);
      if (fromIndex >= length) {
        return -1;
      }

      if (fromIndex < 0) {
        fromIndex = 0;
      }
    }

    if (fromIndex > 0) {
      return findIdxFrom(iterable, searchElement, fromIndex, extendFn);
    }

    return findIndex(iterable, function (element, index) {
      return index in iterable && extendFn(searchElement, element);
    });
  }

  if (argLength > 3 || (argLength > 2 && isFalsey(extendFn))) {
    fromIndex = calcFromIndex(iterable, arguments[2]);
    if (fromIndex >= length) {
      return -1;
    }

    if (fromIndex < 0) {
      fromIndex = 0;
    }
  }

  return pIndexOf.call(iterable, searchElement, fromIndex);
};

},{"attempt-x":32,"calculate-from-index-x":131,"find-index-x":138,"is-falsey-x":160,"is-nan-x":168,"is-string":186,"same-value-x":433,"same-value-zero-x":434,"split-if-boxed-bug-x":435,"to-length-x":142,"to-object-x":446}],130:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":162,"is-primitive":178,"to-string-symbols-supported-x":449}],131:[function(require,module,exports){
/**
 * @file Calculates a fromIndex of a given value for an array.
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module calculate-from-index-x
 */

'use strict';

var toObject = require('to-object-x');
var toLength = require('to-length-x').toLength2018;
var toInteger = require('to-integer-x').toInteger2018;
var isArrayLike = require('is-array-like-x');

var getMax = function _getMax(a, b) {
  return a >= b ? a : b;
};

/**
 * This method calculates a fromIndex of a given value for an array.
 *
 * @param {array} array * The array on which to calculate the starting index.
 * @throws {TypeError} If array is null or undefined.
 * @param {number} fromIndex * The position in this array at which to begin. A
 *  negative value gives the index of array.length + fromIndex by asc.
 * @returns {number} The calculated fromIndex. Default is 0.
 * @example
 * var calcFromIndex = require('calculate-from-index-x');
 *
 * calcFromIndex([1, 2, 3], 1); // 1
 * calcFromIndex([1, 2, 3], Infinity); // Infinity
 * calcFromIndex([1, 2, 3], -Infinity); // 0
 * calcFromIndex([1, 2, 3], -1); // 2
 */
module.exports = function calcFromIndex(array, fromIndex) {
  var object = toObject(array);
  if (isArrayLike(object) === false) {
    return 0;
  }

  var index = toInteger(fromIndex);

  return index >= 0 ? index : getMax(0, toLength(object.length) + index);
};

},{"is-array-like-x":152,"to-integer-x":134,"to-length-x":135,"to-object-x":446}],132:[function(require,module,exports){
/**
 * @file Shim for Math.sign.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-math.sign|20.2.2.29 Math.sign(x)}
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-sign-x
 */

'use strict';

var libToNumber = require('to-number-x');
var toNumber2016 = libToNumber.toNumber2016;
var toNumber2018 = libToNumber.toNumber2018;
var numberIsNaN = require('is-nan-x');

var $sign2016 = function sign2016(x) {
  var n = toNumber2016(x);
  if (n === 0 || numberIsNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

var $sign2018 = function sign2018(x) {
  var n = toNumber2018(x);
  if (n === 0 || numberIsNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

module.exports = {
  /**
   * Reference to sign2018.
   */
  sign: $sign2018,

  /**
   * This method returns the sign of a number, indicating whether the number is positive,
   * negative or zero. (ES2016)
   *
   * @param {*} x - A number.
   * @returns {number} A number representing the sign of the given argument. If the argument
   * is a positive number, negative number, positive zero or negative zero, the function will
   * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
   * @example
   * var mathSign = require('math-sign-x').sign2016;
   *
   * mathSign(3);     //  1
   * mathSign(-3);    // -1
   * mathSign('-3');  // -1
   * mathSign(0);     //  0
   * mathSign(-0);    // -0
   * mathSign(NaN);   // NaN
   * mathSign('foo'); // NaN
   * mathSign();      // NaN
   */
  sign2016: $sign2016,

  /**
   * This method returns the sign of a number, indicating whether the number is positive,
   * negative or zero. (ES2018)
   *
   * @param {*} x - A number.
   * @returns {number} A number representing the sign of the given argument. If the argument
   * is a positive number, negative number, positive zero or negative zero, the function will
   * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
   * @example
   * var mathSign = require('math-sign-x').sign2018;
   *
   * mathSign(3);     //  1
   * mathSign(-3);    // -1
   * mathSign('-3');  // -1
   * mathSign(0);     //  0
   * mathSign(-0);    // -0
   * mathSign(NaN);   // NaN
   * mathSign('foo'); // NaN
   * mathSign();      // NaN
   */
  sign2018: $sign2018
};

},{"is-nan-x":168,"to-number-x":136}],133:[function(require,module,exports){
/**
 * @file Parses a string argument and returns an integer of the specified radix.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module parse-int-x
 */

'use strict';

var nativeParseInt = parseInt;
var NAN = require('nan-x');
var toStr = require('to-string-x');
var trimLeft2016 = require('trim-left-x').trimLeft2016;
var trimLeft2018 = require('trim-left-x').trimLeft2018;
var chachedCtrs = require('cached-constructors-x');
var castNumber = chachedCtrs.Number;
var charAt = chachedCtrs.String.prototype.charAt;
var hexRegex = /^[-+]?0[xX]/;
var test = hexRegex.test;

var $parseInt2016 = function parseInt2016(string, radix) {
  var str = trimLeft2016(toStr(string));

  return nativeParseInt(str, castNumber(radix) || (test.call(hexRegex, str) ? 16 : 10));
};

var $parseInt2018 = function parseInt2018(string, radix) {
  var str = trimLeft2018(toStr(string));
  if (charAt.call(str, 0) === '\u180E') {
    return NAN;
  }

  return nativeParseInt(str, castNumber(radix) || (test.call(hexRegex, str) ? 16 : 10));
};

module.exports = {
  /**
   * Reference to parseInt2018.
   */
  parseInt: $parseInt2018,

  /**
   * This method parses a string argument and returns an integer of the specified
   * radix (the base in mathematical numeral systems). (ES2016)
   *
   * @param {string} string - The value to parse. If the string argument is not a
   *  string, then it is converted to a string (using the ToString abstract
   *  operation). Leading whitespace in the string argument is ignored.
   * @param {number} radix - An integer between 2 and 36 that represents the radix
   *  (the base in mathematical numeral systems) of the above mentioned string.
   *  Specify 10 for the decimal numeral system commonly used by humans. Always
   *  specify this parameter to eliminate reader confusion and to guarantee
   *  predictable behavior. Different implementations produce different results
   *  when a radix is not specified, usually defaulting the value to 10.
   * @throws {TypeError} If target is a Symbol or is not coercible.
   * @returns {number} An integer number parsed from the given string. If the first
   *  character cannot be converted to a number, NaN is returned.
   * @example
   * var $parseInt = require('parse-int-x').parseInt2016;
   *
   * // The following examples all return 15
   * $parseInt(' 0xF', 16);
   * $parseInt(' F', 16);
   * $parseInt('17', 8);
   * $parseInt(021, 8);
   * $parseInt('015', 10);   // $parseInt(015, 10); will return 15
   * $parseInt(15.99, 10);
   * $parseInt('15,123', 10);
   * $parseInt('FXX123', 16);
   * $parseInt('1111', 2);
   * $parseInt('15 * 3', 10);
   * $parseInt('15e2', 10);
   * $parseInt('15px', 10);
   * $parseInt('12', 13);
   *
   * //The following examples all return NaN:
   * $parseInt('Hello', 8); // Not a number at all
   * $parseInt('546', 2);   // Digits are not valid for binary representations
   */
  parseInt2016: $parseInt2016,

  /**
   * This method parses a string argument and returns an integer of the specified
   * radix (the base in mathematical numeral systems). (ES2018)
   *
   * @param {string} string - The value to parse. If the string argument is not a
   *  string, then it is converted to a string (using the ToString abstract
   *  operation). Leading whitespace in the string argument is ignored.
   * @param {number} radix - An integer between 2 and 36 that represents the radix
   *  (the base in mathematical numeral systems) of the above mentioned string.
   *  Specify 10 for the decimal numeral system commonly used by humans. Always
   *  specify this parameter to eliminate reader confusion and to guarantee
   *  predictable behavior. Different implementations produce different results
   *  when a radix is not specified, usually defaulting the value to 10.
   * @throws {TypeError} If target is a Symbol or is not coercible.
   * @returns {number} An integer number parsed from the given string. If the first
   *  character cannot be converted to a number, NaN is returned.
   * @example
   * var $parseInt = require('parse-int-x').parseInt2018;
   *
   * // The following examples all return 15
   * $parseInt(' 0xF', 16);
   * $parseInt(' F', 16);
   * $parseInt('17', 8);
   * $parseInt(021, 8);
   * $parseInt('015', 10);   // $parseInt(015, 10); will return 15
   * $parseInt(15.99, 10);
   * $parseInt('15,123', 10);
   * $parseInt('FXX123', 16);
   * $parseInt('1111', 2);
   * $parseInt('15 * 3', 10);
   * $parseInt('15e2', 10);
   * $parseInt('15px', 10);
   * $parseInt('12', 13);
   *
   * //The following examples all return NaN:
   * $parseInt('Hello', 8); // Not a number at all
   * $parseInt('546', 2);   // Digits are not valid for binary representations
   */
  parseInt2018: $parseInt2018
};

},{"cached-constructors-x":36,"nan-x":404,"to-string-x":451,"trim-left-x":452}],134:[function(require,module,exports){
/**
 * @file ToInteger converts 'argument' to an integral numeric value.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger|7.1.4 ToInteger ( argument )}
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-integer-x
 */

'use strict';

var libToNumber = require('to-number-x');
var toNumber2016 = libToNumber.toNumber2016;
var toNumber2018 = libToNumber.toNumber2018;
var numberIsNaN = require('is-nan-x');
var numberIsFinite = require('is-finite-x');
var libMathSign = require('math-sign-x');
var mathSign2016 = libMathSign.sign2016;
var mathSign2018 = libMathSign.sign2018;
var mathFloor = Math.floor;
var mathAbs = Math.abs;

var $toInteger2016 = function toInteger2016(value) {
  var number = toNumber2016(value);
  if (numberIsNaN(number)) {
    return 0;
  }

  if (number === 0 || numberIsFinite(number) === false) {
    return number;
  }

  return mathSign2016(number) * mathFloor(mathAbs(number));
};

var $toInteger2018 = function toInteger2018(value) {
  var number = toNumber2018(value);
  if (numberIsNaN(number)) {
    return 0;
  }

  if (number === 0 || numberIsFinite(number) === false) {
    return number;
  }

  return mathSign2018(number) * mathFloor(mathAbs(number));
};

module.exports = {
  /**
   * Reference to toInteger2018.
   */
  toInteger: $toInteger2018,

  /**
   * Converts `value` to an integer. (ES2016)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   *
   * @example
   * var toInteger = require('to-integer-x').toInteger2016;
   * toInteger(3); // 3
   * toInteger(Number.MIN_VALUE); // 0
   * toInteger(Infinity); // 1.7976931348623157e+308
   * toInteger('3'); // 3
   */
  toInteger2016: $toInteger2016,

  /**
   * Converts `value` to an integer. (ES2018)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   *
   * @example
   * var toInteger = require('to-integer-x').toInteger2018;
   * toInteger(3); // 3
   * toInteger(Number.MIN_VALUE); // 0
   * toInteger(Infinity); // 1.7976931348623157e+308
   * toInteger('3'); // 3
   */
  toInteger2018: $toInteger2018
};

},{"is-finite-x":161,"is-nan-x":168,"math-sign-x":132,"to-number-x":136}],135:[function(require,module,exports){
/**
 * @file Shim for ToLength.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tolength|7.1.15 ToLength ( argument )}
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-length-x
 */

'use strict';

var libToInteger = require('to-integer-x');
var toInteger2016 = libToInteger.toInteger2016;
var toInteger2018 = libToInteger.toInteger2018;
var MAX_SAFE_INTEGER = require('max-safe-integer');

var $toLength2016 = function toLength2016(value) {
  var len = toInteger2016(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

var $toLength2018 = function toLength2018(value) {
  var len = toInteger2018(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

module.exports = {
  /**
   * Reference to toLength2018.
   */
  toLength: $toLength2018,

  /**
   * Converts `value` to an integer suitable for use as the length of an
   * array-like object. (ES2016)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   * var toLength = require('to-length-x').toLength2016;
   * toLength(3); // 3
   * toLength(Number.MIN_VALUE); // 0
   * toLength(Infinity); // Number.MAX_SAFE_INTEGER
   * toLength('3'); // 3
   */
  toLength2016: $toLength2016,

  /**
   * Converts `value` to an integer suitable for use as the length of an
   * array-like object. (ES2018)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   * var toLength = require('to-length-x').toLength2018;
   * toLength(3); // 3
   * toLength(Number.MIN_VALUE); // 0
   * toLength(Infinity); // Number.MAX_SAFE_INTEGER
   * toLength('3'); // 3
   */
  toLength2018: $toLength2018
};

},{"max-safe-integer":397,"to-integer-x":134}],136:[function(require,module,exports){
/**
 * @file Converts argument to a value of type Number.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-number-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var castNumber = cachedCtrs.Number;
var Rx = cachedCtrs.RegExp;
var toPrimitive = require('to-primitive-x');
var libTrim = require('trim-x');
var trim2016 = libTrim.trim2016;
var trim2018 = libTrim.trim2018;
var libParseInt = require('parse-int-x');
var $parseInt2016 = libParseInt.parseInt2016;
var $parseInt2018 = libParseInt.parseInt2018;
var pStrSlice = cachedCtrs.String.prototype.slice;
var NAN = require('nan-x');

var binaryRegex = /^0b[01]+$/i;
// Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is
// an own property of regexes. wtf.
var test = binaryRegex.test;
var isBinary = function _isBinary(value) {
  return test.call(binaryRegex, value);
};

var octalRegex = /^0o[0-7]+$/i;
var isOctal = function _isOctal(value) {
  return test.call(octalRegex, value);
};

var nonWSregex2016 = new Rx('[\u0085\u200b\ufffe]', 'g');
var hasNonWS2016 = function _hasNonWS(value) {
  return test.call(nonWSregex2016, value);
};

var nonWSregex2018 = new Rx('[\u0085\u180e\u200b\ufffe]', 'g');
var hasNonWS2018 = function _hasNonWS(value) {
  return test.call(nonWSregex2018, value);
};

var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = function _isInvalidHexLiteral(value) {
  return test.call(invalidHexLiteral, value);
};

var $toNumber2016 = function toNumber2016(argument) {
  var value = toPrimitive(argument, Number);
  if (typeof value === 'symbol') {
    throw new TypeError('Cannot convert a Symbol value to a number');
  }

  if (typeof value === 'string') {
    if (isBinary(value)) {
      return toNumber2016($parseInt2016(pStrSlice.call(value, 2), 2));
    }

    if (isOctal(value)) {
      return toNumber2016($parseInt2016(pStrSlice.call(value, 2), 8));
    }

    if (hasNonWS2016(value) || isInvalidHexLiteral(value)) {
      return NAN;
    }

    var trimmed = trim2016(value);
    if (trimmed !== value) {
      return toNumber2016(trimmed);
    }
  }

  return castNumber(value);
};

var $toNumber2018 = function toNumber2018(argument) {
  var value = toPrimitive(argument, Number);
  if (typeof value === 'symbol') {
    throw new TypeError('Cannot convert a Symbol value to a number');
  }

  if (typeof value === 'string') {
    if (isBinary(value)) {
      return toNumber2018($parseInt2018(pStrSlice.call(value, 2), 2));
    }

    if (isOctal(value)) {
      return toNumber2018($parseInt2018(pStrSlice.call(value, 2), 8));
    }

    if (hasNonWS2018(value) || isInvalidHexLiteral(value)) {
      return NAN;
    }

    var trimmed = trim2018(value);
    if (trimmed !== value) {
      return toNumber2018(trimmed);
    }
  }

  return castNumber(value);
};

module.exports = {
  /**
   * reference to toNumber2018.
   */
  toNumber: $toNumber2018,

  /**
   * This method converts argument to a value of type Number. (ES2016)

   * @param {*} argument - The argument to convert to a number.
   * @throws {TypeError} - If argument is a Symbol or not coercible.
   * @returns {*} The argument converted to a number.
   * @example
   * var toNumber = require('to-number-x').toNumber2016;
   *
   * toNumber('1'); // 1
   * toNumber(null); // 0
   * toNumber(true); // 1
   * toNumber('0o10'); // 8
   * toNumber('0b10'); // 2
   * toNumber('0xF'); // 16
   *
   * toNumber(' 1 '); // 1
   *
   * toNumber(Symbol('')) // TypeError
   * toNumber(Object.create(null)) // TypeError
   */
  toNumber2016: $toNumber2016,

  /**
   * This method converts argument to a value of type Number. (ES2018)

   * @param {*} argument - The argument to convert to a number.
   * @throws {TypeError} - If argument is a Symbol or not coercible.
   * @returns {*} The argument converted to a number.
   * @example
   * var toNumber = require('to-number-x').toNumber2018;
   *
   * toNumber('1'); // 1
   * toNumber(null); // 0
   * toNumber(true); // 1
   * toNumber('0o10'); // 8
   * toNumber('0b10'); // 2
   * toNumber('0xF'); // 16
   *
   * toNumber(' 1 '); // 1
   *
   * toNumber(Symbol('')) // TypeError
   * toNumber(Object.create(null)) // TypeError
   */
  toNumber2018: $toNumber2018
};

},{"cached-constructors-x":36,"nan-x":404,"parse-int-x":133,"to-primitive-x":447,"trim-x":137}],137:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left and right end of a string.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-x
 */

'use strict';

var libTrimLeft = require('trim-left-x');
var trimLeft2016 = libTrimLeft.trimLeft2016;
var trimLeft2018 = libTrimLeft.trimLeft2018;
var libTrimRight = require('trim-right-x');
var trimRight2016 = libTrimRight.trimRight2016;
var trimRight2018 = libTrimRight.trimRight2016;

var $trim2016 = function trim2016(string) {
  return trimLeft2016(trimRight2016(string));
};

var $trim2018 = function trim2018(string) {
  return trimLeft2018(trimRight2018(string));
};

module.exports = {
  /**
   * A reference to trim2018.
   */
  trim: $trim2018,

  /**
   * This method removes whitespace from the left and right end of a string.
   * (ES2016)
   * @param {string} string - The string to trim the whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The trimmed string.
   * @example
   * var trim = require('trim-x');
   *
   * trim(' \t\na \t\n') === 'a'; // true
   */
  trim2016: $trim2016,

  /**
   * This method removes whitespace from the left and right end of a string.
   * (ES2018)
   *
   * @param {string} string - The string to trim the whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The trimmed string.
   * @example
   * var trim = require('trim-x');
   *
   * trim(' \t\na \t\n') === 'a'; // true
   */
  trim2018: $trim2018
};

},{"trim-left-x":452,"trim-right-x":144}],138:[function(require,module,exports){
/**
 * @file This method returns the index of the first element in the array that satisfies the provided testing function.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module find-index-x
 */

'use strict';

var pFindIndex = typeof Array.prototype.findIndex === 'function' && Array.prototype.findIndex;

var isWorking;
if (pFindIndex) {
  var attempt = require('attempt-x');
  var testArr = [];
  testArr.length = 2;
  testArr[1] = 1;
  var res = attempt.call(testArr, pFindIndex, function (item, idx) {
    return idx === 0;
  });

  isWorking = res.threw === false && res.value === 0;

  if (isWorking) {
    res = attempt.call(1, pFindIndex, function (item, idx) {
      return idx === 0;
    });

    isWorking = res.threw === false && res.value === -1;
  }

  if (isWorking) {
    isWorking = attempt.call([], pFindIndex).threw;
  }

  if (isWorking) {
    res = attempt.call('abc', pFindIndex, function (item) {
      return item === 'c';
    });

    isWorking = res.threw === false && res.value === 2;
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }('a', 'b', 'c')), pFindIndex, function (item) {
      return item === 'c';
    });

    isWorking = res.threw === false && res.value === 2;
  }
}

var findIdx;
if (isWorking) {
  findIdx = function findIndex(array, callback) {
    var args = [callback];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return pFindIndex.apply(array, args);
  };
} else {
  var toLength = require('to-length-x');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');
  var splitIfBoxedBug = require('split-if-boxed-bug-x');

  findIdx = function findIndex(array, callback) {
    var object = toObject(array);
    assertIsFunction(callback);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    if (length < 1) {
      return -1;
    }

    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var index = 0;
    while (index < length) {
      if (callback.call(thisArg, iterable[index], index, object)) {
        return index;
      }

      index += 1;
    }

    return -1;
  };
}

/**
 * Like `findIndex`, this method returns an index in the array, if an element
 * in the array satisfies the provided testing function. Otherwise -1 is returned.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If array is `null` or `undefined`-
 * @param {Function} callback - Function to execute on each value in the array,
 *  taking three arguments: `element`, `index` and `array`.
 * @throws {TypeError} If `callback` is not a function.
 * @param {*} [thisArg] - Object to use as `this` when executing `callback`.
 * @returns {number} Returns index of positively tested element, otherwise -1.
 * @example
 * var findIndex = require('find-index-x');
 *
 * function isPrime(element, index, array) {
 *   var start = 2;
 *   while (start <= Math.sqrt(element)) {
 *     if (element % start++ < 1) {
 *       return false;
 *     }
 *   }
 *   return element > 1;
 * }
 *
 * console.log(findIndex([4, 6, 8, 12, 14], isPrime)); // -1, not found
 * console.log(findIndex([4, 6, 7, 12, 13], isPrime)); // 2
 */
module.exports = findIdx;

},{"assert-is-function-x":130,"attempt-x":32,"split-if-boxed-bug-x":435,"to-length-x":142,"to-object-x":446}],139:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19,"is-nan-x":168,"to-number-x":143}],140:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"cached-constructors-x":36,"dup":20,"to-string-x":451,"trim-x":455,"white-space-x":460}],141:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21,"is-finite-x":161,"is-nan-x":168,"math-sign-x":139,"to-number-x":143}],142:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22,"max-safe-integer":397,"to-integer-x":141}],143:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"cached-constructors-x":36,"dup":23,"nan-x":404,"parse-int-x":140,"to-primitive-x":447,"trim-x":455}],144:[function(require,module,exports){
/**
 * @file This method removes whitespace from the right end of a string.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-right-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reRight2016 = new Rx('[' + require('white-space-x').string2016 + ']+$');
var reRight2018 = new Rx('[' + require('white-space-x').string2018 + ']+$');
var replace = ''.replace;

var $trimRight2016 = function trimRight2016(string) {
  return replace.call(requireCoercibleToString(string), reRight2016, '');
};

var $trimRight2018 = function trimRight2018(string) {
  return replace.call(requireCoercibleToString(string), reRight2018, '');
};

module.exports = {
  /**
   * A reference to trimRight2018.
   */
  trimRight: $trimRight2018,

  /**
   * This method removes whitespace from the right end of a string. (ES2016)
   *
   * @param {string} string - The string to trim the right end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The right trimmed string.
   * @example
   * var trimRight = require('trim-right-x');
   *
   * trimRight(' \t\na \t\n') === ' \t\na'; // true
   */
  trimRight2016: $trimRight2016,

  /**
   * This method removes whitespace from the right end of a string. (ES2018)
   *
   * @param {string} string - The string to trim the right end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The right trimmed string.
   * @example
   * var trimRight = require('trim-right-x');
   *
   * trimRight(' \t\na \t\n') === ' \t\na'; // true
   */
  trimRight2018: $trimRight2018
};

},{"cached-constructors-x":36,"require-coercible-to-string-x":429,"white-space-x":145}],145:[function(require,module,exports){
/**
 * @file List of ECMAScript white space characters.
 * @version 3.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module white-space-x
 */

'use strict';

/**
 * A record of a white space character.
 *
 * @typedef {Object} CharRecord
 * @property {number} code - The character code.
 * @property {string} description - A description of the character.
 * @property {boolean} es5 - Whether the spec lists this as a white space.
 * @property {boolean} es2015 - Whether the spec lists this as a white space.
 * @property {boolean} es2016 - Whether the spec lists this as a white space.
 * @property {boolean} es2017 - Whether the spec lists this as a white space.
 * @property {boolean} es2018 - Whether the spec lists this as a white space.
 * @property {string} string - The character string.
 */

/**
 * An array of the whitespace char codes, string, descriptions and language
 * presence in the specifications.
 *
 * @private
 * @type Array.<CharRecord>
 */
var list = [
  {
    code: 0x0009,
    description: 'Tab',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u0009'
  },
  {
    code: 0x000a,
    description: 'Line Feed',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000a'
  },
  {
    code: 0x000b,
    description: 'Vertical Tab',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000b'
  },
  {
    code: 0x000c,
    description: 'Form Feed',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000c'
  },
  {
    code: 0x000d,
    description: 'Carriage Return',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000d'
  },
  {
    code: 0x0020,
    description: 'Space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u0020'
  },
  /*
  {
    code: 0x0085,
    description: 'Next line',
    es5: false,
    es2015: false,
    es2016: false,
    es2017: false,
    es2018: false,
    string: '\u0085'
  }
  */
  {
    code: 0x00a0,
    description: 'No-break space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u00a0'
  },
  {
    code: 0x1680,
    description: 'Ogham space mark',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u1680'
  },
  {
    code: 0x180e,
    description: 'Mongolian vowel separator',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: false,
    es2018: false,
    string: '\u180e'
  },
  {
    code: 0x2000,
    description: 'En quad',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2000'
  },
  {
    code: 0x2001,
    description: 'Em quad',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2001'
  },
  {
    code: 0x2002,
    description: 'En space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2002'
  },
  {
    code: 0x2003,
    description: 'Em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2003'
  },
  {
    code: 0x2004,
    description: 'Three-per-em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2004'
  },
  {
    code: 0x2005,
    description: 'Four-per-em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2005'
  },
  {
    code: 0x2006,
    description: 'Six-per-em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2006'
  },
  {
    code: 0x2007,
    description: 'Figure space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2007'
  },
  {
    code: 0x2008,
    description: 'Punctuation space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2008'
  },
  {
    code: 0x2009,
    description: 'Thin space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2009'
  },
  {
    code: 0x200a,
    description: 'Hair space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u200a'
  },
  /*
  {
    code: 0x200b,
    description: 'Zero width space',
    es5: false,
    es2015: false,
    es2016: false,
    es2017: false,
    es2018: false,
    string: '\u200b'
  },
  */
  {
    code: 0x2028,
    description: 'Line separator',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2028'
  },
  {
    code: 0x2029,
    description: 'Paragraph separator',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2029'
  },
  {
    code: 0x202f,
    description: 'Narrow no-break space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u202f'
  },
  {
    code: 0x205f,
    description: 'Medium mathematical space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u205f'
  },
  {
    code: 0x3000,
    description: 'Ideographic space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u3000'
  },
  {
    code: 0xfeff,
    description: 'Byte Order Mark',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\ufeff'
  }
];

var stringES2016 = '';
var stringES2018 = '';
var length = list.length;
for (var i = 0; i < length; i += 1) {
  if (list[i].es2016) {
    stringES2016 += list[i].string;
  }

  if (list[i].es2018) {
    stringES2018 += list[i].string;
  }
}

module.exports = {
  /**
   * An array of the whitespace char codes, string, descriptions and language
   * presence in the specifications.
   *
   * @type Array.<CharRecord>
   * @example
   * var whiteSpace = require('white-space-x');
   * whiteSpaces.list.foreach(function (item) {
   *   console.log(lib.description, item.code, item.string);
   * });
   */
  list: list,
  /**
   * A string of the ES2017 to ES2018 whitespace characters.
   *
   * @type string
   */
  string: stringES2018,

  /**
   * A string of the ES5 to ES2016 whitespace characters.
   *
   * @type string
   */
  string5: stringES2016,

  /**
   * A string of the ES5 to ES2016 whitespace characters.
   *
   * @type string
   */
  string2015: stringES2016,

  /**
   * A string of the ES5 to ES2016 whitespace characters.
   *
   * @type string
   * @example
   * var whiteSpace = require('white-space-x');
   * var characters = [
   *   '\u0009',
   *   '\u000a',
   *   '\u000b',
   *   '\u000c',
   *   '\u000d',
   *   '\u0020',
   *   '\u00a0',
   *   '\u1680',
   *   '\u180e',
   *   '\u2000',
   *   '\u2001',
   *   '\u2002',
   *   '\u2003',
   *   '\u2004',
   *   '\u2005',
   *   '\u2006',
   *   '\u2007',
   *   '\u2008',
   *   '\u2009',
   *   '\u200a',
   *   '\u2028',
   *   '\u2029',
   *   '\u202f',
   *   '\u205f',
   *   '\u3000',
   *   '\ufeff'
   * ];
   * var ws = characters.join('');
   * var re1 = new RegExp('^[' + whiteSpace.string2016 + ']+$)');
   * re1.test(ws); // true
   */
  string2016: stringES2016,

  /**
   * A string of the ES2017 to ES2018 whitespace characters.
   *
   * @type string
   */
  string2017: stringES2018,

  /**
   * A string of the ES2017 to ES2018 whitespace characters.
   *
   * @type string
   * @example
   * var whiteSpace = require('white-space-x');
   * var characters = [
   *   '\u0009',
   *   '\u000a',
   *   '\u000b',
   *   '\u000c',
   *   '\u000d',
   *   '\u0020',
   *   '\u00a0',
   *   '\u1680',
   *   '\u2000',
   *   '\u2001',
   *   '\u2002',
   *   '\u2003',
   *   '\u2004',
   *   '\u2005',
   *   '\u2006',
   *   '\u2007',
   *   '\u2008',
   *   '\u2009',
   *   '\u200a',
   *   '\u2028',
   *   '\u2029',
   *   '\u202f',
   *   '\u205f',
   *   '\u3000',
   *   '\ufeff'
   * ];
   * var ws = characters.join('');
   * var re1 = new RegExp('^[' + whiteSpace.string2018 + ']+$)');
   * re1.test(ws); // true
   */
  string2018: stringES2018
};

},{}],146:[function(require,module,exports){
/**
 * @file The constant value Infinity.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module infinity-x
 */

'use strict';

/**
 * The constant value Infinity derived mathematically by 1 / 0.
 *
 * @type number
 * @example
 * var INFINITY = require('infinity-x');
 *
 * INFINITY === Infinity; // true
 * -INFINITY === -Infinity; // true
 * INFINITY === -Infinity; // false
 */
module.exports = 1 / 0;

},{}],147:[function(require,module,exports){
/**
 * @file An implementation of node's ES6 inspect module.
 * @version 1.9.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @see https://nodejs.org/api/util.html#util_util_inspect_object_options
 * @module inspect-x
 */

'use strict';

var isFunction = require('is-function-x');
var isGeneratorFunction = require('is-generator-function');
var isAsyncFunction = require('is-async-function-x');
var isRegExp = require('is-regex');
var defineProperties = require('object-define-properties-x');
var isDate = require('is-date-object');
var isArrayBuffer = require('is-array-buffer-x');
var isSet = require('is-set-x');
var isMap = require('is-map-x');
var isTypedArray = require('is-typed-array');
var isDataView = require('is-data-view-x');
var isUndefined = require('validate.io-undefined');
var isNil = require('is-nil-x');
var isNull = require('lodash.isnull');
var isError = require('is-error-x');
var isObjectLike = require('is-object-like-x');
var isPromise = require('is-promise');
var isString = require('is-string');
var isNumber = require('is-number-object');
var isBoolean = require('is-boolean-object');
var isNegZero = require('is-negative-zero');
var isSymbol = require('is-symbol');
var isPrimitive = require('is-primitive');
var getFunctionName = require('get-function-name-x');
var hasSymbolSupport = require('has-symbol-support-x');
var hasOwn = require('has-own-property-x');
var whiteSpace = require('white-space-x');
var reSingle = new RegExp('\\{[' + whiteSpace.string + ']+\\}');
var hasSet = typeof Set === 'function' && isSet(new Set());
var testSet = hasSet && new Set(['SetSentinel']);
var sForEach = hasSet && Set.prototype.forEach;
var sValues = hasSet && Set.prototype.values;
var hasMap = typeof Map === 'function' && isMap(new Map());
var testMap = hasMap && new Map([[1, 'MapSentinel']]);
var mForEach = hasMap && Map.prototype.forEach;
var mValues = hasMap && Map.prototype.values;
var pSymToStr = hasSymbolSupport && Symbol.prototype.toString;
var pSymValOf = hasSymbolSupport && Symbol.prototype.valueOf;
var indexOf = require('index-of-x');
var reduce = require('array-reduce-x');
var forEach = require('array-for-each-x');
var filter = require('array-filter-x');
var reflectOwnKeys = require('reflect-own-keys-x');
var $stringify = require('json3').stringify;
var $keys = require('object-keys-x');
var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
var $getPrototypeOf = require('get-prototype-of-x');
var $propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var $isArray = require('is-array-x');
var $includes = require('array-includes-x');
var $assign = require('object-assign-x');
var $isNaN = require('is-nan');
var pRegExpToString = RegExp.prototype.toString;
var pErrorToString = Error.prototype.toString;
var pNumberToString = Number.prototype.toString;
var pBooleanToString = Boolean.prototype.toString;
var toISOString = require('to-iso-string-x');
var collections = require('collections-x');
var defineProperty = require('object-define-property-x');
// var hasToStringTag = hasSymbolSupport && typeof Symbol.toStringTag === 'symbol';
var bpe = 'BYTES_PER_ELEMENT';
var inspect;
var fmtValue;

var customInspectSymbol = hasSymbolSupport ? Symbol('inspect.custom') : '_inspect.custom_';

var supportsClasses;
try {
  // eslint-disable-next-line no-new-func
  new Function('return class My {}')();
  supportsClasses = true;
} catch (e) {}

var supportsGetSet;
try {
  var testVar;
  var testObject = defineProperty({}, 'defaultOptions', {
    get: function _get() {
      return testVar;
    },
    set: function _set(val) {
      testVar = val;
      return testVar;
    }
  });

  testObject.defaultOptions = 'test';
  supportsGetSet = testVar === 'test' && testObject.defaultOptions === 'test';
} catch (ignore) {}

var $seal = isFunction(Object.seal) ? Object.seal : function seal(obj) {
  return obj;
};

var $getOwnPropertySymbols = isFunction(Object.getOwnPropertySymbols) && Object.getOwnPropertySymbols;
if ($getOwnPropertySymbols) {
  try {
    var gOPSymbol = hasSymbolSupport && Symbol('');
    var gOPSObj = { a: 1 };
    gOPSObj[gOPSymbol] = 2;

    var gOPSymbols = $getOwnPropertySymbols(gOPSObj);
    if (gOPSymbol) {
      if (gOPSymbols.length !== 1 || gOPSymbols[0] !== gOPSymbol) {
        throw new Error('Inavlid result');
      }
    } else if (gOPSymbols.length !== 0) {
      throw new Error('Inavlid result');
    }
  } catch (ignore) {
    $getOwnPropertySymbols = null;
  }
}

var missingError;
var errProps;
try {
  throw new Error('test');
} catch (e) {
  errProps = $keys(e);
  forEach($keys(new Error()), function _pusher(p) {
    if ($includes(errProps, p) === false) {
      errProps.push(p);
    }
  });

  var errorString = pErrorToString.call(e);
  var errorStack = e.stack;
  if (errorStack) {
    var errorRx = new RegExp('^' + errorString);
    if (errorRx.test(errorStack) === false) {
      missingError = true;
    }
  }
}

if (isDate(Date.prototype)) {
  isDate = function _isDate(value) {
    try {
      value.getTime();
      return true;
    } catch (ignore) {
      return false;
    }
  };
}

var dateProps = $keys(Date);
var shimmedDate;
if (dateProps.length && $includes(dateProps, 'now') && $includes(dateProps, 'UTC') && $includes(dateProps, 'parse')) {
  shimmedDate = $includes($keys(new Date()), 'constructor');
}

var inspectDefaultOptions = $seal({
  breakLength: 60,
  colors: false,
  customInspect: true,
  depth: 2,
  maxArrayLength: 100,
  showHidden: false,
  showProxy: false
});

var isBooleanType = function _isBooleanType(arg) {
  return typeof arg === 'boolean';
};

var isNumberType = function _isNumberType(arg) {
  return typeof arg === 'number';
};

var isStringType = function _isStringType(arg) {
  return typeof arg === 'string';
};

var isSymbolType = function _isSymbolType(arg) {
  return typeof arg === 'symbol';
};

var isMapIterator = function _isMapIterator(value) {
  if (hasMap === false || isObjectLike(value) === false) {
    return false;
  }

  try {
    return value.next.call(mValues.call(testMap)).value === 'MapSentinel';
  } catch (ignore) {}

  return false;
};

var isSetIterator = function _isSetIterator(value) {
  if (hasSet === false || isObjectLike(value) === false) {
    return false;
  }

  try {
    return value.next.call(sValues.call(testSet)).value === 'SetSentinel';
  } catch (ignore) {}

  return false;
};

var filterIndexes = function _filterIndexes(keys, length) {
  var i = keys.length - 1;
  while (i > -1) {
    var key = keys[i];
    if (key > -1 && key % 1 === 0 && key < length && isSymbolType(key) === false) {
      keys.splice(i, 1);
    }

    i -= 1;
  }
};

var pushUniq = function _pushUniq(arr, value) {
  if ($includes(arr, value) === false) {
    arr.push(value);
  }
};

var unshiftUniq = function _unshiftUniq(arr, value) {
  var index = indexOf(arr, value);
  if (index > -1) {
    arr.splice(index, 1);
  }

  arr.unshift(value);
};

var stylizeWithColor = function _stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    var colors = inspect.colors[style];
    return '\u001b[' + colors[0] + 'm' + str + '\u001b[' + colors[1] + 'm';
  }

  return str;
};

var stylizeNoColor = function _stylizeNoColor(str) {
  return str;
};

var getNameSep = function _getNameSep(obj) {
  var name = getFunctionName(obj);
  return name ? ': ' + name : name;
};

var collectionEach = function _collectionEach(collection, callback) {
  if (isMap(collection)) {
    mForEach.call(collection, callback);
  } else if (isSet(collection)) {
    sForEach.call(collection, callback);
  }
};

var getConstructorOf = function _getConstructorOf(obj) {
  var o = obj;
  var maxLoop = 100;
  while (isNil(o) === false && maxLoop > -1) {
    o = Object(o);
    var descriptor = getOwnPropertyDescriptor(o, 'constructor');
    if (descriptor && descriptor.value) {
      return descriptor.value;
    }

    o = $getPrototypeOf(o);
    maxLoop -= 1;
  }

  return null;
};

var isSub = function _isSub(value) {
  if (supportsClasses !== true || isPrimitive(value)) {
    return false;
  }

  var constructor = getConstructorOf(value);
  return isFunction(constructor) === false && isFunction(constructor, true);
};

var getSubName = function _getSubName(value, name) {
  if (isSub(value)) {
    var subName = getFunctionName(getConstructorOf(value));
    if (subName && subName !== name) {
      return subName;
    }
  }

  return name ? name : getFunctionName(getConstructorOf(value));
};

var fmtNumber = function _fmtNumber(ctx, value) {
  // Format -0 as '-0'.
  return ctx.stylize(isNegZero(value) ? '-0' : pNumberToString.call(value), 'number');
};

var fmtPrimitive = function _fmtPrimitive(ctx, value) {
  if (isNil(value)) {
    var str = String(value);
    return ctx.stylize(str, str);
  }

  if (isStringType(value)) {
    var simple = $stringify(value).replace(/^"|"$/g, '').replace(/'/g, '\\\'').replace(/\\"/g, '"');
    return ctx.stylize('\'' + simple + '\'', 'string');
  }

  if (isNumberType(value)) {
    return fmtNumber(ctx, value);
  }

  if (isBooleanType(value)) {
    return ctx.stylize(pBooleanToString.call(value), 'boolean');
  }

  // es6 symbol primitive
  if (isSymbolType(value)) {
    return ctx.stylize(pSymToStr.call(value), 'symbol');
  }

  return void 0;
};

var fmtPrimNoColor = function _fmtPrimNoColor(ctx, value) {
  var stylize = ctx.stylize;
  ctx.stylize = stylizeNoColor;
  var str = fmtPrimitive(ctx, value);
  ctx.stylize = stylize;
  return str;
};

var recurse = function _recurse(depth) {
  return isNull(depth) ? null : depth - 1;
};

/*
var isCollection = function (value) {
  return isSet(value) || isMap(value);
};
*/

var isDigits = function _isDigits(key) {
  return (/^\d+$/).test(key);
};

// eslint-disable-next-line max-params
var fmtProp = function _fmtProp(ctx, value, depth, visibleKeys, key, arr) {
  var desc = getOwnPropertyDescriptor(value, key) || { value: value[key] };

  /*
  // this is a fix for broken FireFox, should not be needed with es6-shim
  if (key === 'size' && isCollection(value) && isFunction(value.size)) {
    desc.value = value.size();
  }
  */

  var name;
  if ($includes(visibleKeys, key) === false) {
    if (key === bpe && Boolean(value[bpe]) === false && isTypedArray(value)) {
      var constructor = getConstructorOf(value);
      if (constructor) {
        desc.value = constructor[bpe];
      }
    } else if (isSymbolType(key)) {
      name = '[' + ctx.stylize(pSymToStr.call(key), 'symbol') + ']';
    } else {
      name = '[' + key + ']';
    }
  }

  var str;
  if (desc.get) {
    str = ctx.stylize(desc.set ? '[Getter/Setter]' : '[Getter]', 'special');
  } else if (desc.set) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = fmtValue(ctx, desc.value, recurse(depth));
    if (str.indexOf('\n') > -1) {
      var rx = arr ? /\n/g : /(^|\n)/g;
      var rStr = arr ? '\n  ' : '\n   ';
      str = str.replace(rx, rStr);
    }
  }

  if (isUndefined(name)) {
    if (arr && isDigits(key)) {
      return str;
    }

    name = $stringify(key);
    if (/^"[\w$]+"$/.test(name)) {
      name = ctx.stylize(name.slice(1, -1), 'name');
    } else {
      name = name.replace(/'/g, '\\\'').replace(/\\"/g, '"').replace(/(^"|"$)/g, '\'').replace(/\\\\/g, '\\');
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
};

// eslint-disable-next-line max-params
var fmtObject = function _fmtObject(ctx, value, depth, visibleKeys, keys) {
  var out = [];
  forEach(keys, function _pusherFmObject(key) {
    out.push(fmtProp(ctx, value, depth, visibleKeys, key, false));
  });

  return out;
};

// eslint-disable-next-line max-params
var fmtArray = function _fmtArray(ctx, value, depth, visibleKeys, keys) {
  var output = [];
  var visibleLength = 0;
  var index = 0;
  while (index < value.length && visibleLength < ctx.maxArrayLength) {
    var emptyItems = 0;
    while (index < value.length && hasOwn(value, pNumberToString.call(index)) === false) {
      emptyItems += 1;
      index += 1;
    }

    if (emptyItems > 0) {
      var ending = emptyItems > 1 ? 's' : '';
      var message = '<' + emptyItems + ' empty item' + ending + '>';
      output.push(ctx.stylize(message, 'undefined'));
    } else {
      output.push(fmtProp(ctx, value, depth, visibleKeys, pNumberToString.call(index), true));
      index += 1;
    }

    visibleLength += 1;
  }

  var remaining = value.length - index;
  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }

  forEach(keys, function _pusherFmtArray(key) {
    if (isSymbolType(key) || isDigits(key) === false) {
      output.push(fmtProp(ctx, value, depth, visibleKeys, key, true));
    }
  });

  return output;
};

// eslint-disable-next-line max-params
var fmtTypedArray = function _fmtTypedArray(ctx, value, depth, visibleKeys, keys) {
  var maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  var remaining = value.length - maxLength;
  var output = new Array(maxLength);
  for (var i = 0; i < maxLength; i += 1) {
    output[i] = fmtNumber(ctx, value[i]);
  }

  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }

  forEach(keys, function _pusherFmtTypedArray(key) {
    if (isSymbolType(key) || isDigits(key) === false) {
      output.push(fmtProp(ctx, value, depth, visibleKeys, key, true));
    }
  });

  return output;
};

// eslint-disable-next-line max-params
var fmtSet = function _fmtSet(ctx, value, depth, visibleKeys, keys) {
  var out = [];
  collectionEach(value, function _pusherFmtSet1(v) {
    out.push(fmtValue(ctx, v, recurse(depth)));
  });

  forEach(keys, function _pusherFmtSet2(key) {
    out.push(fmtProp(ctx, value, depth, visibleKeys, key, false));
  });

  return out;
};

// eslint-disable-next-line max-params
var fmtMap = function (ctx, value, depth, visibleKeys, keys) {
  var out = [];
  collectionEach(value, function (v, k) {
    var r = recurse(depth);
    out.push(fmtValue(ctx, k, r) + ' => ' + fmtValue(ctx, v, r));
  });

  forEach(keys, function (key) {
    out.push(fmtProp(ctx, value, depth, visibleKeys, key, false));
  });

  return out;
};

var reduceToSingleString = function _reduceToSingleString(out, base, braces) {
  var length = reduce(out, function _reducer(prev, cur) {
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  var result;
  if (length > 60) {
    // If the opening "brace" is too large, like in the case of "Set {",
    // we need to force the first item to be on the next line or the
    // items will not line up correctly.
    var layoutBase = base === '' && braces[0].length === 1 ? '' : base + '\n ';
    result = braces[0] + layoutBase + ' ' + out.join(',\n  ') + ' ' + braces[1];
  } else {
    result = braces[0] + base + ' ' + out.join(', ') + ' ' + braces[1];
  }

  return result.replace(reSingle, '{}');
};

var fmtDate = function _fmtDate(value) {
  return $isNaN(value.getTime()) ? 'Invalid Date' : toISOString(value);
};

var fmtError = function _fmtError(value) {
  var stack = value.stack;
  if (stack) {
    if (supportsClasses) {
      var subName = getSubName(value);
      if (subName && stack.startsWith(subName) === false) {
        var msg = value.message;
        return stack.replace(pErrorToString.call(value), subName + (msg ? ': ' + msg : ''));
      }
    } else if (missingError) {
      return pErrorToString.call(value) + '\n' + stack;
    }
  }

  return stack || '[' + pErrorToString.call(value) + ']';
};

var filterDateKeys = function _filterDateKeys(key) {
  return key !== 'constructor';
};

var filterErrorKeys = function _filterErrorKeys(key) {
  return $includes(errProps, key) === false;
};

var getVisibleKeys = function _getVisibleKeys(value) {
  var keys = $keys(value);
  if (keys.length > 0) {
    if (shimmedDate && isDate(value)) {
      return filter(keys, filterDateKeys);
    }

    if (errProps.length > 0 && isError(value)) {
      return filter(keys, filterErrorKeys);
    }
  }

  return keys;
};

var getEnumSymbols = function _getEnumSymbols(value) {
  if ($getOwnPropertySymbols) {
    return filter($getOwnPropertySymbols(value), function _filterEnumSymbolKeys(key) {
      return $propertyIsEnumerable.call(value, key);
    });
  }

  return [];
};

// eslint-disable-next-line complexity
fmtValue = function _fmtValue(ctx, value, depth) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value) {
    var maybeCustomInspect = value[customInspectSymbol] || value.inspect;
    if (isFunction(maybeCustomInspect)) {
      // Filter out the util module, its inspect function is special
      if (maybeCustomInspect !== inspect) {
        var constructor = getConstructorOf(value);
        // Also filter out any prototype objects using the circular check.
        var isCircular = constructor && constructor.prototype === value;
        if (isCircular === false) {
          var ret = maybeCustomInspect.call(value, depth, ctx);
          // If the custom inspection method returned `this`, don't go into
          // infinite recursion.
          // eslint-disable-next-line max-depth
          if (ret !== value) {
            return isStringType(ret) ? ret : fmtValue(ctx, ret, depth);
          }
        }
      }
    }
  }

  // Primitive types cannot have properties
  var primitive = fmtPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var visibleKeys = getVisibleKeys(value);
  var keys;
  if (ctx.showHidden) {
    keys = reflectOwnKeys(value);
    if (isError(value)) {
      if ($includes(visibleKeys, 'message') === false && $includes(keys, 'message') === false) {
        unshiftUniq(keys, 'message');
      }

      /*
      if (includes(visibleKeys, 'name') === false && includes(keys, 'name') === false) {
        unshiftUniq(keys, 'name');
      }
      */
    }
  } else {
    keys = visibleKeys.concat(getEnumSymbols(value));
  }

  if (isString(value)) {
    // for boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisey up the out and are redundant
    filterIndexes(keys, value.length);
    filterIndexes(visibleKeys, value.length);
  } else if (isArrayBuffer(value)) {
    filterIndexes(keys, value.byteLength);
    filterIndexes(visibleKeys, value.byteLength);
  }

  var name;
  var formatted;
  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    // This could be a boxed primitive (new String(), etc.)
    if (isString(value)) {
      return ctx.stylize(
        '[' + getSubName(value, 'String') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']',
        'string'
      );
    }

    if (isNumber(value)) {
      return ctx.stylize(
        '[' + getSubName(value, 'Number') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']',
        'number'
      );
    }

    if (isBoolean(value)) {
      return ctx.stylize(
        '[' + getSubName(value, 'Boolean') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']',
        'boolean'
      );
    }

    if (isSymbol(value)) {
      return ctx.stylize(
        '[Symbol: ' + fmtPrimNoColor(ctx, pSymValOf.call(value)) + ']',
        'symbol'
      );
    }

    if (isAsyncFunction(value)) {
      return ctx.stylize('[AsyncFunction' + getNameSep(value) + ']', 'special');
    }

    if (isGeneratorFunction(value)) {
      return ctx.stylize('[GeneratorFunction' + getNameSep(value) + ']', 'special');
    }

    if (isFunction(value)) {
      return ctx.stylize('[' + getSubName(value, 'Function') + getNameSep(value) + ']', 'special');
    }

    if (supportsClasses && isFunction(value, true)) {
      return ctx.stylize('[Class' + getNameSep(value) + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(pRegExpToString.call(value), 'regexp');
    }

    if (isDate(value)) {
      name = getSubName(value);
      formatted = ctx.stylize(fmtDate(value), 'date');
      if (name === 'Date') {
        return formatted;
      }

      return ctx.stylize('[' + name + ': ' + formatted + ']', 'date');
    }

    if (isError(value)) {
      return fmtError(value);
    }

    // Fast path for ArrayBuffer. Can't do the same for DataView because it
    // has a non-primitive buffer property that we need to recurse for.
    if (isArrayBuffer(value)) {
      return getSubName(value, 'ArrayBuffer') + ' { byteLength: ' + fmtNumber(ctx, value.byteLength) + ' }';
    }

    if (isMapIterator(value)) {
      return getSubName(value, 'MapIterator') + ' {}';
    }

    if (isSetIterator(value)) {
      return getSubName(value, 'SetIterator') + ' {}';
    }

    if (isPromise(value)) {
      return getSubName(value, 'Promise') + ' {}';
    }
  }

  var base = '';
  var empty = false;
  var braces = ['{', '}'];
  var fmtter = fmtObject;
  // We can't compare constructors for various objects using a comparison
  // like `constructor === Array` because the object could have come from a
  // different context and thus the constructor won't match. Instead we check
  // the constructor names (including those up the prototype chain where
  // needed) to determine object types.
  if (isString(value)) {
    // Make boxed primitive Strings look like such
    base = '[' + getSubName(value, 'String') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']';
  } else if (isNumber(value)) {
    // Make boxed primitive Numbers look like such
    base = '[' + getSubName(value, 'Number') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']';
  } else if (isBoolean(value)) {
    // Make boxed primitive Booleans look like such
    base = '[' + getSubName(value, 'Boolean') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']';
  } else if (isFunction(value)) {
    // Make functions say that they are functions
    base = '[' + getSubName(value, 'Function') + getNameSep(value) + ']';
  } else if (supportsClasses && isFunction(value, true)) {
    // Make functions say that they are functions
    base = '[Class' + getNameSep(value) + ']';
  } else if (isRegExp(value)) {
    // Make RegExps say that they are RegExps
    // name = getSubName(value, 'RegExp');
    base = pRegExpToString.call(value);
  } else if (isDate(value)) {
    // Make dates with properties first say the date
    name = getSubName(value);
    formatted = fmtDate(value);
    if (name === 'Date') {
      base = formatted;
    } else {
      base = '[' + name + ': ' + formatted + ']';
    }
  } else if (isError(value)) {
    name = getSubName(value);
    // Make error with message first say the error
    base = fmtError(value);
  } else if ($isArray(value)) {
    name = getSubName(value);
    // Unset the constructor to prevent "Array [...]" for ordinary arrays.
    name = name === 'Array' ? '' : name;
    braces = ['[', ']'];
    if (ctx.showHidden) {
      unshiftUniq(keys, 'length');
    }

    empty = value.length === 0;
    fmtter = fmtArray;
  } else if (isSet(value)) {
    name = getSubName(value, 'Set');
    fmtter = fmtSet;
    // With `showHidden`, `length` will display as a hidden property for
    // arrays. For consistency's sake, do the same for `size`, even though
    // this property isn't selected by Object.getOwnPropertyNames().
    if (ctx.showHidden) {
      unshiftUniq(keys, 'size');
    }

    empty = value.size === 0;
  } else if (isMap(value)) {
    name = getSubName(value, 'Map');
    fmtter = fmtMap;
    // With `showHidden`, `length` will display as a hidden property for
    // arrays. For consistency's sake, do the same for `size`, even though
    // this property isn't selected by Object.getOwnPropertyNames().
    if (ctx.showHidden) {
      unshiftUniq(keys, 'size');
    }

    empty = value.size === 0;
  } else if (isArrayBuffer(value)) {
    name = getSubName(value, 'ArrayBuffer');
    unshiftUniq(keys, 'byteLength');
    pushUniq(visibleKeys, 'byteLength');
  } else if (isDataView(value)) {
    name = getSubName(value, 'DataView');
    unshiftUniq(keys, 'buffer');
    unshiftUniq(keys, 'byteOffset');
    unshiftUniq(keys, 'byteLength');
    pushUniq(visibleKeys, 'byteLength');
    pushUniq(visibleKeys, 'byteOffset');
    pushUniq(visibleKeys, 'buffer');
  } else if (isTypedArray(value)) {
    name = getSubName(value);
    braces = ['[', ']'];
    fmtter = fmtTypedArray;
    if (ctx.showHidden) {
      unshiftUniq(keys, 'buffer');
      unshiftUniq(keys, 'byteOffset');
      unshiftUniq(keys, 'byteLength');
      unshiftUniq(keys, 'length');
      unshiftUniq(keys, bpe);
    }
  } else if (isPromise(value)) {
    name = getSubName(value, 'Promise');
  } else if (isMapIterator(value)) {
    name = getSubName(value, 'MapIterator');
    empty = true;
  } else if (isSetIterator(value)) {
    name = getSubName(value, 'SetIterator');
    empty = true;
  } else {
    name = getSubName(value);
    // Unset the constructor to prevent "Object {...}" for ordinary objects.
    name = name === 'Object' ? '' : name;
    empty = true; // No other data than keys.
  }

  if (base) {
    base = ' ' + base;
  } else if (name) {
    // Add constructor name if available
    braces[0] = name + ' ' + braces[0];
  }

  empty = empty === true && keys.length === 0;
  if (empty) {
    return braces[0] + base + braces[1];
  }

  if (depth < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(pRegExpToString.call(value), 'regexp');
    } else if ($isArray(value)) {
      return ctx.stylize('[Array]', 'special');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  if (ctx.seen.has(value)) {
    return ctx.stylize('[Circular]', 'special');
  }

  ctx.seen.add(value);
  var out = fmtter(ctx, value, depth, visibleKeys, keys);
  ctx.seen['delete'](value);
  return reduceToSingleString(out, base, braces);
};

inspect = function _inspect(obj, opts) {
  // default options
  var ctx = {
    seen: new collections.Set(),
    stylize: stylizeNoColor
  };

  // legacy...
  if (arguments.length >= 3 && isUndefined(arguments[2]) === false) {
    ctx.depth = arguments[2];
  }

  if (arguments.length >= 4 && isUndefined(arguments[3]) === false) {
    ctx.colors = arguments[3];
  }

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  }

  // Set default and user-specified options
  if (supportsGetSet) {
    ctx = $assign({}, inspect.defaultOptions, ctx, opts);
  } else {
    ctx = $assign({}, inspectDefaultOptions, inspect.defaultOptions, ctx, opts);
  }

  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }

  if (isNull(ctx.maxArrayLength)) {
    ctx.maxArrayLength = Infinity;
  }

  return fmtValue(ctx, obj, ctx.depth);
};

if (supportsGetSet) {
  defineProperty(inspect, 'defaultOptions', {
    get: function _get() {
      return inspectDefaultOptions;
    },
    set: function _set(options) {
      if (isObjectLike(options) === false) {
        throw new TypeError('"options" must be an object');
      }

      return $assign(inspectDefaultOptions, options);
    }
  });
} else {
  defineProperties(inspect, {
    defaultOptions: {
      value: $assign({}, inspectDefaultOptions),
      writable: true
    }
  });
}

defineProperties(inspect, {
  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  colors: {
    value: {
      black: [30, 39],
      blue: [34, 39],
      bold: [1, 22],
      cyan: [36, 39],
      green: [32, 39],
      grey: [90, 39],
      inverse: [7, 27],
      italic: [3, 23],
      magenta: [35, 39],
      red: [31, 39],
      underline: [4, 24],
      white: [37, 39],
      yellow: [33, 39]
    }
  },
  custom: {
    value: customInspectSymbol
  },
  // Don't use 'blue' not visible on cmd.exe
  styles: {
    value: {
      'boolean': 'yellow',
      date: 'magenta',
      // name: intentionally not styling
      'null': 'bold',
      number: 'yellow',
      regexp: 'red',
      special: 'cyan',
      string: 'green',
      symbol: 'green',
      undefined: 'grey'
    }
  }
});

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 * Values may supply their own custom `inspect(depth, opts)` functions,
 * when called they receive the current depth in the recursive inspection,
 * as well as the options object passed to `inspect`.
 *
 * @param {Object} obj - The object to print out.
 * @param {Object} [opts] - Options object that alters the out.
 * @returns {string} The string representation.
 * @example
 * var inspect = require('inspect-x');
 *
 * console.log(inspect(inspect, { showHidden: true, depth: null }));
 * //{ [Function: inspect]
 * //  [length]: 2,
 * //  [name]: 'inspect',
 * //  [prototype]: inspect { [constructor]: [Circular] },
 * //  [colors]:
 * //   { [bold]: [ 1, 22, [length]: 2 ],
 * //     [italic]: [ 3, 23, [length]: 2 ],
 * //     [underline]: [ 4, 24, [length]: 2 ],
 * //     [inverse]: [ 7, 27, [length]: 2 ],
 * //     [white]: [ 37, 39, [length]: 2 ],
 * //     [grey]: [ 90, 39, [length]: 2 ],
 * //     [black]: [ 30, 39, [length]: 2 ],
 * //     [blue]: [ 34, 39, [length]: 2 ],
 * //     [cyan]: [ 36, 39, [length]: 2 ],
 * //     [green]: [ 32, 39, [length]: 2 ],
 * //     [magenta]: [ 35, 39, [length]: 2 ],
 * //     [red]: [ 31, 39, [length]: 2 ],
 * //     [yellow]: [ 33, 39, [length]: 2 ] },
 * //  [styles]:
 * //   { [special]: 'cyan',
 * //     [number]: 'yellow',
 * //     [boolean]: 'yellow',
 * //     [undefined]: 'grey',
 * //     [null]: 'bold',
 * //     [string]: 'green',
 * //     [symbol]: 'green',
 * //     [date]: 'magenta',
 * //     [regexp]: 'red' } }
 */
module.exports = inspect;

},{"array-filter-x":7,"array-for-each-x":8,"array-includes-x":9,"array-reduce-x":17,"collections-x":42,"get-function-name-x":114,"get-prototype-of-x":120,"has-own-property-x":148,"has-symbol-support-x":124,"index-of-x":129,"is-array-buffer-x":151,"is-array-x":153,"is-async-function-x":154,"is-boolean-object":155,"is-data-view-x":157,"is-date-object":158,"is-error-x":159,"is-function-x":162,"is-generator-function":163,"is-map-x":167,"is-nan":170,"is-negative-zero":173,"is-nil-x":174,"is-number-object":175,"is-object-like-x":176,"is-primitive":178,"is-promise":179,"is-regex":180,"is-set-x":185,"is-string":186,"is-symbol":188,"is-typed-array":189,"json3":190,"lodash.isnull":191,"object-assign-x":409,"object-define-properties-x":414,"object-define-property-x":415,"object-get-own-property-descriptor-x":149,"object-keys-x":417,"reflect-own-keys-x":427,"to-iso-string-x":440,"validate.io-undefined":459,"white-space-x":460}],148:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43,"es-to-primitive/es6":102,"is-symbol":188,"safe-to-string-x":432,"to-object-x":446}],149:[function(require,module,exports){
/**
 * @file Sham for ES6 Object.getOwnPropertyDescriptor
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-get-own-property-descriptor-x
 */

'use strict';

var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getOPDFallback;

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3

var doesGOPDWork = function (object) {
  try {
    object.sentinel = 0;
    return $getOwnPropertyDescriptor(object, 'sentinel').value === 0;
  } catch (ignore) {
    return false;
  }
};

// check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
if ($getOwnPropertyDescriptor) {
  var getOPDWorksOnObject = doesGOPDWork({});
  var getOPDWorksOnDom = typeof document === 'undefined' || doesGOPDWork(document.createElement('div'));
  if (getOPDWorksOnDom === false || getOPDWorksOnObject === false) {
    getOPDFallback = $getOwnPropertyDescriptor;
  }
}

var toObject;
if ($getOwnPropertyDescriptor && Boolean(getOPDFallback) === false) {
  try {
    $getOwnPropertyDescriptor(42, 'name');
  } catch (err) {
    toObject = require('to-object-x');
    $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
      return $getOwnPropertyDescriptor(toObject(object), property);
    };
  }
} else if (Boolean($getOwnPropertyDescriptor) === false || getOPDFallback) {
  toObject = require('to-object-x');
  var owns = require('has-own-property-x');
  var prototypeOfObject = Object.prototype;

  var propertyIsEnumerable = prototypeOfObject.propertyIsEnumerable;
  var isEnumerable = function (object, property) {
    return propertyIsEnumerable.call(object, property);
  };

  // If JS engine supports accessors creating shortcuts.
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
  if (supportsAccessors) {
    // eslint-disable-next-line no-underscore-dangle
    var lg = prototypeOfObject.__lookupGetter__;
    // eslint-disable-next-line no-underscore-dangle
    var ls = prototypeOfObject.__lookupSetter__;
    lookupGetter = function (object, property) {
      return lg.call(object, property);
    };

    lookupSetter = function (object, property) {
      return ls.call(object, property);
    };
  }

  $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
    var obj = toObject(object);

    // make a valiant attempt to use the real getOwnPropertyDescriptor
    // for I8's DOM elements.
    if (getOPDFallback) {
      try {
        return getOPDFallback.call(Object, obj, property);
      } catch (ignore) {
        // try the shim if the real one doesn't work
      }
    }

    var descriptor;

    // If object does not owns property return undefined immediately.
    if (owns(obj, property) === false) {
      return descriptor;
    }

    // If object has a property then it's for sure `configurable`, and
    // probably `enumerable`. Detect enumerability though.
    descriptor = {
      configurable: true,
      enumerable: isEnumerable(obj, property)
    };

    // If JS engine supports accessor properties then property may be a
    // getter or setter.
    if (supportsAccessors) {
      // Unfortunately `__lookupGetter__` will return a getter even
      // if object has own non getter property along with a same named
      // inherited getter. To avoid misbehavior we temporary remove
      // `__proto__` so that `__lookupGetter__` will return getter only
      // if it's owned by an object.
      // eslint-disable-next-line no-proto
      var prototype = obj.__proto__;
      var notPrototypeOfObject = obj !== prototypeOfObject;
      // avoid recursion problem, breaking in Opera Mini when
      // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
      // or any other Object.prototype accessor
      if (notPrototypeOfObject) {
        // eslint-disable-next-line no-proto
        object.__proto__ = prototypeOfObject;
      }

      var getter = lookupGetter(obj, property);
      var setter = lookupSetter(obj, property);

      if (notPrototypeOfObject) {
        // Once we have getter and setter we can put values back.
        // eslint-disable-next-line no-proto
        obj.__proto__ = prototype;
      }

      if (getter || setter) {
        if (getter) {
          descriptor.get = getter;
        }

        if (setter) {
          descriptor.set = setter;
        }

        // If it was accessor property we're done and return here
        // in order to avoid adding `value` to the descriptor.
        return descriptor;
      }
    }

    // If we got this far we know that object has an own property that is
    // not an accessor so we set it as a value and return descriptor.
    descriptor.value = obj[property];
    descriptor.writable = true;
    return descriptor;
  };
}

/**
 * This method returns a property descriptor for an own property (that is,
 * one directly present on an object and not in the object's prototype chain)
 * of a given object.
 *
 * @param {*} object - The object in which to look for the property.
 * @param {*} property - The name of the property whose description is to be retrieved.
 * @returns {Object} A property descriptor of the given property if it exists on the object, undefined otherwise.
 * @example
 * var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
 * var obj = { bar: 42 };
 * var d = getOwnPropertyDescriptor(o, 'bar');
 * // d is {
 * //   configurable: true,
 * //   enumerable: true,
 * //   value: 42,
 * //   writable: true
 * // }
 */
module.exports = $getOwnPropertyDescriptor;

},{"has-own-property-x":148,"to-object-x":446}],150:[function(require,module,exports){
'use strict';

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{}],151:[function(require,module,exports){
/**
 * @file Detect whether or not an object is an ArrayBuffer.
 * @version 1.7.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-array-buffer-x
 */

/* global ArrayBuffer */

'use strict';

var attempt = require('attempt-x');
var isObjectLike = require('is-object-like-x');
var hasABuf = typeof ArrayBuffer === 'function';
var bLength = false;
var toStringTag;
var aBufTag;

if (hasABuf) {
  if (require('has-to-string-tag-x')) {
    var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
    var descriptor = getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength');
    if (descriptor && typeof descriptor.get === 'function') {
      var res = attempt(function () {
        return new ArrayBuffer(4);
      });

      if (res.threw === false && isObjectLike(res.value)) {
        res = attempt.call(res.value, descriptor.get);
        bLength = res.threw === false && typeof res.value === 'number' && descriptor.get;
      }
    }
  }

  if (bLength === false) {
    toStringTag = require('to-string-tag-x');
    aBufTag = '[object ArrayBuffer]';
  }
}

/**
 * Determine if an `object` is an `ArrayBuffer`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is an `ArrayBuffer`,
 *  else false`.
 * @example
 * var isArrayBuffer = require('is-array-buffer-x');
 *
 * isArrayBuffer(new ArrayBuffer(4)); // true
 * isArrayBuffer(null); // false
 * isArrayBuffer([]); // false
 */
module.exports = function isArrayBuffer(object) {
  if (hasABuf === false || isObjectLike(object) === false) {
    return false;
  }

  if (bLength === false) {
    return toStringTag(object) === aBufTag;
  }

  var result = attempt.call(object, bLength);
  return result.threw === false && typeof result.value === 'number';
};

},{"attempt-x":32,"has-to-string-tag-x":127,"is-object-like-x":176,"object-get-own-property-descriptor-x":416,"to-string-tag-x":450}],152:[function(require,module,exports){
/**
 * @file Determine if a value is array like.
 * @version 1.8.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-array-like-x
 */

'use strict';

var isNil = require('is-nil-x');
var isFunction = require('is-function-x');
var isLength = require('is-length-x');

/**
 * Checks if value is array-like. A value is considered array-like if it's
 * not a function and has a `length` that's an integer greater than or
 * equal to 0 and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @param {*} value - The object to be tested.
 * @returns {boolean} Returns `true` if subject is array-like, else `false`.
 * @example
 * var isArrayLike = require('is-array-like-x');
 *
 * isArrayLike([1, 2, 3]); // true
 * isArrayLike(document.body.children); // true
 * isArrayLike('abc'); // true
 * isArrayLike(_.noop); // false
 */
module.exports = function isArrayLike(value) {
  return isNil(value) === false && isFunction(value, true) === false && isLength(value.length);
};

},{"is-function-x":162,"is-length-x":166,"is-nil-x":174}],153:[function(require,module,exports){
/**
 * @file Determines whether the passed value is an Array.
 * @version 1.2.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-array-x
 */

'use strict';

var nativeIsArray = typeof Array.isArray === 'function' && Array.isArray;

var testRes = nativeIsArray && require('attempt-x')(function () {
  return nativeIsArray([]) === true && nativeIsArray({ length: 0 }) === false;
});

var $isArray;
if (testRes && testRes.threw === false && testRes.value === true) {
  $isArray = nativeIsArray;
} else {
  var toStringTag = require('to-string-tag-x');
  $isArray = function isArray(obj) {
    return toStringTag(obj) === '[object Array]';
  };
}

/**
 * The isArray() function determines whether the passed value is an Array.
 *
 * @param {*} obj - The object to be checked..
 * @returns {boolean} `true` if the object is an Array; otherwise, `false`.
 * @example
 * var isArray = require('is-array-x');
 *
 * isArray([]); // true
 * isArray({}); // false
 */
module.exports = $isArray;

},{"attempt-x":32,"to-string-tag-x":450}],154:[function(require,module,exports){
/**
 * @file Determine if a function is a native aync function.
 * @see {@link https://tc39.github.io/ecma262/#sec-async-function-definitions|14.6 Async Function Definitions}
 * @version 1.7.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-async-function-x
 */

'use strict';

var toStringTag = require('to-string-tag-x');
var hasToStringTag = require('has-to-string-tag-x');
var normalise = require('normalize-space-x').normalizeSpace2018;
var isFnRegex = /^async function/;
var test = isFnRegex.test;
var replaceComments = require('replace-comments-x');
var functionCtr = function () {}.constructor;
var fToString = functionCtr.prototype.toString;
var $getPrototypeOf = require('get-prototype-of-x');
var attempt = require('attempt-x');

var testRes = attempt(function () {
  return $getPrototypeOf(functionCtr('return async function() {}')());
});

var supportsAsync = testRes.threw === false;
var asyncProto = testRes.value;

/**
 * Checks if `value` is classified as an `Async Function` object.
 *
 * @param {*} fn - The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 * @example
 * var isAsyncFunction = require('is--async-function-x');
 *
 * isAsyncFunction(); // false
 * isAsyncFunction(Number.MIN_VALUE); // false
 * isAsyncFunction('abc'); // false
 * isAsyncFunction(true); // false
 * isAsyncFunction({ name: 'abc' }); // false
 * isAsyncFunction(function () {}); // false
 * isAsyncFunction(new Function ()); // false
 * isAsyncFunction(function* test1() {}); // false
 * isAsyncFunction(function test2(a, b) {}); // false
 * isAsyncFunction(class Test {}); // false
 * isAsyncFunction((x, y) => {return this;}); // false
 * isAsyncFunction(async functin() {}); // true
 */
module.exports = function isAsyncFunction(fn) {
  if (supportsAsync === false || typeof fn !== 'function') {
    return false;
  }

  var str;
  try {
    str = normalise(replaceComments(fToString.call(fn), ' '));
  } catch (ignore) {
    return false;
  }

  if (test.call(isFnRegex, str)) {
    return true;
  }

  if (hasToStringTag === false) {
    return toStringTag(fn) === '[object AsyncFunction]';
  }

  return $getPrototypeOf(fn) === asyncProto;
};

},{"attempt-x":32,"get-prototype-of-x":120,"has-to-string-tag-x":127,"normalize-space-x":405,"replace-comments-x":428,"to-string-tag-x":450}],155:[function(require,module,exports){
'use strict';

var boolToStr = Boolean.prototype.toString;

var tryBooleanObject = function tryBooleanObject(value) {
	try {
		boolToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var boolClass = '[object Boolean]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isBoolean(value) {
	if (typeof value === 'boolean') { return true; }
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryBooleanObject(value) : toStr.call(value) === boolClass;
};

},{}],156:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (typeof value === 'function' && !value.prototype) { return true; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],157:[function(require,module,exports){
/**
 * @file Detect whether or not an object is a DataView.
 * @version 1.6.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-data-view-x
 */

/* global ArrayBuffer, DataView */

'use strict';

var attempt = require('attempt-x');
var isObjectLike = require('is-object-like-x');
var hasDView = typeof DataView === 'function';
var getByteLength = false;
var legacyCheck;

if (hasDView) {
  var res = attempt(function () {
    return new DataView(new ArrayBuffer(4));
  });

  var dataView = res.threw === false && isObjectLike(res.value) && res.value;

  if (dataView && require('has-to-string-tag-x')) {
    var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
    var descriptor = getOwnPropertyDescriptor(DataView.prototype, 'byteLength');
    if (descriptor && typeof descriptor.get === 'function') {
      res = attempt.call(dataView, descriptor.get);
      getByteLength = res.threw === false && typeof res.value === 'number' && descriptor.get;
    }
  }

  if (getByteLength === false) {
    var toStringTag = require('to-string-tag-x');
    var dViewTag = '[object DataView]';
    if (toStringTag(dataView) === dViewTag) {
      legacyCheck = function _legacyCheck(object) {
        return toStringTag(object) === dViewTag;
      };
    } else {
      var isArrayBuffer = require('is-array-buffer-x');
      legacyCheck = function _legacyCheck(object) {
        var isByteLength = typeof object.byteLength === 'number';
        var isByteOffset = typeof object.byteOffset === 'number';
        var isGetFloat32 = typeof object.getFloat32 === 'function';
        var isSetFloat64 = typeof object.setFloat64 === 'function';
        return isByteLength && isByteOffset && isGetFloat32 && isSetFloat64 && isArrayBuffer(object.buffer);
      };
    }
  }
}

/**
 * Determine if an `object` is an `DataView`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is a `DataView`, else `false`.
 * @example
 * var isDataView = require('is-data-view-x');
 * var ab = new ArrayBuffer(4);
 * var dv = new DataView(ab);
 *
 * isDataView(ab); // false
 * isDataView(true); // false
 * isDataView(dv); // true
 */
module.exports = function isDataView(object) {
  if (hasDView === false || isObjectLike(object) === false) {
    return false;
  }

  if (legacyCheck) {
    return legacyCheck(object);
  }

  var result = attempt.call(object, getByteLength);
  return result.threw === false && typeof result.value === 'number';
};

},{"attempt-x":32,"has-to-string-tag-x":127,"is-array-buffer-x":151,"is-object-like-x":176,"object-get-own-property-descriptor-x":416,"to-string-tag-x":450}],158:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],159:[function(require,module,exports){
/**
 * @file  Detect whether a value is an error.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-error-x
 */

'use strict';

var toStringTag = require('to-string-tag-x');
var isObjectLike = require('is-object-like-x');
var $getPrototypeOf = require('get-prototype-of-x');

var errorCheck = function checkIfError(value) {
  return toStringTag(value) === '[object Error]';
};

if (errorCheck(Error.prototype) === false) {
  var errorProto = Error.prototype;
  var testStringTag = errorCheck;
  errorCheck = function checkIfError(value) {
    return value === errorProto || testStringTag(value);
  };
}

/**
 * Determine whether or not a given `value` is an `Error` type.
 *
 * @param {*} value - The object to be tested.
 * @returns {boolean} Returns `true` if `value` is an `Error` type,
 *  else `false`.
 * @example
 * var isError = require('is-error-x');
 *
 * isError(); // false
 * isError(Number.MIN_VALUE); // false
 * isError('abc'); // false
 * isError(new Error()); //true
 */
module.exports = function isError(value) {
  if (isObjectLike(value) === false) {
    return false;
  }

  var object = value;
  var maxLoop = 100;
  while (object && maxLoop > -1) {
    if (errorCheck(object)) {
      return true;
    }

    object = $getPrototypeOf(object);
    maxLoop -= 1;
  }

  return false;
};

},{"get-prototype-of-x":120,"is-object-like-x":176,"to-string-tag-x":450}],160:[function(require,module,exports){
/**
 * @file Test if a given value is falsey.
 * @version 1.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-falsey-x
 */

'use strict';

var toBoolean = require('to-boolean-x');

/**
 * This method tests if a given value is falsey.
 *
 * @param {*} value - The value to test.
 * @returns {boolean} `true` if the value is falsey: otherwise `false`.
 * @example
 * var isFalsey = require('is-falsey-x');
 *
 * isFalsey(); // true
 * isFalsey(0); // true
 * isFalsey(''); // true
 * isFalsey(false); // true
 * isFalsey(null); // true
 *
 * isFalsey(true); // false
 * isFalsey([]); // false
 * isFalsey(1); // false
 * isFalsey(function () {}); // false
 */
module.exports = function isFalsey(value) {
  return toBoolean(value) === false;
};

},{"to-boolean-x":438}],161:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Number.isFinite.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-number.isfinite|20.1.2.2 Number.isFinite ( number )}
 * @version 3.0.4
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-finite-x
 */

'use strict';

var numberIsNaN = require('is-nan-x');
var INFINITY = require('infinity-x');

/**
 * This method determines whether the passed value is a finite number.
 *
 * @param {*} number - The value to be tested for finiteness.
 * @returns {boolean} A Boolean indicating whether or not the given value is a finite number.
 * @example
 * var numIsFinite = require('is-finite-x');
 *
 * numIsFinite(Infinity);  // false
 * numIsFinite(NaN);       // false
 * numIsFinite(-Infinity); // false
 *
 * numIsFinite(0);         // true
 * numIsFinite(2e64);      // true
 *
 * numIsFinite('0');       // false, would've been true with
 *                         // global isFinite('0')
 * numIsFinite(null);      // false, would've been true with
 */
module.exports = function isFinite(number) {
  return typeof number === 'number' && numberIsNaN(number) === false && number !== INFINITY && number !== -INFINITY;
};

},{"infinity-x":146,"is-nan-x":168}],162:[function(require,module,exports){
/**
 * @file Determine whether a given value is a function object.
 * @version 3.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-function-x
 */

'use strict';

var attempt = require('attempt-x');
var fToString = Function.prototype.toString;
var toBoolean = require('to-boolean-x');
var isFalsey = require('is-falsey-x');
var toStringTag = require('to-string-tag-x');
var hasToStringTag = require('has-to-string-tag-x');
var isPrimitive = require('is-primitive');
var normalise = require('normalize-space-x').normalizeSpace;
var deComment = require('replace-comments-x');
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var asyncTag = '[object AsyncFunction]';
var ctrRx = /^class /;
var test = ctrRx.test;

var hasNativeClass = attempt(function () {
  // eslint-disable-next-line no-new-func
  return Function('"use strict"; return class My {};')();
}).threw === false;

var testClassstring = function _testClassstring(value) {
  return test.call(ctrRx, normalise(deComment(fToString.call(value), ' ')));
};

var isES6ClassFn = function isES6ClassFunc(value) {
  var result = attempt(testClassstring, value);

  return result.threw === false && result.value;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @private
 * @param {*} value - The value to check.
 * @param {boolean} allowClass - Whether to filter ES6 classes.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 */
var tryFuncToString = function funcToString(value, allowClass) {
  if (hasNativeClass && allowClass === false && isES6ClassFn(value)) {
    return false;
  }

  return attempt.call(value, fToString).threw === false;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @param {*} value - The value to check.
 * @param {boolean} [allowClass=false] - Whether to filter ES6 classes.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 * @example
 * var isFunction = require('is-function-x');
 *
 * isFunction(); // false
 * isFunction(Number.MIN_VALUE); // false
 * isFunction('abc'); // false
 * isFunction(true); // false
 * isFunction({ name: 'abc' }); // false
 * isFunction(function () {}); // true
 * isFunction(new Function ()); // true
 * isFunction(function* test1() {}); // true
 * isFunction(function test2(a, b) {}); // true
 * isFunction(async function test3() {}); // true
 * isFunction(class Test {}); // false
 * isFunction(class Test {}, true); // true
 * isFunction((x, y) => {return this;}); // true
 */
module.exports = function isFunction(value) {
  if (isPrimitive(value)) {
    return false;
  }

  if (hasToStringTag) {
    return tryFuncToString(value, toBoolean(arguments[1]));
  }

  if (hasNativeClass && isFalsey(arguments[1]) && isES6ClassFn(value)) {
    return false;
  }

  var strTag = toStringTag(value);
  return strTag === funcTag || strTag === genTag || strTag === asyncTag;
};

},{"attempt-x":32,"has-to-string-tag-x":127,"is-falsey-x":160,"is-primitive":178,"normalize-space-x":405,"replace-comments-x":428,"to-boolean-x":438,"to-string-tag-x":450}],163:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var generatorFunc = getGeneratorFunc();
var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	return getProto(fn) === GeneratorFunction;
};

},{}],164:[function(require,module,exports){
/**
 * @file Determine whether the passed value is a zero based index.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-index-x
 */

'use strict';

var safeToString = require('to-string-symbols-supported-x');
var toInteger = require('to-integer-x').toInteger2018;
var toNumber = require('to-number-x').toNumber2018;
var mathClamp = require('math-clamp-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');
var reIsUint = /^(?:0|[1-9]\d*)$/;
var rxTest = reIsUint.test;

/**
 * This method determines whether the passed value is a zero based index.
 * JavaScript arrays are zero-indexed: the first element of an array is at
 * index 0, and the last element is at the index equal to the value of the
 * array's length property minus 1.
 *
 * @param {number|string} value - The value to be tested for being a zero based index.
 * @param {number} [length=MAX_SAFE_INTEGER] - The length that sets the upper bound.
 * @returns {boolean} A Boolean indicating whether or not the given value is a
 * zero based index within bounds.
 * @example
 * var isIndex = require('is-index-x');
 *
 * isIndex(0);                    // true
 * isIndex(1);                    // true
 * isIndex('10');                 // true
 *
 * isIndex(-100000);              // false
 * isIndex(Math.pow(2, 53));      // false
 * isIndex(0.1);                  // false
 * isIndex(Math.PI);              // false
 * isIndex(NaN);                  // false
 * isIndex(Infinity);             // false
 * isIndex(-Infinity);            // false
 * isIndex(true);                 // false
 * isIndex(false);                // false
 * isIndex([1]);                  // false
 * isIndex(10, 10);               // false
 */
module.exports = function isIndex(value) {
  var string = safeToString(value);
  if (rxTest.call(reIsUint, string) === false) {
    return false;
  }

  var number = toNumber(string);
  if (arguments.length > 1) {
    return number < mathClamp(toInteger(arguments[1]), MAX_SAFE_INTEGER);
  }

  return number < MAX_SAFE_INTEGER;
};

},{"math-clamp-x":395,"max-safe-integer":397,"to-integer-x":439,"to-number-x":442,"to-string-symbols-supported-x":449}],165:[function(require,module,exports){
/**
 * @file Determine whether the passed value is an integer.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-integer-x
 */

'use strict';

var numberIsFinite = require('is-finite-x');
var toInteger = require('to-integer-x').toInteger2018;

/**
 * This method determines whether the passed value is an integer.
 *
 * @param {*} value - The value to be tested for being an integer.
 * @returns {boolean} A Boolean indicating whether or not the given value is an integer.
 * @example
 * var isInteger = require('is-integer-x');
 *
 * isInteger(0);         // true
 * isInteger(1);         // true
 * isInteger(-100000);   // true
 *
 * isInteger(0.1);       // false
 * isInteger(Math.PI);   // false
 *
 * isInteger(NaN);       // false
 * isInteger(Infinity);  // false
 * isInteger(-Infinity); // false
 * isInteger('10');      // false
 * isInteger(true);      // false
 * isInteger(false);     // false
 * isInteger([1]);       // false
 */
module.exports = function isInteger(value) {
  return numberIsFinite(value) && toInteger(value) === value;
};

},{"is-finite-x":161,"to-integer-x":439}],166:[function(require,module,exports){
/**
 * @file Checks if `value` is a valid array-like length.
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-length-x
 */

'use strict';

var isSafeInteger = require('is-safe-integer-x');

/**
 * This method checks if `value` is a valid array-like length.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 * var isLength = require('is-length-x');
 *
 * isLength(3); // => true
 * isLength(Number.MIN_VALUE); // => false
 * isLength(Infinity); // => false
 * isLength('3'); // => false
 */
module.exports = function isLength(value) {
  return isSafeInteger(value) && value >= 0;
};

},{"is-safe-integer-x":184}],167:[function(require,module,exports){
/**
 * @file Detect whether or not an object is an ES6 Map.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-map-x
 */

'use strict';

var isFalsey = require('is-falsey-x');
var attempt;
var isObjectLike;
var isLength;
var getSize;

if (typeof Map === 'function') {
  var descriptor = require('object-get-own-property-descriptor-x')(Map.prototype, 'size');
  if (descriptor && typeof descriptor.get === 'function') {
    attempt = require('attempt-x');
    isObjectLike = require('is-object-like-x');
    var res = attempt(function () {
      return new Map();
    });

    if (res.threw === false && isObjectLike(res.value)) {
      isLength = require('is-length-x');
      res = attempt.call(res.value, descriptor.get);
      if (res.threw === false && isLength(res.value)) {
        getSize = descriptor.get;
      }
    }

  }
}

/**
 * Determine if an `object` is a `Map`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is a `Map`,
 *  else `false`.
 * @example
 * var isMap = require('is-map-x');
 * var m = new Map();
 *
 * isMap([]); // false
 * isMap(true); // false
 * isMap(m); // true
 */
module.exports = function isMap(object) {
  if (isFalsey(getSize) || isObjectLike(object) === false) {
    return false;
  }

  var result = attempt.call(object, getSize);
  return result.threw === false && isLength(result.value);
};

},{"attempt-x":32,"is-falsey-x":160,"is-length-x":166,"is-object-like-x":176,"object-get-own-property-descriptor-x":416}],168:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Number.isNaN - the global isNaN returns false positives.
 * @version 1.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-nan-x
 */

'use strict';

/**
 * This method determines whether the passed value is NaN and its type is
 * `Number`. It is a more robust version of the original, global isNaN().
 *
 * @param {*} value - The value to be tested for NaN.
 * @returns {boolean} `true` if the given value is NaN and its type is Number;
 *  otherwise, `false`.
 * @example
 * var numberIsNaN = require('is-nan-x');
 *
 * numberIsNaN(NaN);        // true
 * numberIsNaN(Number.NaN); // true
 * numberIsNaN(0 / 0);      // true
 *
 * // e.g. these would have been true with global isNaN()
 * numberIsNaN('NaN');      // false
 * numberIsNaN(undefined);  // false
 * numberIsNaN({});         // false
 * numberIsNaN('blabla');   // false
 *
 * // These all return false
 * numberIsNaN(true);
 * numberIsNaN(null);
 * numberIsNaN(37);
 * numberIsNaN('37');
 * numberIsNaN('37.37');
 * numberIsNaN('');
 * numberIsNaN(' ');
 */
module.exports = function isNaN(value) {
  return value !== value;
};

},{}],169:[function(require,module,exports){
'use strict';

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};

},{}],170:[function(require,module,exports){
'use strict';

var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(implementation, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = implementation;

},{"./implementation":169,"./polyfill":171,"./shim":172,"define-properties":99}],171:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};

},{"./implementation":169}],172:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, { isNaN: function () { return Number.isNaN !== polyfill; } });
	return polyfill;
};

},{"./polyfill":171,"define-properties":99}],173:[function(require,module,exports){
'use strict';

module.exports = function isNegativeZero(number) {
	return number === 0 && (1 / number) === -Infinity;
};


},{}],174:[function(require,module,exports){
/**
 * @file Checks if `value` is `null` or `undefined`.
 * @version 1.4.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-nil-x
 */

'use strict';

var isUndefined = require('validate.io-undefined');
var isNull = require('lodash.isnull');

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 * var isNil = require('is-nil-x');
 *
 * isNil(null); // => true
 * isNil(void 0); // => true
 * isNil(NaN); // => false
 */
module.exports = function isNil(value) {
  return isNull(value) || isUndefined(value);
};

},{"lodash.isnull":191,"validate.io-undefined":459}],175:[function(require,module,exports){
'use strict';

var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject(value) {
	try {
		numToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var numClass = '[object Number]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isNumberObject(value) {
	if (typeof value === 'number') { return true; }
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
};

},{}],176:[function(require,module,exports){
/**
 * @file Determine if a value is object like.
 * @version 1.7.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-object-like-x
 */

'use strict';

var isFunction = require('is-function-x');
var isPrimitive = require('is-primitive');

/**
 * Checks if `value` is object-like. A value is object-like if it's not a
 * primitive and not a function.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 * var isObjectLike = require('is-object-like-x');
 *
 * isObjectLike({});
 * // => true
 *
 * isObjectLike([1, 2, 3]);
 * // => true
 *
 * isObjectLike(_.noop);
 * // => false
 *
 * isObjectLike(null);
 * // => false
 */
module.exports = function isObjectLike(value) {
  return isPrimitive(value) === false && isFunction(value, true) === false;
};

},{"is-function-x":162,"is-primitive":177}],177:[function(require,module,exports){
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isPrimitive(val) {
  if (typeof val === 'object') {
    return val === null;
  }
  return typeof val !== 'function';
};

},{}],178:[function(require,module,exports){
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

// see http://jsperf.com/testing-value-is-primitive/7
module.exports = function isPrimitive(value) {
  return value == null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],179:[function(require,module,exports){
module.exports = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

},{}],180:[function(require,module,exports){
'use strict';

var has = require('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":128}],181:[function(require,module,exports){
/**
 * @file Is this value a JS regex?
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-regexp-x
 */

'use strict';

var isObjectLike = require('is-object-like-x');

var toStringTag;
var regexClass;
var has;
var gOPD;
var regexExec;
var defineProperty;

if (require('has-to-string-tag-x')) {
  has = require('has-own-property-x');
  gOPD = require('object-get-own-property-descriptor-x');
  defineProperty = require('object-define-property-x');
  regexExec = RegExp.prototype.exec;
} else {
  toStringTag = require('to-string-tag-x');
  regexClass = '[object RegExp]';
}

var tryRegexExecCall = function tryRegexExec(value, descriptor) {
  try {
    value.lastIndex = 0;
    regexExec.call(value);
    return true;
  } catch (e) {
    return false;
  } finally {
    defineProperty(value, 'lastIndex', descriptor);
  }
};

/**
 * This method tests if a value is a regex.
 *
 * @param {*} value - The value to test.
 * @returns {boolean} `true` if value is a regex; otherwise `false`.
 * @example
 * var isRegex = require('is-regexp-x');
 *
 * isRegex(undefined); // false
 * isRegex(null); // false
 * isRegex(false); // false
 * isRegex(true); // false
 * isRegex(42); // false
 * isRegex('foo'); // false
 * isRegex(function () {}); // false
 * isRegex([]); // false
 * isRegex({})); // false
 *
 * isRegex(/a/g); // true
 * isRegex(new RegExp('a', 'g')); // true
 */
module.exports = function isRegex(value) {
  if (isObjectLike(value) === false) {
    return false;
  }

  if (toStringTag) {
    return toStringTag(value) === regexClass;
  }

  var descriptor = gOPD(value, 'lastIndex');
  var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
  if (hasLastIndexDataProperty !== true) {
    return false;
  }

  return tryRegexExecCall(value, descriptor);
};

},{"has-own-property-x":122,"has-to-string-tag-x":127,"is-object-like-x":176,"object-define-property-x":183,"object-get-own-property-descriptor-x":416,"to-string-tag-x":450}],182:[function(require,module,exports){
/**
 * @file If IsObject(value) is false, throw a TypeError exception.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-object-x
 */

'use strict';

var safeToString = require('to-string-symbols-supported-x');
var isPrimitive = require('is-primitive');

/**
   * Tests `value` to see if it is an object, throws a `TypeError` if it is
   * not. Otherwise returns the `value`.
   *
   * @param {*} value - The argument to be tested.
   * @throws {TypeError} Throws if `value` is not an object.
   * @returns {*} Returns `value` if it is an object.
   * @example
   * var assertIsObject = require('assert-is-object-x');
   * var primitive = true;
   * var mySymbol = Symbol('mySymbol');
   * var symObj = Object(mySymbol);
   * var object = {};
   * function fn () {}
   *
   * assertIsObject(primitive); // TypeError 'true is not an object'
   * assertIsObject(mySymbol); // TypeError 'Symbol(mySymbol) is not an object'
   * assertIsObject(symObj); // Returns symObj.
   * assertIsObject(object); // Returns object.
   * assertIsObject(fn); // Returns fn.
   */
module.exports = function assertIsObject(value) {
  if (isPrimitive(value)) {
    throw new TypeError(safeToString(value) + ' is not an object');
  }

  return value;
};

},{"is-primitive":178,"to-string-symbols-supported-x":449}],183:[function(require,module,exports){
/**
 * @file Sham for Object.defineProperty
 * @version 4.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-define-property-x
 */

'use strict';

var attempt = require('attempt-x');
var isFalsey = require('is-falsey-x');
var toObject = require('to-object-x');
var toPropertyKey = require('to-property-key-x');
var has = require('has-own-property-x');
var isFunction = require('is-function-x');
var isUndefined = require('validate.io-undefined');
var assertIsObject = require('assert-is-object-x');
var nativeDefProp = typeof Object.defineProperty === 'function' && Object.defineProperty;
var definePropertyFallback;

var toPropertyDescriptor = function _toPropertyDescriptor(desc) {
  var object = toObject(desc);
  var descriptor = {};
  if (has(object, 'enumerable')) {
    descriptor.enumerable = Boolean(object.enumerable);
  }

  if (has(object, 'configurable')) {
    descriptor.configurable = Boolean(object.configurable);
  }

  if (has(object, 'value')) {
    descriptor.value = object.value;
  }

  if (has(object, 'writable')) {
    descriptor.writable = Boolean(object.writable);
  }

  if (has(object, 'get')) {
    var getter = object.get;
    if (isUndefined(getter) === false && isFunction(getter) === false) {
      throw new TypeError('getter must be a function');
    }

    descriptor.get = getter;
  }

  if (has(object, 'set')) {
    var setter = object.set;
    if (isUndefined(setter) === false && isFunction(setter) === false) {
      throw new TypeError('setter must be a function');
    }

    descriptor.set = setter;
  }

  if ((has(descriptor, 'get') || has(descriptor, 'set')) && (has(descriptor, 'value') || has(descriptor, 'writable'))) {
    throw new TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
  }

  return descriptor;
};

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var $defineProperty;
// check whether defineProperty works if it's given. Otherwise, shim partially.
if (nativeDefProp) {
  var testWorksWith = function _testWorksWith(object) {
    var testResult = attempt(nativeDefProp, object, 'sentinel', {});
    return testResult.threw === false && testResult.value === object && 'sentinel' in object;
  };

  var doc = typeof document !== 'undefined' && document;
  if (testWorksWith({}) && (isFalsey(doc) || testWorksWith(doc.createElement('div')))) {
    $defineProperty = function defineProperty(object, property, descriptor) {
      return nativeDefProp(assertIsObject(object), toPropertyKey(property), toPropertyDescriptor(descriptor));
    };
  } else {
    definePropertyFallback = nativeDefProp;
  }
}

if (isFalsey(nativeDefProp) || definePropertyFallback) {
  var prototypeOfObject = Object.prototype;

  // If JS engine supports accessors creating shortcuts.
  var defineGetter;
  var defineSetter;
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors = has(prototypeOfObject, '__defineGetter__');
  if (supportsAccessors) {
    /* eslint-disable no-underscore-dangle, no-restricted-properties */
    defineGetter = prototypeOfObject.__defineGetter__;
    defineSetter = prototypeOfObject.__defineSetter__;
    lookupGetter = prototypeOfObject.__lookupGetter__;
    lookupSetter = prototypeOfObject.__lookupSetter__;
    /* eslint-enable no-underscore-dangle, no-restricted-properties */
  }

  $defineProperty = function defineProperty(object, property, descriptor) {
    assertIsObject(object);
    var propKey = toPropertyKey(property);
    var propDesc = toPropertyDescriptor(descriptor);

    // make a valiant attempt to use the real defineProperty for IE8's DOM elements.
    if (definePropertyFallback) {
      var result = attempt.call(Object, definePropertyFallback, object, propKey, propDesc);
      if (result.threw === false) {
        return result.value;
      }
      // try the shim if the real one doesn't work
    }

    // If it's a data property.
    if (has(propDesc, 'value')) {
      // fail silently if 'writable', 'enumerable', or 'configurable' are requested but not supported
      if (supportsAccessors && (lookupGetter.call(object, propKey) || lookupSetter.call(object, propKey))) {
        // As accessors are supported only on engines implementing
        // `__proto__` we can safely override `__proto__` while defining
        // a property to make sure that we don't hit an inherited accessor.
        /* eslint-disable no-proto */
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;
        // Deleting a property anyway since getter / setter may be defined on object itself.
        delete object[propKey];
        object[propKey] = propDesc.value;
        // Setting original `__proto__` back now.
        object.__proto__ = prototype;
        /* eslint-enable no-proto */
      } else {
        object[propKey] = propDesc.value;
      }
    } else {
      if (supportsAccessors === false && (propDesc.get || propDesc.set)) {
        throw new TypeError('getters & setters can not be defined on this javascript engine');
      }

      // If we got that far then getters and setters can be defined !!
      if (propDesc.get) {
        defineGetter.call(object, propKey, propDesc.get);
      }

      if (propDesc.set) {
        defineSetter.call(object, propKey, propDesc.set);
      }
    }

    return object;
  };
}

/**
 * This method defines a new property directly on an object, or modifies an
 * existing property on an object, and returns the object.
 *
 * @param {Object} object - The object on which to define the property.
 * @param {string} property - The name of the property to be defined or modified.
 * @param {Object} descriptor - The descriptor for the property being defined or modified.
 * @returns {Object} The object that was passed to the function.
 * @example
 * var defineProperty = require('object-define-property-x');
 *
 * var o = {}; // Creates a new object
 *
 * defineProperty(o, 'a', {
 *   value: 37,
 *   writable: true
 * });
 */
module.exports = $defineProperty;

},{"assert-is-object-x":182,"attempt-x":32,"has-own-property-x":122,"is-falsey-x":160,"is-function-x":162,"to-object-x":446,"to-property-key-x":448,"validate.io-undefined":459}],184:[function(require,module,exports){
/**
 * @file Determine whether the passed value is a safe integer.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-safe-integer-x
 */

'use strict';

var isInteger = require('is-integer-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');
var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;

/**
 * This method determines whether the passed value is a safe integer.
 *
 * Can be exactly represented as an IEEE-754 double precision number, and
 * whose IEEE-754 representation cannot be the result of rounding any other
 * integer to fit the IEEE-754 representation.
 *
 * @param {*} value - The value to be tested for being a safe integer.
 * @returns {boolean} A Boolean indicating whether or not the given value is a
 *  safe integer.
 * @example
 * var isSafeInteger = require('is-safe-integer-x');
 *
 * isSafeInteger(0);                    // true
 * isSafeInteger(1);                    // true
 * isSafeInteger(-100000);              // true
 *
 * isSafeInteger(Math.pow(2, 53));      // false
 * isSafeInteger(0.1);                  // false
 * isSafeInteger(Math.PI);              // false
 *
 * isSafeInteger(NaN);                  // false
 * isSafeInteger(Infinity);             // false
 * isSafeInteger(-Infinity);            // false
 * isSafeInteger('10');                 // false
 * isSafeInteger(true);                 // false
 * isSafeInteger(false);                // false
 * isSafeInteger([1]);                  // false
 */
module.exports = function isSafeInteger(value) {
  return isInteger(value) && value >= MIN_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
};

},{"is-integer-x":165,"max-safe-integer":397}],185:[function(require,module,exports){
/**
 * @file Detect whether or not an object is an ES6 SET.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-set-x
 */

'use strict';

var isFalsey = require('is-falsey-x');
var attempt;
var isObjectLike;
var isLength;
var getSize;

if (typeof Set === 'function') {
  var descriptor = require('object-get-own-property-descriptor-x')(Set.prototype, 'size');
  if (descriptor && typeof descriptor.get === 'function') {
    attempt = require('attempt-x');
    isObjectLike = require('is-object-like-x');
    var res = attempt(function () {
      return new Set();
    });

    if (res.threw === false && isObjectLike(res.value)) {
      isLength = require('is-length-x');
      res = attempt.call(res.value, descriptor.get);
      if (res.threw === false && isLength(res.value)) {
        getSize = descriptor.get;
      }
    }

  }
}

/**
 * Determine if an `object` is a `Set`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is a `Set`,
 *  else `false`.
 * @example
 * var isSet = require('is-set-x');
 * var s = new Set();
 *
 * isSet([]); // false
 * isSet(true); // false
 * isSet(s); // true
 */
module.exports = function isSet(object) {
  if (isFalsey(getSize) || isObjectLike(object) === false) {
    return false;
  }

  var result = attempt.call(object, getSize);
  return result.threw === false && isLength(result.value);
};

},{"attempt-x":32,"is-falsey-x":160,"is-length-x":166,"is-object-like-x":176,"object-get-own-property-descriptor-x":416}],186:[function(require,module,exports){
'use strict';

var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isString(value) {
	if (typeof value === 'string') { return true; }
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};

},{}],187:[function(require,module,exports){
/**
 * @file Tests if 2 characters together are a surrogate pair.
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-surrogate-pair-x
 */

'use strict';

var isString = require('is-string');

/**
 * Tests if the two character arguments combined are a valid UTF-16
 * surrogate pair.
 *
 * @param {*} char1 - The first character of a suspected surrogate pair.
 * @param {*} char2 - The second character of a suspected surrogate pair.
 * @returns {boolean} Returns true if the two characters create a valid
 *  'UTF-16' surrogate pair; otherwise false.
 * @example
 * var isSurrogatePair = require('is-surrogate-pair-x');
 *
 * var test1 = 'a';
 * var test2 = '';
 *
 * isSurrogatePair(test1.charAt(0), test1.charAt(1)); // false
 * isSurrogatePair(test2.charAt(0), test2.charAt(1)); // true
 */
module.exports = function isSurrogatePair(char1, char2) {
  if (isString(char1) && char1.length === 1 && isString(char2) && char2.length === 1) {
    var code1 = char1.charCodeAt();
    if (code1 >= 0xD800 && code1 <= 0xDBFF) {
      var code2 = char2.charCodeAt();
      if (code2 >= 0xDC00 && code2 <= 0xDFFF) {
        return true;
      }
    }
  }

  return false;
};

},{"is-string":186}],188:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = require('has-symbols')();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false && value;
	};
}

},{"has-symbols":125}],189:[function(require,module,exports){
(function (global){
'use strict';

var forEach = require('foreach');

var toStr = Object.prototype.toString;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var typedArrays = {
	Float32Array: true,
	Float64Array: true,
	Int8Array: true,
	Int16Array: true,
	Int32Array: true,
	Uint8Array: true,
	Uint8ClampedArray: true,
	Uint16Array: true,
	Uint32Array: true
};

var slice = String.prototype.slice;
var toStrTags = {};
var gOPD = Object.getOwnPropertyDescriptor;
if (hasToStringTag && gOPD && Object.getPrototypeOf) {
	forEach(typedArrays, function (_, typedArray) {
		var arr = new global[typedArray]();
		if (!(Symbol.toStringTag in arr)) {
			throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
		}
		var proto = Object.getPrototypeOf(arr);
		var descriptor = gOPD(proto, Symbol.toStringTag);
		if (!descriptor) {
			var superProto = Object.getPrototypeOf(proto);
			descriptor = gOPD(superProto, Symbol.toStringTag);
		}
		toStrTags[typedArray] = descriptor.get;
	});
}

var tryTypedArrays = function tryTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) { return !!typedArrays[slice.call(toStr.call(value), 8, -1)]; }
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"foreach":110}],190:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],191:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

module.exports = isNull;

},{}],192:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":284,"./_root":332}],193:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":292,"./_hashDelete":293,"./_hashGet":294,"./_hashHas":295,"./_hashSet":296}],194:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":308,"./_listCacheDelete":309,"./_listCacheGet":310,"./_listCacheHas":311,"./_listCacheSet":312}],195:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":284,"./_root":332}],196:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":313,"./_mapCacheDelete":314,"./_mapCacheGet":315,"./_mapCacheHas":316,"./_mapCacheSet":317}],197:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":284,"./_root":332}],198:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":284,"./_root":332}],199:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":196,"./_setCacheAdd":333,"./_setCacheHas":334}],200:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":194,"./_stackClear":338,"./_stackDelete":339,"./_stackGet":340,"./_stackHas":341,"./_stackSet":342}],201:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":332}],202:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":332}],203:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":284,"./_root":332}],204:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],205:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],206:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],207:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":250,"./_isIndex":301,"./isArguments":359,"./isArray":360,"./isBuffer":362,"./isTypedArray":376}],208:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],209:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],210:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],211:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":215,"./eq":352}],212:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":352}],213:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":264,"./keys":378}],214:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":264,"./keysIn":379}],215:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":272}],216:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });

    return result;
  }

  if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });

    return result;
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":200,"./_arrayEach":205,"./_assignValue":211,"./_baseAssign":213,"./_baseAssignIn":214,"./_cloneBuffer":258,"./_copyArray":263,"./_copySymbols":265,"./_copySymbolsIn":266,"./_getAllKeys":280,"./_getAllKeysIn":281,"./_getTag":289,"./_initCloneArray":297,"./_initCloneByTag":298,"./_initCloneObject":299,"./isArray":360,"./isBuffer":362,"./isMap":367,"./isObject":370,"./isSet":373,"./keys":378}],217:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":370}],218:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],219:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":209,"./_isFlattenable":300}],220:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":269}],221:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":220,"./keys":378}],222:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":256,"./_toKey":345}],223:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":209,"./isArray":360}],224:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":201,"./_getRawTag":286,"./_objectToString":325}],225:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],226:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":218,"./_baseIsNaN":232,"./_strictIndexOf":343}],227:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":224,"./isObjectLike":371}],228:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":229,"./isObjectLike":371}],229:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":200,"./_equalArrays":273,"./_equalByTag":274,"./_equalObjects":275,"./_getTag":289,"./isArray":360,"./isBuffer":362,"./isTypedArray":376}],230:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":289,"./isObjectLike":371}],231:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":200,"./_baseIsEqual":228}],232:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],233:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":305,"./_toSource":346,"./isFunction":365,"./isObject":370}],234:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":289,"./isObjectLike":371}],235:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":224,"./isLength":366,"./isObjectLike":371}],236:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":239,"./_baseMatchesProperty":240,"./identity":357,"./isArray":360,"./property":385}],237:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":306,"./_nativeKeys":322}],238:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":306,"./_nativeKeysIn":323,"./isObject":370}],239:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":231,"./_getMatchData":283,"./_matchesStrictComparable":319}],240:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":228,"./_isKey":303,"./_isStrictComparable":307,"./_matchesStrictComparable":319,"./_toKey":345,"./get":355,"./hasIn":356}],241:[function(require,module,exports){
var basePickBy = require('./_basePickBy'),
    hasIn = require('./hasIn');

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

},{"./_basePickBy":242,"./hasIn":356}],242:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSet = require('./_baseSet'),
    castPath = require('./_castPath');

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;

},{"./_baseGet":222,"./_baseSet":247,"./_castPath":256}],243:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],244:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":222}],245:[function(require,module,exports){
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;

},{}],246:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":327,"./_setToString":336,"./identity":357}],247:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    castPath = require('./_castPath'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;

},{"./_assignValue":211,"./_castPath":256,"./_isIndex":301,"./_toKey":345,"./isObject":370}],248:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":272,"./constant":351,"./identity":357}],249:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],250:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],251:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":201,"./_arrayMap":208,"./isArray":360,"./isSymbol":375}],252:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],253:[function(require,module,exports){
var castPath = require('./_castPath'),
    last = require('./last'),
    parent = require('./_parent'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

},{"./_castPath":256,"./_parent":328,"./_toKey":345,"./last":380}],254:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":208}],255:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],256:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":303,"./_stringToPath":344,"./isArray":360,"./toString":393}],257:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":202}],258:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":332}],259:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":257}],260:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],261:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":201}],262:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":257}],263:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],264:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":211,"./_baseAssignValue":215}],265:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":264,"./_getSymbols":287}],266:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":264,"./_getSymbolsIn":288}],267:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":332}],268:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":246,"./_isIterateeCall":302}],269:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],270:[function(require,module,exports){
var eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;

},{"./eq":352}],271:[function(require,module,exports){
var isPlainObject = require('./isPlainObject');

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;

},{"./isPlainObject":372}],272:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":284}],273:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":199,"./_arraySome":210,"./_cacheHas":255}],274:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":201,"./_Uint8Array":202,"./_equalArrays":273,"./_mapToArray":318,"./_setToArray":335,"./eq":352}],275:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":280}],276:[function(require,module,exports){
var basePropertyOf = require('./_basePropertyOf');

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

module.exports = escapeHtmlChar;

},{"./_basePropertyOf":245}],277:[function(require,module,exports){
/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

module.exports = escapeStringChar;

},{}],278:[function(require,module,exports){
var flatten = require('./flatten'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

},{"./_overRest":327,"./_setToString":336,"./flatten":354}],279:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],280:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":223,"./_getSymbols":287,"./keys":378}],281:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":223,"./_getSymbolsIn":288,"./keysIn":379}],282:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":304}],283:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":307,"./keys":378}],284:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":233,"./_getValue":290}],285:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":326}],286:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":201}],287:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":206,"./stubArray":386}],288:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":209,"./_getPrototype":285,"./_getSymbols":287,"./stubArray":386}],289:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":192,"./_Map":195,"./_Promise":197,"./_Set":198,"./_WeakMap":203,"./_baseGetTag":224,"./_toSource":346}],290:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],291:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":256,"./_isIndex":301,"./_toKey":345,"./isArguments":359,"./isArray":360,"./isLength":366}],292:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":321}],293:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],294:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":321}],295:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":321}],296:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":321}],297:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],298:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":257,"./_cloneDataView":259,"./_cloneRegExp":260,"./_cloneSymbol":261,"./_cloneTypedArray":262}],299:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":217,"./_getPrototype":285,"./_isPrototype":306}],300:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":201,"./isArguments":359,"./isArray":360}],301:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],302:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":301,"./eq":352,"./isArrayLike":361,"./isObject":370}],303:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":360,"./isSymbol":375}],304:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],305:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":267}],306:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],307:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":370}],308:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],309:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":212}],310:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":212}],311:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":212}],312:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":212}],313:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":193,"./_ListCache":194,"./_Map":195}],314:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":282}],315:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":282}],316:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":282}],317:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":282}],318:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],319:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],320:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":382}],321:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":284}],322:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":326}],323:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],324:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":279}],325:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],326:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],327:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":204}],328:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSlice = require('./_baseSlice');

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

},{"./_baseGet":222,"./_baseSlice":249}],329:[function(require,module,exports){
/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

module.exports = reEscape;

},{}],330:[function(require,module,exports){
/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

module.exports = reEvaluate;

},{}],331:[function(require,module,exports){
/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;

},{}],332:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":279}],333:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],334:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],335:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],336:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":248,"./_shortOut":337}],337:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],338:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":194}],339:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],340:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],341:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],342:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":194,"./_Map":195,"./_MapCache":196}],343:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],344:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":320}],345:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":375}],346:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],347:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    keysIn = require('./keysIn');

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;

},{"./_copyObject":264,"./_createAssigner":268,"./keysIn":379}],348:[function(require,module,exports){
var apply = require('./_apply'),
    baseRest = require('./_baseRest'),
    isError = require('./isError');

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = attempt;

},{"./_apply":204,"./_baseRest":246,"./isError":364}],349:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":216}],350:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":216}],351:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],352:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],353:[function(require,module,exports){
var escapeHtmlChar = require('./_escapeHtmlChar'),
    toString = require('./toString');

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;

},{"./_escapeHtmlChar":276,"./toString":393}],354:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten');

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

},{"./_baseFlatten":219}],355:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":222}],356:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":225,"./_hasPath":291}],357:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],358:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;

},{"./_baseIndexOf":226,"./isArrayLike":361,"./isString":374,"./toInteger":391,"./values":394}],359:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":227,"./isObjectLike":371}],360:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],361:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":365,"./isLength":366}],362:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":332,"./stubFalse":387}],363:[function(require,module,exports){
var baseKeys = require('./_baseKeys'),
    getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isPrototype = require('./_isPrototype'),
    isTypedArray = require('./isTypedArray');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

},{"./_baseKeys":237,"./_getTag":289,"./_isPrototype":306,"./isArguments":359,"./isArray":360,"./isArrayLike":361,"./isBuffer":362,"./isTypedArray":376}],364:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike'),
    isPlainObject = require('./isPlainObject');

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

module.exports = isError;

},{"./_baseGetTag":224,"./isObjectLike":371,"./isPlainObject":372}],365:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":224,"./isObject":370}],366:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],367:[function(require,module,exports){
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

},{"./_baseIsMap":230,"./_baseUnary":252,"./_nodeUtil":324}],368:[function(require,module,exports){
/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

module.exports = isNull;

},{}],369:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

},{"./_baseGetTag":224,"./isObjectLike":371}],370:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],371:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],372:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":224,"./_getPrototype":285,"./isObjectLike":371}],373:[function(require,module,exports){
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

},{"./_baseIsSet":234,"./_baseUnary":252,"./_nodeUtil":324}],374:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":224,"./isArray":360,"./isObjectLike":371}],375:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":224,"./isObjectLike":371}],376:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":235,"./_baseUnary":252,"./_nodeUtil":324}],377:[function(require,module,exports){
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

},{}],378:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":207,"./_baseKeys":237,"./isArrayLike":361}],379:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":207,"./_baseKeysIn":238,"./isArrayLike":361}],380:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],381:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    baseForOwn = require('./_baseForOwn'),
    baseIteratee = require('./_baseIteratee');

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;

},{"./_baseAssignValue":215,"./_baseForOwn":221,"./_baseIteratee":236}],382:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":196}],383:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseClone = require('./_baseClone'),
    baseUnset = require('./_baseUnset'),
    castPath = require('./_castPath'),
    copyObject = require('./_copyObject'),
    customOmitClone = require('./_customOmitClone'),
    flatRest = require('./_flatRest'),
    getAllKeysIn = require('./_getAllKeysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;

},{"./_arrayMap":208,"./_baseClone":216,"./_baseUnset":253,"./_castPath":256,"./_copyObject":264,"./_customOmitClone":271,"./_flatRest":278,"./_getAllKeysIn":281}],384:[function(require,module,exports){
var basePick = require('./_basePick'),
    flatRest = require('./_flatRest');

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;

},{"./_basePick":241,"./_flatRest":278}],385:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":243,"./_basePropertyDeep":244,"./_isKey":303,"./_toKey":345}],386:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],387:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],388:[function(require,module,exports){
var assignInWith = require('./assignInWith'),
    attempt = require('./attempt'),
    baseValues = require('./_baseValues'),
    customDefaultsAssignIn = require('./_customDefaultsAssignIn'),
    escapeStringChar = require('./_escapeStringChar'),
    isError = require('./isError'),
    isIterateeCall = require('./_isIterateeCall'),
    keys = require('./keys'),
    reInterpolate = require('./_reInterpolate'),
    templateSettings = require('./templateSettings'),
    toString = require('./toString');

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

module.exports = template;

},{"./_baseValues":254,"./_customDefaultsAssignIn":270,"./_escapeStringChar":277,"./_isIterateeCall":302,"./_reInterpolate":331,"./assignInWith":347,"./attempt":348,"./isError":364,"./keys":378,"./templateSettings":389,"./toString":393}],389:[function(require,module,exports){
var escape = require('./escape'),
    reEscape = require('./_reEscape'),
    reEvaluate = require('./_reEvaluate'),
    reInterpolate = require('./_reInterpolate');

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

module.exports = templateSettings;

},{"./_reEscape":329,"./_reEvaluate":330,"./_reInterpolate":331,"./escape":353}],390:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":392}],391:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":390}],392:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":370,"./isSymbol":375}],393:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":251}],394:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":254,"./keys":378}],395:[function(require,module,exports){
/**
 * @file Clamp a number to limits.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-clamp-x
 */

'use strict';

var toNumber = require('to-number-x').toNumber2018;

/**
 * This method clamp a number to min and max limits inclusive.
 *
 * @param {number} value - The number to be clamped.
 * @param {number} [min=0] - The minimum number.
 * @param {number} max - The maximum number.
 * @throws {RangeError} If min > max.
 * @return {number} The clamped number.
 * @example
 * var mathClamp = require('math-clamp-x');
 */
module.exports = function clamp(value) {
  var number = toNumber(value);
  var argsLength = arguments.length;
  if (argsLength < 2) {
    return number;
  }

  var min = toNumber(arguments[1]);
  var max;
  if (argsLength < 3) {
    max = min;
    min = 0;
  } else {
    max = toNumber(arguments[2]);
  }

  if (min > max) {
    throw new RangeError('"min" must be less than "max"');
  }

  if (number < min) {
    return min;
  }

  if (number > max) {
    return max;
  }

  return number;
};

},{"to-number-x":442}],396:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"dup":132,"is-nan-x":168,"to-number-x":442}],397:[function(require,module,exports){
'use strict';
module.exports = 9007199254740991;

},{}],398:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "A-IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.2]"
  },
  {
    "Header Field Name": "Accept-Additions",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Charset",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.3]"
  },
  {
    "Header Field Name": "Accept-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Accept-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.4][RFC7694, Section 3]"
  },
  {
    "Header Field Name": "Accept-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.5]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Accept-Patch",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC5789]"
  },
  {
    "Header Field Name": "Accept-Post",
    "Template": "perm/accept-post",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://www.w3.org/TR/ldp/]"
  },
  {
    "Header Field Name": "Accept-Ranges",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 2.3]"
  },
  {
    "Header Field Name": "Age",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.1]"
  },
  {
    "Header Field Name": "Allow",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.1]"
  },
  {
    "Header Field Name": "ALPN",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7639, Section 2]"
  },
  {
    "Header Field Name": "Also-Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Alt-Svc",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alt-Used",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alternate-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Alternates",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Apply-To-Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "Approved",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archive",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Article-Names",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Article-Updates",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Authentication-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 4]"
  },
  {
    "Header Field Name": "Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 3]"
  },
  {
    "Header Field Name": "Authentication-Results",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7601]"
  },
  {
    "Header Field Name": "Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.2]"
  },
  {
    "Header Field Name": "Auto-Submitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3834 section 5]"
  },
  {
    "Header Field Name": "Autoforwarded",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Autosubmitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC1808][RFC2068 Section 14.11]"
  },
  {
    "Header Field Name": "Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Body",
    "Template": "",
    "Protocol": "none",
    "Status": "reserved",
    "Reference": "[RFC6068]"
  },
  {
    "Header Field Name": "C-Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cache-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.2]"
  },
  {
    "Header Field Name": "CalDAV-Timezones",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7809, Section 7.1]"
  },
  {
    "Header Field Name": "Cancel-Key",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cancel-Lock",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Close",
    "Template": "",
    "Protocol": "http",
    "Status": "reserved",
    "Reference": "[RFC7230, Section 8.1]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Connection",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.1]"
  },
  {
    "Header Field Name": "Content-Alternative",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2068][RFC2616]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC2110][RFC2557]"
  },
  {
    "Header Field Name": "Content-Description",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6266]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Duration",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.2.2]"
  },
  {
    "Header Field Name": "Content-features",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.3.2]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Length",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.4.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 4.2]"
  },
  {
    "Header Field Name": "Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Script-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Style-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Translation-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "standard",
    "Reference": "[RFC8255]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.1.5]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Conversion",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Conversion-With-Loss",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "DASL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5323]"
  },
  {
    "Header Field Name": "DAV",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "DL-Expansion-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.1.2]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Date-Received",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Default-Style",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Deferred-Delivery",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delivery-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delta-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Depth",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Derived-From",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Destination",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Differential-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Discarded-X400-IPMS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Discarded-X400-MTS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disclose-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-Options",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Distribution",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "DKIM-Signature",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6376]"
  },
  {
    "Header Field Name": "Downgraded-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Final-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Mail-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Message-Id",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Original-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Rcpt-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Early-Data",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8470]"
  },
  {
    "Header Field Name": "Encoding",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Encrypted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ETag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.3]"
  },
  {
    "Header Field Name": "Expect",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.1]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.3]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Expiry-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Followup-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Forwarded",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7239]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.1]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Generate-Delivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "GetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Hobareg",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC7486, Section 6.1.1]"
  },
  {
    "Header Field Name": "Host",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.4]"
  },
  {
    "Header Field Name": "HTTP2-Settings",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7540, Section 3.2.1]"
  },
  {
    "Header Field Name": "IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "If",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "If-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.1]"
  },
  {
    "Header Field Name": "If-Modified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.3]"
  },
  {
    "Header Field Name": "If-None-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.2]"
  },
  {
    "Header Field Name": "If-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.2]"
  },
  {
    "Header Field Name": "If-Schedule-Tag-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "If-Unmodified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.4]"
  },
  {
    "Header Field Name": "Importance",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Include-Referred-Token-Binding-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Incomplete-Copy",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Injection-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Injection-Info",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Keep-Alive",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Last-Modified",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.2]"
  },
  {
    "Header Field Name": "Latest-Delivery-Time",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Lines",
    "Template": "",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5536][RFC3977]"
  },
  {
    "Header Field Name": "Link",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8288]"
  },
  {
    "Header Field Name": "List-Archive",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Help",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Owner",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Subscribe",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe",
    "Template": "perm/list-unsubscribe",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC8058]"
  },
  {
    "Header Field Name": "Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.2]"
  },
  {
    "Header Field Name": "Lock-Token",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Max-Forwards",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.2]"
  },
  {
    "Header Field Name": "Memento-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Message-Context",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Meter",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Appendix A.1]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "MMHS-Exempted-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.1 and Appendix B.105]"
  },
  {
    "Header Field Name": "MMHS-Extended-Authorisation-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.2 and Appendix B.106]"
  },
  {
    "Header Field Name": "MMHS-Subject-Indicator-Codes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.3 and Appendix B.107]"
  },
  {
    "Header Field Name": "MMHS-Handling-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.4 and Appendix B.108]"
  },
  {
    "Header Field Name": "MMHS-Message-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.5 and Appendix B.109]"
  },
  {
    "Header Field Name": "MMHS-Codress-Message-Indicator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.6 and Appendix B.110]"
  },
  {
    "Header Field Name": "MMHS-Originator-Reference",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.7 and Appendix B.111]"
  },
  {
    "Header Field Name": "MMHS-Primary-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.8 and Appendix B.101]"
  },
  {
    "Header Field Name": "MMHS-Copy-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.9 and Appendix B.102]"
  },
  {
    "Header Field Name": "MMHS-Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.10 and Appendix B.103]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-CC",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Acp127-Message-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.14 and Appendix B.116]"
  },
  {
    "Header Field Name": "MMHS-Originator-PLAD",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.15 and Appendix B.117]"
  },
  {
    "Header Field Name": "MT-Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6758]"
  },
  {
    "Header Field Name": "Negotiate",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Newsgroups",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Host",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC2980][RFC5536]"
  },
  {
    "Header Field Name": "Obsoletes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional-WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 3]"
  },
  {
    "Header Field Name": "Ordering-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "mail",
    "Status": "informational",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Origin",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6454]"
  },
  {
    "Header Field Name": "Original-Encoded-Information-Types",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Original-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Recipient",
    "Template": "perm/original-recipient",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3798][RFC5337]"
  },
  {
    "Header Field Name": "Original-Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5537]"
  },
  {
    "Header Field Name": "Originator-Return-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Overwrite",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "P3P",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Path",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Pep-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Position",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Posting-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Pragma",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.4]"
  },
  {
    "Header Field Name": "Prefer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Preference-Applied",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Prevent-NonDelivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ProfileObject",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Query",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Request",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.3]"
  },
  {
    "Header Field Name": "Proxy-Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 4]"
  },
  {
    "Header Field Name": "Proxy-Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.4]"
  },
  {
    "Header Field Name": "Proxy-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Instruction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public-Key-Pins",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Public-Key-Pins-Report-Only",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.1]"
  },
  {
    "Header Field Name": "Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC5321]"
  },
  {
    "Header Field Name": "Received-SPF",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7208]"
  },
  {
    "Header Field Name": "Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Referer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.2]"
  },
  {
    "Header Field Name": "Relay-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Reply-By",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Require-Recipient-Valid-Since",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7293]"
  },
  {
    "Header Field Name": "Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Retry-After",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.3]"
  },
  {
    "Header Field Name": "Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Safe",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Schedule-Reply",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Schedule-Tag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Sec-Token-Binding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Extensions",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Key",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Security-Scheme",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "See-Also",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Sensitivity",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Server",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.2]"
  },
  {
    "Header Field Name": "Set-Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Set-Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "SetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SLUG",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5023]"
  },
  {
    "Header Field Name": "SoapAction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Solicitation",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC3865]"
  },
  {
    "Header Field Name": "Status-URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Strict-Transport-Security",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6797]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Summary",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2156]"
  },
  {
    "Header Field Name": "Surrogate-Capability",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Surrogate-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TCN",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TE",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.3]"
  },
  {
    "Header Field Name": "Timeout",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "TLS-Report-Domain",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "TLS-Report-Submitter",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Topic",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.4]"
  },
  {
    "Header Field Name": "Trailer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.4]"
  },
  {
    "Header Field Name": "Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.1]"
  },
  {
    "Header Field Name": "TTL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.2]"
  },
  {
    "Header Field Name": "Urgency",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.3]"
  },
  {
    "Header Field Name": "URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Upgrade",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.7]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.3]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2616]"
  },
  {
    "Header Field Name": "Variant-Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.4]"
  },
  {
    "Header Field Name": "VBR-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5518]"
  },
  {
    "Header Field Name": "Via",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.7.1]"
  },
  {
    "Header Field Name": "WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.1]"
  },
  {
    "Header Field Name": "Want-Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Warning",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.5]"
  },
  {
    "Header Field Name": "X400-Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-MTS-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Originator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Trace",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X-Content-Type-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://fetch.spec.whatwg.org/#x-content-type-options-header]"
  },
  {
    "Header Field Name": "X-Frame-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7034]"
  },
  {
    "Header Field Name": "Xref",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Access-Control",
    "Template": "prov/access-control",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Credentials",
    "Template": "prov/access-control-allow-credentials",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Headers",
    "Template": "prov/access-control-allow-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Methods",
    "Template": "prov/access-control-allow-methods",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Origin",
    "Template": "prov/access-control-allow-origin",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Max-Age",
    "Template": "prov/access-control-max-age",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Method",
    "Template": "prov/access-control-request-method",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Headers",
    "Template": "prov/access-control-request-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "AMP-Cache-Transform",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[https://github.com/ampproject/amphtml/blob/master/spec/amp-cache-transform.md]"
  },
  {
    "Header Field Name": "Apparently-To",
    "Template": "prov/apparently-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "ARC-Authentication-Results",
    "Template": "prov/arc-authentication-results",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Message-Signature",
    "Template": "prov/arc-message-signature",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Seal",
    "Template": "prov/arc-seal",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cost",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "Eesst-Version",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Errors-To",
    "Template": "prov/errors-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "Form-Sub",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-levine-mailbomb-header]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Method-Check",
    "Template": "prov/method-check",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check-Expires",
    "Template": "prov/method-check-expires",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "MMHS-Authorizing-Users",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7912]"
  },
  {
    "Header Field Name": "Non-Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Privicon",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-koenig-privicons]"
  },
  {
    "Header Field Name": "Referer-Root",
    "Template": "prov/referer-root",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Resolution-Hint",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Resolver-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SIO-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SIO-Label-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SubOK",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Subst",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Title",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Color",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Media",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Pixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Resolution",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Windowpixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "mail",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Device-Accept",
    "Template": "prov/x-device-accept",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Charset",
    "Template": "prov/x-device-accept-charset",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Encoding",
    "Template": "prov/x-device-accept-encoding",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Language",
    "Template": "prov/x-device-accept-language",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-User-Agent",
    "Template": "prov/x-device-user-agent",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Mittente",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-PGP-Sig",
    "Template": "prov/x-pgp-sig",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[ftp://ftp.isc.org/pub/pgpcontrol/FORMAT][https://ftp.isc.org/pub/pgpcontrol/FORMAT]"
  },
  {
    "Header Field Name": "X-Ricevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Riferimento-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-TipoRicevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Trasporto",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-VerificaSicurezza",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  }
]
},{}],399:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "Lines",
    "Template": "",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5536][RFC3977]"
  },
  {
    "Header Field Name": "Access-Control",
    "Template": "prov/access-control",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check",
    "Template": "prov/method-check",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check-Expires",
    "Template": "prov/method-check-expires",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Referer-Root",
    "Template": "prov/referer-root",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "mail",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  }
]
},{}],400:[function(require,module,exports){
module.exports = {
  all: require('./all.json'),
  permanent: require('./permanent.json'),
  provisional: require('./provisional.json'),
  standard: require('./standard.json'),
  deprecated: require('./deprecated.json')
};

},{"./all.json":398,"./deprecated.json":399,"./permanent.json":401,"./provisional.json":402,"./standard.json":403}],401:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "A-IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.2]"
  },
  {
    "Header Field Name": "Accept-Additions",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Charset",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.3]"
  },
  {
    "Header Field Name": "Accept-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Accept-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.4][RFC7694, Section 3]"
  },
  {
    "Header Field Name": "Accept-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.5]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Accept-Patch",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC5789]"
  },
  {
    "Header Field Name": "Accept-Post",
    "Template": "perm/accept-post",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://www.w3.org/TR/ldp/]"
  },
  {
    "Header Field Name": "Accept-Ranges",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 2.3]"
  },
  {
    "Header Field Name": "Age",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.1]"
  },
  {
    "Header Field Name": "Allow",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.1]"
  },
  {
    "Header Field Name": "ALPN",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7639, Section 2]"
  },
  {
    "Header Field Name": "Also-Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Alt-Svc",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alt-Used",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alternate-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Alternates",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Apply-To-Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "Approved",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archive",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Article-Names",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Article-Updates",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Authentication-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 4]"
  },
  {
    "Header Field Name": "Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 3]"
  },
  {
    "Header Field Name": "Authentication-Results",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7601]"
  },
  {
    "Header Field Name": "Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.2]"
  },
  {
    "Header Field Name": "Auto-Submitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3834 section 5]"
  },
  {
    "Header Field Name": "Autoforwarded",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Autosubmitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC1808][RFC2068 Section 14.11]"
  },
  {
    "Header Field Name": "Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Body",
    "Template": "",
    "Protocol": "none",
    "Status": "reserved",
    "Reference": "[RFC6068]"
  },
  {
    "Header Field Name": "C-Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cache-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.2]"
  },
  {
    "Header Field Name": "CalDAV-Timezones",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7809, Section 7.1]"
  },
  {
    "Header Field Name": "Cancel-Key",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cancel-Lock",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Close",
    "Template": "",
    "Protocol": "http",
    "Status": "reserved",
    "Reference": "[RFC7230, Section 8.1]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Connection",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.1]"
  },
  {
    "Header Field Name": "Content-Alternative",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2068][RFC2616]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC2110][RFC2557]"
  },
  {
    "Header Field Name": "Content-Description",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6266]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Duration",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.2.2]"
  },
  {
    "Header Field Name": "Content-features",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.3.2]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Length",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.4.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 4.2]"
  },
  {
    "Header Field Name": "Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Script-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Style-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Translation-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "standard",
    "Reference": "[RFC8255]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.1.5]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Conversion",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Conversion-With-Loss",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "DASL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5323]"
  },
  {
    "Header Field Name": "DAV",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "DL-Expansion-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.1.2]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Date-Received",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Default-Style",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Deferred-Delivery",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delivery-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delta-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Depth",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Derived-From",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Destination",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Differential-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Discarded-X400-IPMS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Discarded-X400-MTS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disclose-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-Options",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Distribution",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "DKIM-Signature",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6376]"
  },
  {
    "Header Field Name": "Downgraded-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Final-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Mail-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Message-Id",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Original-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Rcpt-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Early-Data",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8470]"
  },
  {
    "Header Field Name": "Encoding",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Encrypted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ETag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.3]"
  },
  {
    "Header Field Name": "Expect",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.1]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.3]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Expiry-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Followup-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Forwarded",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7239]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.1]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Generate-Delivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "GetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Hobareg",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC7486, Section 6.1.1]"
  },
  {
    "Header Field Name": "Host",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.4]"
  },
  {
    "Header Field Name": "HTTP2-Settings",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7540, Section 3.2.1]"
  },
  {
    "Header Field Name": "IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "If",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "If-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.1]"
  },
  {
    "Header Field Name": "If-Modified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.3]"
  },
  {
    "Header Field Name": "If-None-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.2]"
  },
  {
    "Header Field Name": "If-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.2]"
  },
  {
    "Header Field Name": "If-Schedule-Tag-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "If-Unmodified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.4]"
  },
  {
    "Header Field Name": "Importance",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Include-Referred-Token-Binding-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Incomplete-Copy",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Injection-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Injection-Info",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Keep-Alive",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Last-Modified",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.2]"
  },
  {
    "Header Field Name": "Latest-Delivery-Time",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Lines",
    "Template": "",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5536][RFC3977]"
  },
  {
    "Header Field Name": "Link",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8288]"
  },
  {
    "Header Field Name": "List-Archive",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Help",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Owner",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Subscribe",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe",
    "Template": "perm/list-unsubscribe",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC8058]"
  },
  {
    "Header Field Name": "Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.2]"
  },
  {
    "Header Field Name": "Lock-Token",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Max-Forwards",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.2]"
  },
  {
    "Header Field Name": "Memento-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Message-Context",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Meter",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Appendix A.1]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "MMHS-Exempted-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.1 and Appendix B.105]"
  },
  {
    "Header Field Name": "MMHS-Extended-Authorisation-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.2 and Appendix B.106]"
  },
  {
    "Header Field Name": "MMHS-Subject-Indicator-Codes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.3 and Appendix B.107]"
  },
  {
    "Header Field Name": "MMHS-Handling-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.4 and Appendix B.108]"
  },
  {
    "Header Field Name": "MMHS-Message-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.5 and Appendix B.109]"
  },
  {
    "Header Field Name": "MMHS-Codress-Message-Indicator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.6 and Appendix B.110]"
  },
  {
    "Header Field Name": "MMHS-Originator-Reference",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.7 and Appendix B.111]"
  },
  {
    "Header Field Name": "MMHS-Primary-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.8 and Appendix B.101]"
  },
  {
    "Header Field Name": "MMHS-Copy-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.9 and Appendix B.102]"
  },
  {
    "Header Field Name": "MMHS-Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.10 and Appendix B.103]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-CC",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Acp127-Message-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.14 and Appendix B.116]"
  },
  {
    "Header Field Name": "MMHS-Originator-PLAD",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.15 and Appendix B.117]"
  },
  {
    "Header Field Name": "MT-Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6758]"
  },
  {
    "Header Field Name": "Negotiate",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Newsgroups",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Host",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC2980][RFC5536]"
  },
  {
    "Header Field Name": "Obsoletes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional-WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 3]"
  },
  {
    "Header Field Name": "Ordering-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "mail",
    "Status": "informational",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Origin",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6454]"
  },
  {
    "Header Field Name": "Original-Encoded-Information-Types",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Original-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Recipient",
    "Template": "perm/original-recipient",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3798][RFC5337]"
  },
  {
    "Header Field Name": "Original-Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5537]"
  },
  {
    "Header Field Name": "Originator-Return-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Overwrite",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "P3P",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Path",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Pep-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Position",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Posting-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Pragma",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.4]"
  },
  {
    "Header Field Name": "Prefer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Preference-Applied",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Prevent-NonDelivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ProfileObject",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Query",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Request",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.3]"
  },
  {
    "Header Field Name": "Proxy-Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 4]"
  },
  {
    "Header Field Name": "Proxy-Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.4]"
  },
  {
    "Header Field Name": "Proxy-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Instruction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public-Key-Pins",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Public-Key-Pins-Report-Only",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.1]"
  },
  {
    "Header Field Name": "Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC5321]"
  },
  {
    "Header Field Name": "Received-SPF",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7208]"
  },
  {
    "Header Field Name": "Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Referer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.2]"
  },
  {
    "Header Field Name": "Relay-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Reply-By",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Require-Recipient-Valid-Since",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7293]"
  },
  {
    "Header Field Name": "Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Retry-After",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.3]"
  },
  {
    "Header Field Name": "Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Safe",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Schedule-Reply",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Schedule-Tag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Sec-Token-Binding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Extensions",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Key",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Security-Scheme",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "See-Also",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Sensitivity",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Server",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.2]"
  },
  {
    "Header Field Name": "Set-Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Set-Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "SetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SLUG",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5023]"
  },
  {
    "Header Field Name": "SoapAction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Solicitation",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC3865]"
  },
  {
    "Header Field Name": "Status-URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Strict-Transport-Security",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6797]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Summary",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2156]"
  },
  {
    "Header Field Name": "Surrogate-Capability",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Surrogate-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TCN",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TE",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.3]"
  },
  {
    "Header Field Name": "Timeout",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "TLS-Report-Domain",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "TLS-Report-Submitter",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Topic",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.4]"
  },
  {
    "Header Field Name": "Trailer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.4]"
  },
  {
    "Header Field Name": "Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.1]"
  },
  {
    "Header Field Name": "TTL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.2]"
  },
  {
    "Header Field Name": "Urgency",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.3]"
  },
  {
    "Header Field Name": "URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Upgrade",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.7]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.3]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2616]"
  },
  {
    "Header Field Name": "Variant-Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.4]"
  },
  {
    "Header Field Name": "VBR-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5518]"
  },
  {
    "Header Field Name": "Via",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.7.1]"
  },
  {
    "Header Field Name": "WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.1]"
  },
  {
    "Header Field Name": "Want-Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Warning",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.5]"
  },
  {
    "Header Field Name": "X400-Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-MTS-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Originator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Trace",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X-Content-Type-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://fetch.spec.whatwg.org/#x-content-type-options-header]"
  },
  {
    "Header Field Name": "X-Frame-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7034]"
  },
  {
    "Header Field Name": "Xref",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  }
]
},{}],402:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "Access-Control",
    "Template": "prov/access-control",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Credentials",
    "Template": "prov/access-control-allow-credentials",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Headers",
    "Template": "prov/access-control-allow-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Methods",
    "Template": "prov/access-control-allow-methods",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Origin",
    "Template": "prov/access-control-allow-origin",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Max-Age",
    "Template": "prov/access-control-max-age",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Method",
    "Template": "prov/access-control-request-method",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Headers",
    "Template": "prov/access-control-request-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "AMP-Cache-Transform",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[https://github.com/ampproject/amphtml/blob/master/spec/amp-cache-transform.md]"
  },
  {
    "Header Field Name": "Apparently-To",
    "Template": "prov/apparently-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "ARC-Authentication-Results",
    "Template": "prov/arc-authentication-results",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Message-Signature",
    "Template": "prov/arc-message-signature",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Seal",
    "Template": "prov/arc-seal",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cost",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "Eesst-Version",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Errors-To",
    "Template": "prov/errors-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "Form-Sub",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-levine-mailbomb-header]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Method-Check",
    "Template": "prov/method-check",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check-Expires",
    "Template": "prov/method-check-expires",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "MMHS-Authorizing-Users",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7912]"
  },
  {
    "Header Field Name": "Non-Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Privicon",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-koenig-privicons]"
  },
  {
    "Header Field Name": "Referer-Root",
    "Template": "prov/referer-root",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Resolution-Hint",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Resolver-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SIO-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SIO-Label-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SubOK",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Subst",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Title",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Color",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Media",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Pixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Resolution",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Windowpixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "mail",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Device-Accept",
    "Template": "prov/x-device-accept",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Charset",
    "Template": "prov/x-device-accept-charset",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Encoding",
    "Template": "prov/x-device-accept-encoding",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Language",
    "Template": "prov/x-device-accept-language",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-User-Agent",
    "Template": "prov/x-device-user-agent",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Mittente",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-PGP-Sig",
    "Template": "prov/x-pgp-sig",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[ftp://ftp.isc.org/pub/pgpcontrol/FORMAT][https://ftp.isc.org/pub/pgpcontrol/FORMAT]"
  },
  {
    "Header Field Name": "X-Ricevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Riferimento-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-TipoRicevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Trasporto",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-VerificaSicurezza",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  }
]
},{}],403:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.2]"
  },
  {
    "Header Field Name": "Accept-Charset",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.3]"
  },
  {
    "Header Field Name": "Accept-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.4][RFC7694, Section 3]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.5]"
  },
  {
    "Header Field Name": "Accept-Post",
    "Template": "perm/accept-post",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://www.w3.org/TR/ldp/]"
  },
  {
    "Header Field Name": "Accept-Ranges",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 2.3]"
  },
  {
    "Header Field Name": "Age",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.1]"
  },
  {
    "Header Field Name": "Allow",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.1]"
  },
  {
    "Header Field Name": "ALPN",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7639, Section 2]"
  },
  {
    "Header Field Name": "Alt-Svc",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alt-Used",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Approved",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archive",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 3]"
  },
  {
    "Header Field Name": "Authentication-Results",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7601]"
  },
  {
    "Header Field Name": "Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.2]"
  },
  {
    "Header Field Name": "Auto-Submitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3834 section 5]"
  },
  {
    "Header Field Name": "Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Cache-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.2]"
  },
  {
    "Header Field Name": "CalDAV-Timezones",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7809, Section 7.1]"
  },
  {
    "Header Field Name": "Cancel-Key",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cancel-Lock",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Connection",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.1]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6266]"
  },
  {
    "Header Field Name": "Content-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.2.2]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.3.2]"
  },
  {
    "Header Field Name": "Content-Length",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.4.2]"
  },
  {
    "Header Field Name": "Content-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 4.2]"
  },
  {
    "Header Field Name": "Content-Translation-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "standard",
    "Reference": "[RFC8255]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.1.5]"
  },
  {
    "Header Field Name": "Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "DASL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5323]"
  },
  {
    "Header Field Name": "DAV",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.1.2]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Depth",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Destination",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Distribution",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "DKIM-Signature",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6376]"
  },
  {
    "Header Field Name": "Downgraded-Final-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Message-Id",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Original-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Early-Data",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8470]"
  },
  {
    "Header Field Name": "ETag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.3]"
  },
  {
    "Header Field Name": "Expect",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.1]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.3]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Followup-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Forwarded",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7239]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.1]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Host",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.4]"
  },
  {
    "Header Field Name": "HTTP2-Settings",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7540, Section 3.2.1]"
  },
  {
    "Header Field Name": "If",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "If-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.1]"
  },
  {
    "Header Field Name": "If-Modified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.3]"
  },
  {
    "Header Field Name": "If-None-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.2]"
  },
  {
    "Header Field Name": "If-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.2]"
  },
  {
    "Header Field Name": "If-Schedule-Tag-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "If-Unmodified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.4]"
  },
  {
    "Header Field Name": "In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Include-Referred-Token-Binding-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Injection-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Injection-Info",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Last-Modified",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.2]"
  },
  {
    "Header Field Name": "Link",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8288]"
  },
  {
    "Header Field Name": "List-Unsubscribe-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC8058]"
  },
  {
    "Header Field Name": "Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.2]"
  },
  {
    "Header Field Name": "Lock-Token",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Max-Forwards",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.2]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Appendix A.1]"
  },
  {
    "Header Field Name": "MT-Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6758]"
  },
  {
    "Header Field Name": "Newsgroups",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Ordering-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Origin",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6454]"
  },
  {
    "Header Field Name": "Original-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Original-Recipient",
    "Template": "perm/original-recipient",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3798][RFC5337]"
  },
  {
    "Header Field Name": "Original-Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5537]"
  },
  {
    "Header Field Name": "Original-Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Overwrite",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Path",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Position",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Pragma",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.4]"
  },
  {
    "Header Field Name": "Prefer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Preference-Applied",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Proxy-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.3]"
  },
  {
    "Header Field Name": "Proxy-Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 4]"
  },
  {
    "Header Field Name": "Proxy-Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.4]"
  },
  {
    "Header Field Name": "Public-Key-Pins",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Public-Key-Pins-Report-Only",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.1]"
  },
  {
    "Header Field Name": "Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC5321]"
  },
  {
    "Header Field Name": "Received-SPF",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7208]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Referer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.2]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Require-Recipient-Valid-Since",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7293]"
  },
  {
    "Header Field Name": "Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Retry-After",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.3]"
  },
  {
    "Header Field Name": "Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Schedule-Reply",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Schedule-Tag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Sec-Token-Binding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Extensions",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Key",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Server",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.2]"
  },
  {
    "Header Field Name": "Set-Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "SLUG",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5023]"
  },
  {
    "Header Field Name": "Strict-Transport-Security",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6797]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Summary",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2156]"
  },
  {
    "Header Field Name": "TE",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.3]"
  },
  {
    "Header Field Name": "Timeout",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "TLS-Report-Domain",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "TLS-Report-Submitter",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Topic",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.4]"
  },
  {
    "Header Field Name": "Trailer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.4]"
  },
  {
    "Header Field Name": "Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.1]"
  },
  {
    "Header Field Name": "TTL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.2]"
  },
  {
    "Header Field Name": "Urgency",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.3]"
  },
  {
    "Header Field Name": "Upgrade",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.7]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.3]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2616]"
  },
  {
    "Header Field Name": "Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.4]"
  },
  {
    "Header Field Name": "VBR-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5518]"
  },
  {
    "Header Field Name": "Via",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.7.1]"
  },
  {
    "Header Field Name": "WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.1]"
  },
  {
    "Header Field Name": "Warning",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.5]"
  },
  {
    "Header Field Name": "X-Content-Type-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://fetch.spec.whatwg.org/#x-content-type-options-header]"
  },
  {
    "Header Field Name": "Xref",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  }
]
},{}],404:[function(require,module,exports){
/**
 * @file The constant NaN derived mathematically by 0 / 0.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module nan-x
 */

'use strict';

/**
 * The constant NaN derived mathematically by 0 / 0.
 *
 * @type number
 * @example
 * var NAN = require('nan-x');
 *
 * NAN !== NAN; // true
 * NAN === NAN; // false
 */
module.exports = 0 / 0;

},{}],405:[function(require,module,exports){
/**
 * @file Trims and replaces sequences of whitespace characters by a single space.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module normalize-space-x
 */

'use strict';

var libTrim = require('trim-x');
var trim2016 = libTrim.trim2016;
var trim2018 = libTrim.trim2018;
var Rx = require('cached-constructors-x').RegExp;
var libWhiteSpace = require('white-space-x');
var reNormalize2016 = new Rx('[' + libWhiteSpace.string2016 + ']+', 'g');
var reNormalize2018 = new Rx('[' + libWhiteSpace.string2018 + ']+', 'g');
var replace = ''.replace;

var $normalizeSpace2016 = function normalizeSpace2016(string) {
  return replace.call(trim2016(string), reNormalize2016, ' ');
};

var $normalizeSpace2018 = function normalizeSpace2018(string) {
  return replace.call(trim2018(string), reNormalize2018, ' ');
};

module.exports = {
  /**
   * Reference to normalizeSpace2018.
   */
  normalizeSpace: $normalizeSpace2018,

  /**
   * This method strips leading and trailing white-space from a string,
   * replaces sequences of whitespace characters by a single space,
   * and returns the resulting string. (ES2016)
   *
   * @param {string} string - The string to be normalized.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The normalized string.
   * @example
   * var normalizeSpace = require('normalize-space-x');
   *
   * normalizeSpace(' \t\na \t\nb \t\n') === 'a b'; // true
   */
  normalizeSpace2016: $normalizeSpace2016,

  /**
   * This method strips leading and trailing white-space from a string,
   * replaces sequences of whitespace characters by a single space,
   * and returns the resulting string. (ES2018)
   *
   * @param {string} string - The string to be normalized.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The normalized string.
   * @example
   * var normalizeSpace = require('normalize-space-x');
   *
   * normalizeSpace(' \t\na \t\nb \t\n') === 'a b'; // true
   */
  normalizeSpace2018: $normalizeSpace2018
};

},{"cached-constructors-x":36,"trim-x":407,"white-space-x":408}],406:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"cached-constructors-x":36,"dup":144,"require-coercible-to-string-x":429,"white-space-x":408}],407:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"dup":137,"trim-left-x":452,"trim-right-x":406}],408:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"dup":145}],409:[function(require,module,exports){
/**
 * @file Used to copy the values of all enumerable own properties from one or more source objects to a target object.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-assign-x
 */

'use strict';

var attempt = require('attempt-x');
var objectKeys = require('object-keys-x');
var isFunction = require('is-function-x');
var reduce = require('array-reduce-x');
var getOwnPropertyNames = require('get-own-property-names-x');
var isObjectLike = require('is-object-like-x');
var nativeAssign = isFunction(Object.assign) && Object.assign;

var workingNativeAssign = function _nativeWorks() {
  var obj = {};
  var res = attempt(nativeAssign, obj, { 0: 1 }, { 1: 2 });
  return res.threw === false && res.value === obj && objectKeys(obj).length === 2 && obj[0] === 1 && obj[1] === 2;
};

// eslint-disable-next-line id-length
var lacksProperEnumerationOrder = function _enumOrder() {
  // https://bugs.chromium.org/p/v8/issues/detail?id=4118
  var test1 = Object('abc');
  test1[5] = 'de';
  if (getOwnPropertyNames(test1)[0] === '5') {
    return true;
  }

  var strNums = '0123456789';
  // https://bugs.chromium.org/p/v8/issues/detail?id=3056
  var test2 = reduce(strNums.split(''), function (acc, ignore, index) {
    acc['_' + String.fromCharCode(index)] = index;
    return acc;
  }, {});

  var order = reduce(getOwnPropertyNames(test2), function (acc, name) {
    return acc + test2[name];
  }, '');

  if (order !== strNums) {
    return true;
  }

  // https://bugs.chromium.org/p/v8/issues/detail?id=3056
  var letters = 'abcdefghijklmnopqrst';
  var test3 = reduce(letters.split(''), function (acc, letter) {
    acc[letter] = letter;
    return acc;
  }, {});

  var result = attempt(nativeAssign, {}, test3);
  return result.threw === false && objectKeys(result.value).join('') !== letters;
};

// eslint-disable-next-line id-length
var assignHasPendingExceptions = function _exceptions() {
  if (isFunction(Object.preventExtensions) === false) {
    return false;
  }

  // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
  // which is 72% slower than our shim, and Firefox 40's native implementation.
  var result = attempt(Object.preventExtensions, { 1: 2 });
  if (result.threw || isObjectLike(result.value) === false) {
    return false;
  }

  var thrower = result.value;
  result = attempt(nativeAssign, thrower, 'xy');
  return result.threw ? thrower[1] === 'y' : false;
};

var shouldImplement = (function () {
  if (nativeAssign === false) {
    return true;
  }

  if (workingNativeAssign() === false) {
    return true;
  }

  if (lacksProperEnumerationOrder()) {
    return true;
  }

  if (assignHasPendingExceptions()) {
    return true;
  }

  return false;
}());

var $assign;
if (shouldImplement) {
  var toObject = require('to-object-x');
  var slice = require('array-slice-x');
  var isNil = require('is-nil-x');
  var getOEPS = require('get-own-enumerable-property-symbols-x');
  var concat = Array.prototype.concat;

  // 19.1.3.1
  $assign = function assign(target) {
    return reduce(slice(arguments, 1), function _assignSources(tgt, source) {
      if (isNil(source)) {
        return tgt;
      }

      var object = Object(source);
      return reduce(concat.call(objectKeys(object), getOEPS(object)), function _assignTo(tar, key) {
        tar[key] = object[key];
        return tar;
      }, tgt);
    }, toObject(target));
  };
} else {
  $assign = nativeAssign;
}

/**
 * This method is used to copy the values of all enumerable own properties from
 * one or more source objects to a target object. It will return the target object.
 *
 * @param {*} target - The target object.
 * @param {*} [...source] - The source object(s).
 * @throws {TypeError} If target is null or undefined.
 * @returns {Object} The target object.
 * @example
 * var assign = require('object-assign-x');
 *
 * var obj = { a: 1 };
 * var copy = assign({}, obj);
 * console.log(copy); // { a: 1 }
 */
module.exports = $assign;

},{"array-reduce-x":410,"array-slice-x":24,"attempt-x":32,"get-own-enumerable-property-symbols-x":115,"get-own-property-names-x":412,"is-function-x":162,"is-nil-x":174,"is-object-like-x":176,"object-keys-x":413,"to-object-x":446}],410:[function(require,module,exports){
/**
 * @file Reduce an array (from left to right) to a single value.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-reduce-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var ArrayCtr = cachedCtrs.Array;
var castObject = cachedCtrs.Object;
var nativeReduce = typeof ArrayCtr.prototype.reduce === 'function' && ArrayCtr.prototype.reduce;

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
var isWorking;
if (nativeReduce) {
  var attempt = require('attempt-x');
  isWorking = attempt.call([], nativeReduce, function (acc) {
    return acc;
  }).threw;

  var res;
  if (isWorking) {
    res = attempt.call(castObject('abc'), nativeReduce, function (acc, c) {
      return acc + c;
    }, 'x');

    isWorking = res.threw === false && res.value === 'xabc';
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }(1, 2, 3)), nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 1);

    isWorking = res.threw === false && res.value === 7;
  }

  if (isWorking) {
    res = attempt.call({
      0: 1,
      1: 2,
      3: 3,
      4: 4,
      length: 4
    }, nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 2);

    isWorking = res.threw === false && res.value === 8;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativeReduce, function (acc, node) {
        acc[acc.length] = node;
        return acc;
      }, []);

      isWorking = res.threw === false && res.value.length === 1 && res.value[0] === div;
    }
  }

  if (isWorking) {
    // eslint-disable-next-line max-params
    res = attempt.call('ab', nativeReduce, function (_, __, ___, list) {
      return list;
    });

    isWorking = res.threw === false && typeof res.value === 'object';
  }
}

var $reduce;
if (nativeReduce && isWorking) {
  $reduce = function reduce(array, callBack /* , initialValue */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativeReduce.apply(array, args);
  };
} else {
  // Check failure of by-index access of string characters (IE < 9)
  // and failure of `0 in boxedString` (Rhino)
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x').toLength2018;
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $reduce = function reduce(array, callBack /* , initialValue*/) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var argsLength = arguments.length;
    // no value to return if no initial value and an empty array
    if (length === 0 && argsLength < 3) {
      throw new TypeError('reduce of empty array with no initial value');
    }

    var i = 0;
    var result;
    if (argsLength > 2) {
      result = arguments[2];
    } else {
      do {
        if (i in iterable) {
          result = iterable[i];
          i += 1;
          // eslint-disable-next-line no-restricted-syntax
          break;
        }

        // if array contains no values, no initial value to return
        i += 1;
        if (i >= length) {
          throw new TypeError('reduce of empty array with no initial value');
        }
      } while (true); // eslint-disable-line no-constant-condition
    }

    while (i < length) {
      if (i in iterable) {
        result = callBack(result, iterable[i], i, object);
      }

      i += 1;
    }

    return result;
  };
}

/**
 * This method applies a function against an accumulator and each element in the
 * array (from left to right) to reduce it to a single value.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to execute for each element.
 * @param {*} [initialValue] - Value to use as the first argument to the first
 *  call of the callback. If no initial value is supplied, the first element in
 *  the array will be used. Calling reduce on an empty array without an initial
 *  value is an error.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @throws {TypeError} If called on an empty array without an initial value.
 * @returns {*} The value that results from the reduction.
 * @example
 * var reduce = require('array-reduce-x');
 *
 * var sum = reduce([0, 1, 2, 3], function (a, b) {
 *   return a + b;
 * }, 0);
 * // sum is 6
 */
module.exports = $reduce;

},{"assert-is-function-x":411,"attempt-x":32,"cached-constructors-x":36,"split-if-boxed-bug-x":435,"to-length-x":441,"to-object-x":446}],411:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":162,"is-primitive":178,"to-string-symbols-supported-x":449}],412:[function(require,module,exports){
/**
 * @file Creates an array of all properties (enumerable or not) found directly upon a given object.
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-property-names-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeGOPN = typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames;

var getOPN;
if (nativeGOPN) {
  var attempt = require('attempt-x');
  var isArray = require('is-array-x');
  var isCorrectRes = function _isCorrectRes(r, length) {
    return r.threw === false && isArray(r.value) && r.value.length === length;
  };

  var either = function _either(r, a, b) {
    var x = r.value[0];
    var y = r.value[1];
    return (x === a && y === b) || (x === b && y === a);
  };

  var res = attempt(nativeGOPN, 'fo');
  if (isCorrectRes(res, 3) && either(res, '0', '1') && res.value[2] === 'length') {
    getOPN = nativeGOPN;
  } else {
    res = attempt(nativeGOPN, { a: 1, b: 2 });
    if (isCorrectRes(res, 2) && either(res, 'a', 'b')) {
      var toStringTag = require('to-string-tag-x');
      var arraySlice = require('array-slice-x');
      var win = typeof window === 'object' && window;
      var cachedWindowNames = win ? nativeGOPN(win) : [];

      getOPN = function getOwnPropertyNames(obj) {
        var val = toObject(obj);
        // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
        if (win && win !== window && toStringTag(val) === '[object Window]') {
          var result = attempt(nativeGOPN, val);
          return result.threw ? arraySlice(cachedWindowNames) : result.value;
        }

        return nativeGOPN(val);
      };
    }
  }
}

if (typeof getOPN !== 'function') {
  var objectKeys = require('object-keys-x');
  getOPN = function getOwnPropertyNames(obj) {
    return objectKeys(obj);
  };
}

/**
 * This method creates an array of all properties (enumerable or not) found
 * directly upon a given object.
 *
 * @param {object} obj - The object whose enumerable and non-enumerable own
 *  properties are to be returned.
 * @throws {TypeError} If target is null or undefined.
 * @returns {array} An array of strings that correspond to the properties found
 *  directly upon the given object.
 * @example
 * var getOwnPropertyName = require('get-own-property-name-x');
 *
 * getOwnPropertyNames('foo'); // ["0", "1", "2", "length"]
 */
module.exports = getOPN;

},{"array-slice-x":24,"attempt-x":32,"is-array-x":153,"object-keys-x":413,"to-object-x":446,"to-string-tag-x":450}],413:[function(require,module,exports){
/**
 * @file An ES6 Object.keys shim.
 * @version 2.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-keys-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeKeys = typeof Object.keys === 'function' && Object.keys;

var isWorking;
var throwsWithNull;
var worksWithPrim;
var worksWithRegex;
var worksWithArgs;
var worksWithStr;
if (nativeKeys) {
  var attempt = require('attempt-x');
  var isArray = require('is-array-x');
  var isCorrectRes = function _isCorrectRes(r, length) {
    return r.threw === false && isArray(r.value) && r.value.length === length;
  };

  var either = function _either(r, a, b) {
    var x = r.value[0];
    var y = r.value[1];
    return (x === a && y === b) || (x === b && y === a);
  };

  var testObj = { a: 1, b: 2 };
  var res = attempt(nativeKeys, testObj);
  isWorking = isCorrectRes(res, 2) && either(res, 'a', 'b');

  if (isWorking) {
    testObj = Object('a');
    testObj.y = 1;
    res = attempt(nativeKeys, testObj);
    isWorking = isCorrectRes(res, 2) && either(res, '0', 'y');
  }

  if (isWorking) {
    throwsWithNull = attempt(nativeKeys, null).threw;
    worksWithPrim = isCorrectRes(attempt(nativeKeys, 42), 0);
    worksWithRegex = attempt(nativeKeys, /a/g).threw === false;

    res = attempt(nativeKeys, (function () {
      return arguments;
    }(1, 2)));

    worksWithArgs = isCorrectRes(res, 2) && either(res, '0', '1');

    res = attempt(nativeKeys, Object('ab'));
    worksWithStr = isCorrectRes(res, 2) && either(res, '0', '1');
  }
}

var objectKeys;
if (isWorking) {
  if (throwsWithNull && worksWithPrim && worksWithRegex && worksWithArgs && worksWithStr) {
    objectKeys = nativeKeys;
  } else {
    var isArguments = worksWithArgs !== true && require('is-arguments');
    var arraySlice = isArguments && require('array-like-slice-x');
    var splitIfBoxed = worksWithStr !== true && require('split-if-boxed-bug-x');
    var isString = splitIfBoxed && require('is-string');
    var isRegexp = worksWithRegex !== true && require('is-regexp-x');
    var has = isRegexp && require('has-own-property-x');

    objectKeys = function keys(object) {
      var obj = toObject ? toObject(object) : object;
      if (isArguments && isArguments(obj)) {
        obj = arraySlice(obj);
      } else if (isString && isString(obj)) {
        obj = splitIfBoxed(obj);
      } else if (isRegexp && isRegexp(obj)) {
        var regexKeys = [];
        // eslint-disable-next-line no-restricted-syntax
        for (var k in obj) {
          if (has(obj, k)) {
            regexKeys[regexKeys.length] = k;
          }
        }

        return regexKeys;
      }

      return nativeKeys(obj);
    };
  }
} else {
  var objKeys = require('object-keys');
  objectKeys = function keys(object) {
    return objKeys(toObject(object));
  };
}

/**
 * This method returns an array of a given object's own enumerable properties,
 * in the same order as that provided by a for...in loop (the difference being
 * that a for-in loop enumerates properties in the prototype chain as well).
 *
 * @param {*} obj The object of which the enumerable own properties are to be returned.
 * @return {Array} An array of strings that represent all the enumerable properties of the given object.
 * @example
 * var objectKeys = require('object-keys-x');
 *
 * var obj = {
 *   arr: [],
 *   bool: true,
 *   'null': null,
 *   num: 42,
 *   obj: { },
 *   str: 'boz',
 *   undefined: void 0
 * };
 *
 * objectKeys(obj); // ['arr', 'bool', 'null', 'num', 'obj', 'str', 'undefined']
 */
module.exports = objectKeys;

},{"array-like-slice-x":14,"attempt-x":32,"has-own-property-x":122,"is-arguments":150,"is-array-x":153,"is-regexp-x":181,"is-string":186,"object-keys":418,"split-if-boxed-bug-x":435,"to-object-x":446}],414:[function(require,module,exports){
/**
 * @file Sham for Object.defineProperties
 * @version 2.0.4
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-define-properties-x
 */

'use strict';

var forEach = require('array-for-each-x');
var $keys = require('object-keys-x');
var $defineProperty = require('object-define-property-x');
var $defineProperties = Object.defineProperties;
var definePropertiesFallback;

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var doesDefinePropertyWork = function _doesDefinePropertyWork(object) {
  try {
    $defineProperty(object, 'sentinel', {});
    return 'sentinel' in object;
  } catch (exception) {
    return false;
  }
};

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if ($defineProperty) {
  // eslint-disable-next-line id-length
  var definePropertyWorksOnObject = doesDefinePropertyWork({});
  var definePropertyWorksOnDom = typeof document === 'undefined' || doesDefinePropertyWork(document.createElement('div'));
  if (definePropertyWorksOnObject === false || definePropertyWorksOnDom === false) {
    definePropertiesFallback = Object.defineProperties;
  }
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (Boolean($defineProperties) === false || definePropertiesFallback) {
  $defineProperties = function defineProperties(object, properties) {
    // make a valiant attempt to use the real defineProperties
    if (definePropertiesFallback) {
      try {
        return definePropertiesFallback.call(Object, object, properties);
      } catch (exception) {
        // try the shim if the real one doesn't work
      }
    }

    forEach($keys(properties), function (property) {
      if (property !== '__proto__') {
        $defineProperty(object, property, properties[property]);
      }
    });
    return object;
  };
}

/**
 * This method defines new or modifies existing properties directly on an
 * object, returning the object.
 *
 * @param {Object} object - The object on which to define or modify properties.
 * @param {Object} properties - An object whose own enumerable properties
 *  constitute descriptors for the
 * properties to be defined or modified.
 * @returns {Object} The object that was passed to the function.
 * @example
 * var defineProperties = require('object-define-properties-x');
 *
 * var obj = {};
 * defineProperties(obj, {
 *   'property1': {
 *     value: true,
 *     writable: true
 *   },
 *   'property2': {
 *     value: 'Hello',
 *     writable: true
 *   }
 *   // etc. etc.
 * });
 */
module.exports = $defineProperties;

},{"array-for-each-x":8,"object-define-property-x":415,"object-keys-x":417}],415:[function(require,module,exports){
/**
 * @file Sham for Object.defineProperty
 * @version 2.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-define-property-x
 */

'use strict';

var isPrimitive = require('is-primitive');
var owns = require('has-own-property-x');
var $defineProperty = Object.defineProperty;

var prototypeOfObject = Object.prototype;
var definePropertyFallback;
// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
if (supportsAccessors) {
  /* eslint-disable no-underscore-dangle, no-restricted-properties */
  defineGetter = prototypeOfObject.__defineGetter__;
  defineSetter = prototypeOfObject.__defineSetter__;
  lookupGetter = prototypeOfObject.__lookupGetter__;
  lookupSetter = prototypeOfObject.__lookupSetter__;
  /* eslint-enable no-underscore-dangle, no-restricted-properties */
}

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var doesDefinePropertyWork = function _doesDefinePropertyWork(object) {
  try {
    $defineProperty(object, 'sentinel', {});
    return 'sentinel' in object;
  } catch (exception) {
    return false;
  }
};

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if ($defineProperty) {
  // eslint-disable-next-line id-length
  var definePropertyWorksOnObject = doesDefinePropertyWork({});
  var definePropertyWorksOnDom = typeof document === 'undefined' || doesDefinePropertyWork(document.createElement('div'));
  if (definePropertyWorksOnObject === false || definePropertyWorksOnDom === false) {
    definePropertyFallback = Object.defineProperty;
  }
}

if (Boolean($defineProperty) === false || definePropertyFallback) {
  var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
  var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
  // eslint-disable-next-line id-length
  var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

  $defineProperty = function defineProperty(object, property, descriptor) {
    if (isPrimitive(object)) {
      throw new TypeError(ERR_NON_OBJECT_TARGET + object);
    }
    if (isPrimitive(descriptor)) {
      throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
    }
    // make a valiant attempt to use the real defineProperty
    // for I8's DOM elements.
    if (definePropertyFallback) {
      try {
        return definePropertyFallback.call(Object, object, property, descriptor);
      } catch (exception) {
        // try the shim if the real one doesn't work
      }
    }

    // If it's a data property.
    if ('value' in descriptor) {
      // fail silently if 'writable', 'enumerable', or 'configurable'
      // are requested but not supported
      /*
      // alternate approach:
      if ( // can't implement these features; allow false but not true
          ('writable' in descriptor && !descriptor.writable) ||
          ('enumerable' in descriptor && !descriptor.enumerable) ||
          ('configurable' in descriptor && !descriptor.configurable)
      ))
          throw new RangeError(
            'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
          );
      */

      if (supportsAccessors && (lookupGetter.call(object, property) || lookupSetter.call(object, property))) {
        // As accessors are supported only on engines implementing
        // `__proto__` we can safely override `__proto__` while defining
        // a property to make sure that we don't hit an inherited
        // accessor.
        /* eslint-disable no-proto */
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;
        // Deleting a property anyway since getter / setter may be
        // defined on object itself.
        delete object[property];
        object[property] = descriptor.value;
        // Setting original `__proto__` back now.
        object.__proto__ = prototype;
        /* eslint-enable no-proto */
      } else {
        object[property] = descriptor.value;
      }
    } else {
      var hasGetter = 'get' in descriptor;
      var hasSetter = 'set' in descriptor;
      if (supportsAccessors === false && (hasGetter || hasSetter)) {
        throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
      }
      // If we got that far then getters and setters can be defined !!
      if (hasGetter) {
        defineGetter.call(object, property, descriptor.get);
      }
      if (hasSetter) {
        defineSetter.call(object, property, descriptor.set);
      }
    }
    return object;
  };
}

/**
 * This method defines a new property directly on an object, or modifies an existing property on an object,
 * and returns the object.
 *
 * @param {Object} object - The object on which to define the property.
 * @param {string} property - The name of the property to be defined or modified.
 * @param {Object} descriptor - The descriptor for the property being defined or modified.
 * @returns {Object} The object that was passed to the function.
 * @example
 * var defineProperty = require('object-define-property-x');
 *
 * var o = {}; // Creates a new object
 *
 * defineProperty(o, 'a', {
 *   value: 37,
 *   writable: true
 * });
 */
module.exports = $defineProperty;

},{"has-own-property-x":122,"is-primitive":178}],416:[function(require,module,exports){
/**
 * @file Sham for ES6 Object.getOwnPropertyDescriptor
 * @version 3.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-get-own-property-descriptor-x
 */

'use strict';

var toObject = require('to-object-x');
var toPropertyKey = require('to-property-key-x');
var isFalsey = require('is-falsey-x');
var attempt = require('attempt-x');

var nativeGOPD = typeof Object.getOwnPropertyDescriptor === 'function' && Object.getOwnPropertyDescriptor;
var getOPDFallback1;
var getOPDFallback2;

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3

var doesGOPDWork = function (object, prop) {
  object[toPropertyKey(prop)] = 0;
  var testResult = attempt(nativeGOPD, object, prop);
  return testResult.threw === false && testResult.value.value === 0;
};

// check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
var $getOwnPropertyDescriptor;
if (nativeGOPD) {
  var doc = typeof document !== 'undefined' && document;
  var getOPDWorksOnDom = doc ? doesGOPDWork(doc.createElement('div'), 'sentinel') : true;
  if (getOPDWorksOnDom) {
    var res = attempt(nativeGOPD, Object('abc'), 1);
    var worksWithStr = res.threw === false && res.value && res.value.value === 'b';
    if (worksWithStr) {
      var getOPDWorksOnObject = doesGOPDWork({}, 'sentinel');
      if (getOPDWorksOnObject) {
        var worksWithPrim = attempt(nativeGOPD, 42, 'name').threw === false;
        var worksWithObjSym = require('has-symbol-support-x') && doesGOPDWork({}, Object(Symbol('')));
        // eslint-disable-next-line max-depth
        if (worksWithObjSym) {
          // eslint-disable-next-line max-depth
          if (worksWithPrim) {
            $getOwnPropertyDescriptor = nativeGOPD;
          } else {
            $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
              return nativeGOPD(toObject(object), property);
            };
          }
        } else if (worksWithPrim) {
          $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            return nativeGOPD(object, toPropertyKey(property));
          };
        } else {
          $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            return nativeGOPD(toObject(object), toPropertyKey(property));
          };
        }
      } else {
        getOPDFallback1 = nativeGOPD;
      }
    } else {
      getOPDFallback2 = nativeGOPD;
    }
  }
}

if (isFalsey($getOwnPropertyDescriptor) || getOPDFallback1 || getOPDFallback2) {
  var owns = require('has-own-property-x');
  var isPrimitive = require('is-primitive');
  var isString = require('is-string');
  var isIndex = require('is-index-x');
  var propertyIsEnumerable = require('property-is-enumerable-x');
  var prototypeOfObject = Object.prototype;

  // If JS engine supports accessors creating shortcuts.
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
  if (supportsAccessors) {
    // eslint-disable-next-line no-underscore-dangle
    var lg = prototypeOfObject.__lookupGetter__;
    // eslint-disable-next-line no-underscore-dangle
    var ls = prototypeOfObject.__lookupSetter__;
    lookupGetter = function (object, property) {
      return lg.call(object, property);
    };

    lookupSetter = function (object, property) {
      return ls.call(object, property);
    };
  }

  $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
    var obj = toObject(object);
    var propKey = toPropertyKey(property);

    var result;
    // make a valiant attempt to use the real getOwnPropertyDescriptor for I8's DOM elements.
    if (getOPDFallback1) {
      result = attempt.call(Object, getOPDFallback1, obj, propKey);
      if (result.threw === false) {
        return result.value;
      }
      // try the shim if the real one doesn't work
    }

    var isStringIndex = isString(obj) && isIndex(propKey, obj.length);
    if (getOPDFallback2 && isStringIndex === false) {
      result = attempt.call(Object, getOPDFallback2, obj, propKey);
      if (result.threw === false) {
        return result.value;
      }
      // try the shim if the real one doesn't work
    }

    var descriptor;
    // If object does not owns property return undefined immediately.
    if (isStringIndex === false && owns(obj, propKey) === false) {
      return descriptor;
    }

    // If object has a property then it's for sure `configurable`, and
    // probably `enumerable`. Detect enumerability though.
    descriptor = {
      configurable: isPrimitive(object) === false && isStringIndex === false,
      enumerable: propertyIsEnumerable(obj, propKey)
    };

    // If JS engine supports accessor properties then property may be a
    // getter or setter.
    if (supportsAccessors) {
      // Unfortunately `__lookupGetter__` will return a getter even
      // if object has own non getter property along with a same named
      // inherited getter. To avoid misbehavior we temporary remove
      // `__proto__` so that `__lookupGetter__` will return getter only
      // if it's owned by an object.
      // eslint-disable-next-line no-proto
      var prototype = obj.__proto__;
      var notPrototypeOfObject = obj !== prototypeOfObject;
      // avoid recursion problem, breaking in Opera Mini when
      // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
      // or any other Object.prototype accessor
      if (notPrototypeOfObject) {
        // eslint-disable-next-line no-proto
        obj.__proto__ = prototypeOfObject;
      }

      var getter = lookupGetter(obj, propKey);
      var setter = lookupSetter(obj, propKey);

      if (notPrototypeOfObject) {
        // Once we have getter and setter we can put values back.
        // eslint-disable-next-line no-proto
        obj.__proto__ = prototype;
      }

      if (getter || setter) {
        if (getter) {
          descriptor.get = getter;
        }

        if (setter) {
          descriptor.set = setter;
        }

        // If it was accessor property we're done and return here
        // in order to avoid adding `value` to the descriptor.
        return descriptor;
      }
    }

    // If we got this far we know that object has an own property that is
    // not an accessor so we set it as a value and return descriptor.
    if (isStringIndex) {
      descriptor.value = obj.charAt(propKey);
      descriptor.writable = false;
    } else {
      descriptor.value = obj[propKey];
      descriptor.writable = true;
    }

    return descriptor;
  };
}

/**
 * This method returns a property descriptor for an own property (that is,
 * one directly present on an object and not in the object's prototype chain)
 * of a given object.
 *
 * @param {*} object - The object in which to look for the property.
 * @param {*} property - The name of the property whose description is to be retrieved.
 * @returns {Object} A property descriptor of the given property if it exists on the object, undefined otherwise.
 * @example
 * var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
 * var obj = { bar: 42 };
 * var d = getOwnPropertyDescriptor(o, 'bar');
 * // d is {
 * //   configurable: true,
 * //   enumerable: true,
 * //   value: 42,
 * //   writable: true
 * // }
 */
module.exports = $getOwnPropertyDescriptor;

},{"attempt-x":32,"has-own-property-x":122,"has-symbol-support-x":124,"is-falsey-x":160,"is-index-x":164,"is-primitive":178,"is-string":186,"property-is-enumerable-x":425,"to-object-x":446,"to-property-key-x":448}],417:[function(require,module,exports){
/**
 * @file An ES6 Object.keys shim.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-keys-x
 */

'use strict';

var isArguments = require('is-arguments');
var toObject = require('to-object-x');
var originalKeys = Object.keys;

try {
  var arr = originalKeys({ a: 1, b: 2 });
  if (arr.length !== 2 || arr[0] !== 'a' || arr[1] !== 'b') {
    throw new Error('failed keys');
  }
} catch (ignore) {
  originalKeys = require('object-keys');
}

var keysWorksWithArguments = (function () {
  // Safari 5.0 bug
  return originalKeys(arguments).length === 2;
}(1, 2));

var keysHasArgumentsLengthBug = (function () {
  var argKeys = originalKeys(arguments);
  return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
}(1));

var objectKeys;
if (!keysWorksWithArguments || keysHasArgumentsLengthBug) {
  var arraySlice = Array.prototype.slice;
  objectKeys = function keys(object) {
    var obj = toObject(object);
    if (isArguments(object)) {
      return originalKeys(arraySlice.call(obj));
    }

    return originalKeys(obj);
  };
} else {
  objectKeys = function keys(object) {
    return originalKeys(toObject(object));
  };
}

/**
 * This method returns an array of a given object's own enumerable properties,
 * in the same order as that provided by a for...in loop (the difference being
 * that a for-in loop enumerates properties in the prototype chain as well).
 *
 * @param {*} obj The object of which the enumerable own properties are to be returned.
 * @return {Array} An array of strings that represent all the enumerable properties of the given object.
 * @example
 * var objectKeys = require('object-keys-x');
 *
 * var obj = {
 *   arr: [],
 *   bool: true,
 *   'null': null,
 *   num: 42,
 *   obj: { },
 *   str: 'boz',
 *   undefined: void 0
 * };
 *
 * objectKeys(obj); // ['arr', 'bool', 'null', 'num', 'obj', 'str', 'undefined']
 */
module.exports = objectKeys;

},{"is-arguments":150,"object-keys":418,"to-object-x":446}],418:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$applicationCache: true,
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":419}],419:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],420:[function(require,module,exports){
(function (process,setImmediate){
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

module.exports = onFinished
module.exports.isFinished = isFinished

/**
 * Module dependencies.
 * @private
 */

var first = require('ee-first')

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished(msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg)
    return msg
  }

  // attach the listener to the message
  attachListener(msg, listener)

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished(msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish(error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket)
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket)
    callback(socket)
  }
}

}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":424,"ee-first":100,"timers":437}],421:[function(require,module,exports){
"use strict";

// <https://lacke.mn/reduce-your-bundle-js-file-size/>
// // <https://github.com/lodash/babel-plugin-lodash/issues/221>
var isError = require('lodash/isError');

var isArray = require('lodash/isArray');

var isEmpty = require('lodash/isEmpty');

var pick = require('lodash/pick');

var isFunction = require('lodash/isFunction'); // we want to support parsing other fields than the standard:
// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors>
// <https://github.com/stripe/stripe-node/blob/3c07d851cf897490d8b93dd4457dda0c4c8e667f/lib/Error.js#L33>


var parseErr = function parseErr(err) {
  var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!isError(err)) throw new Error('`err` must be an Error');
  if (!isArray(fields)) throw new Error('`fields` must be an Array');
  var keys = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(err)).concat(Object.getOwnPropertyNames(err)).forEach(function (key) {
    if (!isFunction(err[key])) keys[key] = err[key];
  });
  if (!keys.name && err.constructor.name) keys.name = err.constructor.name;
  return isArray(fields) && !isEmpty(fields) ? pick(keys, fields) : keys;
};

module.exports = parseErr;
},{"lodash/isArray":360,"lodash/isEmpty":363,"lodash/isError":364,"lodash/isFunction":365,"lodash/pick":384}],422:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"cached-constructors-x":36,"dup":133,"nan-x":404,"to-string-x":451,"trim-left-x":452}],423:[function(require,module,exports){
"use strict";

var Url = require('url-parse');

var cookie = require('cookie');

var safeStringify = require('fast-safe-stringify'); // <https://lacke.mn/reduce-your-bundle-js-file-size/>
// <https://github.com/lodash/babel-plugin-lodash/issues/221>


var pick = require('lodash/pick');

var isString = require('lodash/isString');

var isObject = require('lodash/isObject');

var clone = require('lodash/clone');

var cloneDeep = require('lodash/cloneDeep');

var isUndefined = require('lodash/isUndefined');

var isNull = require('lodash/isNull');

var isFunction = require('lodash/isFunction');

var isEmpty = require('lodash/isEmpty');

var isArray = require('lodash/isArray');

var mapValues = require('lodash/mapValues');

var hasWindow = typeof window !== 'undefined' && typeof window.document !== 'undefined'; // https://stackoverflow.com/a/39087474

function maskPasswords(obj) {
  return mapValues(obj, function (val, key) {
    if (isObject(val)) return maskPasswords(val);
    return key === 'password' && isString(val) ? new Array(val.length + 1).join('*') : val;
  });
} // inspired by raven's parseRequest
// eslint-disable-next-line complexity


var parseRequest = function parseRequest() {
  var originalReq = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var userFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['id', 'email', 'full_name', 'ip_address'];
  var req = cloneDeep(pick(originalReq, ['method', 'query', 'header', 'headers', 'cookies', 'originalUrl', 'url', 'ip', 'connection']));
  if (Object.prototype.hasOwnProperty.call(req, 'hostname') && originalReq.host) req.host = clone(originalReq.host);
  var headers = req.headers || req.header || {};
  var method = req.method || 'GET'; // inspired from `preserve-qs` package

  var originalUrl = '';

  if (isString(req.originalUrl)) {
    originalUrl = req.originalUrl;
  } else if (isString(req.url)) originalUrl = req.url;else if (hasWindow) originalUrl = window.location.pathname + window.location.search;

  originalUrl = new Url(originalUrl); // parse query, path, and origin to prepare absolute Url

  var query = isObject(req.query) ? req.query : Url.qs.parse(originalUrl.query);
  var path = originalUrl.origin === 'null' ? originalUrl.pathname : "".concat(originalUrl.origin).concat(originalUrl.pathname);
  var qs = Url.qs.stringify(query, true);
  var absoluteUrl = path + qs; // default to the user object

  var user = isObject(originalReq.user) ? isFunction(originalReq.user.toObject) ? originalReq.user.toObject() : clone(originalReq.user) : {};
  var ip = '';

  if (isString(req.ip)) {
    ip = req.ip;
  } else if (isObject(req.connection) && isString(req.connection.remoteAddress)) ip = req.connection.remoteAddress;

  if (ip && !isString(user.ip_address)) user.ip_address = ip;
  if (isArray(userFields) && !isEmpty(userFields)) user = pick(user, userFields);
  var body = '';
  if (!['GET', 'HEAD'].includes(method) && !isUndefined(originalReq.body)) body = isString(originalReq.body) ? clone(originalReq.body) : cloneDeep(originalReq.body); // recursively search through body and filter out passwords from it

  if (isObject(body)) body = maskPasswords(body);
  if (!isUndefined(body) && !isNull(body) && !isString(body)) body = safeStringify(body); // populate user agent and referrer if
  // we're in a browser and they're unset

  if (hasWindow) {
    // set user agent
    if (typeof window.navigator !== 'undefined' && isObject(window.navigator) && isString(window.navigator.userAgent) && (!isString(headers['user-agent']) || !headers['user-agent'])) headers['user-agent'] = window.navigator.userAgent;

    if (typeof window.document !== 'undefined' && isObject(window.document)) {
      // set referrer
      if (isString(window.document.referrer) && (!isString(headers.referer) || !headers.referer) && (!isString(headers.referrer) || !headers.referrer)) headers.referer = window.document.referrer; // set cookie

      if (isString(window.document.cookie) && (!isString(headers.cookie) || !headers.cookie)) headers.cookie = window.document.cookie;
    }
  } // parse the cookies (if any were set)


  var cookies = cookie.parse(headers.cookie || '');
  return {
    request: {
      method: method,
      query: query,
      headers: headers,
      cookies: cookies,
      body: body,
      url: absoluteUrl
    },
    user: user
  };
};

module.exports = parseRequest;
},{"cookie":95,"fast-safe-stringify":104,"lodash/clone":349,"lodash/cloneDeep":350,"lodash/isArray":360,"lodash/isEmpty":363,"lodash/isFunction":365,"lodash/isNull":368,"lodash/isObject":370,"lodash/isString":374,"lodash/isUndefined":377,"lodash/mapValues":381,"lodash/pick":384,"url-parse":457}],424:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],425:[function(require,module,exports){
/**
 * @file Indicates whether the specified property is enumerable.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module property-is-enumerable-x
 */

'use strict';

var toPropertyKey = require('to-property-key-x');
var toObject = require('to-object-x');
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

/**
 * This method returns a Boolean indicating whether the specified property is
 * enumerable. Does not attempt to fix bugs in IE<9 or old Opera, otherwise it
 * does ES6ify the method.
 *
 * @param {!Object} object - The object on which to test the property.
 * @param {string|Symbol} property - The name of the property to test.
 * @throws {TypeError} If target is null or undefined.
 * @returns {boolean} A Boolean indicating whether the specified property is
 *  enumerable.
 * @example
 * var propertyIsEnumerable = require('property-is-enumerable-x');
 *
 * var o = {};
 * var a = [];
 * o.prop = 'is enumerable';
 * a[0] = 'is enumerable';
 *
 * propertyIsEnumerable(o, 'prop'); // true
 * propertyIsEnumerable(a, 0); // true
 */
module.exports = function propertyIsEnumerable(object, property) {
  return propIsEnumerable.call(toObject(object), toPropertyKey(property));
};

},{"to-object-x":446,"to-property-key-x":448}],426:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(value));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],427:[function(require,module,exports){
/**
 * @file Sham for Reflect.ownKeys
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module reflect-own-keys-x
 */

'use strict';

var hasReflect = require('has-reflect-support-x');
var reflectOwnKeys = hasReflect && Reflect.ownKeys;

if (reflectOwnKeys) {
  try {
    var k = reflectOwnKeys({ a: 1, b: 2 }).sort();
    if (k.length !== 2 || k[0] !== 'a' || k[1] !== 'b') {
      throw new Error('failed');
    }
  } catch (ignore) {
    reflectOwnKeys = null;
  }
}

if (Boolean(reflectOwnKeys) === false) {
  var assertIsObject = require('assert-is-object-x');
  var getOwnPropertyNames = require('get-own-property-names-x');
  var getOwnPropertySymbols = require('get-own-property-symbols-x');
  var concat = Array.prototype.concat;

  reflectOwnKeys = function ownKeys(target) {
    assertIsObject(target);
    return concat.call(getOwnPropertyNames(target), getOwnPropertySymbols(target));
  };
}

/**
 * This method returns an array of the target object's own property keys.
 * Its return value is equivalent to
 * Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)).
 *
 * @param {*} target - The target object from which to get the own keys.
 * @throws {TypeError} If target is not an Object.
 * @returns {Object} An Array of the target object's own property keys.
 * @example
 * var reflectOwnKeys = require('reflect-own-keys-x');
 * reflectOwnKeys({ a: 1, b: 2 }); // ['a', 'b']
 */
module.exports = reflectOwnKeys;

},{"assert-is-object-x":31,"get-own-property-names-x":118,"get-own-property-symbols-x":119,"has-reflect-support-x":123}],428:[function(require,module,exports){
/**
 * @file Replace the comments in a string.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module replace-comments-x
 */

'use strict';

var toStr = require('to-string-x');
var requireCoercibleToString = require('require-coercible-to-string-x');
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var replace = ''.replace;

/**
 * This method replaces comments in a string.
 *
 * @param {string} string - The string to be stripped.
 * @param {string} [replacement] - The string to be used as a replacement.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @throws {TypeError} If replacement is not coercible.
 * @returns {string} The new string with the comments replaced.
 * @example
 * var replaceComments = require('replace-comments-x');
 *
 * replaceComments(test;/* test * /, ''), // 'test;'
 * replaceComments(test; // test, ''), // 'test;'
 */
module.exports = function replaceComments(string) {
  return replace.call(requireCoercibleToString(string), STRIP_COMMENTS, arguments.length > 1 ? toStr(arguments[1]) : '');
};

},{"require-coercible-to-string-x":429,"to-string-x":451}],429:[function(require,module,exports){
/**
 * @file Requires an argument is corecible then converts using ToString.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module require-coercible-to-string-x
 */

'use strict';

var requireObjectCoercible = require('require-object-coercible-x');
var toStr = require('to-string-x');

/**
 * This method requires an argument is corecible then converts using ToString.
 *
 * @param {*} value - The value to converted to a string.
 * @throws {TypeError} If value is null or undefined.
 * @returns {string} The value as a string.
 * @example
 * var requireCoercibleToString = require('require-coercible-to-string-x');
 *
 * requireCoercibleToString(); // TypeError
 * requireCoercibleToString(null); // TypeError
 * requireCoercibleToString(Symbol('')); // TypeError
 * requireCoercibleToString(Object.create(null)); // TypeError
 * requireCoercibleToString(1); // '1'
 * requireCoercibleToString(true); // 'true'
 */
module.exports = function requireCoercibleToString(value) {
  return toStr(requireObjectCoercible(value));
};

},{"require-object-coercible-x":430,"to-string-x":451}],430:[function(require,module,exports){
/**
 * @file ES6-compliant shim for RequireObjectCoercible.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-requireobjectcoercible|7.2.1 RequireObjectCoercible ( argument )}
 * @version 1.4.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module require-object-coercible-x
 */

'use strict';

var isNil = require('is-nil-x');

/**
 * The abstract operation RequireObjectCoercible throws an error if argument
 * is a value that cannot be converted to an Object using ToObject.
 *
 * @param {*} value - The `value` to check.
 * @throws {TypeError} If `value` is a `null` or `undefined`.
 * @returns {string} The `value`.
 * @example
 * var RequireObjectCoercible = require('require-object-coercible-x');
 *
 * RequireObjectCoercible(); // TypeError
 * RequireObjectCoercible(null); // TypeError
 * RequireObjectCoercible('abc'); // 'abc'
 * RequireObjectCoercible(true); // true
 * RequireObjectCoercible(Symbol('foo')); // Symbol('foo')
 */
module.exports = function RequireObjectCoercible(value) {
  if (isNil(value)) {
    throw new TypeError('Cannot call method on ' + value);
  }

  return value;
};

},{"is-nil-x":174}],431:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],432:[function(require,module,exports){
/**
 * @file Like ES6 ToString but handles Symbols too.
 * @see {@link https://github.com/Xotic750/to-string-x|to-string-x}
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module safe-to-string-x
 */

'use strict';

var isSymbol = require('is-symbol');
var pToString = require('has-symbol-support-x') && Symbol.prototype.toString;

/**
 * The abstract operation `safeToString` converts a `Symbol` literal or
 * object to `Symbol()` instead of throwing a `TypeError`.
 *
 * @param {*} value - The value to convert to a string.
 * @returns {string} The converted value.
 * @example
 * var safeToString = require('safe-to-string-x');
 *
 * safeToString(); // 'undefined'
 * safeToString(null); // 'null'
 * safeToString('abc'); // 'abc'
 * safeToString(true); // 'true'
 * safeToString(Symbol('foo')); // 'Symbol(foo)'
 * safeToString(Symbol.iterator); // 'Symbol(Symbol.iterator)'
 * safeToString(Object(Symbol.iterator)); // 'Symbol(Symbol.iterator)'
 */
module.exports = function safeToString(value) {
  return pToString && isSymbol(value) ? pToString.call(value) : String(value);
};

},{"has-symbol-support-x":124,"is-symbol":188}],433:[function(require,module,exports){
/**
 * @file Determines whether two values are the same value.
 * @version 1.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module same-value-x
 */

'use strict';

var numberIsNaN = require('is-nan-x');

/**
 * This method is the comparison abstract operation SameValue(x, y), where x
 * and y are ECMAScript language values, produces true or false.
 *
 * @param {*} value1 - The first value to compare.
 * @param {*} value2 - The second value to compare.
 * @returns {boolean} A Boolean indicating whether or not the two arguments are
 *  the same value.
 * @example
 * var sameValue = require('same-value-x');
 *
 * sameValue(1, 1); // true
 * sameValue(true, true); // true
 * sameValue(NaN, NaN); // true
 * sameValue(true, false); // false
 * sameValue(0, -0); // false
 */
module.exports = function sameValue(value1, value2) {
  if (value1 === 0 && value2 === 0) {
    return 1 / value1 === 1 / value2;
  }

  if (value1 === value2) {
    return true;
  }

  return numberIsNaN(value1) && numberIsNaN(value2);
};

},{"is-nan-x":168}],434:[function(require,module,exports){
/**
 * @file ES6-compliant shim for SameValueZero.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero|7.2.10 SameValueZero(x, y)}
 * @version 1.3.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module same-value-zero-x
 */

'use strict';

var sameValue = require('same-value-x');

/**
 * This method determines whether two values are the same value.
 * SameValueZero differs from SameValue (`Object.is`) only in its treatment
 * of +0 and -0.
 *
 * @param {*} x - The first value to compare.
 * @param {*} y - The second value to compare.
 * @returns {boolean} A Boolean indicating whether or not the two arguments
 * are the same value.
 * @example
 * var sameValueZero = require('same-value-zero-x');
 * sameValueZero(0, 0); // true
 * sameValueZero(-0, -0); // true
 * sameValueZero(0, -0); // true
 * sameValueZero(NaN, NaN); //true
 * sameValueZero(Infinity, Infinity); // true
 * sameValueZero(-Infinity, -Infinity); // true
 */
module.exports = function sameValueZero(x, y) {
  return x === y || sameValue(x, y);
};

},{"same-value-x":433}],435:[function(require,module,exports){
/**
 * @file Tests if a value is a string with the boxed bug; splits to an array.
 * @version 1.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module split-if-boxed-bug-x
 */

'use strict';

var strSplit;
var isString;
if (require('has-boxed-string-x') === false) {
  strSplit = ''.split;
  isString = typeof strSplit === 'function' && require('is-string');
}

/**
 * This method tests if a value is a string with the boxed bug; splits to an
 * array for iteration; otherwise returns the original value.
 *
 * @param {*} value - The value to be tested.
 * @returns {*} An array or characters if value was a string with the boxed bug;
 *  otherwise the value.
 * @example
 * var splitIfBoxedBug = require('split-if-boxed-bug-x');
 *
 * // No boxed bug
 * splitIfBoxedBug('abc'); // 'abc'
 *
 * // Boxed bug
 * splitIfBoxedBug('abc'); // ['a', 'b', 'c']
 */
module.exports = function splitIfBoxedBug(value) {
  return isString && isString(value) ? strSplit.call(value, '') : value;
};


},{"has-boxed-string-x":121,"is-string":186}],436:[function(require,module,exports){
/**
 * @file Pads a string with another string (repeated, if needed).
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module string-pad-start-x
 */

'use strict';

var requireObjectCoercible = require('require-object-coercible-x');
var toStr = require('to-string-x');
var toLength = require('to-length-x').toLength2018;
var isUndefined = require('validate.io-undefined');
var strSlice = String.prototype.slice;

/**
 * This method pads the current string with another string (repeated, if needed)
 * so that the resulting string reaches the given length. The padding is applied
 * from the start (left) of the current string.
 *
 * @param {string} string - The string to pad.
 * @throws {TypeError} If target is null or undefined.
 * @param {number} targetLength - The length of the resulting string once the
 *  current string has been padded. If the value is lower than the current
 *  string's length, the current string will be returned as is.
 * @param {string} [padString] - The string to pad the current string with. If
 *  this string is too long to stay within the target length, it will be
 *  truncated and the left-most part will be applied. The default value for this
 *  parameter is " " (U+0020).
 * @returns {string} A String of the specified length with the pad string
 *  applied from the start.
 * @example
 * var padStart = require('string-pad-start-x');
 *
 * padStart('a', 3, 'b'); // 'bba'
 * padStart('a', 3); // '  a'
 * padStart('a', 2, 'bc'); // 'ba'
 */
module.exports = function padStart(string, targetLength) {
  var str = toStr(requireObjectCoercible(string));
  var stringLength = toLength(str.length);
  var fillString;
  if (arguments.length > 2) {
    fillString = arguments[2];
  }

  var filler = isUndefined(fillString) ? '' : toStr(fillString);
  if (filler === '') {
    filler = ' ';
  }

  var intMaxLength = toLength(targetLength);
  if (intMaxLength <= stringLength) {
    return str;
  }

  var fillLen = intMaxLength - stringLength;
  while (filler.length < fillLen) {
    var fLen = filler.length;
    var remainingCodeUnits = fillLen - fLen;
    filler += fLen > remainingCodeUnits ? strSlice.call(filler, 0, remainingCodeUnits) : filler;
  }

  var truncatedStringFiller = filler.length > fillLen ? strSlice.call(filler, 0, fillLen) : filler;

  return truncatedStringFiller + str;
};

},{"require-object-coercible-x":430,"to-length-x":441,"to-string-x":451,"validate.io-undefined":459}],437:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":424,"timers":437}],438:[function(require,module,exports){
/**
 * @file Converts argument to a value of type Boolean.
 * @version 1.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-boolean-x
 */

'use strict';

/**
 * The abstract operation ToBoolean converts argument to a value of type Boolean.
 *
 * @param {*} value - The value to be converted.
 * @returns {boolean} 'true' if value is truthy; otherwise 'false'.
 * @example
 * var toBoolean = require('to-boolean-x');
 *
 * toBoolean(null); // false
 * toBoolean(''); // false
 * toBoolean(1); // true
 * toBoolean('0'); // true
 */
module.exports = function toBoolean(value) {
  return !!value;
};

},{}],439:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"dup":134,"is-finite-x":161,"is-nan-x":168,"math-sign-x":396,"to-number-x":442}],440:[function(require,module,exports){
/**
 * @file Cross-browser toISOString support.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-iso-string-x
 */

'use strict';

var nativeToISOString = typeof Date.prototype.toISOString === 'function' && Date.prototype.toISOString;

var isWorking;
if (nativeToISOString) {
  var attempt = require('attempt-x');
  var res = attempt.call(new Date(0), nativeToISOString);
  isWorking = res.threw === false && res.value === '1970-01-01T00:00:00.000Z';
  if (isWorking) {
    res = attempt.call(new Date(-62198755200000), nativeToISOString);
    isWorking = res.threw === false && res.value.indexOf('-000001') > -1;
  }

  if (isWorking) {
    res = attempt.call(new Date(-1), nativeToISOString);
    isWorking = res.threw === false && res.value === '1969-12-31T23:59:59.999Z';
  }
}

var $toISOString;
if (isWorking) {
  $toISOString = function toISOString(date) {
    return nativeToISOString.call(date);
  };
} else {
  var isDate = require('is-date-object');
  var padStart = require('string-pad-start-x');
  var map = require('array-map-x');
  var arraySlice = require('array-slice-x');
  var join = Array.prototype.join;

  $toISOString = function toISOString(date) {
    if (isDate(date) === false) {
      throw new TypeError('toISOString called on incompatible receiver.');
    }

    if (isFinite(date) === false || isFinite(date.getTime()) === false) {
      // Adope Photoshop requires the second check.
      throw new RangeError('toISOString called on non-finite value.');
    }

    var year = date.getUTCFullYear();
    var month = date.getUTCMonth();
    // see https://github.com/es-shims/es5-shim/issues/111
    year += (month / 12) >> 0; // floor
    month = ((month % 12) + 12) % 12;

    // the date time string format is specified in 15.9.1.15.
    var parts = [
      month + 1,
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds()
    ];

    var sign;
    if (year < 0) {
      sign = '-';
    } else if (year > 9999) {
      sign = '+';
    } else {
      sign = '';
    }

    year = sign + padStart(Math.abs(year), sign ? 6 : 4, '0');
    var result = map(parts, function _mapper(item) {
      // pad months, days, hours, minutes, and seconds to have two digits.
      return padStart(item, 2, '0');
    });

    var dateStr = year + '-' + join.call(arraySlice(result, 0, 2), '-');
    // pad milliseconds to have three digits.
    var msStr = padStart(date.getUTCMilliseconds(date), 3, '0');
    var timeStr = join.call(arraySlice(result, 2), ':') + '.' + msStr;

    return dateStr + 'T' + timeStr + 'Z';
  };
}

/**
 * This method returns a string in simplified extended ISO format (ISO 8601),
 * which is always 24 or 27 characters long (YYYY-MM-DDTHH:mm:ss.sssZ or
 * YYYYYY-MM-DDTHH:mm:ss.sssZ, respectively). The timezone is always zero UTC
 * offset, as denoted by the suffix "Z".
 *
 * @param {Object} date A Date object.
 * @throws {TypeError} If date is not a Date object.
 * @throws {RangeError} If date is invalid.
 * @return {string} Given date in the ISO 8601 format according to universal time.

 * @example
 * var toISOString = require('to-iso-string-x');
 * toISOString(new Date(0)); // '1970-01-01T00:00:00.000Z'
 */
module.exports = $toISOString;

},{"array-map-x":15,"array-slice-x":24,"attempt-x":32,"is-date-object":158,"string-pad-start-x":436}],441:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"dup":135,"max-safe-integer":397,"to-integer-x":439}],442:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"cached-constructors-x":36,"dup":136,"nan-x":404,"parse-int-x":422,"to-primitive-x":447,"trim-x":444}],443:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"cached-constructors-x":36,"dup":144,"require-coercible-to-string-x":429,"white-space-x":445}],444:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"dup":137,"trim-left-x":452,"trim-right-x":443}],445:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"dup":145}],446:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToObject.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-toobject|7.1.13 ToObject ( argument )}
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-object-x
 */

'use strict';

var requireObjectCoercible = require('require-object-coercible-x');
var castObject = require('cached-constructors-x').Object;

/**
 * The abstract operation ToObject converts argument to a value of
 * type Object.
 *
 * @param {*} value - The `value` to convert.
 * @throws {TypeError} If `value` is a `null` or `undefined`.
 * @returns {!Object} The `value` converted to an object.
 * @example
 * var ToObject = require('to-object-x');
 *
 * ToObject(); // TypeError
 * ToObject(null); // TypeError
 * ToObject('abc'); // Object('abc')
 * ToObject(true); // Object(true)
 * ToObject(Symbol('foo')); // Object(Symbol('foo'))
 */
module.exports = function toObject(value) {
  return castObject(requireObjectCoercible(value));
};

},{"cached-constructors-x":36,"require-object-coercible-x":430}],447:[function(require,module,exports){
/**
 * @file Converts a JavaScript object to a primitive value.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-primitive-x
 */

'use strict';

var hasSymbols = require('has-symbol-support-x');
var isPrimitive = require('is-primitive');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');
var isFunction = require('is-function-x');
var requireObjectCoercible = require('require-object-coercible-x');
var isNil = require('is-nil-x');
var isUndefined = require('validate.io-undefined');
var symToPrimitive = hasSymbols && Symbol.toPrimitive;
var symValueOf = hasSymbols && Symbol.prototype.valueOf;

var toStringOrder = ['toString', 'valueOf'];
var toNumberOrder = ['valueOf', 'toString'];
var orderLength = 2;

var ordinaryToPrimitive = function _ordinaryToPrimitive(O, hint) {
  requireObjectCoercible(O);
  if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
    throw new TypeError('hint must be "string" or "number"');
  }

  var methodNames = hint === 'string' ? toStringOrder : toNumberOrder;
  var method;
  var result;
  for (var i = 0; i < orderLength; i += 1) {
    method = O[methodNames[i]];
    if (isFunction(method)) {
      result = method.call(O);
      if (isPrimitive(result)) {
        return result;
      }
    }
  }

  throw new TypeError('No default value');
};

var getMethod = function _getMethod(O, P) {
  var func = O[P];
  if (isNil(func) === false) {
    if (isFunction(func) === false) {
      throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
    }

    return func;
  }

  return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive

/**
 * This method converts a JavaScript object to a primitive value.
 * Note: When toPrimitive is called with no hint, then it generally behaves as
 * if the hint were Number. However, objects may over-ride this behaviour by
 * defining a @@toPrimitive method. Of the objects defined in this specification
 * only Date objects (see 20.3.4.45) and Symbol objects (see 19.4.3.4) over-ride
 * the default ToPrimitive behaviour. Date objects treat no hint as if the hint
 * were String.
 *
 * @param {*} input - The input to convert.
 * @param {constructor} [prefferedtype] - The preffered type (String or Number).
 * @throws {TypeError} If unable to convert input to a primitive.
 * @returns {string|number} The converted input as a primitive.
 * @example
 * var toPrimitive = require('to-primitive-x');
 *
 * var date = new Date(0);
 * toPrimitive(date)); // Thu Jan 01 1970 01:00:00 GMT+0100 (CET)
 * toPrimitive(date, String)); // Thu Jan 01 1970 01:00:00 GMT+0100 (CET)
 * toPrimitive(date, Number)); // 0
 */
module.exports = function toPrimitive(input, preferredType) {
  if (isPrimitive(input)) {
    return input;
  }

  var hint = 'default';
  if (arguments.length > 1) {
    if (preferredType === String) {
      hint = 'string';
    } else if (preferredType === Number) {
      hint = 'number';
    }
  }

  var exoticToPrim;
  if (hasSymbols) {
    if (symToPrimitive) {
      exoticToPrim = getMethod(input, symToPrimitive);
    } else if (isSymbol(input)) {
      exoticToPrim = symValueOf;
    }
  }

  if (isUndefined(exoticToPrim) === false) {
    var result = exoticToPrim.call(input, hint);
    if (isPrimitive(result)) {
      return result;
    }

    throw new TypeError('unable to convert exotic object to primitive');
  }

  if (hint === 'default' && (isDate(input) || isSymbol(input))) {
    hint = 'string';
  }

  return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"has-symbol-support-x":124,"is-date-object":158,"is-function-x":162,"is-nil-x":174,"is-primitive":178,"is-symbol":188,"require-object-coercible-x":430,"validate.io-undefined":459}],448:[function(require,module,exports){
/**
 * @file Converts argument to a value that can be used as a property key.
 * @version 2.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-property-key-x
 */

'use strict';

var hasSymbols = require('has-symbol-support-x');
var toPrimitive = require('to-primitive-x');
var toStr = require('to-string-x');

/**
 * This method Converts argument to a value that can be used as a property key.
 *
 * @param {*} argument - The argument to onvert to a property key.
 * @throws {TypeError} If argument is not a symbol and is not coercible to a string.
 * @returns {string|symbol} The converted argument.
 * @example
 * var toPropertyKey = require('to-property-key-x');
 *
 * toPropertyKey(); // 'undefined'
 * toPropertyKey(1); // '1'
 * toPropertyKey(true); // 'true'
 *
 * var symbol = Symbol('a');
 * toPropertyKey(symbol); // symbol
 *
 * toPropertyKey(Object.create(null)); // TypeError
 */
module.exports = function toPropertyKey(argument) {
  var key = toPrimitive(argument, String);
  return hasSymbols && typeof key === 'symbol' ? key : toStr(key);
};

},{"has-symbol-support-x":124,"to-primitive-x":447,"to-string-x":451}],449:[function(require,module,exports){
/**
 * @file ES6 abstract ToString with Symbol conversion support.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tostring|7.1.12 ToString ( argument )}
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-string-symbols-supported-x
 */

'use strict';

var castString = require('cached-constructors-x').String;
var pToString = require('has-symbol-support-x') && Symbol.prototype.toString;
var isSymbol = typeof pToString === 'function' && require('is-symbol');

/**
 * The abstract operation ToString converts argument to a value of type String,
 * however the specification states that if the argument is a Symbol then a
 * 'TypeError' is thrown. This version also allows Symbols be converted to
 * a string. Other uncoercible exotics will still throw though.
 *
 * @param {*} value - The value to convert to a string.
 * @returns {string} The converted value.
 * @example
 * var toStringSymbolsSupported = require('to-string-symbols-supported-x');
 *
 * toStringSymbolsSupported(); // 'undefined'
 * toStringSymbolsSupported(null); // 'null'
 * toStringSymbolsSupported('abc'); // 'abc'
 * toStringSymbolsSupported(true); // 'true'
 * toStringSymbolsSupported(Symbol('foo')); // 'Symbol('foo')'
 * toStringSymbolsSupported(Object(Symbol('foo'))); // 'Symbol('foo')'
 * toStringSymbolsSupported(Object.create(null)); // TypeError
 */
module.exports = function toStringSymbolsSupported(value) {
  return isSymbol && isSymbol(value) ? pToString.call(value) : castString(value);
};

},{"cached-constructors-x":36,"has-symbol-support-x":124,"is-symbol":188}],450:[function(require,module,exports){
/**
 * @file Get an object's ES6 @@toStringTag.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring|19.1.3.6 Object.prototype.toString ( )}
 * @version 1.4.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-string-tag-x
 */

'use strict';

var isNull = require('lodash.isnull');
var isUndefined = require('validate.io-undefined');
var toStr = {}.toString;

/**
 * The `toStringTag` method returns "[object type]", where type is the
 * object type.
 *
 * @param {*} value - The object of which to get the object type string.
 * @returns {string} The object type string.
 * @example
 * var toStringTag = require('to-string-tag-x');
 *
 * var o = new Object();
 * toStringTag(o); // returns '[object Object]'
 */
module.exports = function toStringTag(value) {
  if (isNull(value)) {
    return '[object Null]';
  }

  if (isUndefined(value)) {
    return '[object Undefined]';
  }

  return toStr.call(value);
};

},{"lodash.isnull":191,"validate.io-undefined":459}],451:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToString.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tostring|7.1.12 ToString ( argument )}
 * @version 1.4.5
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-string-x
 */

'use strict';

var castString = require('cached-constructors-x').String;
var isSymbol = require('is-symbol');

/**
 * The abstract operation ToString converts argument to a value of type String.
 *
 * @param {*} value - The value to convert to a string.
 * @throws {TypeError} If `value` is a Symbol.
 * @returns {string} The converted value.
 * @example
 * var $toString = require('to-string-x');
 *
 * $toString(); // 'undefined'
 * $toString(null); // 'null'
 * $toString('abc'); // 'abc'
 * $toString(true); // 'true'
 * $toString(Symbol('foo')); // TypeError
 * $toString(Symbol.iterator); // TypeError
 * $toString(Object(Symbol.iterator)); // TypeError
 * $toString(Object.create(null)); // TypeError
 */
module.exports = function ToString(value) {
  if (isSymbol(value)) {
    throw new TypeError('Cannot convert a Symbol value to a string');
  }

  return castString(value);
};

},{"cached-constructors-x":36,"is-symbol":188}],452:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left end of a string.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-left-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reLeft2016 = new Rx('^[' + require('white-space-x').string2016 + ']+');
var reLeft2018 = new Rx('^[' + require('white-space-x').string2018 + ']+');
var replace = ''.replace;

var $trimLeft2016 = function trimLeft2016(string) {
  return replace.call(requireCoercibleToString(string), reLeft2016, '');
};

var $trimLeft2018 = function trimLeft2018(string) {
  return replace.call(requireCoercibleToString(string), reLeft2018, '');
};

module.exports = {
  /**
   * A reference to leftTrim2018.
   */
  trimLeft: $trimLeft2018,

  /**
   * This method removes whitespace from the left end of a string. (ES2016)
   *
   * @param {string} string - The string to trim the left end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The left trimmed string.
   * @example
   * var trimLeft = require('trim-left-x').trimLeft2016;
   *
   * trimLeft(' \t\na \t\n') === 'a \t\n'; // true
   */
  trimLeft2016: $trimLeft2016,

  /**
   * This method removes whitespace from the left end of a string. (ES2018)
   *
   * @param {string} string - The string to trim the left end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The left trimmed string.
   * @example
   * var trimLeft = require('trim-left-x').trimLeft2018;
   *
   * trimLeft(' \t\na \t\n') === 'a \t\n'; // true
   */
  trimLeft2018: $trimLeft2018
};

},{"cached-constructors-x":36,"require-coercible-to-string-x":429,"white-space-x":453}],453:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"dup":145}],454:[function(require,module,exports){
/**
 * @file This method removes whitespace from the right end of a string.
 * @version 2.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-right-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reRight = new Rx('[' + require('white-space-x').string + ']+$');
var replace = ''.replace;

/**
 * This method removes whitespace from the right end of a string.
 *
 * @param {string} string - The string to trim the right end whitespace from.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @returns {string} The right trimmed string.
 * @example
 * var trimRight = require('trim-right-x');
 *
 * trimRight(' \t\na \t\n') === ' \t\na'; // true
 */
module.exports = function trimRight(string) {
  return replace.call(requireCoercibleToString(string), reRight, '');
};

},{"cached-constructors-x":36,"require-coercible-to-string-x":429,"white-space-x":460}],455:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left and right end of a string.
 * @version 2.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-x
 */

'use strict';

var trimLeft = require('trim-left-x');
var trimRight = require('trim-right-x');

/**
 * This method removes whitespace from the left and right end of a string.
 *
 * @param {string} string - The string to trim the whitespace from.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @returns {string} The trimmed string.
 * @example
 * var trim = require('trim-x');
 *
 * trim(' \t\na \t\n') === 'a'; // true
 */
module.exports = function trim(string) {
  return trimLeft(trimRight(string));
};

},{"trim-left-x":456,"trim-right-x":454}],456:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left end of a string.
 * @version 2.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-left-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reLeft = new Rx('^[' + require('white-space-x').string + ']+');
var replace = ''.replace;

/**
 * This method removes whitespace from the left end of a string.
 *
 * @param {string} string - The string to trim the left end whitespace from.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @returns {string} The left trimmed string.
 * @example
 * var trimLeft = require('trim-left-x');
 *
 * trimLeft(' \t\na \t\n') === 'a \t\n'; // true
 */
module.exports = function trimLeft(string) {
  return replace.call(requireCoercibleToString(string), reLeft, '');
};

},{"cached-constructors-x":36,"require-coercible-to-string-x":429,"white-space-x":460}],457:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":426,"requires-port":431}],458:[function(require,module,exports){
/**
 * @file An implementation of node's util.format
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module util-format-x
 */

'use strict';

var inspect = require('inspect-x');
var JSON3 = require('json3');
var safeToString = require('safe-to-string-x');
var isNull = require('lodash.isnull');

var CIRCULAR_ERROR_MESSAGE;
var tryStringify = function _tryStringify(arg) {
  try {
    return JSON3.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        var a = {};
        a.a = a;
        JSON3.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = e.message;
      }
    }

    if (err.name === 'TypeError' && err.message === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }

    throw err;
  }
};

// eslint-disable-next-line complexity
var format = function _format(f) {
  if (typeof f !== 'string') {
    var objects = new Array(arguments.length);
    for (var index = 0; index < arguments.length; index += 1) {
      objects[index] = inspect(arguments[index]);
    }

    return objects.join(' ');
  }

  if (arguments.length === 1) {
    return f;
  }

  var str = '';
  var a = 1;
  var lastPos = 0;
  for (var i = 0; i < f.length;) {
    if (f.charCodeAt(i) === 37/* '%'*/ && i + 1 < f.length) {
      if (f.charCodeAt(i + 1) !== 37/* '%'*/ && a >= arguments.length) {
        i += 1;
        // eslint-disable-next-line no-continue
        continue; // eslint-disable-line no-restricted-syntax
      }

      switch (f.charCodeAt(i + 1)) {
      case 100: // 'd'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += Number(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 105: // 'i'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += parseInt(arguments[a], 10);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 102: // 'f'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += parseFloat(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 106: // 'j'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += tryStringify(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 115: // 's'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += safeToString(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 37: // '%'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += '%';
        // eslint-disable-next-line no-restricted-syntax
        break;
      default: // any other character is not a correct placeholder
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += '%';
        i += 1;
        lastPos = i;
        // eslint-disable-next-line no-continue
        continue; // eslint-disable-line no-restricted-syntax
      }

      i += 2;
      lastPos = i;
      // eslint-disable-next-line no-continue
      continue; // eslint-disable-line no-restricted-syntax
    }

    i += 1;
  }

  if (lastPos === 0) {
    str = f;
  } else if (lastPos < f.length) {
    str += f.slice(lastPos);
  }

  while (a < arguments.length) {
    var x = arguments[a];
    a += 1;

    if (isNull(x) || (typeof x !== 'object' && typeof x !== 'symbol')) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
};

/**
 * The format() method returns a formatted string using the first argument as a
 * printf-like format.
 *
 * The first argument is a string containing zero or more placeholder tokens.
 * Each placeholder token is replaced with the converted value from the
 * corresponding argument. Supported placeholders are:
 *
 * %s - String.
 * %d - Number (integer or floating point value).
 * %i - Integer.
 * %f - Floating point value.
 * %j - JSON. Replaced with the string '[Circular]' if the argument contains circular references.
 * %% - single percent sign ('%'). This does not consume an argument.
 *
 * @param {string} f - Template.
 * @param {*} [...args] - Values.
 * @returns {*} The target.
 * @example
 * var format = require('util-format-x');
 *
 * // If the placeholder does not have a corresponding argument,
 * // the placeholder is not replaced.
 * format('%s:%s', 'foo'); // Returns: 'foo:%s'
 *
 * // If there are more arguments passed to the format() method than the number
 * // of placeholders, the extra arguments are coerced into strings (for objects
 * // and symbols, inspect() is used) then concatenated to the returned
 * // string, each delimited by a space.
 * format('%s:%s', 'foo', 'bar', 'baz'); // 'foo:bar baz'
 *
 * // If the first argument is not a format string then format() returns a
 * // string that is the concatenation of all arguments separated by spaces.
 * // Each argument is converted to a string using inspect().
 * format(1, 2, 3); // '1 2 3'
 *
 * // If only one argument is passed to format(), it is returned as it is
 * //without any formatting.
 * format('%% %s'); // '%% %s'
 */
module.exports = format;

},{"inspect-x":147,"json3":190,"lodash.isnull":191,"safe-to-string-x":432}],459:[function(require,module,exports){
/**
*
*	VALIDATE: undefined
*
*
*	DESCRIPTION:
*		- Validates if a value is undefined.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isUndefined( value )
*	Validates if a value is undefined.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is undefined
*/
function isUndefined( value ) {
	return value === void 0;
} // end FUNCTION isUndefined()


// EXPORTS //

module.exports = isUndefined;

},{}],460:[function(require,module,exports){
/**
 * @file List of ECMAScript5 white space characters.
 * @version 2.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module white-space-x
 */

'use strict';

/**
 * An array of the ES5 whitespace char codes, string, and their descriptions.
 *
 * @name list
 * @type Array.<Object>
 * @example
 * var whiteSpace = require('white-space-x');
 * whiteSpaces.list.foreach(function (item) {
 *   console.log(lib.description, item.code, item.string);
 * });
 */
var list = [
  {
    code: 0x0009,
    description: 'Tab',
    string: '\u0009'
  },
  {
    code: 0x000a,
    description: 'Line Feed',
    string: '\u000a'
  },
  {
    code: 0x000b,
    description: 'Vertical Tab',
    string: '\u000b'
  },
  {
    code: 0x000c,
    description: 'Form Feed',
    string: '\u000c'
  },
  {
    code: 0x000d,
    description: 'Carriage Return',
    string: '\u000d'
  },
  {
    code: 0x0020,
    description: 'Space',
    string: '\u0020'
  },
  /*
  {
    code: 0x0085,
    description: 'Next line - Not ES5 whitespace',
    string: '\u0085'
  }
  */
  {
    code: 0x00a0,
    description: 'No-break space',
    string: '\u00a0'
  },
  {
    code: 0x1680,
    description: 'Ogham space mark',
    string: '\u1680'
  },
  {
    code: 0x180e,
    description: 'Mongolian vowel separator',
    string: '\u180e'
  },
  {
    code: 0x2000,
    description: 'En quad',
    string: '\u2000'
  },
  {
    code: 0x2001,
    description: 'Em quad',
    string: '\u2001'
  },
  {
    code: 0x2002,
    description: 'En space',
    string: '\u2002'
  },
  {
    code: 0x2003,
    description: 'Em space',
    string: '\u2003'
  },
  {
    code: 0x2004,
    description: 'Three-per-em space',
    string: '\u2004'
  },
  {
    code: 0x2005,
    description: 'Four-per-em space',
    string: '\u2005'
  },
  {
    code: 0x2006,
    description: 'Six-per-em space',
    string: '\u2006'
  },
  {
    code: 0x2007,
    description: 'Figure space',
    string: '\u2007'
  },
  {
    code: 0x2008,
    description: 'Punctuation space',
    string: '\u2008'
  },
  {
    code: 0x2009,
    description: 'Thin space',
    string: '\u2009'
  },
  {
    code: 0x200a,
    description: 'Hair space',
    string: '\u200a'
  },
  /*
  {
    code: 0x200b,
    description: 'Zero width space - Not ES5 whitespace',
    string: '\u200b'
  },
  */
  {
    code: 0x2028,
    description: 'Line separator',
    string: '\u2028'
  },
  {
    code: 0x2029,
    description: 'Paragraph separator',
    string: '\u2029'
  },
  {
    code: 0x202f,
    description: 'Narrow no-break space',
    string: '\u202f'
  },
  {
    code: 0x205f,
    description: 'Medium mathematical space',
    string: '\u205f'
  },
  {
    code: 0x3000,
    description: 'Ideographic space',
    string: '\u3000'
  },
  {
    code: 0xfeff,
    description: 'Byte Order Mark',
    string: '\ufeff'
  }
];

var string = '';
var length = list.length;
for (var i = 0; i < length; i += 1) {
  string += list[i].string;
}

/**
 * A string of the ES5 whitespace characters.
 *
 * @name string
 * @type string
 * @example
 * var whiteSpace = require('white-space-x');
 * var characters = [
 *   '\u0009',
 *   '\u000a',
 *   '\u000b',
 *   '\u000c',
 *   '\u000d',
 *   '\u0020',
 *   '\u00a0',
 *   '\u1680',
 *   '\u180e',
 *   '\u2000',
 *   '\u2001',
 *   '\u2002',
 *   '\u2003',
 *   '\u2004',
 *   '\u2005',
 *   '\u2006',
 *   '\u2007',
 *   '\u2008',
 *   '\u2009',
 *   '\u200a',
 *   '\u2028',
 *   '\u2029',
 *   '\u202f',
 *   '\u205f',
 *   '\u3000',
 *   '\ufeff'
 * ];
 * var ws = characters.join('');
 * var re1 = new RegExp('^[' + whiteSpace.string + ']+$)');
 * re1.test(ws); // true
 */
module.exports = {
  list: list,
  string: string
};

},{}],461:[function(require,module,exports){
"use strict";

module.exports = {};
},{}],462:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          {{ req.ip }}\xA0\n          [{{ req.id ? req.id : new Date().toUTCString() }}]\xA0\n          \"\n          {{ req.method }}\xA0\n          {{ req.url }}\xA0\n          HTTP/{{ req.httpVersionMajor }}.{{ req.httpVersionMinor }}\n          \"\xA0\n          {{ res.statusCode }}\xA0\n          {{ res.get('X-Response-Time') }}\n        "], ["\n          {{ req.ip }}\\u00A0\n          [{{ req.id ? req.id : new Date().toUTCString() }}]\\u00A0\n          \"\n          {{ req.method }}\\u00A0\n          {{ req.url }}\\u00A0\n          HTTP/{{ req.httpVersionMajor }}.{{ req.httpVersionMinor }}\n          \"\\u00A0\n          {{ res.statusCode }}\\u00A0\n          {{ res.get('X-Response-Time') }}\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Axe = require('axe');

var parseRequest = require('parse-request');

var parseErr = require('parse-err');

var onFinished = require('on-finished');

var safeStringify = require('fast-safe-stringify'); // <https://lacke.mn/reduce-your-bundle-js-file-size/>
// <https://github.com/lodash/babel-plugin-lodash/issues/221>


var isUndefined = require('lodash/isUndefined');

var isNull = require('lodash/isNull');

var isFunction = require('lodash/isFunction');

var isError = require('lodash/isError');

var isArray = require('lodash/isArray');

var isString = require('lodash/isString');

var isNumber = require('lodash/isNumber');

var isObject = require('lodash/isObject');

var isEmpty = require('lodash/isEmpty');

var tmpl = require('lodash/template');

var _require = require('common-tags'),
    oneLineTrim = _require.oneLineTrim;

var appInfo = require('./app-info');

var Cabin =
/*#__PURE__*/
function () {
  function Cabin(config) {
    var _this = this;

    _classCallCheck(this, Cabin);

    this.config = _objectSpread({
      key: '',
      axe: {},
      logger: null,
      meta: {},
      // <https://github.com/niftylettuce/parse-request>
      userFields: undefined,
      // <https://github.com/niftylettuce/parse-err>
      fields: [],
      message: oneLineTrim(_templateObject()),
      // <https://lodash.com/docs#template>
      templateSettings: {
        interpolate: /{{([\s\S]+?)}}/g
      }
    }, config); // override key with root key in case user forgot

    if (!isEmpty(this.config.axe) && this.config.key) this.config.axe.key = this.config.key;
    if (!isEmpty(this.config.axe)) this.config.logger = new Axe(this.config.axe);else if (this.config.key) this.config.logger = new Axe({
      key: this.config.key
    });
    if (!isObject(this.config.logger)) this.config.logger = new Axe(); // bind the logger

    this.logger = this.config.logger; // parse arg helper

    this.parseArg = this.parseArg.bind(this); // bind helper functions for each log level

    Object.keys(this.logger).filter(function (key) {
      return isFunction(_this.logger[key]);
    }).forEach(function (level) {
      _this[level] = function () {
        var _this$logger;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        args[1] = _this.parseArg(args[1]);

        (_this$logger = _this.logger)[level].apply(_this$logger, _toConsumableArray([].slice.call(args)));
      };
    }); // aliases

    this.err = this.error;
    this.warning = this.warn; // we'd use `auto-bind` package but unfortunately it
    // doesn't have a compiled version without `const` etc

    this.setMeta = this.setMeta.bind(this);
    this.setUser = this.setUser.bind(this);
    this.middleware = this.middleware.bind(this); // backwards compatibility with older `getMeta` method

    this.getMeta = parseRequest; // expose parseRequest and parseErr

    this.parseRequest = parseRequest;
    this.parseErr = parseErr;
  }

  _createClass(Cabin, [{
    key: "parseArg",
    value: function parseArg(arg) {
      if (isUndefined(arg) || isNull(arg)) arg = {};
      if (isError(arg)) arg = {
        err: parseErr(arg, this.config.fields)
      };
      if (isArray(arg)) arg = {
        value: arg
      };
      if (isString(arg)) arg = {
        value: arg
      };
      if (isNumber(arg)) arg = {
        value: arg
      };
      if (isFunction(arg)) arg = {
        value: arg.toString()
      };
      if (!isObject(arg)) arg = {};
      Object.assign(arg, this.config.meta);
      return arg;
    }
  }, {
    key: "setMeta",
    value: function setMeta() {
      var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.config.meta = meta;
    }
  }, {
    key: "setUser",
    value: function setUser() {
      var user = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.config.meta.user = user;
    } // TODO: this should probably not be in the browser bundled version
    // and we should do some `require('./middleware')` with a
    // `"browser": { "./middleware": }` rewrite that includes
    // something else that can be consumed by xhook or something

  }, {
    key: "middleware",
    value: function middleware() {
      var _this2 = this;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var isExpress = !isUndefined(args[2]) && isFunction(args[2]);
      var req = isExpress ? args[0] : args[0].req;
      var res = isExpress ? args[1] : args[0].res;
      var next = isExpress ? args[2] : args[1];
      var logger = {};
      Object.keys(this.logger).filter(function (key) {
        return isFunction(_this2.logger[key]);
      }).forEach(function (key) {
        logger[key] = function () {
          var _this2$logger;

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          args[1] = _this2.parseArg(args[1]); // add `app` object to metadata

          Object.assign(args[1], appInfo); // add `request` object to metadata

          Object.assign(args[1], parseRequest(req, _this2.config.userFields));

          (_this2$logger = _this2.logger)[key].apply(_this2$logger, _toConsumableArray([].slice.call(args)));
        };
      }); // store a copy of the request body
      // in case we modified it in our middleware
      // (a common practice unfortunately)

      var body = safeStringify(req.body); // upon completion of a response we need to log it

      onFinished(res, function (err, res) {
        if (err) return logger.error(err);
        var level = 'info';
        if (res.statusCode >= 500) level = 'error';else if (res.statusCode >= 400) level = 'warn';
        logger[level](tmpl(_this2.config.message, _objectSpread({}, _this2.config.templateSettings))({
          req: _objectSpread({}, req, {
            body: body
          }),
          res: isExpress ? res : args[0].response
        }).trim());
      }); // add `log` (shorthand) and `logger` methods
      // `req.log`
      // `res.log`
      // `ctx.req`
      // `ctx.res`
      // `ctx.request`
      // `ctx.response`
      // <https://github.com/pinojs/koa-pino-logger/issues/14>
      // <https://github.com/pinojs/koa-pino-logger/blob/master/logger.js#L11>
      // <https://github.com/pinojs/pino-http/blob/master/logger.js#L55>

      req.log = logger;
      res.log = logger;
      req.logger = logger;
      res.logger = logger;

      if (!isExpress) {
        var ctx = args[0];
        ctx.log = logger;
        ctx.logger = logger;
        ctx.request.log = logger;
        ctx.request.logger = logger;
        ctx.response.log = logger;
        ctx.response.logger = logger;
      }

      return next();
    }
  }]);

  return Cabin;
}();

Cabin.Axe = Axe;
Cabin.parseRequest = parseRequest;
Cabin.parseErr = parseErr;
module.exports = Cabin;
},{"./app-info":461,"axe":33,"common-tags":55,"fast-safe-stringify":104,"lodash/isArray":360,"lodash/isEmpty":363,"lodash/isError":364,"lodash/isFunction":365,"lodash/isNull":368,"lodash/isNumber":369,"lodash/isObject":370,"lodash/isString":374,"lodash/isUndefined":377,"lodash/template":388,"on-finished":420,"parse-err":421,"parse-request":423}]},{},[462])(462)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL2FnZW50LWJhc2UuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9AbGFkanMvc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL0BsYWRqcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LWZpbHRlci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LWZvci1lYWNoLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktaW5jbHVkZXMteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1pbmNsdWRlcy14L25vZGVfbW9kdWxlcy9pcy1maW5pdGUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1pbmNsdWRlcy14L25vZGVfbW9kdWxlcy9tYXRoLXNpZ24teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1pbmNsdWRlcy14L25vZGVfbW9kdWxlcy90by1pbnRlZ2VyLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktaW5jbHVkZXMteC9ub2RlX21vZHVsZXMvdG8tbGVuZ3RoLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktbGlrZS1zbGljZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LW1hcC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LW1hcC14L25vZGVfbW9kdWxlcy9hc3NlcnQtaXMtZnVuY3Rpb24teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1yZWR1Y2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1yZWR1Y2UteC9ub2RlX21vZHVsZXMvbWF0aC1zaWduLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktcmVkdWNlLXgvbm9kZV9tb2R1bGVzL3BhcnNlLWludC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXJlZHVjZS14L25vZGVfbW9kdWxlcy90by1pbnRlZ2VyLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktcmVkdWNlLXgvbm9kZV9tb2R1bGVzL3RvLWxlbmd0aC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXJlZHVjZS14L25vZGVfbW9kdWxlcy90by1udW1iZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1zbGljZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXNvbWUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQtaXMtZnVuY3Rpb24teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQtaXMtb2JqZWN0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXR0ZW1wdC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4ZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlnLWNvdW50ZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ib29sZWFuL2Rpc3QvYm9vbGVhbi5qcyIsIm5vZGVfbW9kdWxlcy9jYWNoZWQtY29uc3RydWN0b3JzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FsY3VsYXRlLWZyb20taW5kZXgteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xsZWN0aW9ucy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbGxlY3Rpb25zLXgvbm9kZV9tb2R1bGVzL2hhcy1vd24tcHJvcGVydHkteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvVGVtcGxhdGVUYWcvVGVtcGxhdGVUYWcuanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL1RlbXBsYXRlVGFnL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9jb2RlQmxvY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL2NvbW1hTGlzdHMvY29tbWFMaXN0cy5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvY29tbWFMaXN0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvY29tbWFMaXN0c0FuZC9jb21tYUxpc3RzQW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9jb21tYUxpc3RzQW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9jb21tYUxpc3RzT3IvY29tbWFMaXN0c09yLmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9jb21tYUxpc3RzT3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL2h0bWwvaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvaHRtbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL2lubGluZUFycmF5VHJhbnNmb3JtZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL2lubGluZUFycmF5VHJhbnNmb3JtZXIvaW5saW5lQXJyYXlUcmFuc2Zvcm1lci5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvaW5saW5lTGlzdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL2lubGluZUxpc3RzL2lubGluZUxpc3RzLmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9vbmVMaW5lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9vbmVMaW5lL29uZUxpbmUuanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL29uZUxpbmVDb21tYUxpc3RzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9vbmVMaW5lQ29tbWFMaXN0cy9vbmVMaW5lQ29tbWFMaXN0cy5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvb25lTGluZUNvbW1hTGlzdHNBbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL29uZUxpbmVDb21tYUxpc3RzQW5kL29uZUxpbmVDb21tYUxpc3RzQW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9vbmVMaW5lQ29tbWFMaXN0c09yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9vbmVMaW5lQ29tbWFMaXN0c09yL29uZUxpbmVDb21tYUxpc3RzT3IuanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL29uZUxpbmVJbmxpbmVMaXN0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvb25lTGluZUlubGluZUxpc3RzL29uZUxpbmVJbmxpbmVMaXN0cy5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvb25lTGluZVRyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL29uZUxpbmVUcmltL29uZUxpbmVUcmltLmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9yZW1vdmVOb25QcmludGluZ1ZhbHVlc1RyYW5zZm9ybWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9yZW1vdmVOb25QcmludGluZ1ZhbHVlc1RyYW5zZm9ybWVyL3JlbW92ZU5vblByaW50aW5nVmFsdWVzVHJhbnNmb3JtZXIuanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL3JlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvcmVwbGFjZVJlc3VsdFRyYW5zZm9ybWVyL3JlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lci5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvcmVwbGFjZVN0cmluZ1RyYW5zZm9ybWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9yZXBsYWNlU3RyaW5nVHJhbnNmb3JtZXIvcmVwbGFjZVN0cmluZ1RyYW5zZm9ybWVyLmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9yZXBsYWNlU3Vic3RpdHV0aW9uVHJhbnNmb3JtZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL3JlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lci9yZXBsYWNlU3Vic3RpdHV0aW9uVHJhbnNmb3JtZXIuanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL3NhZmVIdG1sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9zYWZlSHRtbC9zYWZlSHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvc291cmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9zcGxpdFN0cmluZ1RyYW5zZm9ybWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9zcGxpdFN0cmluZ1RyYW5zZm9ybWVyL3NwbGl0U3RyaW5nVHJhbnNmb3JtZXIuanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL3N0cmlwSW5kZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9zdHJpcEluZGVudC9zdHJpcEluZGVudC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvc3RyaXBJbmRlbnRUcmFuc2Zvcm1lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvc3RyaXBJbmRlbnRUcmFuc2Zvcm1lci9zdHJpcEluZGVudFRyYW5zZm9ybWVyLmpzIiwibm9kZV9tb2R1bGVzL2NvbW1vbi10YWdzL3NyYy9zdHJpcEluZGVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL3N0cmlwSW5kZW50cy9zdHJpcEluZGVudHMuanMiLCJub2RlX21vZHVsZXMvY29tbW9uLXRhZ3Mvc3JjL3RyaW1SZXN1bHRUcmFuc2Zvcm1lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21tb24tdGFncy9zcmMvdHJpbVJlc3VsdFRyYW5zZm9ybWVyL3RyaW1SZXN1bHRUcmFuc2Zvcm1lci5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb25zb2xlLXBvbHlmaWxsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nvb2tpZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jdWlkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N1aWQvbGliL2ZpbmdlcnByaW50LmJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY3VpZC9saWIvcGFkLmpzIiwibm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VlLWZpcnN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9lczIwMTUuanMiLCJub2RlX21vZHVsZXMvZXMtdG8tcHJpbWl0aXZlL2VzNi5qcyIsIm5vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvaGVscGVycy9pc1ByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZpbmQtaW5kZXgteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zvcm1hdC1zcGVjaWZpZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtZnVuY3Rpb24tbmFtZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1vd24tZW51bWVyYWJsZS1wcm9wZXJ0eS1zeW1ib2xzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LW93bi1lbnVtZXJhYmxlLXByb3BlcnR5LXN5bWJvbHMteC9ub2RlX21vZHVsZXMvYXJyYXktZmlsdGVyLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1vd24tcHJvcGVydHktc3ltYm9scy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1wcm90b3R5cGUtb2YteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtYm94ZWQtc3RyaW5nLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLW93bi1wcm9wZXJ0eS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1yZWZsZWN0LXN1cHBvcnQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9sLXN1cHBvcnQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtdG8tc3RyaW5nLXRhZy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXgtb2YteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgvbm9kZV9tb2R1bGVzL21hdGgtc2lnbi14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgvbm9kZV9tb2R1bGVzL3BhcnNlLWludC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgvbm9kZV9tb2R1bGVzL3RvLWludGVnZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L25vZGVfbW9kdWxlcy90by1sZW5ndGgteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L25vZGVfbW9kdWxlcy90by1udW1iZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L25vZGVfbW9kdWxlcy90cmltLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXgtb2YteC9ub2RlX21vZHVsZXMvZmluZC1pbmRleC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL3RyaW0tcmlnaHQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy90cmltLXJpZ2h0LXgvbm9kZV9tb2R1bGVzL3doaXRlLXNwYWNlLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5maW5pdHkteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbnNwZWN0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5zcGVjdC14L25vZGVfbW9kdWxlcy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWFycmF5LWJ1ZmZlci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWFycmF5LWxpa2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hcnJheS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWFzeW5jLWZ1bmN0aW9uLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYm9vbGVhbi1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGF0YS12aWV3LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGF0ZS1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZXJyb3IteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mYWxzZXkteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1maW5pdGUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1pbmRleC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWludGVnZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1sZW5ndGgteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1tYXAteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uYW4teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uZWdhdGl2ZS16ZXJvL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLW5pbC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLW51bWJlci1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtb2JqZWN0LWxpa2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1vYmplY3QtbGlrZS14L25vZGVfbW9kdWxlcy9pcy1wcmltaXRpdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcHJpbWl0aXZlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXByb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXhwLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXhwLXgvbm9kZV9tb2R1bGVzL2Fzc2VydC1pcy1vYmplY3QteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1yZWdleHAteC9ub2RlX21vZHVsZXMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXNhZmUtaW50ZWdlci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXNldC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1zdXJyb2dhdGUtcGFpci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXN5bWJvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uMy9saWIvanNvbjMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzbnVsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTbGljZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbnNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jdXN0b21PbWl0Q2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VzY2FwZUh0bWxDaGFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcGFyZW50LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVFc2NhcGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19yZUV2YWx1YXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcmVJbnRlcnBvbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvYXNzaWduSW5XaXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9hdHRlbXB0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmVEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2VzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2luY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNOdW1iZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNVbmRlZmluZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbGFzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWFwVmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9vbWl0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RlbXBsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90ZW1wbGF0ZVNldHRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3ZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRoLWNsYW1wLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWF4LXNhZmUtaW50ZWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZXNzYWdlLWhlYWRlcnMvYWxsLmpzb24iLCJub2RlX21vZHVsZXMvbWVzc2FnZS1oZWFkZXJzL2RlcHJlY2F0ZWQuanNvbiIsIm5vZGVfbW9kdWxlcy9tZXNzYWdlLWhlYWRlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVzc2FnZS1oZWFkZXJzL3Blcm1hbmVudC5qc29uIiwibm9kZV9tb2R1bGVzL21lc3NhZ2UtaGVhZGVycy9wcm92aXNpb25hbC5qc29uIiwibm9kZV9tb2R1bGVzL21lc3NhZ2UtaGVhZGVycy9zdGFuZGFyZC5qc29uIiwibm9kZV9tb2R1bGVzL25hbi14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25vcm1hbGl6ZS1zcGFjZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduLXgvbm9kZV9tb2R1bGVzL2FycmF5LXJlZHVjZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24teC9ub2RlX21vZHVsZXMvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24teC9ub2RlX21vZHVsZXMvb2JqZWN0LWtleXMteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1rZXlzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvb24tZmluaXNoZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2UtZXJyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS1yZXF1ZXN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvcGVydHktaXMtZW51bWVyYWJsZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlZmxlY3Qtb3duLWtleXMteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXBsYWNlLWNvbW1lbnRzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVxdWlyZS1jb2VyY2libGUtdG8tc3RyaW5nLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLXRvLXN0cmluZy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhbWUtdmFsdWUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYW1lLXZhbHVlLXplcm8teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGxpdC1pZi1ib3hlZC1idWcteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmctcGFkLXN0YXJ0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90by1ib29sZWFuLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG8taXNvLXN0cmluZy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLW9iamVjdC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXByaW1pdGl2ZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXByb3BlcnR5LWtleS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXN0cmluZy1zeW1ib2xzLXN1cHBvcnRlZC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXN0cmluZy10YWcteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1zdHJpbmcteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmltLWxlZnQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmltLXJpZ2h0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpbS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyaW0teC9ub2RlX21vZHVsZXMvdHJpbS1sZWZ0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZm9ybWF0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFsaWRhdGUuaW8tdW5kZWZpbmVkL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93aGl0ZS1zcGFjZS14L2luZGV4LmpzIiwic3JjL2FwcC1pbmZvLmJyb3dzZXIuanMiLCJzcmMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0NBOzs7O0lBSXFCLFc7QUFDbkI7Ozs7OztBQU1BLHlCQUE2QjtBQUFBOztBQUFBLHNDQUFkLFlBQWM7QUFBZCxrQkFBYztBQUFBOztBQUFBOztBQUFBLFNBdUI3QixHQXZCNkIsR0F1QnZCLFVBQUMsT0FBRCxFQUE2QjtBQUFBLHlDQUFoQixXQUFnQjtBQUFoQixtQkFBZ0I7QUFBQTs7QUFDakMsVUFBSSxPQUFPLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsZUFBTyxNQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsUUFBMkIsT0FBM0IsQ0FBUDtBQUNEOztBQUVELFVBQUksT0FBTyxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CO0FBQ0EsZUFBTyxNQUFLLGtCQUFMLENBQXdCLE9BQXhCLENBQVA7QUFDRDs7QUFFRDtBQUNBLGdCQUFVLFFBQVEsR0FBUixDQUFZLE1BQUssZUFBTCxDQUFxQixJQUFyQixPQUFaLENBQVY7QUFDQSxhQUFPLE1BQUssa0JBQUwsQ0FDTCxRQUFRLE1BQVIsQ0FBZSxNQUFLLG9CQUFMLENBQTBCLElBQTFCLFFBQXFDLFdBQXJDLENBQWYsQ0FESyxDQUFQO0FBR0QsS0F6QzRCOztBQUMzQjtBQUNBLFFBQUksYUFBYSxNQUFiLEdBQXNCLENBQXRCLElBQTJCLE1BQU0sT0FBTixDQUFjLGFBQWEsQ0FBYixDQUFkLENBQS9CLEVBQStEO0FBQzdELHFCQUFlLGFBQWEsQ0FBYixDQUFmO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFLLFlBQUwsR0FBb0IsYUFBYSxHQUFiLENBQWlCLHVCQUFlO0FBQ2xELGFBQU8sT0FBTyxXQUFQLEtBQXVCLFVBQXZCLEdBQW9DLGFBQXBDLEdBQW9ELFdBQTNEO0FBQ0QsS0FGbUIsQ0FBcEI7O0FBSUE7QUFDQSxXQUFPLEtBQUssR0FBWjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7Ozs7K0JBUVcsVyxFQUFhLFEsRUFBNEI7QUFBQSx5Q0FBZixhQUFlO0FBQWYscUJBQWU7QUFBQTs7QUFDbEQsYUFBTyxLQUFLLEdBQVosa0JBQWtCLDhCQUFZLFFBQVosU0FBeUIsYUFBekIsRUFBbEI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7eUNBUXFCLGEsRUFBZSxXLEVBQWEsYSxFQUFlO0FBQzlELFVBQU0sZUFBZSxLQUFLLHFCQUFMLENBQ25CLGNBQWMsS0FBZCxFQURtQixFQUVuQixXQUZtQixDQUFyQjtBQUlBLGFBQU8sR0FBRyxNQUFILENBQVUsV0FBVixFQUF1QixZQUF2QixFQUFxQyxhQUFyQyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztvQ0FNZ0IsRyxFQUFLO0FBQ25CLFVBQU0sS0FBSyxTQUFMLEVBQUssQ0FBQyxHQUFELEVBQU0sU0FBTjtBQUFBLGVBQ1QsVUFBVSxRQUFWLEdBQXFCLFVBQVUsUUFBVixDQUFtQixHQUFuQixDQUFyQixHQUErQyxHQUR0QztBQUFBLE9BQVg7QUFFQSxhQUFPLEtBQUssWUFBTCxDQUFrQixNQUFsQixDQUF5QixFQUF6QixFQUE2QixHQUE3QixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7MENBT3NCLFksRUFBYyxXLEVBQWE7QUFDL0MsVUFBTSxLQUFLLFNBQUwsRUFBSyxDQUFDLEdBQUQsRUFBTSxTQUFOO0FBQUEsZUFDVCxVQUFVLGNBQVYsR0FDSSxVQUFVLGNBQVYsQ0FBeUIsR0FBekIsRUFBOEIsV0FBOUIsQ0FESixHQUVJLEdBSEs7QUFBQSxPQUFYO0FBSUEsYUFBTyxLQUFLLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBeUIsRUFBekIsRUFBNkIsWUFBN0IsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7dUNBTW1CLFMsRUFBVztBQUM1QixVQUFNLEtBQUssU0FBTCxFQUFLLENBQUMsR0FBRCxFQUFNLFNBQU47QUFBQSxlQUNULFVBQVUsV0FBVixHQUF3QixVQUFVLFdBQVYsQ0FBc0IsR0FBdEIsQ0FBeEIsR0FBcUQsR0FENUM7QUFBQSxPQUFYO0FBRUEsYUFBTyxLQUFLLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBeUIsRUFBekIsRUFBNkIsU0FBN0IsQ0FBUDtBQUNEOzs7Ozs7a0JBbkhrQixXOzs7Ozs7Ozs7Ozs7Ozs7OztRQ0pkLE87Ozs7Ozs7Ozs7Ozs7Ozs7O1FDQUEsTzs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLGFBQWEsMEJBQ2pCLHNDQUF1QixFQUFFLFdBQVcsR0FBYixFQUF2QixDQURpQixvRUFBbkI7O2tCQU1lLFU7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDWFIsTzs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLGdCQUFnQiwwQkFDcEIsc0NBQXVCLEVBQUUsV0FBVyxHQUFiLEVBQWtCLGFBQWEsS0FBL0IsRUFBdkIsQ0FEb0Isb0VBQXRCOztrQkFNZSxhOzs7Ozs7Ozs7Ozs7Ozs7OztRQ1hSLE87Ozs7Ozs7Ozs7QUNBUDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxlQUFlLDBCQUNuQixzQ0FBdUIsRUFBRSxXQUFXLEdBQWIsRUFBa0IsYUFBYSxJQUEvQixFQUF2QixDQURtQixvRUFBckI7O2tCQU1lLFk7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDWFIsTzs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxPQUFPLDBCQUNYLHNDQUF1QixJQUF2QixDQURXLG9KQUFiOztrQkFRZSxJOzs7Ozs7Ozs7Ozs7Ozs7OztRQ2ZSLE87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDQ0EsVzs7QUFFUDtBQUhBOztRQUlPLHFCO1FBQ0Esc0I7UUFDQSx3QjtRQUNBLDhCO1FBQ0Esd0I7UUFDQSxzQjtRQUNBLHNCO1FBQ0Esa0M7O0FBRVA7O1FBQ08sVTtRQUNBLGE7UUFDQSxZO1FBQ0EsSTtRQUNBLFM7UUFDQSxNO1FBQ0EsUTtRQUNBLE87UUFDQSxXO1FBQ0EsaUI7UUFDQSxtQjtRQUNBLG9CO1FBQ0EsVztRQUNBLGtCO1FBQ0EsVztRQUNBLFk7Ozs7Ozs7Ozs7Ozs7Ozs7UUM3QkEsTzs7Ozs7Ozs7O0FDQVAsSUFBTSxXQUFXO0FBQ2YsYUFBVyxFQURJO0FBRWYsZUFBYSxFQUZFO0FBR2YsVUFBUTtBQUhPLENBQWpCOztBQU1BOzs7Ozs7OztBQVFBLElBQU0seUJBQXlCLFNBQXpCLHNCQUF5QjtBQUFBLE1BQUMsSUFBRCx1RUFBUSxRQUFSO0FBQUEsU0FBc0I7QUFDbkQsa0JBRG1ELDBCQUNwQyxZQURvQyxFQUN0QixXQURzQixFQUNUO0FBQ3hDO0FBQ0EsVUFBSSxNQUFNLE9BQU4sQ0FBYyxZQUFkLENBQUosRUFBaUM7QUFDL0IsWUFBTSxjQUFjLGFBQWEsTUFBakM7QUFDQSxZQUFNLFlBQVksS0FBSyxTQUF2QjtBQUNBLFlBQU0sY0FBYyxLQUFLLFdBQXpCO0FBQ0EsWUFBTSxTQUFTLEtBQUssTUFBcEI7QUFDQTtBQUNBO0FBQ0EsWUFBTSxTQUFTLFlBQVksS0FBWixDQUFrQixnQkFBbEIsQ0FBZjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1YseUJBQWUsYUFBYSxJQUFiLENBQWtCLFlBQVksT0FBTyxDQUFQLENBQTlCLENBQWY7QUFDRCxTQUZELE1BRU87QUFDTCx5QkFBZSxhQUFhLElBQWIsQ0FBa0IsWUFBWSxHQUE5QixDQUFmO0FBQ0Q7QUFDRDtBQUNBLFlBQUksZUFBZSxjQUFjLENBQWpDLEVBQW9DO0FBQ2xDLGNBQU0saUJBQWlCLGFBQWEsV0FBYixDQUF5QixTQUF6QixDQUF2QjtBQUNBLHlCQUNFLGFBQWEsS0FBYixDQUFtQixDQUFuQixFQUFzQixjQUF0QixLQUNDLFNBQVMsU0FBVCxHQUFxQixFQUR0QixJQUVBLEdBRkEsR0FHQSxXQUhBLEdBSUEsYUFBYSxLQUFiLENBQW1CLGlCQUFpQixDQUFwQyxDQUxGO0FBTUQ7QUFDRjtBQUNELGFBQU8sWUFBUDtBQUNEO0FBNUJrRCxHQUF0QjtBQUFBLENBQS9COztrQkErQmUsc0I7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDN0NSLE87Ozs7Ozs7Ozs7QUNBUDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxjQUFjLDhIQUFwQjs7a0JBTWUsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNYUixPOzs7Ozs7Ozs7O0FDQVA7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLFVBQVUsMEJBQ2Qsd0NBQXlCLGlCQUF6QixFQUE0QyxHQUE1QyxDQURjLGtDQUFoQjs7a0JBS2UsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNUUixPOzs7Ozs7Ozs7O0FDQVA7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU0sb0JBQW9CLDBCQUN4QixzQ0FBdUIsRUFBRSxXQUFXLEdBQWIsRUFBdkIsQ0FEd0IsRUFFeEIsd0NBQXlCLFVBQXpCLEVBQXFDLEdBQXJDLENBRndCLGtDQUExQjs7a0JBTWUsaUI7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDWFIsTzs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLHVCQUF1QiwwQkFDM0Isc0NBQXVCLEVBQUUsV0FBVyxHQUFiLEVBQWtCLGFBQWEsS0FBL0IsRUFBdkIsQ0FEMkIsRUFFM0Isd0NBQXlCLFVBQXpCLEVBQXFDLEdBQXJDLENBRjJCLGtDQUE3Qjs7a0JBTWUsb0I7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDWFIsTzs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLHNCQUFzQiwwQkFDMUIsc0NBQXVCLEVBQUUsV0FBVyxHQUFiLEVBQWtCLGFBQWEsSUFBL0IsRUFBdkIsQ0FEMEIsRUFFMUIsd0NBQXlCLFVBQXpCLEVBQXFDLEdBQXJDLENBRjBCLGtDQUE1Qjs7a0JBTWUsbUI7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDWFIsTzs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLHFCQUFxQiw0REFFekIsd0NBQXlCLFVBQXpCLEVBQXFDLEdBQXJDLENBRnlCLGtDQUEzQjs7a0JBTWUsa0I7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDWFIsTzs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxjQUFjLDBCQUNsQix3Q0FBeUIsWUFBekIsRUFBdUMsRUFBdkMsQ0FEa0Isa0NBQXBCOztrQkFLZSxXOzs7Ozs7Ozs7Ozs7Ozs7OztRQ1RSLE87Ozs7Ozs7OztBQ0FQLElBQU0sZUFBZSxTQUFmLFlBQWU7QUFBQSxTQUNuQixLQUFLLElBQUwsSUFBYSxDQUFDLE9BQU8sS0FBUCxDQUFhLENBQWIsQ0FBZCxJQUFpQyxPQUFPLENBQVAsS0FBYSxTQUQzQjtBQUFBLENBQXJCOztBQUdBLElBQU0scUNBQXFDLFNBQXJDLGtDQUFxQztBQUFBLFNBQU87QUFDaEQsa0JBRGdELDBCQUNqQyxZQURpQyxFQUNuQjtBQUMzQixVQUFJLE1BQU0sT0FBTixDQUFjLFlBQWQsQ0FBSixFQUFpQztBQUMvQixlQUFPLGFBQWEsTUFBYixDQUFvQixZQUFwQixDQUFQO0FBQ0Q7QUFDRCxVQUFJLGFBQWEsWUFBYixDQUFKLEVBQWdDO0FBQzlCLGVBQU8sWUFBUDtBQUNEO0FBQ0QsYUFBTyxFQUFQO0FBQ0Q7QUFUK0MsR0FBUDtBQUFBLENBQTNDOztrQkFZZSxrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNmUixPOzs7Ozs7Ozs7QUNBUDs7Ozs7O0FBTUEsSUFBTSwyQkFBMkIsU0FBM0Isd0JBQTJCLENBQUMsV0FBRCxFQUFjLFdBQWQ7QUFBQSxTQUErQjtBQUM5RCxlQUQ4RCx1QkFDbEQsU0FEa0QsRUFDdkM7QUFDckIsVUFBSSxlQUFlLElBQWYsSUFBdUIsZUFBZSxJQUExQyxFQUFnRDtBQUM5QyxjQUFNLElBQUksS0FBSixDQUNKLHlEQURJLENBQU47QUFHRDtBQUNELGFBQU8sVUFBVSxPQUFWLENBQWtCLFdBQWxCLEVBQStCLFdBQS9CLENBQVA7QUFDRDtBQVI2RCxHQUEvQjtBQUFBLENBQWpDOztrQkFXZSx3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNqQlIsTzs7Ozs7Ozs7O0FDQVAsSUFBTSwyQkFBMkIsU0FBM0Isd0JBQTJCLENBQUMsV0FBRCxFQUFjLFdBQWQ7QUFBQSxTQUErQjtBQUM5RCxZQUQ4RCxvQkFDckQsR0FEcUQsRUFDaEQ7QUFDWixVQUFJLGVBQWUsSUFBZixJQUF1QixlQUFlLElBQTFDLEVBQWdEO0FBQzlDLGNBQU0sSUFBSSxLQUFKLENBQ0oseURBREksQ0FBTjtBQUdEOztBQUVELGFBQU8sSUFBSSxPQUFKLENBQVksV0FBWixFQUF5QixXQUF6QixDQUFQO0FBQ0Q7QUFUNkQsR0FBL0I7QUFBQSxDQUFqQzs7a0JBWWUsd0I7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDWlIsTzs7Ozs7Ozs7O0FDQVAsSUFBTSxpQ0FBaUMsU0FBakMsOEJBQWlDLENBQUMsV0FBRCxFQUFjLFdBQWQ7QUFBQSxTQUErQjtBQUNwRSxrQkFEb0UsMEJBQ3JELFlBRHFELEVBQ3ZDLFdBRHVDLEVBQzFCO0FBQ3hDLFVBQUksZUFBZSxJQUFmLElBQXVCLGVBQWUsSUFBMUMsRUFBZ0Q7QUFDOUMsY0FBTSxJQUFJLEtBQUosQ0FDSiwrREFESSxDQUFOO0FBR0Q7O0FBRUQ7QUFDQSxVQUFJLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QixlQUFPLFlBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLGFBQWEsUUFBYixHQUF3QixPQUF4QixDQUFnQyxXQUFoQyxFQUE2QyxXQUE3QyxDQUFQO0FBQ0Q7QUFDRjtBQWRtRSxHQUEvQjtBQUFBLENBQXZDOztrQkFpQmUsOEI7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDakJSLE87Ozs7Ozs7Ozs7QUNBUDs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU0sV0FBVywwQkFDZixzQ0FBdUIsSUFBdkIsQ0FEZSx1R0FLZiw4Q0FBK0IsSUFBL0IsRUFBcUMsT0FBckMsQ0FMZSxFQU1mLDhDQUErQixJQUEvQixFQUFxQyxNQUFyQyxDQU5lLEVBT2YsOENBQStCLElBQS9CLEVBQXFDLE1BQXJDLENBUGUsRUFRZiw4Q0FBK0IsSUFBL0IsRUFBcUMsUUFBckMsQ0FSZSxFQVNmLDhDQUErQixJQUEvQixFQUFxQyxRQUFyQyxDQVRlLEVBVWYsOENBQStCLElBQS9CLEVBQXFDLFFBQXJDLENBVmUsQ0FBakI7O2tCQWFlLFE7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDcEJSLE87Ozs7Ozs7Ozs7Ozs7Ozs7O1FDQUEsTzs7Ozs7Ozs7O0FDQVAsSUFBTSx5QkFBeUIsU0FBekIsc0JBQXlCO0FBQUEsU0FBWTtBQUN6QyxrQkFEeUMsMEJBQzFCLFlBRDBCLEVBQ1osV0FEWSxFQUNDO0FBQ3hDLFVBQUksV0FBVyxJQUFYLElBQW1CLE9BQU8sT0FBUCxLQUFtQixRQUExQyxFQUFvRDtBQUNsRCxZQUFJLE9BQU8sWUFBUCxLQUF3QixRQUF4QixJQUFvQyxhQUFhLFFBQWIsQ0FBc0IsT0FBdEIsQ0FBeEMsRUFBd0U7QUFDdEUseUJBQWUsYUFBYSxLQUFiLENBQW1CLE9BQW5CLENBQWY7QUFDRDtBQUNGLE9BSkQsTUFJTztBQUNMLGNBQU0sSUFBSSxLQUFKLENBQVUscURBQVYsQ0FBTjtBQUNEO0FBQ0QsYUFBTyxZQUFQO0FBQ0Q7QUFWd0MsR0FBWjtBQUFBLENBQS9COztrQkFhZSxzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNiUixPOzs7Ozs7Ozs7O0FDQVA7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLGNBQWMsNEZBQXBCOztrQkFLZSxXOzs7Ozs7Ozs7Ozs7Ozs7OztRQ1RSLE87Ozs7Ozs7Ozs7OztBQ0FQOzs7OztBQUtBLElBQU0seUJBQXlCLFNBQXpCLHNCQUF5QjtBQUFBLE1BQUMsSUFBRCx1RUFBUSxTQUFSO0FBQUEsU0FBdUI7QUFDcEQsZUFEb0QsdUJBQ3hDLFNBRHdDLEVBQzdCO0FBQ3JCLFVBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3RCO0FBQ0EsWUFBTSxRQUFRLFVBQVUsS0FBVixDQUFnQixtQkFBaEIsQ0FBZDtBQUNBLFlBQU0sU0FBUyxTQUFTLEtBQUssR0FBTCxnQ0FBWSxNQUFNLEdBQU4sQ0FBVTtBQUFBLGlCQUFNLEdBQUcsTUFBVDtBQUFBLFNBQVYsQ0FBWixFQUF4QjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1YsY0FBTSxTQUFTLElBQUksTUFBSixTQUFpQixNQUFqQixRQUE0QixJQUE1QixDQUFmO0FBQ0EsaUJBQU8sVUFBVSxPQUFWLENBQWtCLE1BQWxCLEVBQTBCLEVBQTFCLENBQVA7QUFDRDtBQUNELGVBQU8sU0FBUDtBQUNEO0FBQ0QsVUFBSSxTQUFTLEtBQWIsRUFBb0I7QUFDbEI7QUFDQSxlQUFPLFVBQVUsT0FBVixDQUFrQixhQUFsQixFQUFpQyxFQUFqQyxDQUFQO0FBQ0Q7QUFDRCxZQUFNLElBQUksS0FBSixvQkFBMkIsSUFBM0IsQ0FBTjtBQUNEO0FBakJtRCxHQUF2QjtBQUFBLENBQS9COztrQkFvQmUsc0I7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDekJSLE87Ozs7Ozs7Ozs7QUNBUDs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU0sZUFBZSwwQkFDbkIsc0NBQXVCLEtBQXZCLENBRG1CLGtDQUFyQjs7a0JBS2UsWTs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNUUixPOzs7Ozs7Ozs7QUNBUDs7Ozs7QUFLQSxJQUFNLHdCQUF3QixTQUF4QixxQkFBd0I7QUFBQSxNQUFDLElBQUQsdUVBQVEsRUFBUjtBQUFBLFNBQWdCO0FBQzVDLGVBRDRDLHVCQUNoQyxTQURnQyxFQUNyQjtBQUNyQixVQUFJLFNBQVMsRUFBYixFQUFpQjtBQUNmLGVBQU8sVUFBVSxJQUFWLEVBQVA7QUFDRDs7QUFFRCxhQUFPLEtBQUssV0FBTCxFQUFQOztBQUVBLFVBQUksU0FBUyxPQUFULElBQW9CLFNBQVMsTUFBakMsRUFBeUM7QUFDdkMsZUFBTyxVQUFVLE9BQVYsQ0FBa0IsTUFBbEIsRUFBMEIsRUFBMUIsQ0FBUDtBQUNEOztBQUVELFVBQUksU0FBUyxLQUFULElBQWtCLFNBQVMsT0FBL0IsRUFBd0M7QUFDdEMsZUFBTyxVQUFVLE9BQVYsQ0FBa0IsTUFBbEIsRUFBMEIsRUFBMUIsQ0FBUDtBQUNEOztBQUVELFlBQU0sSUFBSSxLQUFKLDBCQUFpQyxJQUFqQyxDQUFOO0FBQ0Q7QUFqQjJDLEdBQWhCO0FBQUEsQ0FBOUI7O2tCQW9CZSxxQjs7OztBQ3pCZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy8vQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdERBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gfVxuXG5mdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuWyd1c2UnLCAnb24nLCAnb25jZScsICdzZXQnLCAncXVlcnknLCAndHlwZScsICdhY2NlcHQnLCAnYXV0aCcsICd3aXRoQ3JlZGVudGlhbHMnLCAnc29ydFF1ZXJ5JywgJ3JldHJ5JywgJ29rJywgJ3JlZGlyZWN0cycsICd0aW1lb3V0JywgJ2J1ZmZlcicsICdzZXJpYWxpemUnLCAncGFyc2UnLCAnY2EnLCAna2V5JywgJ3BmeCcsICdjZXJ0J10uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgLy8gRGVmYXVsdCBzZXR0aW5nIGZvciBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGFnZW50XG4gIEFnZW50LnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmF1bHRzLnB1c2goe1xuICAgICAgZm46IGZuLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgdGhpcy5fZGVmYXVsdHMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBfdG9Db25zdW1hYmxlQXJyYXkoZGVmLmFyZ3MpKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG52YXIgcm9vdDtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBXZWIgV29ya2VyXG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIHtcbiAgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIGNvbnNvbGUud2FybignVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudCcpO1xuICByb290ID0gdm9pZCAwO1xufVxuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbnZhciBSZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbnZhciBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcblxudmFyIEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudC1iYXNlJyk7XG4vKipcbiAqIE5vb3AuXG4gKi9cblxuXG5mdW5jdGlvbiBub29wKCkge31cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG5cbnZhciByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICh0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH0gLy8gdXJsIGZpcnN0XG5cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdChtZXRob2QsIHVybCk7XG59O1xuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gZnVuY3Rpb24gKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdCAmJiAoIXJvb3QubG9jYXRpb24gfHwgcm9vdC5sb2NhdGlvbi5wcm90b2NvbCAhPSAnZmlsZTonIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSJyk7XG59O1xuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxudmFyIHRyaW0gPSAnJy50cmltID8gZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIHMudHJpbSgpO1xufSA6IGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpO1xufTtcbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IgKHZhciBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBcIlwiLmNvbmNhdChrZXksIFwiW1wiKS5jb25jYXQoc3Via2V5LCBcIl1cIiksIHZhbFtzdWJrZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gIH1cbn1cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cblxucmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYWlyO1xuICB2YXIgcG9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcblxuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICd0ZXh0L3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICBmb3JtOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuLyoqXG4gKiBEZWZhdWx0IHBhcnNlcnMuXG4gKlxuICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcbiAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAqICAgICB9O1xuICpcbiAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7IC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcblxuICB0aGlzLnRleHQgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJyA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB2YXIgc3RhdHVzID0gdGhpcy54aHIuc3RhdHVzOyAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG5cbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuXG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcblxuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTsgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcblxuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAodGhpcy50ZXh0ID09PSBudWxsICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJyA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSkgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG5cbiAgaWYgKHRoaXMucmVxLl9wYXJzZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXEuX3BhcnNlcih0aGlzLCBzdHIpO1xuICB9XG5cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpID8gcGFyc2Uoc3RyKSA6IG51bGw7XG59O1xuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlc3BvbnNlLnByb3RvdHlwZS50b0Vycm9yID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcbiAgdmFyIG1zZyA9IFwiY2Fubm90IFwiLmNvbmNhdChtZXRob2QsIFwiIFwiKS5jb25jYXQodXJsLCBcIiAoXCIpLmNvbmNhdCh0aGlzLnN0YXR1cywgXCIpXCIpO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcbiAgcmV0dXJuIGVycjtcbn07XG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuXG4gIHRoaXMuX2hlYWRlciA9IHt9OyAvLyBjb2VyY2VzIGhlYWRlciBuYW1lcyB0byBsb3dlcmNhc2VcblxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlOyAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuXG4gICAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgICAgLy8gaWU5IGRvZXNuJ3QgaGF2ZSAncmVzcG9uc2UnIHByb3BlcnR5XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IHR5cGVvZiBzZWxmLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7IC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuXG4gICAgICAgIGVyci5zdGF0dXMgPSBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IGVyci5zdGF0dXM7IC8vIGJhY2t3YXJkcy1jb21wYXQgb25seVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG4gICAgdmFyIG5ld19lcnI7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFzZWxmLl9pc1Jlc3BvbnNlT0socmVzKSkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH0gLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG5cblxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbiAodXNlciwgcGFzcywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcGFzcyA9ICcnO1xuXG4gIGlmIChfdHlwZW9mKHBhc3MpID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7XG4gICAgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBwYXNzO1xuICAgIHBhc3MgPSAnJztcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJyA/ICdiYXNpYycgOiAnYXV0bydcbiAgICB9O1xuICB9XG5cbiAgdmFyIGVuY29kZXIgPSBmdW5jdGlvbiBlbmNvZGVyKHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGZpZWxkLCBmaWxlLCBvcHRpb25zKSB7XG4gIGlmIChmaWxlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gIGlmICh0aGlzLl9zaG91bGRSZXRyeShlcnIsIHJlcykpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0cnkoKTtcbiAgfVxuXG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIGlmIChlcnIpIHtcbiAgICBpZiAodGhpcy5fbWF4UmV0cmllcykgZXJyLnJldHJpZXMgPSB0aGlzLl9yZXRyaWVzIC0gMTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZuKGVyciwgcmVzKTtcbn07XG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59OyAvLyBUaGlzIG9ubHkgd2FybnMsIGJlY2F1c2UgdGhlIHJlcXVlc3QgaXMgc3RpbGwgbGlrZWx5IHRvIHdvcmtcblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5idWZmZXIgPSBSZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLndhcm4oJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudCcpO1xuICByZXR1cm4gdGhpcztcbn07IC8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5cblxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50Jyk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5faXNIb3N0ID0gZnVuY3Rpb24gX2lzSG9zdChvYmopIHtcbiAgLy8gTmF0aXZlIG9iamVjdHMgc3RyaW5naWZ5IHRvIFtvYmplY3QgRmlsZV0sIFtvYmplY3QgQmxvYl0sIFtvYmplY3QgRm9ybURhdGFdLCBldGMuXG4gIHJldHVybiBvYmogJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn07XG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChmbikge1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnQnKTtcbiAgfVxuXG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7IC8vIHN0b3JlIGNhbGxiYWNrXG5cbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wOyAvLyBxdWVyeXN0cmluZ1xuXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm4gdGhpcy5jYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQgZXZlbiBiZWZvcmUgLmVuZCgpIHdhcyBjYWxsZWQnKSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9IHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKTtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIHRoaXMuX3NldFRpbWVvdXRzKCk7IC8vIHN0YXRlIGNoYW5nZVxuXG5cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG5cbiAgICBpZiAocmVhZHlTdGF0ZSAhPSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG5cblxuICAgIHZhciBzdGF0dXM7XG5cbiAgICB0cnkge1xuICAgICAgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdGF0dXMgPSAwO1xuICAgIH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTsgLy8gcHJvZ3Jlc3NcblxuXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKGRpcmVjdGlvbiwgZSkge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cblxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcblxuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKSk7XG5cbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICd1cGxvYWQnKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkgey8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9IC8vIGluaXRpYXRlIHJlcXVlc3RcblxuXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH0gLy8gQ09SU1xuXG5cbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7IC8vIGJvZHlcblxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmIHRoaXMubWV0aG9kICE9ICdHRVQnICYmIHRoaXMubWV0aG9kICE9ICdIRUFEJyAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgICB2YXIgX3NlcmlhbGl6ZSA9IHRoaXMuX3NlcmlhbGl6ZXIgfHwgcmVxdWVzdC5zZXJpYWxpemVbY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdIDogJyddO1xuXG4gICAgaWYgKCFfc2VyaWFsaXplICYmIGlzSlNPTihjb250ZW50VHlwZSkpIHtcbiAgICAgIF9zZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cblxuICAgIGlmIChfc2VyaWFsaXplKSBkYXRhID0gX3NlcmlhbGl6ZShkYXRhKTtcbiAgfSAvLyBzZXQgaGVhZGVyIGZpZWxkc1xuXG5cbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAodGhpcy5oZWFkZXJbZmllbGRdID09IG51bGwpIGNvbnRpbnVlO1xuICAgIGlmICh0aGlzLmhlYWRlci5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH0gLy8gc2VuZCBzdHVmZlxuXG5cbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7IC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG5cbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xufTtcblxucmVxdWVzdC5hZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBBZ2VudCgpO1xufTtcblxuWydHRVQnLCAnUE9TVCcsICdPUFRJT05TJywgJ1BBVENIJywgJ1BVVCcsICdERUxFVEUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uICh1cmwsIGZuKSB7XG4gICAgdmFyIHJlcSA9IG5ldyByZXF1ZXN0LlJlcXVlc3QobWV0aG9kLCB1cmwpO1xuXG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcblxuICAgIGlmIChmbikge1xuICAgICAgcmVxLmVuZChmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbn0pO1xuQWdlbnQucHJvdG90eXBlLmRlbCA9IEFnZW50LnByb3RvdHlwZS5kZWxldGU7XG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxucmVxdWVzdC5vcHRpb25zID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59XG5cbnJlcXVlc3QuZGVsID0gZGVsO1xucmVxdWVzdC5kZWxldGUgPSBkZWw7XG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0OyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlcXVlc3RCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVxdWVzdEJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBkZWxldGUgdGhpcy5fdGltZXI7XG4gIGRlbGV0ZSB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKSB7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdGhpcy5fcmVzcG9uc2VUeXBlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pIHtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9uKSB7XG4gICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIHRpbWVvdXQgb3B0aW9uJywgb3B0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKSB7XG4gIC8vIERlZmF1bHQgdG8gMSBpZiBubyBjb3VudCBwYXNzZWQgb3IgdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudCA9PT0gdHJ1ZSkgY291bnQgPSAxO1xuICBpZiAoY291bnQgPD0gMCkgY291bnQgPSAwO1xuICB0aGlzLl9tYXhSZXRyaWVzID0gY291bnQ7XG4gIHRoaXMuX3JldHJpZXMgPSAwO1xuICB0aGlzLl9yZXRyeUNhbGxiYWNrID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIEVSUk9SX0NPREVTID0gWydFQ09OTlJFU0VUJywgJ0VUSU1FRE9VVCcsICdFQUREUklORk8nLCAnRVNPQ0tFVFRJTUVET1VUJ107XG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuXG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlOyAvLyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0c1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlcyAmJiByZXMuc3RhdHVzICYmIHJlcy5zdGF0dXMgPj0gNTAwICYmIHJlcy5zdGF0dXMgIT0gNTAxKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7IC8vIFN1cGVyYWdlbnQgdGltZW91dFxuXG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9yZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTsgLy8gbm9kZVxuXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxID0gbnVsbDtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0ID0gZmFsc2U7XG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXMnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSB7XG4gICAgICBzZWxmLm9uKCdlcnJvcicsIGlubmVyUmVqZWN0KTtcbiAgICAgIHNlbGYuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpO2Vsc2UgaW5uZXJSZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgcmVxdWlyZWQnKTtcbiAgdGhpcy5fb2tDYWxsYmFjayA9IGNiO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5faXNSZXNwb25zZU9LID0gZnVuY3Rpb24gKHJlcykge1xuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9va0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX29rQ2FsbGJhY2socmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwO1xufTtcbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldDtcbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZmllbGQsIHZhbCkge1xuICBpZiAoaXNPYmplY3QoZmllbGQpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZpZWxkKSB7XG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobmFtZSA9PT0gbnVsbCB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCIuZmllbGQoKSBjYW4ndCBiZSB1c2VkIGlmIC5zZW5kKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcblxuXG4gIGlmICh2YWwgPT09IG51bGwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gIH1cblxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG5cbiAgdGhpcy5yZXEgJiYgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbiAodXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgXCJCYXNpYyBcIi5jb25jYXQoYmFzZTY0RW5jb2RlcihcIlwiLmNvbmNhdCh1c2VyLCBcIjpcIikuY29uY2F0KHBhc3MpKSkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6XG4gICAgICAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBcIkJlYXJlciBcIi5jb25jYXQodXNlcikpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uIChvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyXG4gIH07XG59O1xuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGlzT2JqID0gaXNPYmplY3QoZGF0YSk7XG4gIHZhciB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICBpZiAodGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmogJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfSAvLyBtZXJnZVxuXG5cbiAgaWYgKGlzT2JqICYmIGlzT2JqZWN0KHRoaXMuX2RhdGEpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhID8gXCJcIi5jb25jYXQodGhpcy5fZGF0YSwgXCImXCIpLmNvbmNhdChkYXRhKSA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gZGVmYXVsdCB0byBqc29uXG5cblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uIChzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fZmluYWxpemVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuXG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuXG4gIHRoaXMuX3F1ZXJ5Lmxlbmd0aCA9IDA7IC8vIE1ha2VzIHRoZSBjYWxsIGlkZW1wb3RlbnRcblxuICBpZiAodGhpcy5fc29ydCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudXJsLmluZGV4T2YoJz8nKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX3NvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJz8nICsgcXVlcnlBcnIuam9pbignJicpO1xuICAgIH1cbiAgfVxufTsgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUudHJhY2UoJ1Vuc3VwcG9ydGVkJyk7XG59O1xuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbiAocmVhc29uLCB0aW1lb3V0LCBlcnJubykge1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJcIi5jb25jYXQocmVhc29uICsgdGltZW91dCwgXCJtcyBleGNlZWRlZFwiKSk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gZGVhZGxpbmVcblxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9IC8vIHJlc3BvbnNlIHRpbWVvdXRcblxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzcG9uc2VCYXNlO1xuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGhlYWRlcikge1xuICAvLyBUT0RPOiBtb2FyIVxuICAvLyBUT0RPOiBtYWtlIHRoaXMgYSB1dGlsXG4gIC8vIGNvbnRlbnQtdHlwZVxuICB2YXIgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTsgLy8gcGFyYW1zXG5cbiAgdmFyIHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG5cbiAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgIHRoaXNba2V5XSA9IHBhcmFtc1trZXldO1xuICB9XG5cbiAgdGhpcy5saW5rcyA9IHt9OyAvLyBsaW5rc1xuXG4gIHRyeSB7XG4gICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHsvLyBpZ25vcmVcbiAgfVxufTtcbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7IC8vIHN0YXR1cyAvIGNsYXNzXG5cbiAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7IC8vIGJhc2ljc1xuXG4gIHRoaXMuaW5mbyA9IHR5cGUgPT0gMTtcbiAgdGhpcy5vayA9IHR5cGUgPT0gMjtcbiAgdGhpcy5yZWRpcmVjdCA9IHR5cGUgPT0gMztcbiAgdGhpcy5jbGllbnRFcnJvciA9IHR5cGUgPT0gNDtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IHR5cGUgPT0gNTtcbiAgdGhpcy5lcnJvciA9IHR5cGUgPT0gNCB8fCB0eXBlID09IDUgPyB0aGlzLnRvRXJyb3IoKSA6IGZhbHNlOyAvLyBzdWdhclxuXG4gIHRoaXMuY3JlYXRlZCA9IHN0YXR1cyA9PSAyMDE7XG4gIHRoaXMuYWNjZXB0ZWQgPSBzdGF0dXMgPT0gMjAyO1xuICB0aGlzLm5vQ29udGVudCA9IHN0YXR1cyA9PSAyMDQ7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IHN0YXR1cyA9PSA0MDA7XG4gIHRoaXMudW5hdXRob3JpemVkID0gc3RhdHVzID09IDQwMTtcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gc3RhdHVzID09IDQwNjtcbiAgdGhpcy5mb3JiaWRkZW4gPSBzdGF0dXMgPT0gNDAzO1xuICB0aGlzLm5vdEZvdW5kID0gc3RhdHVzID09IDQwNDtcbiAgdGhpcy51bnByb2Nlc3NhYmxlRW50aXR5ID0gc3RhdHVzID09IDQyMjtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xufTtcbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5wYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uIChvYmosIHN0cikge1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICB2YXIgdmFsID0gcGFydHMuc2hpZnQoKTtcbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcbi8qKlxuICogUGFyc2UgTGluayBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBzdHIpIHtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gICAgdmFyIHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgICB2YXIgcmVsID0gcGFydHNbMV0uc3BsaXQoLyAqPSAqLylbMV0uc2xpY2UoMSwgLTEpO1xuICAgIG9ialtyZWxdID0gdXJsO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzLmNsZWFuSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlciwgY2hhbmdlc09yaWdpbikge1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC1sZW5ndGgnXTtcbiAgZGVsZXRlIGhlYWRlclsndHJhbnNmZXItZW5jb2RpbmcnXTtcbiAgZGVsZXRlIGhlYWRlci5ob3N0OyAvLyBzZWN1aXJ0eVxuXG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlci5hdXRob3JpemF0aW9uO1xuICAgIGRlbGV0ZSBoZWFkZXIuY29va2llO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcjtcbn07IiwiLyoqXG4gKiBAZmlsZSBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktZmlsdGVyLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG52YXIgc29tZSA9IHJlcXVpcmUoJ2FycmF5LXNvbWUteCcpO1xuXG52YXIgJGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgY2FsbEJhY2sgLyogLCB0aGlzQXJnICovKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gIGFzc2VydElzRnVuY3Rpb24oY2FsbEJhY2spO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB3cmFwcGVkID0gZnVuY3Rpb24gX3dyYXBwZWQoaXRlbSwgaWR4LCBvYmopIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gICAgaWYgKGNhbGxCYWNrLmNhbGwodGhpcywgaXRlbSwgaWR4LCBvYmopKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYXJncyA9IFtvYmplY3QsIHdyYXBwZWRdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICBhcmdzWzJdID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgc29tZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxCYWNrIC0gRnVuY3Rpb24gaXMgYSBwcmVkaWNhdGUsIHRvIHRlc3QgZWFjaCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2FycmF5fSBBIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbHRlciA9IHJlcXVpcmUoJ2FycmF5LWZpbHRlci14Jyk7XG4gKlxuICogZnVuY3Rpb24gaXNCaWdFbm91Z2godmFsdWUpIHtcbiAqICAgcmV0dXJuIHZhbHVlID49IDEwO1xuICogfVxuICpcbiAqIHZhciBmaWx0ZXJlZCA9IGZpbHRlcihbMTIsIDUsIDgsIDEzMCwgNDRdLCBpc0JpZ0Vub3VnaCk7XG4gKiAvLyBmaWx0ZXJlZCBpcyBbMTIsIDEzMCwgNDRdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGZpbHRlcjtcbiIsIi8qKlxuICogQGZpbGUgRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGFycmF5IGVsZW1lbnQuXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktZm9yLWVhY2gteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcbnZhciBzb21lID0gcmVxdWlyZSgnYXJyYXktc29tZS14Jyk7XG5cbnZhciAkZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goYXJyYXksIGNhbGxCYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxCYWNrKTtcbiAgdmFyIHdyYXBwZWQgPSBmdW5jdGlvbiBfd3JhcHBlZChpdGVtLCBpZHgsIG9iaikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICBjYWxsQmFjay5jYWxsKHRoaXMsIGl0ZW0sIGlkeCwgb2JqKTtcbiAgfTtcblxuICB2YXIgYXJncyA9IFtvYmplY3QsIHdyYXBwZWRdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICBhcmdzWzJdID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgc29tZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBleGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsQmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFycmF5IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBjYWxsQmFjayBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2FycmF5LWZvci1lYWNoLXgnKTtcbiAqXG4gKiB2YXIgaXRlbXMgPSBbJ2l0ZW0xJywgJ2l0ZW0yJywgJ2l0ZW0zJ107XG4gKiB2YXIgY29weSA9IFtdO1xuICpcbiAqIGZvckVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pe1xuICogICBjb3B5LnB1c2goaXRlbSlcbiAqIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRmb3JFYWNoO1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gYXJyYXkgaW5jbHVkZXMgYSBjZXJ0YWluIGVsZW1lbnQuXG4gKiBAdmVyc2lvbiAxLjAuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktaW5jbHVkZXMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBuYXRpdmVJbmNsdWRlcyA9IEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcztcbnZhciAkaW5jbHVkZXM7XG5cbmlmIChuYXRpdmVJbmNsdWRlcykge1xuICB2YXIgYXJyID0ge1xuICAgIDE6ICdhJyxcbiAgICAyOiBOYU4sXG4gICAgMzogLTAsXG4gICAgbGVuZ3RoOiA1XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBpZiAobmF0aXZlSW5jbHVkZXMuY2FsbChhcnIsIHZvaWQgMCwgLTEpICYmIG5hdGl2ZUluY2x1ZGVzLmNhbGwoYXJyLCBOYU4pICYmIG5hdGl2ZUluY2x1ZGVzLmNhbGwoJ2FiYycsICdjJykpIHtcbiAgICAgICRpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gICAgICAgIHZhciBhcmdzID0gW3NlYXJjaEVsZW1lbnRdO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBhcmdzWzFdID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUluY2x1ZGVzLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxufVxuXG5pZiAoQm9vbGVhbigkaW5jbHVkZXMpID09PSBmYWxzZSkge1xuICB2YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgdmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14Jyk7XG4gIHZhciBzYW1lVmFsdWVaZXJvID0gcmVxdWlyZSgnc2FtZS12YWx1ZS16ZXJvLXgnKTtcbiAgdmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJ2ZpbmQtaW5kZXgteCcpO1xuICB2YXIgc3BsaXRTdHJpbmcgPSByZXF1aXJlKCdoYXMtYm94ZWQtc3RyaW5nLXgnKSA9PT0gZmFsc2U7XG4gIHZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXgtb2YteCcpO1xuICB2YXIgY2FsY0Zyb21JbmRleCA9IHJlcXVpcmUoJ2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgnKTtcblxuICAvKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGluZGV4IGluIHRoZSBhcnJheSwgaWYgYW4gZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICogc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLiBPdGhlcndpc2UgLTEgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdCAtIFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCAtIEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGluZGV4IG9mIGZvdW5kIGVsZW1lbnQsIG90aGVyd2lzZSAtMS5cbiAgICovXG4gIHZhciBmaW5kSWR4RnJvbSA9IGZ1bmN0aW9uIGZpbmRJbmRleEZyb20ob2JqZWN0LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgZklkeCA9IGZyb21JbmRleDtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgob2JqZWN0Lmxlbmd0aCk7XG4gICAgd2hpbGUgKGZJZHggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChzYW1lVmFsdWVaZXJvKG9iamVjdFtmSWR4XSwgc2VhcmNoRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZJZHg7XG4gICAgICB9XG5cbiAgICAgIGZJZHggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgJGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHNlYXJjaEVsZW1lbnQpIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAgIHZhciBpdGVyYWJsZSA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKG9iamVjdCkgPyBvYmplY3Quc3BsaXQoJycpIDogb2JqZWN0O1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWZpbmVkKHNlYXJjaEVsZW1lbnQpKSB7XG4gICAgICB2YXIgZnJvbUluZGV4ID0gY2FsY0Zyb21JbmRleChpdGVyYWJsZSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGlmIChmcm9tSW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21JbmRleCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmRJZHhGcm9tKGl0ZXJhYmxlLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaW5kSW5kZXgoaXRlcmFibGUsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBzYW1lVmFsdWVaZXJvKHNlYXJjaEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgfSkgPiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhPZihpdGVyYWJsZSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzJdLCAnc2FtZXZhbHVlemVybycpID4gLTE7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGFycmF5IGluY2x1ZGVzIGEgY2VydGFpbiBlbGVtZW50LFxuICogcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgYXMgYXBwcm9wcmlhdGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgYXJyYXlgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCAtIEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBgYXJyYXlgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXhdIC0gVGhlIHBvc2l0aW9uIGluIHRoaXMgYXJyYXkgYXQgd2hpY2ggdG8gYmVnaW5cbiAqICBzZWFyY2hpbmcgZm9yIHNlYXJjaEVsZW1lbnQuIEEgbmVnYXRpdmUgdmFsdWUgc2VhcmNoZXMgZnJvbSB0aGUgaW5kZXggb2ZcbiAqICBhcnJheS5sZW5ndGggKyBmcm9tSW5kZXggYnkgYXNjLiBEZWZhdWx0cyB0byAwLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBzZWFyY2hlZCBlbGVtZW50IGlzIGluY2x1ZGVkOyBvdGhlcndpc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5jbHVkZXMgPSByZXF1aXJlKCdhcnJheS1pbmNsdWRlcy14Jyk7XG4gKlxuICogdmFyIHN1YmplY3QgPSBbMiwgMywgdW5kZWZpbmVkLCB0cnVlLCAnaGVqJywgbnVsbCwgMiwgZmFsc2UsIDAsIC0wLCBOYU5dO1xuICogaW5jbHVkZXMoc3ViamVjdCwgdW5kZWZpbmVkKTsgLy8gdHJ1ZVxuICogaW5jbHVkZXMoc3ViamVjdCwgdW5kZWZpbmVkLCAzKTsgLy8gZmFsc2VcbiAqIGluY2x1ZGVzKHN1YmplY3QsIE5hTik7IC8vIHRydWVcbiAqIGluY2x1ZGVzKHN1YmplY3QsIDEwKTsgLy8gZmFsc2VcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGluY2x1ZGVzO1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE51bWJlci5pc0Zpbml0ZS5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNmaW5pdGV8MjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlICggbnVtYmVyICl9XG4gKiBAdmVyc2lvbiAxLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtZmluaXRlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCdpcy1uYW4nKTtcblxudmFyICRpc0Zpbml0ZTtcbmlmICh0eXBlb2YgTnVtYmVyLmlzRmluaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZSgnbWF4LXNhZmUtaW50ZWdlcicpO1xuICB0cnkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoTUFYX1NBRkVfSU5URUdFUikgJiYgTnVtYmVyLmlzRmluaXRlKEluZmluaXR5KSA9PT0gZmFsc2UpIHtcbiAgICAgICRpc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGlnbm9yZSkge31cbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSBudW1iZXIgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBmaW5pdGVuZXNzLlxuICogQHJldHVybnMge2Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICogdmFyIG51bUlzRmluaXRlID0gcmVxdWlyZSgnaXMtZmluaXRlLXgnKTtcbiAqXG4gKiBudW1Jc0Zpbml0ZShJbmZpbml0eSk7ICAvLyBmYWxzZVxuICogbnVtSXNGaW5pdGUoTmFOKTsgICAgICAgLy8gZmFsc2VcbiAqIG51bUlzRmluaXRlKC1JbmZpbml0eSk7IC8vIGZhbHNlXG4gKlxuICogbnVtSXNGaW5pdGUoMCk7ICAgICAgICAgLy8gdHJ1ZVxuICogbnVtSXNGaW5pdGUoMmU2NCk7ICAgICAgLy8gdHJ1ZVxuICpcbiAqIG51bUlzRmluaXRlKCcwJyk7ICAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsIGlzRmluaXRlKCcwJylcbiAqIG51bUlzRmluaXRlKG51bGwpOyAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRpc0Zpbml0ZSB8fCBmdW5jdGlvbiBpc0Zpbml0ZShudW1iZXIpIHtcbiAgcmV0dXJuICEodHlwZW9mIG51bWJlciAhPT0gJ251bWJlcicgfHwgJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSBJbmZpbml0eSB8fCBudW1iZXIgPT09IC1JbmZpbml0eSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE1hdGguc2lnbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1tYXRoLnNpZ258MjAuMi4yLjI5IE1hdGguc2lnbih4KX1cbiAqIEB2ZXJzaW9uIDEuMy4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBtYXRoLXNpZ24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJ2lzLW5hbicpO1xuXG52YXIgJHNpZ247XG5pZiAodHlwZW9mIE1hdGguc2lnbiA9PT0gJ2Z1bmN0aW9uJykge1xuICB0cnkge1xuICAgIGlmIChNYXRoLnNpZ24oMTApID09PSAxICYmIE1hdGguc2lnbigtMTApID09PSAtMSAmJiBNYXRoLnNpZ24oMCkgPT09IDApIHtcbiAgICAgICRzaWduID0gTWF0aC5zaWduO1xuICAgIH1cbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXIsIGluZGljYXRpbmcgd2hldGhlciB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLFxuICogbmVnYXRpdmUgb3IgemVyby5cbiAqXG4gKiBAcGFyYW0geyp9IHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgc2lnbiBvZiB0aGUgZ2l2ZW4gYXJndW1lbnQuIElmIHRoZSBhcmd1bWVudFxuICogaXMgYSBwb3NpdGl2ZSBudW1iZXIsIG5lZ2F0aXZlIG51bWJlciwgcG9zaXRpdmUgemVybyBvciBuZWdhdGl2ZSB6ZXJvLCB0aGUgZnVuY3Rpb24gd2lsbFxuICogcmV0dXJuIDEsIC0xLCAwIG9yIC0wIHJlc3BlY3RpdmVseS4gT3RoZXJ3aXNlLCBOYU4gaXMgcmV0dXJuZWQuXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hdGhTaWduID0gcmVxdWlyZSgnbWF0aC1zaWduLXgnKTtcbiAqXG4gKiBtYXRoU2lnbigzKTsgICAgIC8vICAxXG4gKiBtYXRoU2lnbigtMyk7ICAgIC8vIC0xXG4gKiBtYXRoU2lnbignLTMnKTsgIC8vIC0xXG4gKiBtYXRoU2lnbigwKTsgICAgIC8vICAwXG4gKiBtYXRoU2lnbigtMCk7ICAgIC8vIC0wXG4gKiBtYXRoU2lnbihOYU4pOyAgIC8vIE5hTlxuICogbWF0aFNpZ24oJ2ZvbycpOyAvLyBOYU5cbiAqIG1hdGhTaWduKCk7ICAgICAgLy8gTmFOXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJHNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIHZhciBuID0gTnVtYmVyKHgpO1xuICBpZiAobiA9PT0gMCB8fCAkaXNOYU4obikpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHJldHVybiBuID4gMCA/IDEgOiAtMTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFRvSW50ZWdlciBjb252ZXJ0cyAnYXJndW1lbnQnIHRvIGFuIGludGVncmFsIG51bWVyaWMgdmFsdWUuXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnRlZ2VyfDcuMS40IFRvSW50ZWdlciAoIGFyZ3VtZW50ICl9XG4gKiBAdmVyc2lvbiAxLjQuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8taW50ZWdlci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGlzTmFOID0gcmVxdWlyZSgnaXMtbmFuJyk7XG52YXIgJGlzRmluaXRlID0gcmVxdWlyZSgnaXMtZmluaXRlLXgnKTtcbnZhciAkc2lnbiA9IHJlcXVpcmUoJ21hdGgtc2lnbi14Jyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgndG8taW50ZWdlci14Jyk7XG4gKiB0b0ludGVnZXIoMyk7IC8vIDNcbiAqIHRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gMFxuICogdG9JbnRlZ2VyKEluZmluaXR5KTsgLy8gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqIHRvSW50ZWdlcignMycpOyAvLyAzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciBudW1iZXIgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAoJGlzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IDAgfHwgJGlzRmluaXRlKG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiAkc2lnbihudW1iZXIpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEVTNi1jb21wbGlhbnQgc2hpbSBmb3IgVG9MZW5ndGguXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGh8Ny4xLjE1IFRvTGVuZ3RoICggYXJndW1lbnQgKX1cbiAqIEB2ZXJzaW9uIDEuNC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1sZW5ndGgteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSByZXF1aXJlKCdtYXgtc2FmZS1pbnRlZ2VyJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICogYXJyYXktbGlrZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAqIHRvTGVuZ3RoKDMpOyAvLyAzXG4gKiB0b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gMFxuICogdG9MZW5ndGgoSW5maW5pdHkpOyAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICogdG9MZW5ndGgoJzMnKTsgLy8gM1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvTGVuZ3RoKHZhbHVlKSB7XG4gIHZhciBsZW4gPSB0b0ludGVnZXIodmFsdWUpO1xuICAvLyBpbmNsdWRlcyBjb252ZXJ0aW5nIC0wIHRvICswXG4gIGlmIChsZW4gPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDcm9zcy1icm93c2VyIGFycmF5LWxpa2Ugc2xpY2VyLlxuICogQHZlcnNpb24gMS4yLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFycmF5LWxpa2Utc2xpY2UteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCd0by1pbnRlZ2VyLXgnKS50b0ludGVnZXIyMDE4O1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKS50b0xlbmd0aDIwMTg7XG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCd2YWxpZGF0ZS5pby11bmRlZmluZWQnKTtcbnZhciBzcGxpdElmQm94ZWRCdWcgPSByZXF1aXJlKCdzcGxpdC1pZi1ib3hlZC1idWcteCcpO1xuXG52YXIgZ2V0TWF4ID0gZnVuY3Rpb24gX2dldE1heChhLCBiKSB7XG4gIHJldHVybiBhID49IGIgPyBhIDogYjtcbn07XG5cbnZhciBnZXRNaW4gPSBmdW5jdGlvbiBfZ2V0TWluKGEsIGIpIHtcbiAgcmV0dXJuIGEgPD0gYiA/IGEgOiBiO1xufTtcblxudmFyIHNldFJlbGF0aXZlID0gZnVuY3Rpb24gX3NldFJlbGF0aXZlKHZhbHVlLCBsZW5ndGgpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IGdldE1heChsZW5ndGggKyB2YWx1ZSwgMCkgOiBnZXRNaW4odmFsdWUsIGxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFRoZSBzbGljZSgpIG1ldGhvZCByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhbiBhcnJheSBpbnRvIGEgbmV3XG4gKiBhcnJheSBvYmplY3Qgc2VsZWN0ZWQgZnJvbSBiZWdpbiB0byBlbmQgKGVuZCBub3QgaW5jbHVkZWQpLiBUaGUgb3JpZ2luYWxcbiAqIGFycmF5IHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gYXJnc09iamVjdCAtIFRoZSBgYXJndW1lbnRzYCB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdIC0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBiZWdpbiBleHRyYWN0aW9uLlxuICogIEEgbmVnYXRpdmUgaW5kZXggY2FuIGJlIHVzZWQsIGluZGljYXRpbmcgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGVcbiAqICBzZXF1ZW5jZS4gc2xpY2UoLTIpIGV4dHJhY3RzIHRoZSBsYXN0IHR3byBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgYmVnaW4gaXMgdW5kZWZpbmVkLCBzbGljZSBiZWdpbnMgZnJvbSBpbmRleCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gWmVyby1iYXNlZCBpbmRleCBiZWZvcmUgd2hpY2ggdG8gZW5kIGV4dHJhY3Rpb24uXG4gKiAgU2xpY2UgZXh0cmFjdHMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLiBGb3IgZXhhbXBsZSwgc2xpY2UoWzAsMSwyLDMsNF0sMSw0KVxuICogIGV4dHJhY3RzIHRoZSBzZWNvbmQgZWxlbWVudCB0aHJvdWdoIHRoZSBmb3VydGggZWxlbWVudCAoZWxlbWVudHMgaW5kZXhlZFxuICogIDEsIDIsIGFuZCAzKS5cbiAqICBBIG5lZ2F0aXZlIGluZGV4IGNhbiBiZSB1c2VkLCBpbmRpY2F0aW5nIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlXG4gKiAgc2VxdWVuY2UuIHNsaWNlKDIsLTEpIGV4dHJhY3RzIHRoZSB0aGlyZCBlbGVtZW50IHRocm91Z2ggdGhlIHNlY29uZC10by1sYXN0XG4gKiAgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgZW5kIGlzIG9taXR0ZWQsIHNsaWNlIGV4dHJhY3RzIHRocm91Z2ggdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UgKGFyci5sZW5ndGgpLlxuICogIElmIGVuZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgc2VxdWVuY2UsIHNsaWNlIGV4dHJhY3RzIHRocm91Z2hcbiAqICB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSAoYXJyLmxlbmd0aCkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIGV4dHJhY3RlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXJyYXlMaWtlU2xpY2UgPSByZXF1aXJlKCdhcnJheS1saWtlLXNsaWNlLXgnKTtcbiAqIHZhciBhcmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzO1xuICogfSgnQmFuYW5hJywgJ09yYW5nZScsICdMZW1vbicsICdBcHBsZScsICdNYW5nbycpKTtcbiAqXG4gKiB2YXIgY2l0cnVzID0gYXJyYXlMaWtlU2xpY2UoYXJncywgMSwgMyk7XG4gKlxuICogLy8gYXJncyBjb250YWlucyBbJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGVtb24nLCAnQXBwbGUnLCAnTWFuZ28nXVxuICogLy8gY2l0cnVzIGNvbnRhaW5zIFsnT3JhbmdlJywnTGVtb24nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNsaWNlKGFycmF5TGlrZSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaXRlcmFibGUgPSBzcGxpdElmQm94ZWRCdWcodG9PYmplY3QoYXJyYXlMaWtlKSk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICB2YXIgayA9IHNldFJlbGF0aXZlKHRvSW50ZWdlcihzdGFydCksIGxlbmd0aCk7XG4gIHZhciByZWxhdGl2ZUVuZCA9IGlzVW5kZWZpbmVkKGVuZCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgdmFyIGZpbmFsRW5kID0gc2V0UmVsYXRpdmUocmVsYXRpdmVFbmQsIGxlbmd0aCk7XG4gIHZhciB2YWwgPSBbXTtcbiAgdmFsLmxlbmd0aCA9IGdldE1heChmaW5hbEVuZCAtIGssIDApO1xuICB2YXIgbmV4dCA9IDA7XG4gIHdoaWxlIChrIDwgZmluYWxFbmQpIHtcbiAgICBpZiAoayBpbiBpdGVyYWJsZSkge1xuICAgICAgdmFsW25leHRdID0gaXRlcmFibGVba107XG4gICAgfVxuXG4gICAgbmV4dCArPSAxO1xuICAgIGsgKz0gMTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDcmVhdGVzIGFuIGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gKiBAdmVyc2lvbiAyLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktbWFwLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYWNoZWRDdHJzID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14Jyk7XG52YXIgQXJyYXlDdHIgPSBjYWNoZWRDdHJzLkFycmF5O1xudmFyIGNhc3RPYmplY3QgPSBjYWNoZWRDdHJzLk9iamVjdDtcbnZhciBuYXRpdmVNYXAgPSB0eXBlb2YgQXJyYXlDdHIucHJvdG90eXBlLm1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheUN0ci5wcm90b3R5cGUubWFwO1xuXG52YXIgaXNXb3JraW5nO1xuaWYgKG5hdGl2ZU1hcCkge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICB2YXIgc3B5ID0gMDtcbiAgdmFyIHJlcyA9IGF0dGVtcHQuY2FsbChbMSwgMl0sIG5hdGl2ZU1hcCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG5cbiAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMiAmJiByZXMudmFsdWVbMF0gPT09IDEgJiYgcmVzLnZhbHVlWzFdID09PSAyO1xuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSAnJztcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoY2FzdE9iamVjdCgnYWInKSwgbmF0aXZlTWFwLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAyICYmIHJlcy52YWx1ZVswXSA9PT0gJ2EnICYmIHJlcy52YWx1ZVsxXSA9PT0gJ2InO1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHNweSA9IDA7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgIH0oMSwgMikpLCBuYXRpdmVNYXAsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDIgJiYgcmVzLnZhbHVlWzBdID09PSAxICYmIHJlcy52YWx1ZVsxXSA9PT0gMjtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSAwO1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCh7XG4gICAgICAwOiAxLFxuICAgICAgMjogMixcbiAgICAgIGxlbmd0aDogM1xuICAgIH0sIG5hdGl2ZU1hcCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMyAmJiAoMSBpbiByZXMudmFsdWUpID09PSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICBzcHkgPSBudWxsO1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKGZyYWdtZW50LmNoaWxkTm9kZXMsIG5hdGl2ZU1hcCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcblxuICAgICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiByZXMudmFsdWVbMF0gPT09IGRpdjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgdmFyIGlzU3RyaWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMpID09PSBmYWxzZTtcbiAgICB9KCkpO1xuXG4gICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICBzcHkgPSBudWxsO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKFsxXSwgbmF0aXZlTWFwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgICAgc3B5ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgfSwgJ3gnKTtcblxuICAgICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiBzcHkgPT09IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHNweSA9IHt9O1xuICAgIHZhciBmbiA9IFtcbiAgICAgICdyZXR1cm4gbmF0aXZlTWFwLmNhbGwoXCJmb29cIiwgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7JyxcbiAgICAgICdpZiAoQm9vbGVhbihjb250ZXh0KSA9PT0gZmFsc2UgfHwgdHlwZW9mIGNvbnRleHQgIT09IFwib2JqZWN0XCIpIHsnLFxuICAgICAgJ3NweS52YWx1ZSA9IHRydWU7fX0pOydcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgcmVzID0gYXR0ZW1wdChGdW5jdGlvbignbmF0aXZlTWFwJywgJ3NweScsIGZuKSwgbmF0aXZlTWFwLCBzcHkpO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMyAmJiBzcHkudmFsdWUgIT09IHRydWU7XG4gIH1cbn1cblxudmFyICRtYXA7XG5pZiAobmF0aXZlTWFwKSB7XG4gICRtYXAgPSBmdW5jdGlvbiBtYXAoYXJyYXksIGNhbGxCYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBhcmdzID0gW2NhbGxCYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZU1hcC5hcHBseShhcnJheSwgYXJncyk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgc3BsaXRJZkJveGVkQnVnID0gcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKS50b0xlbmd0aDIwMTg7XG4gIHZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xuICB2YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG5cbiAgJG1hcCA9IGZ1bmN0aW9uIG1hcChhcnJheSwgY2FsbEJhY2sgLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgIGFzc2VydElzRnVuY3Rpb24oY2FsbEJhY2spO1xuICAgIHZhciBpdGVyYWJsZSA9IHNwbGl0SWZCb3hlZEJ1ZyhvYmplY3QpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICAgIHZhciB0aGlzQXJnO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG5cbiAgICB2YXIgbm9UaGlzID0gaXNVbmRlZmluZWQodGhpc0FyZyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgcmVzdWx0W2ldID0gbm9UaGlzID8gY2FsbEJhY2soaXRlbSwgaSwgb2JqZWN0KSA6IGNhbGxCYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWRcbiAqIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNhbGxpbmcgYXJyYXkuXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbEJhY2sgLSBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGVsZW1lbnQgb2YgdGhlIEFycmF5LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2FycmF5fSBBIG5ldyBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICogY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hcCA9IHJlcXVpcmUoJ2FycmF5LW1hcC14Jyk7XG4gKlxuICogdmFyIG51bWJlcnMgPSBbMSwgNCwgOV07XG4gKiB2YXIgcm9vdHMgPSBtYXAobnVtYmVycywgTWF0aC5zcXJ0KTtcbiAqIC8vIHJvb3RzIGlzIG5vdyBbMSwgMiwgM11cbiAqIC8vIG51bWJlcnMgaXMgc3RpbGwgWzEsIDQsIDldXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJG1hcDtcbiIsIi8qKlxuICogQGZpbGUgSWYgaXNGdW5jdGlvbihjYWxsYmFja2ZuKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICogQHZlcnNpb24gMi4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFzc2VydC1pcy1mdW5jdGlvbi14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uLXgnKTtcbnZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKCd0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteCcpO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnaXMtcHJpbWl0aXZlJyk7XG5cbi8qKlxuICogVGVzdHMgYGNhbGxiYWNrYCB0byBzZWUgaWYgaXQgaXMgYSBmdW5jdGlvbiwgdGhyb3dzIGEgYFR5cGVFcnJvcmAgaWYgaXQgaXNcbiAqIG5vdC4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIGBjYWxsYmFja2AuXG4gKlxuICogQHBhcmFtIHsqfSBjYWxsYmFjayAtIFRoZSBhcmd1bWVudCB0byBiZSB0ZXN0ZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IFRocm93cyBpZiBgY2FsbGJhY2tgIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYGNhbGxiYWNrYCBpZiBpdCBpcyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG4gKiB2YXIgcHJpbWl0aXZlID0gdHJ1ZTtcbiAqIHZhciBteVN5bWJvbCA9IFN5bWJvbCgnbXlTeW1ib2wnKTtcbiAqIHZhciBzeW1PYmogPSBPYmplY3QobXlTeW1ib2wpO1xuICogdmFyIG9iamVjdCA9IHt9O1xuICogZnVuY3Rpb24gZm4gKCkge31cbiAqXG4gKiBhc3NlcnRJc0Z1bmN0aW9uKHByaW1pdGl2ZSk7XG4gKiAgICAvLyBUeXBlRXJyb3IgJ3RydWUgaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihvYmplY3QpO1xuICogICAgLy8gVHlwZUVycm9yICcjPE9iamVjdD4gaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihteVN5bWJvbCk7XG4gKiAgICAvLyBUeXBlRXJyb3IgJ1N5bWJvbChteVN5bWJvbCkgaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihzeW1PYmopO1xuICogICAgLy8gVHlwZUVycm9yICcjPE9iamVjdD4gaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihmbik7XG4gKiAgICAvLyBSZXR1cm5zIGZuLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2VydElzRnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spID09PSBmYWxzZSkge1xuICAgIHZhciBtc2cgPSBpc1ByaW1pdGl2ZShjYWxsYmFjaykgPyBzYWZlVG9TdHJpbmcoY2FsbGJhY2spIDogJyM8T2JqZWN0Pic7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2s7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBSZWR1Y2UgYW4gYXJyYXkgKGZyb20gbGVmdCB0byByaWdodCkgdG8gYSBzaW5nbGUgdmFsdWUuXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktcmVkdWNlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG52YXIgbmF0aXZlUmVkdWNlID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPT09ICdmdW5jdGlvbicgJiYgQXJyYXkucHJvdG90eXBlLnJlZHVjZTtcblxuLy8gRVM1IDE1LjQuNC4yMVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIxXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVxudmFyIGlzV29ya2luZztcbmlmIChuYXRpdmVSZWR1Y2UpIHtcbiAgaXNXb3JraW5nID0gYXR0ZW1wdC5jYWxsKFtdLCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChhY2MpIHtcbiAgICByZXR1cm4gYWNjO1xuICB9KS50aHJldztcblxuICB2YXIgcmVzO1xuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKE9iamVjdCgnYWJjJyksIG5hdGl2ZVJlZHVjZSwgZnVuY3Rpb24gKGFjYywgYykge1xuICAgICAgcmV0dXJuIGFjYyArIGM7XG4gICAgfSwgJ3gnKTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSAneGFiYyc7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgIH0oMSwgMiwgMykpLCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChhY2MsIGFyZykge1xuICAgICAgcmV0dXJuIGFjYyArIGFyZztcbiAgICB9LCAxKTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSA3O1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCh7XG4gICAgICAwOiAxLFxuICAgICAgMTogMixcbiAgICAgIDM6IDMsXG4gICAgICA0OiA0LFxuICAgICAgbGVuZ3RoOiA0XG4gICAgfSwgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjLCBhcmcpIHtcbiAgICAgIHJldHVybiBhY2MgKyBhcmc7XG4gICAgfSwgMik7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gODtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICByZXMgPSBhdHRlbXB0LmNhbGwoZnJhZ21lbnQuY2hpbGROb2RlcywgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgICAgIGFjY1thY2MubGVuZ3RoXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBbXSk7XG5cbiAgICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiByZXMudmFsdWVbMF0gPT09IGRpdjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoJ2FiJywgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHR5cGVvZiByZXMudmFsdWUgPT09ICdvYmplY3QnO1xuICB9XG59XG5cbnZhciAkcmVkdWNlO1xuaWYgKG5hdGl2ZVJlZHVjZSAmJiBpc1dvcmtpbmcpIHtcbiAgJHJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShhcnJheSwgY2FsbEJhY2sgLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICB2YXIgYXJncyA9IFtjYWxsQmFja107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBhcmdzWzFdID0gYXJndW1lbnRzWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVSZWR1Y2UuYXBwbHkoYXJyYXksIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gQ2hlY2sgZmFpbHVyZSBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMgKElFIDwgOSlcbiAgLy8gYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbiAgdmFyIHNwbGl0SWZCb3hlZEJ1ZyA9IHJlcXVpcmUoJ3NwbGl0LWlmLWJveGVkLWJ1Zy14Jyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcblxuICAkcmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGFycmF5LCBjYWxsQmFjayAvKiAsIGluaXRpYWxWYWx1ZSovKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgIGFzc2VydElzRnVuY3Rpb24oY2FsbEJhY2spO1xuICAgIHZhciBpdGVyYWJsZSA9IHNwbGl0SWZCb3hlZEJ1ZyhvYmplY3QpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJyYXlcbiAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3NMZW5ndGggPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKGFyZ3NMZW5ndGggPiAyKSB7XG4gICAgICByZXN1bHQgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKGkgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEJhY2socmVzdWx0LCBpdGVyYWJsZVtpXSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYXBwbGllcyBhIGZ1bmN0aW9uIGFnYWluc3QgYW4gYWNjdW11bGF0b3IgYW5kIGVhY2ggZWxlbWVudCBpbiB0aGVcbiAqIGFycmF5IChmcm9tIGxlZnQgdG8gcmlnaHQpIHRvIHJlZHVjZSBpdCB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsQmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gLSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdFxuICogIGNhbGwgb2YgdGhlIGNhbGxiYWNrLiBJZiBubyBpbml0aWFsIHZhbHVlIGlzIHN1cHBsaWVkLCB0aGUgZmlyc3QgZWxlbWVudCBpblxuICogIHRoZSBhcnJheSB3aWxsIGJlIHVzZWQuIENhbGxpbmcgcmVkdWNlIG9uIGFuIGVtcHR5IGFycmF5IHdpdGhvdXQgYW4gaW5pdGlhbFxuICogIHZhbHVlIGlzIGFuIGVycm9yLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcnJheSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgY2FsbEJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxlZCBvbiBhbiBlbXB0eSBhcnJheSB3aXRob3V0IGFuIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIHJlZHVjZSA9IHJlcXVpcmUoJ2FycmF5LXJlZHVjZS14Jyk7XG4gKlxuICogdmFyIHN1bSA9IHJlZHVjZShbMCwgMSwgMiwgM10sIGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgIHJldHVybiBhICsgYjtcbiAqIH0sIDApO1xuICogLy8gc3VtIGlzIDZcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkcmVkdWNlO1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE1hdGguc2lnbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1tYXRoLnNpZ258MjAuMi4yLjI5IE1hdGguc2lnbih4KX1cbiAqIEB2ZXJzaW9uIDIuMS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBtYXRoLXNpZ24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciBudW1iZXJJc05hTiA9IHJlcXVpcmUoJ2lzLW5hbi14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlciwgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsXG4gKiBuZWdhdGl2ZSBvciB6ZXJvLlxuICpcbiAqIEBwYXJhbSB7Kn0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMge251bWJlcn0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaWduIG9mIHRoZSBnaXZlbiBhcmd1bWVudC4gSWYgdGhlIGFyZ3VtZW50XG4gKiBpcyBhIHBvc2l0aXZlIG51bWJlciwgbmVnYXRpdmUgbnVtYmVyLCBwb3NpdGl2ZSB6ZXJvIG9yIG5lZ2F0aXZlIHplcm8sIHRoZSBmdW5jdGlvbiB3aWxsXG4gKiByZXR1cm4gMSwgLTEsIDAgb3IgLTAgcmVzcGVjdGl2ZWx5LiBPdGhlcndpc2UsIE5hTiBpcyByZXR1cm5lZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbWF0aFNpZ24gPSByZXF1aXJlKCdtYXRoLXNpZ24teCcpO1xuICpcbiAqIG1hdGhTaWduKDMpOyAgICAgLy8gIDFcbiAqIG1hdGhTaWduKC0zKTsgICAgLy8gLTFcbiAqIG1hdGhTaWduKCctMycpOyAgLy8gLTFcbiAqIG1hdGhTaWduKDApOyAgICAgLy8gIDBcbiAqIG1hdGhTaWduKC0wKTsgICAgLy8gLTBcbiAqIG1hdGhTaWduKE5hTik7ICAgLy8gTmFOXG4gKiBtYXRoU2lnbignZm9vJyk7IC8vIE5hTlxuICogbWF0aFNpZ24oKTsgICAgICAvLyBOYU5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaWduKHgpIHtcbiAgdmFyIG4gPSB0b051bWJlcih4KTtcbiAgaWYgKG4gPT09IDAgfHwgbnVtYmVySXNOYU4obikpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHJldHVybiBuID4gMCA/IDEgOiAtMTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFBhcnNlcyBhIHN0cmluZyBhcmd1bWVudCBhbmQgcmV0dXJucyBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgcGFyc2UtaW50LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuYXRpdmVQYXJzZUludCA9IHBhcnNlSW50O1xudmFyIHdzID0gcmVxdWlyZSgnd2hpdGUtc3BhY2UteCcpLnN0cmluZztcbnZhciB0b1N0ciA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG5cbnZhciAkcGFyc2VJbnQ7XG5pZiAobmF0aXZlUGFyc2VJbnQod3MgKyAnMDgnKSA9PT0gOCAmJiBuYXRpdmVQYXJzZUludCh3cyArICcweDE2JykgPT09IDIyKSB7XG4gICRwYXJzZUludCA9IGZ1bmN0aW9uIHBhcnNlSW50ZWdlcihzdHJpbmcsIHJhZGl4KSB7XG4gICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyKHN0cmluZyksIHJhZGl4KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciB0cmltID0gcmVxdWlyZSgndHJpbS14Jyk7XG4gIHZhciBjYXN0TnVtYmVyID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuTnVtYmVyO1xuICB2YXIgaGV4UmVnZXggPSAvXlstK10/MFt4WF0vO1xuICB2YXIgdGVzdCA9IGhleFJlZ2V4LnRlc3Q7XG5cbiAgJHBhcnNlSW50ID0gZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZywgcmFkaXgpIHtcbiAgICB2YXIgc3RyID0gdHJpbSh0b1N0cihzdHJpbmcpKTtcblxuICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHIsIGNhc3ROdW1iZXIocmFkaXgpIHx8ICh0ZXN0LmNhbGwoaGV4UmVnZXgsIHN0cikgPyAxNiA6IDEwKSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcGFyc2VzIGEgc3RyaW5nIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZFxuICogcmFkaXggKHRoZSBiYXNlIGluIG1hdGhlbWF0aWNhbCBudW1lcmFsIHN5c3RlbXMpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgdmFsdWUgdG8gcGFyc2UuIElmIHRoZSBzdHJpbmcgYXJndW1lbnQgaXMgbm90IGFcbiAqICBzdHJpbmcsIHRoZW4gaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nICh1c2luZyB0aGUgVG9TdHJpbmcgYWJzdHJhY3RcbiAqICBvcGVyYXRpb24pLiBMZWFkaW5nIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl4IC0gQW4gaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDM2IHRoYXQgcmVwcmVzZW50cyB0aGUgcmFkaXhcbiAqICAodGhlIGJhc2UgaW4gbWF0aGVtYXRpY2FsIG51bWVyYWwgc3lzdGVtcykgb2YgdGhlIGFib3ZlIG1lbnRpb25lZCBzdHJpbmcuXG4gKiAgU3BlY2lmeSAxMCBmb3IgdGhlIGRlY2ltYWwgbnVtZXJhbCBzeXN0ZW0gY29tbW9ubHkgdXNlZCBieSBodW1hbnMuIEFsd2F5c1xuICogIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIgdG8gZWxpbWluYXRlIHJlYWRlciBjb25mdXNpb24gYW5kIHRvIGd1YXJhbnRlZVxuICogIHByZWRpY3RhYmxlIGJlaGF2aW9yLiBEaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdHNcbiAqICB3aGVuIGEgcmFkaXggaXMgbm90IHNwZWNpZmllZCwgdXN1YWxseSBkZWZhdWx0aW5nIHRoZSB2YWx1ZSB0byAxMC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGFyZ2V0IGlzIGEgU3ltYm9sIG9yIGlzIG5vdCBjb2VyY2libGUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBbiBpbnRlZ2VyIG51bWJlciBwYXJzZWQgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLiBJZiB0aGUgZmlyc3RcbiAqICBjaGFyYWN0ZXIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgTmFOIGlzIHJldHVybmVkLlxuICogQGV4YW1wbGVcbiAqIHZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCdwYXJzZS1pbnQteCcpO1xuICpcbiAqIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgYWxsIHJldHVybiAxNVxuICogJHBhcnNlSW50KCcgMHhGJywgMTYpO1xuICogJHBhcnNlSW50KCcgRicsIDE2KTtcbiAqICRwYXJzZUludCgnMTcnLCA4KTtcbiAqICRwYXJzZUludCgwMjEsIDgpO1xuICogJHBhcnNlSW50KCcwMTUnLCAxMCk7ICAgLy8gJHBhcnNlSW50KDAxNSwgMTApOyB3aWxsIHJldHVybiAxNVxuICogJHBhcnNlSW50KDE1Ljk5LCAxMCk7XG4gKiAkcGFyc2VJbnQoJzE1LDEyMycsIDEwKTtcbiAqICRwYXJzZUludCgnRlhYMTIzJywgMTYpO1xuICogJHBhcnNlSW50KCcxMTExJywgMik7XG4gKiAkcGFyc2VJbnQoJzE1ICogMycsIDEwKTtcbiAqICRwYXJzZUludCgnMTVlMicsIDEwKTtcbiAqICRwYXJzZUludCgnMTVweCcsIDEwKTtcbiAqICRwYXJzZUludCgnMTInLCAxMyk7XG4gKlxuICogLy9UaGUgZm9sbG93aW5nIGV4YW1wbGVzIGFsbCByZXR1cm4gTmFOOlxuICogJHBhcnNlSW50KCdIZWxsbycsIDgpOyAvLyBOb3QgYSBudW1iZXIgYXQgYWxsXG4gKiAkcGFyc2VJbnQoJzU0NicsIDIpOyAgIC8vIERpZ2l0cyBhcmUgbm90IHZhbGlkIGZvciBiaW5hcnkgcmVwcmVzZW50YXRpb25zXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50O1xuIiwiLyoqXG4gKiBAZmlsZSBUb0ludGVnZXIgY29udmVydHMgJ2FyZ3VtZW50JyB0byBhbiBpbnRlZ3JhbCBudW1lcmljIHZhbHVlLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50ZWdlcnw3LjEuNCBUb0ludGVnZXIgKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMi4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWludGVnZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciBudW1iZXJJc05hTiA9IHJlcXVpcmUoJ2lzLW5hbi14Jyk7XG52YXIgbnVtYmVySXNGaW5pdGUgPSByZXF1aXJlKCdpcy1maW5pdGUteCcpO1xudmFyIG1hdGhTaWduID0gcmVxdWlyZSgnbWF0aC1zaWduLXgnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCd0by1pbnRlZ2VyLXgnKTtcbiAqIHRvSW50ZWdlcigzKTsgLy8gM1xuICogdG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpOyAvLyAwXG4gKiB0b0ludGVnZXIoSW5maW5pdHkpOyAvLyAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICogdG9JbnRlZ2VyKCczJyk7IC8vIDNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIG51bWJlciA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKG51bWJlcklzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IDAgfHwgbnVtYmVySXNGaW5pdGUobnVtYmVyKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgcmV0dXJuIG1hdGhTaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgRVM2LWNvbXBsaWFudCBzaGltIGZvciBUb0xlbmd0aC5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aHw3LjEuMTUgVG9MZW5ndGggKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMi4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWxlbmd0aC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgndG8taW50ZWdlci14Jyk7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IHJlcXVpcmUoJ21heC1zYWZlLWludGVnZXInKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gKiBhcnJheS1saWtlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpO1xuICogdG9MZW5ndGgoMyk7IC8vIDNcbiAqIHRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpOyAvLyAwXG4gKiB0b0xlbmd0aChJbmZpbml0eSk7IC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gKiB0b0xlbmd0aCgnMycpOyAvLyAzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgdmFyIGxlbiA9IHRvSW50ZWdlcih2YWx1ZSk7XG4gIC8vIGluY2x1ZGVzIGNvbnZlcnRpbmcgLTAgdG8gKzBcbiAgaWYgKGxlbiA8PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobGVuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2YgdHlwZSBOdW1iZXIuXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8tbnVtYmVyLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdHJ1Y3RvcnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbnZhciBjYXN0TnVtYmVyID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuTnVtYmVyO1xudmFyIFJ4ID0gY29uc3RydWN0b3JzLlJlZ0V4cDtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ3RvLXByaW1pdGl2ZS14Jyk7XG52YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJ3BhcnNlLWludC14Jyk7XG52YXIgcFN0clNsaWNlID0gJycuc2xpY2U7XG52YXIgTkFOID0gcmVxdWlyZSgnbmFuLXgnKTtcblxudmFyIGJpbmFyeVJlZ2V4ID0gL14wYlswMV0rJC9pO1xuLy8gTm90ZSB0aGF0IGluIElFIDgsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCBkb2Vzbid0IHNlZW0gdG8gZXhpc3Q6IGllLCBcInRlc3RcIiBpcyBhbiBvd24gcHJvcGVydHkgb2YgcmVnZXhlcy4gd3RmLlxudmFyIHRlc3QgPSBiaW5hcnlSZWdleC50ZXN0O1xudmFyIGlzQmluYXJ5ID0gZnVuY3Rpb24gX2lzQmluYXJ5KHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoYmluYXJ5UmVnZXgsIHZhbHVlKTtcbn07XG5cbnZhciBvY3RhbFJlZ2V4ID0gL14wb1swLTddKyQvaTtcbnZhciBpc09jdGFsID0gZnVuY3Rpb24gX2lzT2N0YWwodmFsdWUpIHtcbiAgcmV0dXJuIHRlc3QuY2FsbChvY3RhbFJlZ2V4LCB2YWx1ZSk7XG59O1xuXG52YXIgbm9uV1NyZWdleCA9IG5ldyBSeCgnW1xcdTAwODVcXHUyMDBiXFx1ZmZmZV0nLCAnZycpO1xudmFyIGhhc05vbldTID0gZnVuY3Rpb24gX2hhc05vbldTKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwobm9uV1NyZWdleCwgdmFsdWUpO1xufTtcblxudmFyIGludmFsaWRIZXhMaXRlcmFsID0gL15bLStdMHhbMC05YS1mXSskL2k7XG52YXIgaXNJbnZhbGlkSGV4TGl0ZXJhbCA9IGZ1bmN0aW9uIF9pc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoaW52YWxpZEhleExpdGVyYWwsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci5cblxuICogQHBhcmFtIHsqfSBhcmd1bWVudCAtIFRoZSBhcmd1bWVudCB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHRocm93cyB7VHlwZUVycm9yfSAtIElmIGFyZ3VtZW50IGlzIGEgU3ltYm9sIG9yIG5vdCBjb2VyY2libGUuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIGFyZ3VtZW50IGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCd0by1udW1iZXIteCcpO1xuICpcbiAqIHRvTnVtYmVyKCcxJyk7IC8vIDFcbiAqIHRvTnVtYmVyKG51bGwpOyAvLyAwXG4gKiB0b051bWJlcih0cnVlKTsgLy8gMVxuICogdG9OdW1iZXIoJzBvMTAnKTsgLy8gOFxuICogdG9OdW1iZXIoJzBiMTAnKTsgLy8gMlxuICogdG9OdW1iZXIoJzB4RicpOyAvLyAxNlxuICpcbiAqIHRvTnVtYmVyKCcgMSAnKTsgLy8gMVxuICpcbiAqIHRvTnVtYmVyKFN5bWJvbCgnJykpIC8vIFR5cGVFcnJvclxuICogdG9OdW1iZXIoT2JqZWN0LmNyZWF0ZShudWxsKSkgLy8gVHlwZUVycm9yXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9OdW1iZXIoYXJndW1lbnQpIHtcbiAgdmFyIHZhbHVlID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIE51bWJlcik7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKCRwYXJzZUludChwU3RyU2xpY2UuY2FsbCh2YWx1ZSwgMiksIDIpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPY3RhbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b051bWJlcigkcGFyc2VJbnQocFN0clNsaWNlLmNhbGwodmFsdWUsIDIpLCA4KSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5BTjtcbiAgICB9XG5cbiAgICB2YXIgdHJpbW1lZCA9IHRyaW0odmFsdWUpO1xuICAgIGlmICh0cmltbWVkICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHRyaW1tZWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYXN0TnVtYmVyKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENyb3NzLWJyb3dzZXIgYXJyYXkgc2xpY2VyLlxuICogQHZlcnNpb24gMy41LjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFycmF5LXNsaWNlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xudmFyIGFycmF5TGlrZVNsaWNlID0gcmVxdWlyZSgnYXJyYXktbGlrZS1zbGljZS14Jyk7XG52YXIgbmF0aXZlU2xpY2UgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNTdHJpbmc7XG52YXIgZmFpbEFycjtcbnZhciBmYWlsRE9NO1xuaWYgKG5hdGl2ZVNsaWNlKSB7XG4gIHZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gIHZhciByZXMgPSBhdHRlbXB0LmNhbGwoW1xuICAgIDEsXG4gICAgMixcbiAgICAzXG4gIF0sIG5hdGl2ZVNsaWNlLCAxLCAyKTtcblxuICBmYWlsQXJyID0gcmVzLnRocmV3IHx8IGlzQXJyYXkocmVzLnZhbHVlKSA9PT0gZmFsc2UgfHwgcmVzLnZhbHVlLmxlbmd0aCAhPT0gMSB8fCByZXMudmFsdWVbMF0gIT09IDI7XG4gIGlmIChmYWlsQXJyID09PSBmYWxzZSkge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCgnYWJjJywgbmF0aXZlU2xpY2UsIDEsIDIpO1xuICAgIGlzU3RyaW5nID0gKHJlcy50aHJldyB8fCByZXMudmFsdWUubGVuZ3RoICE9PSAxIHx8IHJlcy52YWx1ZVswXSAhPT0gJ2InKSAmJiByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBmYWlsRE9NID0gZG9jICYmIGF0dGVtcHQuY2FsbChkb2MuZG9jdW1lbnRFbGVtZW50LCBuYXRpdmVTbGljZSkudGhyZXc7XG4gIH1cbn0gZWxzZSB7XG4gIGZhaWxBcnIgPSB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBzbGljZSgpIG1ldGhvZCByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhbiBhcnJheSBpbnRvIGEgbmV3XG4gKiBhcnJheSBvYmplY3Qgc2VsZWN0ZWQgZnJvbSBiZWdpbiB0byBlbmQgKGVuZCBub3QgaW5jbHVkZWQpLiBUaGUgb3JpZ2luYWxcbiAqIGFycmF5IHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcnJheSAtIFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdIC0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBiZWdpbiBleHRyYWN0aW9uLlxuICogIEEgbmVnYXRpdmUgaW5kZXggY2FuIGJlIHVzZWQsIGluZGljYXRpbmcgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGVcbiAqICBzZXF1ZW5jZS4gc2xpY2UoLTIpIGV4dHJhY3RzIHRoZSBsYXN0IHR3byBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgYmVnaW4gaXMgdW5kZWZpbmVkLCBzbGljZSBiZWdpbnMgZnJvbSBpbmRleCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gWmVyby1iYXNlZCBpbmRleCBiZWZvcmUgd2hpY2ggdG8gZW5kIGV4dHJhY3Rpb24uXG4gKiAgU2xpY2UgZXh0cmFjdHMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLiBGb3IgZXhhbXBsZSwgc2xpY2UoMSw0KVxuICogIGV4dHJhY3RzIHRoZSBzZWNvbmQgZWxlbWVudCB0aHJvdWdoIHRoZSBmb3VydGggZWxlbWVudCAoZWxlbWVudHMgaW5kZXhlZFxuICogIDEsIDIsIGFuZCAzKS5cbiAqICBBIG5lZ2F0aXZlIGluZGV4IGNhbiBiZSB1c2VkLCBpbmRpY2F0aW5nIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlXG4gKiAgc2VxdWVuY2UuIHNsaWNlKDIsLTEpIGV4dHJhY3RzIHRoZSB0aGlyZCBlbGVtZW50IHRocm91Z2ggdGhlIHNlY29uZC10by1sYXN0XG4gKiAgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgZW5kIGlzIG9taXR0ZWQsIHNsaWNlIGV4dHJhY3RzIHRocm91Z2ggdGhlIGVuZCBvZiB0aGVcbiAqICBzZXF1ZW5jZSAoYXJyLmxlbmd0aCkuXG4gKiAgSWYgZW5kIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSwgc2xpY2UgZXh0cmFjdHMgdGhyb3VnaFxuICogIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlIChhcnIubGVuZ3RoKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgZXh0cmFjdGVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqIHZhciBzbGljZSA9IHJlcXVpcmUoJ2FycmF5LXNsaWNlLXgnKTtcbiAqIHZhciBmcnVpdHMgPSBbJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGVtb24nLCAnQXBwbGUnLCAnTWFuZ28nXTtcbiAqIHZhciBjaXRydXMgPSBzbGljZShmcnVpdHMsIDEsIDMpO1xuICpcbiAqIC8vIGZydWl0cyBjb250YWlucyBbJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGVtb24nLCAnQXBwbGUnLCAnTWFuZ28nXVxuICogLy8gY2l0cnVzIGNvbnRhaW5zIFsnT3JhbmdlJywnTGVtb24nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gIGlmIChmYWlsQXJyIHx8IChmYWlsRE9NICYmIGlzQXJyYXkob2JqZWN0KSA9PT0gZmFsc2UpIHx8IChpc1N0cmluZyAmJiBpc1N0cmluZyhvYmplY3QpKSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSB7XG4gICAgcmV0dXJuIGFycmF5TGlrZVNsaWNlKG9iamVjdCwgc3RhcnQsIGVuZCk7XG4gIH1cblxuICByZXR1cm4gbmF0aXZlU2xpY2UuYXBwbHkob2JqZWN0LCBhcnJheUxpa2VTbGljZShhcmd1bWVudHMsIDEpKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFRlc3RzIHdoZXRoZXIgc29tZSBlbGVtZW50IHBhc3NlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAxLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktc29tZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIGFzc2VydElzRnVuY3Rpb24gPSByZXF1aXJlKCdhc3NlcnQtaXMtZnVuY3Rpb24teCcpO1xuXG52YXIgdGVzdHMgPSB7XG4gIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gIHByb3Blcmx5Qm94ZXNOb25TdHJpY3Q6IHRydWUsXG4gIHByb3Blcmx5Qm94ZXNTdHJpY3Q6IHRydWVcbn07XG5cbnZhciBuYXRpdmVTb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG5pZiAobmF0aXZlU29tZSkge1xuICB0cnkge1xuICAgIG5hdGl2ZVNvbWUuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgIHRlc3RzLnByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgfSwgJ3gnKTtcblxuICAgIHZhciBmbiA9IFtcbiAgICAgICdyZXR1cm4gbmF0aXZlU29tZS5jYWxsKFwiZm9vXCIsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkgeycsXG4gICAgICAnaWYgKEJvb2xlYW4oY29udGV4dCkgPT09IGZhbHNlIHx8IHR5cGVvZiBjb250ZXh0ICE9PSBcIm9iamVjdFwiKSB7JyxcbiAgICAgICd0ZXN0cy5wcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7fX0pOydcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgRnVuY3Rpb24oJ25hdGl2ZVNvbWUnLCAndGVzdHMnLCBmbikobmF0aXZlU29tZSwgdGVzdHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmF0aXZlU29tZSA9IG51bGw7XG4gIH1cbn1cblxudmFyICRzb21lO1xuaWYgKG5hdGl2ZVNvbWUgJiYgdGVzdHMucHJvcGVybHlCb3hlc05vblN0cmljdCAmJiB0ZXN0cy5wcm9wZXJseUJveGVzU3RyaWN0KSB7XG4gICRzb21lID0gZnVuY3Rpb24gc29tZShhcnJheSwgY2FsbEJhY2sgLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICB2YXIgYXJncyA9IFthc3NlcnRJc0Z1bmN0aW9uKGNhbGxCYWNrKV07XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzWzJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlU29tZS5hcHBseShvYmplY3QsIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gRVM1IDE1LjQuNC4xN1xuICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTdcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxuICB2YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAgdmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG4gIHZhciBzcGxpdFN0cmluZyA9IHJlcXVpcmUoJ2hhcy1ib3hlZC1zdHJpbmcteCcpID09PSBmYWxzZTtcbiAgJHNvbWUgPSBmdW5jdGlvbiBzb21lKGFycmF5LCBjYWxsQmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsQmFjayk7XG4gICAgdmFyIGl0ZXJhYmxlID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcob2JqZWN0KSA/IG9iamVjdC5zcGxpdCgnJykgOiBvYmplY3Q7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7XG4gICAgdmFyIHRoaXNBcmc7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChpIGluIGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzQXJnKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxCYWNrKGl0ZXJhYmxlW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxCYWNrLmNhbGwodGhpc0FyZywgaXRlcmFibGVbaV0sIGksIG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGVzdHMgd2hldGhlciBzb21lIGVsZW1lbnQgaW4gdGhlIGFycmF5IHBhc3NlcyB0aGUgdGVzdFxuICogaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxCYWNrIC0gRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3JcbiAqICBhbnkgYXJyYXkgZWxlbWVudDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBzb21lID0gcmVxdWlyZSgnYXJyYXktc29tZS14Jyk7XG4gKlxuICogZnVuY3Rpb24gaXNCaWdnZXJUaGFuMTAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gKiAgIHJldHVybiBlbGVtZW50ID4gMTA7XG4gKiB9XG4gKlxuICogc29tZShbMiwgNSwgOCwgMSwgNF0sIGlzQmlnZ2VyVGhhbjEwKTsgIC8vIGZhbHNlXG4gKiBzb21lKFsxMiwgNSwgOCwgMSwgNF0sIGlzQmlnZ2VyVGhhbjEwKTsgLy8gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRzb21lO1xuIiwiLyoqXG4gKiBAZmlsZSBJZiBpc0Z1bmN0aW9uKGNhbGxiYWNrZm4pIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXNzZXJ0LWlzLWZ1bmN0aW9uLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIHNhZmVUb1N0cmluZyA9IHJlcXVpcmUoJ3NhZmUtdG8tc3RyaW5nLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAqIFRlc3RzIGBjYWxsYmFja2AgdG8gc2VlIGlmIGl0IGlzIGEgZnVuY3Rpb24sIHRocm93cyBhIGBUeXBlRXJyb3JgIGlmIGl0IGlzXG4gKiBub3QuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBgY2FsbGJhY2tgLlxuICpcbiAqIEBwYXJhbSB7Kn0gY2FsbGJhY2sgLSBUaGUgYXJndW1lbnQgdG8gYmUgdGVzdGVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBUaHJvd3MgaWYgYGNhbGxiYWNrYCBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGBjYWxsYmFja2AgaWYgaXQgaXMgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGFzc2VydElzRnVuY3Rpb24gPSByZXF1aXJlKCdhc3NlcnQtaXMtZnVuY3Rpb24teCcpO1xuICogdmFyIHByaW1pdGl2ZSA9IHRydWU7XG4gKiB2YXIgbXlTeW1ib2wgPSBTeW1ib2woJ215U3ltYm9sJyk7XG4gKiB2YXIgc3ltT2JqID0gT2JqZWN0KG15U3ltYm9sKTtcbiAqIHZhciBvYmplY3QgPSB7fTtcbiAqIGZ1bmN0aW9uIGZuICgpIHt9XG4gKlxuICogYXNzZXJ0SXNGdW5jdGlvbihwcmltaXRpdmUpO1xuICogICAgLy8gVHlwZUVycm9yICd0cnVlIGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24ob2JqZWN0KTtcbiAqICAgIC8vIFR5cGVFcnJvciAnIzxPYmplY3Q+IGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24obXlTeW1ib2wpO1xuICogICAgLy8gVHlwZUVycm9yICdTeW1ib2wobXlTeW1ib2wpIGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24oc3ltT2JqKTtcbiAqICAgIC8vIFR5cGVFcnJvciAnIzxPYmplY3Q+IGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24oZm4pO1xuICogICAgLy8gUmV0dXJucyBmbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgbXNnID0gaXNQcmltaXRpdmUoY2FsbGJhY2spID8gc2FmZVRvU3RyaW5nKGNhbGxiYWNrKSA6ICcjPE9iamVjdD4nO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBjYWxsYmFjaztcbn07XG4iLCIvKipcbiAqIEBmaWxlIElmIElzT2JqZWN0KHZhbHVlKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICogQHZlcnNpb24gMS4zLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFzc2VydC1pcy1vYmplY3QteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNhZmVUb1N0cmluZyA9IHJlcXVpcmUoJ3NhZmUtdG8tc3RyaW5nLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAgICogVGVzdHMgYHZhbHVlYCB0byBzZWUgaWYgaXQgaXMgYW4gb2JqZWN0LCB0aHJvd3MgYSBgVHlwZUVycm9yYCBpZiBpdCBpc1xuICAgKiBub3QuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIGFyZ3VtZW50IHRvIGJlIHRlc3RlZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBUaHJvd3MgaWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgIGlmIGl0IGlzIGFuIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGFzc2VydElzT2JqZWN0ID0gcmVxdWlyZSgnYXNzZXJ0LWlzLW9iamVjdC14Jyk7XG4gICAqIHZhciBwcmltaXRpdmUgPSB0cnVlO1xuICAgKiB2YXIgbXlTeW1ib2wgPSBTeW1ib2woJ215U3ltYm9sJyk7XG4gICAqIHZhciBzeW1PYmogPSBPYmplY3QobXlTeW1ib2wpO1xuICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAqIGZ1bmN0aW9uIGZuICgpIHt9XG4gICAqXG4gICAqIGFzc2VydElzT2JqZWN0KHByaW1pdGl2ZSk7IC8vIFR5cGVFcnJvciAndHJ1ZSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChteVN5bWJvbCk7IC8vIFR5cGVFcnJvciAnU3ltYm9sKG15U3ltYm9sKSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChzeW1PYmopOyAvLyBSZXR1cm5zIHN5bU9iai5cbiAgICogYXNzZXJ0SXNPYmplY3Qob2JqZWN0KTsgLy8gUmV0dXJucyBvYmplY3QuXG4gICAqIGFzc2VydElzT2JqZWN0KGZuKTsgLy8gUmV0dXJucyBmbi5cbiAgICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2VydElzT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBJbnZva2VzIGZ1bmN0aW9uLCByZXR1cm5pbmcgYW4gb2JqZWN0IG9mIHRoZSByZXN1bHRzLlxuICogQHZlcnNpb24gMS4xLjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGF0dGVtcHQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEFyZ3MgPSBmdW5jdGlvbiBfZ2V0QXJncyhhcmdzKSB7XG4gIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aCA+Pj4gMDtcbiAgdmFyIGFycmF5ID0gW107XG4gIHZhciBhcmdMZW5ndGggPSBsZW5ndGggLSAxO1xuICBpZiAoYXJnTGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIGFycmF5Lmxlbmd0aCA9IGFyZ0xlbmd0aDtcbiAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFycmF5W2luZGV4IC0gMV0gPSBhcmdzW2luZGV4XTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yXG4gKiB0aGUgY2F1Z2h0IGVycm9yIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGVcbiAqIGZ1bmN0aW9uIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgb2YgdGhlIHJlc3VsdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICpcbiAqIGZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gKiAgIHRocm93IG5ldyBFcnJvcignVGhyZXcnKTtcbiAqIH1cbiAqXG4gKiBhdHRlbXB0KHRocm93ZXIsIDEsIDIpO1xuICogLy8ge1xuICogLy8gICB0aHJldzogdHJ1ZSxcbiAqIC8vICAgdmFsdWU6IC8vIEVycm9yKCdUaHJldycpIG9iamVjdFxuICogLy8gfVxuICpcbiAqIGZ1bmN0aW9uIHN1bUFyZ3MoYSwgYikge1xuICogICByZXR1cm4gYSArIGI7XG4gKiB9XG4gKlxuICogYXR0ZW1wdChzdW1BcmdzLCAxLCAyKTtcbiAqIC8vIHtcbiAqIC8vICAgdGhyZXc6IGZhbHNlLFxuICogLy8gICB2YWx1ZTogM1xuICogLy8gfVxuICpcbiAqIHZhciB0aGlzQXJnID0gW107XG4gKiBmdW5jdGlvbiBwdXNoZXIoYSwgYikge1xuICogICByZXR1cm4gdGhpcy5wdXNoKGEsIGIpO1xuICogfVxuICpcbiAqIGF0dGVtcHQuY2FsbCh0aGlzQXJnLCBwdXNoZXIsIDEsIDIpO1xuICogLy8ge1xuICogLy8gICB0aHJldzogZmFsc2UsXG4gKiAvLyAgIHZhbHVlOiAyXG4gKiAvLyB9XG4gKiAvLyB0aGlzQXJnID0+IFsxLCAyXTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdHRlbXB0KGZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmV3OiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmbi5hcHBseSh0aGlzLCBnZXRBcmdzKGFyZ3VtZW50cykpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0aHJldzogdHJ1ZSxcbiAgICAgIHZhbHVlOiBlXG4gICAgfTtcbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIGZvcm1hdCA9IHJlcXVpcmUoJ3V0aWwtZm9ybWF0LXgnKTtcblxudmFyIHN1cGVyYWdlbnQgPSByZXF1aXJlKCdAbGFkanMvc3VwZXJhZ2VudCcpO1xuXG52YXIgY3VpZCA9IHJlcXVpcmUoJ2N1aWQnKTtcblxudmFyIHBhcnNlRXJyID0gcmVxdWlyZSgncGFyc2UtZXJyJyk7XG5cbnZhciBzYWZlU3RyaW5naWZ5ID0gcmVxdWlyZSgnZmFzdC1zYWZlLXN0cmluZ2lmeScpOyAvLyA8aHR0cHM6Ly9sYWNrZS5tbi9yZWR1Y2UteW91ci1idW5kbGUtanMtZmlsZS1zaXplLz5cbi8vIDxodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2JhYmVsLXBsdWdpbi1sb2Rhc2gvaXNzdWVzLzIyMT5cblxuXG52YXIgaXNFcnJvciA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Vycm9yJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc09iamVjdCcpO1xuXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdsb2Rhc2gvaXNTdHJpbmcnKTtcblxudmFyIGluY2x1ZGVzID0gcmVxdWlyZSgnbG9kYXNoL2luY2x1ZGVzJyk7XG5cbnZhciBvbWl0ID0gcmVxdWlyZSgnbG9kYXNoL29taXQnKTtcblxudmFyIGlzRW1wdHkgPSByZXF1aXJlKCdsb2Rhc2gvaXNFbXB0eScpO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1VuZGVmaW5lZCcpO1xuXG52YXIgaXNOdWxsID0gcmVxdWlyZSgnbG9kYXNoL2lzTnVsbCcpO1xuXG52YXIgYm9vbGVhbiA9IHJlcXVpcmUoJ2Jvb2xlYW4nKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnbWVzc2FnZS1oZWFkZXJzJyksXG4gICAgc3RhbmRhcmQgPSBfcmVxdWlyZS5zdGFuZGFyZDtcblxudmFyIGZvcm1hdFNwZWNpZmllcnMgPSByZXF1aXJlKCdmb3JtYXQtc3BlY2lmaWVycycpO1xuXG52YXIgc3RhbmRhcmRIZWFkZXJzID0gc3RhbmRhcmQubWFwKGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBvWydIZWFkZXIgRmllbGQgTmFtZSddLnRvTG93ZXJDYXNlKCk7XG59KTtcbnZhciBoYXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bmFzc2lnbmVkLWltcG9ydFxuXG5yZXF1aXJlKCdjb25zb2xlLXBvbHlmaWxsJyk7XG5cbnZhciBsZXZlbHMgPSBbJ3RyYWNlJywgJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsICdlcnJvcicsICdmYXRhbCddO1xudmFyIGVuZHBvaW50ID0gJ2h0dHBzOi8vYXBpLmNhYmluanMuY29tJztcbnZhciBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xuXG52YXIgQXhlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXhlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBeGUpO1xuXG4gICAgdGhpcy5jb25maWcgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGtleTogJycsXG4gICAgICBlbmRwb2ludDogZW5kcG9pbnQsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICByZXRyeTogMyxcbiAgICAgIHNob3dTdGFjazogYm9vbGVhbihwcm9jZXNzLmVudi5TSE9XX1NUQUNLIHx8IGVudiAhPT0gJ3Byb2R1Y3Rpb24nKSxcbiAgICAgIHNob3dNZXRhOiBib29sZWFuKHByb2Nlc3MuZW52LlNIT1dfTUVUQSksXG4gICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgbG9nZ2VyOiBjb25zb2xlLFxuICAgICAgbGV2ZWxzOiBbJ2luZm8nLCAnd2FybicsICdlcnJvcicsICdmYXRhbCddLFxuICAgICAgY2FwdHVyZTogZW52ID09PSAncHJvZHVjdGlvbidcbiAgICB9LCBjb25maWcpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb21pdCh0aGlzLmNvbmZpZy5sb2dnZXIsIFsnY29uZmlnJywgJ2xvZyddKSk7IC8vIHdlIGNvdWxkIGhhdmUgdXNlZCBgYXV0by1iaW5kYCBidXQgaXQncyBub3QgY29tcGlsZWQgZm9yIGJyb3dzZXJcblxuICAgIHRoaXMubG9nID0gdGhpcy5sb2cuYmluZCh0aGlzKTsgLy8gYmluZCBoZWxwZXIgZnVuY3Rpb25zIGZvciBlYWNoIGxvZyBsZXZlbFxuXG4gICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICBfdGhpc1tsZXZlbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMubG9nLmFwcGx5KF90aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkoW2xldmVsXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpKTtcbiAgICAgIH07XG4gICAgfSk7IC8vIGFsaWFzZXNcblxuICAgIHRoaXMuZXJyID0gdGhpcy5lcnJvcjtcbiAgICB0aGlzLndhcm5pbmcgPSB0aGlzLndhcm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuXG4gIF9jcmVhdGVDbGFzcyhBeGUsIFt7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UsIG1ldGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgb3JpZ2luYWxBcmdzID0gW2xldmVsLCBtZXNzYWdlXTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQobWV0YSkpIG9yaWdpbmFsQXJncy5wdXNoKG1ldGEpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAzID8gX2xlbjIgLSAzIDogMCksIF9rZXkyID0gMzsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbEFyZ3MgPSBvcmlnaW5hbEFyZ3MuY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgdmFyIG1vZGlmaWVyID0gMDtcbiAgICAgIGlmIChsZXZlbCA9PT0gJ3dhcm5pbmcnKSBsZXZlbCA9ICd3YXJuJztcbiAgICAgIGlmIChsZXZlbCA9PT0gJ2VycicpIGxldmVsID0gJ2Vycm9yJztcblxuICAgICAgaWYgKGlzRXJyb3IobGV2ZWwpKSB7XG4gICAgICAgIG1ldGEgPSBtZXNzYWdlO1xuICAgICAgICBtZXNzYWdlID0gbGV2ZWw7XG4gICAgICAgIGxldmVsID0gJ2Vycm9yJztcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKGxldmVsKSB8fCAhaW5jbHVkZXMobGV2ZWxzLCBsZXZlbCkpIHtcbiAgICAgICAgbWV0YSA9IG1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2UgPSBsZXZlbDtcbiAgICAgICAgbGV2ZWwgPSAnaW5mbyc7XG4gICAgICAgIG1vZGlmaWVyID0gLTE7XG4gICAgICB9IC8vIGlmIHRoZXJlIGFyZSBmb3VyIG9yIG1vcmUgYXJnc1xuICAgICAgLy8gdGhlbiBpbmZlciB0byB1c2UgdXRpbC5mb3JtYXQgb24gZXZlcnl0aGluZ1xuXG5cbiAgICAgIGlmIChvcmlnaW5hbEFyZ3MubGVuZ3RoID49IDQgKyBtb2RpZmllcikge1xuICAgICAgICBtZXNzYWdlID0gZm9ybWF0LmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KG9yaWdpbmFsQXJncy5zbGljZSgxICsgbW9kaWZpZXIpKSk7XG4gICAgICAgIG1ldGEgPSB7fTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxBcmdzLmxlbmd0aCA9PT0gMyArIG1vZGlmaWVyICYmIGlzU3RyaW5nKG1lc3NhZ2UpICYmIGZvcm1hdFNwZWNpZmllcnMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gaW5jbHVkZXMobWVzc2FnZSwgdCk7XG4gICAgICB9KSkge1xuICAgICAgICAvLyBvdGhlcndpc2UgaWYgdGhlcmUgYXJlIHRocmVlIGFyZ3MgYW5kIGlmIHRoZSBgbWVzc2FnZWAgY29udGFpbnNcbiAgICAgICAgLy8gYSBwbGFjZWhvbGRlciB0b2tlbiAoZS5nLiAnJXMnIG9yICclZCcgLSBzZWUgYWJvdmUgYGZvcm1hdFNwZWNpZmllcnNgIHZhcmlhYmxlKVxuICAgICAgICAvLyB0aGVuIHdlIGNhbiBpbmZlciB0aGF0IHRoZSBgbWV0YWAgYXJnIHBhc3NlZCBpcyB1c2VkIGZvciBmb3JtYXR0aW5nXG4gICAgICAgIG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgbWV0YSk7XG4gICAgICAgIG1ldGEgPSB7fTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRXJyb3IobWVzc2FnZSkpIHtcbiAgICAgICAgaWYgKGlzRXJyb3IobWV0YSkpIHtcbiAgICAgICAgICBtZXRhID0ge1xuICAgICAgICAgICAgZXJyOiBwYXJzZUVycihtZXRhKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzUGxhaW5PYmplY3QobWV0YSkgJiYgIWlzVW5kZWZpbmVkKG1ldGEpICYmICFpc051bGwobWV0YSkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgYG1ldGFgIHZhcmlhYmxlIHBhc3NlZCB3YXMgbm90IGFuIE9iamVjdCB0aGVuIGNvbnZlcnQgaXRcbiAgICAgICAgICBtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIG1ldGEpO1xuICAgICAgICAgIG1ldGEgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpbmcobWVzc2FnZSkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbWVzc2FnZSBpcyBub3QgYSBzdHJpbmcgdGhlbiB3ZSBzaG91bGQgcnVuIGB1dGlsLmZvcm1hdGAgb24gaXRcbiAgICAgICAgICAvLyBhc3N1bWluZyB3ZSdyZSBmb3JtYXR0aW5nIGl0IGxpa2UgaXQgd2FzIGFub3RoZXIgYXJndW1lbnRcbiAgICAgICAgICAvLyAoYXMgb3Bwb3NlZCB0byB1c2luZyBzb21ldGhpbmcgbGlrZSBmYXN0LWpzb24tc3RyaW5naWZ5KVxuICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KG1ldGEpKSBtZXRhID0ge307XG4gICAgICB2YXIgZXJyO1xuXG4gICAgICBpZiAoaXNFcnJvcihtZXNzYWdlKSkge1xuICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KG1ldGEuZXJyKSkgbWV0YS5lcnIgPSBwYXJzZUVycihlcnIpO1xuICAgICAgICB2YXIgX21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBtZXNzYWdlID0gX21lc3NhZ2UubWVzc2FnZTtcbiAgICAgIH0gLy8gc2V0IGRlZmF1bHQgbGV2ZWwgb24gbWV0YVxuXG5cbiAgICAgIG1ldGEubGV2ZWwgPSBsZXZlbDsgLy8gc2V0IHRoZSBib2R5IHVzZWQgZm9yIHJldHVybmluZyB3aXRoIGFuZCBzZW5kaW5nIGxvZ3NcbiAgICAgIC8vIChhbmQgYWxzbyByZW1vdmUgY2lyY3VsYXIgcmVmZXJlbmNlcylcblxuICAgICAgdmFyIGJvZHkgPSBzYWZlU3RyaW5naWZ5KHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgbWV0YTogbWV0YVxuICAgICAgfSk7IC8vIHNlbmQgdG8gQ2FiaW4gb3Igb3RoZXIgbG9nZ2luZyBzZXJ2aWNlIGhlcmUgdGhlIGBtZXNzYWdlYCBhbmQgYG1ldGFgXG5cbiAgICAgIGlmIChjb25maWcuY2FwdHVyZSAmJiBpbmNsdWRlcyhjb25maWcubGV2ZWxzLCBsZXZlbCkgJiYgKCFpc0Vycm9yKGVycikgfHwgIWVyci5fY2FwdHVyZUZhaWxlZCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZGlkbid0IHNwZWNpZnkgYSBrZXlcbiAgICAgICAgLy8gYW5kIHRoZXkgYXJlIHVzaW5nIHRoZSBkZWZhdWx0IGVuZHBvaW50XG4gICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIHRocm93IGFuIGVycm9yIHRvIHRoZW1cbiAgICAgICAgaWYgKGNvbmZpZy5lbmRwb2ludCA9PT0gZW5kcG9pbnQgJiYgIWNvbmZpZy5rZXkpIHRocm93IG5ldyBFcnJvcihcIkNhYmluIEFQSSBrZXkgcmVxdWlyZWQgKGUuZy4gYHsga2V5OiAnWU9VUi1DQUJJTi1BUEktS0VZJyB9KWApXFxuPGh0dHBzOi8vY2FiaW5qcy5jb20+XCIpOyAvLyBjYXB0dXJlIHRoZSBsb2cgb3ZlciBIVFRQXG5cbiAgICAgICAgdmFyIHJlcSA9IHN1cGVyYWdlbnQucG9zdChjb25maWcuZW5kcG9pbnQpLnNldCgnWC1SZXF1ZXN0LUlkJywgY3VpZCgpKS50aW1lb3V0KGNvbmZpZy50aW1lb3V0KTsgLy8gYmFzaWMgYXV0aCAoZS5nLiBDYWJpbiBBUEkga2V5KVxuXG4gICAgICAgIGlmIChjb25maWcua2V5KSByZXEuYXV0aChjb25maWcua2V5KTsgLy8gc2V0IGhlYWRlcnMgaWYgYW55XG5cbiAgICAgICAgaWYgKCFpc0VtcHR5KGNvbmZpZy5oZWFkZXJzKSkge1xuICAgICAgICAgIHZhciBoZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgICAgICAgaWYgKGhhc1dpbmRvdykgaGVhZGVycyA9IE9iamVjdC5rZXlzKGNvbmZpZy5oZWFkZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGhlYWRlcikge1xuICAgICAgICAgICAgaWYgKCFpbmNsdWRlcyhzdGFuZGFyZEhlYWRlcnMsIGNvbmZpZy5oZWFkZXJzW2hlYWRlcl0udG9Mb3dlckNhc2UoKSkpIG1lbW9baGVhZGVyXSA9IGNvbmZpZy5oZWFkZXJzW2hlYWRlcl07XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgcmVxLnNldChoZWFkZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcS5yZXRyeShjb25maWcucmV0cnkpLnNlbmQoYm9keSkuZW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBlcnIuX2NhcHR1cmVGYWlsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBfdGhpczIuY29uZmlnLmxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFN1cHByZXNzIGxvZ3MgaWYgaXQgd2FzIHNpbGVudFxuXG5cbiAgICAgIGlmIChjb25maWcuc2lsZW50KSByZXR1cm4gYm9keTsgLy8gaWYgdGhlcmUgd2FzIG1ldGEgaW5mb3JtYXRpb24gdGhlbiBvdXRwdXQgaXRcblxuICAgICAgdmFyIG9taXR0ZWQgPSBvbWl0KG1ldGEsIFsnbGV2ZWwnLCAnZXJyJ10pOyAvLyBmYXRhbCBzaG91bGQgdXNlIGVycm9yIChlLmcuIGluIGJyb3dzZXIpXG5cbiAgICAgIGlmIChsZXZlbCA9PT0gJ2ZhdGFsJykgbGV2ZWwgPSAnZXJyb3InOyAvLyBpZiB3ZSBkaWRuJ3QgcGFzcyBhIGxldmVsIGFzIGEgbWV0aG9kXG4gICAgICAvLyAoZS5nLiBjb25zb2xlLmluZm8pLCB0aGVuIHdlIHNob3VsZCBzdGlsbFxuICAgICAgLy8gdXNlIHRoZSBsb2dnZXIncyBgbG9nYCBtZXRob2QgdG8gb3V0cHV0XG5cbiAgICAgIGlmIChtb2RpZmllciA9PT0gLTEpIGxldmVsID0gJ2xvZyc7IC8vIHNob3cgc3RhY2sgdHJhY2UgaWYgbmVjZXNzYXJ5IChhbG9uZyB3aXRoIGFueSBtZXRhZGF0YSlcblxuICAgICAgaWYgKGxldmVsID09PSAnZXJyb3InICYmIGlzRXJyb3IoZXJyKSAmJiBjb25maWcuc2hvd1N0YWNrKSB7XG4gICAgICAgIGlmICghY29uZmlnLnNob3dNZXRhIHx8IGlzRW1wdHkob21pdHRlZCkpIHRoaXMuY29uZmlnLmxvZ2dlci5lcnJvcihlcnIpO2Vsc2UgdGhpcy5jb25maWcubG9nZ2VyLmVycm9yKGVyciwgb21pdHRlZCk7XG4gICAgICB9IGVsc2UgaWYgKCFjb25maWcuc2hvd01ldGEgfHwgaXNFbXB0eShvbWl0dGVkKSkge1xuICAgICAgICB0aGlzLmNvbmZpZy5sb2dnZXJbbGV2ZWxdKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nZ2VyW2xldmVsXShtZXNzYWdlLCBvbWl0dGVkKTtcbiAgICAgIH0gLy8gcmV0dXJuIHRoZSBwYXJzZWQgYm9keSBpbiBjYXNlIHdlIG5lZWQgaXRcblxuXG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXhlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4ZTsiLCIvKipcbiogQGZpbGUgQSBiaWcgY291bnRlci5cbiogQHZlcnNpb24gMi4wLjFcbiogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4qIEBtb2R1bGUgYmlnLWNvdW50ZXIteFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJ29iamVjdC1kZWZpbmUtcHJvcGVydGllcy14Jyk7XG5cbi8qKlxuICogU2VyaWFsaXNlIHRoZSBjb3VudGVywrRzIGN1cnJlbnQgdmFsdWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aGlzIEJpZ0NvdW50ZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci5cbiAqL1xudmFyIGNvdW50ZXJUb1N0cmluZyA9IGZ1bmN0aW9uIFRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5jb3VudC5zbGljZSgpLnJldmVyc2UoKS5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogVGhlIEJpZ0NvdW50ZXIgY2xhc3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjbGFzc1xuICovXG52YXIgQmlnQyA9IGZ1bmN0aW9uIEJpZ0NvdW50ZXIoKSB7XG4gIGlmIChCb29sZWFuKHRoaXMpID09PSBmYWxzZSB8fCAodGhpcyBpbnN0YW5jZW9mIEJpZ0MpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBuZXcgQmlnQygpO1xuICB9XG5cbiAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgY291bnQ6IHtcbiAgICAgIHZhbHVlOiBbMF1cbiAgICB9XG4gIH0pO1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhCaWdDLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0cyB0aGUgY291bnRlcsK0cyBjdXJyZW50IHZhbHVlLlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci5cbiAgICovXG4gIGdldDoge1xuICAgIHZhbHVlOiBjb3VudGVyVG9TdHJpbmdcbiAgfSxcbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIGNvdW50ZXLCtHMgdmFsdWUgYnkgYDFgLlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNvdW50ZXIgb2JqZWN0LlxuICAgKi9cbiAgbmV4dDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGNsb25lID0gdGhpcy5jb3VudC5zbGljZSgpO1xuICAgICAgdGhpcy5jb3VudC5sZW5ndGggPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGNsb25lLmxlbmd0aDtcbiAgICAgIHZhciBob3dNYW55ID0gTWF0aC5tYXgobGVuZ3RoLCAxKTtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgd2hpbGUgKGluZGV4IDwgaG93TWFueSB8fCBjYXJyeSkge1xuICAgICAgICB2YXIgemkgPSBjYXJyeSArIChpbmRleCA8IGxlbmd0aCA/IGNsb25lW2luZGV4XSA6IDApICsgKGluZGV4ID09PSAwID8gMSA6IDApO1xuICAgICAgICB0aGlzLmNvdW50LnB1c2goemkgJSAxMCk7XG4gICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih6aSAvIDEwKTtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjb3VudGVyIGJhY2sgdG8gYDBgLlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGNvdW50ZXIgb2JqZWN0LlxuICAgKi9cbiAgcmVzZXQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmNvdW50Lmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmNvdW50LnB1c2goMCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb3VudGVywrRzIGN1cnJlbnQgdmFsdWUuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgdG9KU09OOiB7XG4gICAgdmFsdWU6IGNvdW50ZXJUb1N0cmluZ1xuICB9LFxuICAvKipcbiAgICogR2V0cyB0aGUgY291bnRlcsK0cyBjdXJyZW50IHZhbHVlLlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci5cbiAgICovXG4gIHRvU3RyaW5nOiB7XG4gICAgdmFsdWU6IGNvdW50ZXJUb1N0cmluZ1xuICB9LFxuICAvKipcbiAgICogR2V0cyB0aGUgY291bnRlcsK0cyBjdXJyZW50IHZhbHVlLlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci5cbiAgICovXG4gIHZhbHVlT2Y6IHtcbiAgICB2YWx1ZTogY291bnRlclRvU3RyaW5nXG4gIH1cbn0pO1xuXG4vKipcbiAqIEluY3JlbWVudGFsIGludGVnZXIgY291bnRlci4gQ291bnRzIGZyb20gYDBgIHRvIHZlcnkgYmlnIGludGVyZ2Vycy5cbiAqIEphdmFzY3JpcHTCtHMgbnVtYmVyIHR5cGUgYWxsb3dzIHlvdSB0byBjb3VudCBpbiBpbnRlZ2VyIHN0ZXBzXG4gKiBmcm9tIGAwYCB0byBgOTAwNzE5OTI1NDc0MDk5MWAuIEFzIG9mIEVTNSwgU3RyaW5ncyBjYW4gY29udGFpblxuICogYXBwcm94aW1hdGVseSA2NTAwMCBjaGFyYWN0ZXJzIGFuZCBFUzYgaXMgc3VwcG9zZWQgdG8gaGFuZGxlXG4gKiB0aGUgYE1BWF9TQUZFX0lOVEVHRVJgICh0aG91Z2ggSSBkb27CtHQgYmVsaWV2ZSBhbnkgZW52aXJvbm1lbnRzIHN1cHBvcnRzXG4gKiB0aGlzKS4gVGhpcyBjb3VudGVyIHJlcHJlc2VudHMgaW50ZWdlciB2YWx1ZXMgYXMgc3RyaW5ncyBhbmQgY2FuIHRoZXJlZm9yZVxuICogY291bnQgaW4gaW50ZWdlciBzdGVwcyBmcm9tIGAwYCB0byB0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoICh0aGF0wrRzIHNvbWVcbiAqIDY1MDAwIGRpZ2l0cykuIEluIHRoZSBsb3dlciByYW5nZSwgdXB0byBgOTAwNzE5OTI1NDc0MDk5MWAsIHRoZSBzdHJpbmdzIGNhblxuICogYmUgY29udmVydGVkIHRvIHNhZmUgSmF2YXNjcmlwdCBpbnRlZ2VycyBgTnVtYmVyKHZhbHVlKWAgb3IgYCt2YWx1ZWAuIFRoaXNcbiAqIGNvdW50ZXIgaXMgZ3JlYXQgZm9yIGFueSBhcHBsaWNhdGlvbnMgdGhhdCBuZWVkIGEgcmVhbGx5IGJpZyBjb3VudFxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcsIChhbiBJRCBzdHJpbmcpLlxuICpcbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIHZhciBCaWdDb3VudGVyID0gcmVxdWlyZSgnYmlnLWNvdW50ZXIteCcpO1xuICogdmFyIGNvdW50ZXIgPSBuZXcgQmlnQ291bnRlcigpO1xuICpcbiAqIGNvdW50ZXIuZ2V0KCk7IC8vICcwJ1xuICogY291bnRlci5uZXh0KCk7IC8vIGNvdW50ZXIgb2JqZWN0XG4gKiBjb3VudGVyLmdldCgpOyAvLyAnMSdcbiAqXG4gKiAvLyBNZXRob2RzIGFyZSBjaGFpbmFibGUuXG4gKiBjb3VudGVyLm5leHQoKS5uZXh0KCk7IC8vIGNvdW50ZXIgb2JqZWN0XG4gKiBjb3VudGVyLmdldCgpOyAvLyAnMydcbiAqXG4gKiBjb3VudGVyLnJlc2V0KCk7IC8vIGNvdW50ZXIgb2JqZWN0XG4gKiBjb3VudGVyLmdldCgpOyAvLyAnMCdcbiAqIGNvdW50ZXIudG9TdHJpbmcoKTsgLy8gJzAnXG4gKiBjb3VudGVyLnZhbHVlT2YoKTsgLy8gJzAnXG4gKiBjb3VudGVyLnRvSlNPTigpOyAvLyAnMCdcbiAqXG4gKiAvLyBWYWx1ZXMgdXB0byBgOTAwNzE5OTI1NDc0MDk5MWAgY29udmVydCB0byBudW1iZXJzLlxuICogTnVtYmVyKGNvdW50ZXIpOyAvLyAwXG4gKiArY291bnRlcjsgLy8gMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJpZ0M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBib29sZWFuID0gZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAoL14odHJ1ZXx0fHllc3x5fDEpJC9pLnRlc3QodmFsdWUudHJpbSgpKVxuICAgICk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYm9vbGVhbjsiLCIvKipcbiAqIEBmaWxlIENvbnN0cnVjdG9ycyBjYWNoZWQgZnJvbSBsaXRlcmFscy5cbiAqIEB2ZXJzaW9uIDEuMC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBjYWNoZWQtY29uc3RydWN0b3JzLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29uc3RydWN0b3JzIGNhY2hlZCBmcm9tIGxpdGVyYWxzLlxuICpcbiAqIEB0eXBlIE9iamVjdFxuICogQGV4YW1wbGVcbiAqIHZhciBjb25zdHJ1Y3RvcnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFycmF5OiBbXS5jb25zdHJ1Y3RvcixcbiAgQm9vbGVhbjogdHJ1ZS5jb25zdHJ1Y3RvcixcbiAgRnVuY3Rpb246IGZ1bmN0aW9uICgpIHt9LmNvbnN0cnVjdG9yLFxuICBOdW1iZXI6ICgwKS5jb25zdHJ1Y3RvcixcbiAgT2JqZWN0OiB7fS5jb25zdHJ1Y3RvcixcbiAgUmVnRXhwOiAoLyg/OikvKS5jb25zdHJ1Y3RvcixcbiAgU3RyaW5nOiAnJy5jb25zdHJ1Y3RvclxufTtcbiIsIi8qKlxuICogQGZpbGUgQ2FsY3VsYXRlcyBhIGZyb21JbmRleCBvZiBhIGdpdmVuIHZhbHVlIGZvciBhbiBhcnJheS5cbiAqIEB2ZXJzaW9uIDEuMC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBjYWxjdWxhdGUtZnJvbS1pbmRleC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCd0by1pbnRlZ2VyLXgnKTtcbnZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJ2lzLWFycmF5LWxpa2UteCcpO1xuXG52YXIgJGNhbGNGcm9tSW5kZXggPSBmdW5jdGlvbiBjYWxjRnJvbUluZGV4KGFycmF5LCBmcm9tSW5kZXgpIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgaWYgKGlzQXJyYXlMaWtlKG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgob2JqZWN0Lmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaW5kZXgpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIGEgZnJvbUluZGV4IG9mIGEgZ2l2ZW4gdmFsdWUgZm9yIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IFRoZSBhcnJheSBvbiB3aGljaCB0byBjYWxjdWxhdGUgdGhlIHN0YXJ0aW5nIGluZGV4LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcnJheSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIHBvc2l0aW9uIGluIHRoaXMgYXJyYXkgYXQgd2hpY2ggdG8gYmVnaW4uIEFcbiAqICBuZWdhdGl2ZSB2YWx1ZSBnaXZlcyB0aGUgaW5kZXggb2YgYXJyYXkubGVuZ3RoICsgZnJvbUluZGV4IGJ5IGFzYy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNhbGN1bGF0ZWQgZnJvbUluZGV4LiBEZWZhdWx0IGlzIDAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGNhbGNGcm9tSW5kZXggPSByZXF1aXJlKCdjYWxjdWxhdGUtZnJvbS1pbmRleC14Jyk7XG4gKlxuICogY2FsY0Zyb21JbmRleChbMSwgMiwgM10sIDEpOyAvLyAxXG4gKiBjYWxjRnJvbUluZGV4KFsxLCAyLCAzXSwgSW5maW5pdHkpOyAvLyBJbmZpbml0eVxuICogY2FsY0Zyb21JbmRleChbMSwgMiwgM10sIC1JbmZpbml0eSk7IC8vIDBcbiAqIGNhbGNGcm9tSW5kZXgoWzEsIDIsIDNdLCAtMSk7IC8vIDJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkY2FsY0Zyb21JbmRleDtcbiIsIi8qKlxuICogQGZpbGUgRVM2IGNvbGxlY3Rpb25zIGZhbGxiYWNrIGxpYnJhcnk6IE1hcCBhbmQgU2V0LlxuICogQHZlcnNpb24gMi4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGNvbGxlY3Rpb25zLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMtb3duLXByb3BlcnR5LXgnKTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJ29iamVjdC1kZWZpbmUtcHJvcGVydGllcy14Jyk7XG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbnZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJ2lzLWFycmF5LWxpa2UteCcpO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnaXMtcHJpbWl0aXZlJyk7XG52YXIgaXNTdXJyb2dhdGVQYWlyID0gcmVxdWlyZSgnaXMtc3Vycm9nYXRlLXBhaXIteCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleC1vZi14Jyk7XG52YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG52YXIgYXNzZXJ0SXNPYmplY3QgPSByZXF1aXJlKCdhc3NlcnQtaXMtb2JqZWN0LXgnKTtcbnZhciBJZEdlbmVyYXRvciA9IHJlcXVpcmUoJ2JpZy1jb3VudGVyLXgnKTtcbnZhciBpc05pbCA9IHJlcXVpcmUoJ2lzLW5pbC14Jyk7XG52YXIgaXNNYXAgPSByZXF1aXJlKCdpcy1tYXAteCcpO1xudmFyIGlzU2V0ID0gcmVxdWlyZSgnaXMtc2V0LXgnKTtcbnZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCdpcy1vYmplY3QtbGlrZS14Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5LXgnKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCdpcy1ib29sZWFuLW9iamVjdCcpO1xudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG52YXIgc29tZSA9IHJlcXVpcmUoJ2FycmF5LXNvbWUteCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZ2V0LXByb3RvdHlwZS1vZi14Jyk7XG52YXIgaGFzU3ltYm9sU3VwcG9ydCA9IHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14Jyk7XG52YXIgaGFzUmVhbFN5bWJvbEl0ZXJhdG9yID0gaGFzU3ltYm9sU3VwcG9ydCAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJztcbnZhciBoYXNGYWtlU3ltYm9sSXRlcmF0b3IgPSB0eXBlb2YgU3ltYm9sID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3RyaW5nJztcbnZhciBzeW1JdDtcblxuaWYgKGhhc1JlYWxTeW1ib2xJdGVyYXRvciB8fCBoYXNGYWtlU3ltYm9sSXRlcmF0b3IpIHtcbiAgc3ltSXQgPSBTeW1ib2wuaXRlcmF0b3I7XG59IGVsc2UgaWYgKGlzRnVuY3Rpb24oQXJyYXkucHJvdG90eXBlWydfZXM2LXNoaW0gaXRlcmF0b3JfJ10pKSB7XG4gIHN5bUl0ID0gJ19lczYtc2hpbSBpdGVyYXRvcl8nO1xufSBlbHNlIHtcbiAgc3ltSXQgPSAnQEBpdGVyYXRvcic7XG59XG5cbnZhciBpc051bWJlclR5cGUgPSBmdW5jdGlvbiBfaXNOdW1iZXJUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgYW4gaW50ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IGl0ZXJhYmxlIC0gVmFsdWUgdG8gZGV0ZWN0IGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N5bWJvbHxzdHJpbmd8dW5kZWZpbmVkfSBUaGUgaXRlcmF0b3IgcHJvcGVydHkgaWRlbnRpZmllci5cbiAqL1xudmFyIGdldFN5bWJvbEl0ZXJhdG9yID0gZnVuY3Rpb24gX2dldFN5bWJvbEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gIGlmIChpc05pbChpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgaWYgKChoYXNSZWFsU3ltYm9sSXRlcmF0b3IgfHwgaGFzRmFrZVN5bWJvbEl0ZXJhdG9yKSAmJiBpdGVyYWJsZVtzeW1JdF0pIHtcbiAgICAgIHJldHVybiBzeW1JdDtcbiAgICB9XG5cbiAgICBpZiAoaXRlcmFibGVbJ19lczYtc2hpbSBpdGVyYXRvcl8nXSkge1xuICAgICAgcmV0dXJuICdfZXM2LXNoaW0gaXRlcmF0b3JfJztcbiAgICB9XG5cbiAgICBpZiAoaXRlcmFibGVbJ0BAaXRlcmF0b3InXSkge1xuICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdm9pZCAwO1xufTtcblxuLyoqXG4gKiBJZiBhbiBpdGVyYWJsZSBvYmplY3QgaXMgcGFzc2VkLCBhbGwgb2YgaXRzIGVsZW1lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gKiBuZXcgTWFwL1NldCwgbnVsbCBpcyB0cmVhdGVkIGFzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgLSBFaXRoZXIgJ21hcCcgb3IgJ3NldCcuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIFRoZSBNYXAvU2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gaXRlcmFibGUgLSBWYWx1ZSB0byBwYXJzZWQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG52YXIgcGFyc2VJdGVyYWJsZSA9IGZ1bmN0aW9uIF9wYXJzZUl0ZXJhYmxlKGtpbmQsIGNvbnRleHQsIGl0ZXJhYmxlKSB7XG4gIHZhciBzeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgaWYgKGtpbmQgPT09ICdtYXAnKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoY29udGV4dCwgJ1tbdmFsdWVdXScsIHtcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0pO1xuICB9XG5cbiAgZGVmaW5lUHJvcGVydGllcyhjb250ZXh0LCB7XG4gICAgJ1tbY2hhbmdlZF1dJzoge1xuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICAnW1tpZF1dJzoge1xuICAgICAgdmFsdWU6IG5ldyBJZEdlbmVyYXRvcigpXG4gICAgfSxcbiAgICAnW1trZXldXSc6IHtcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0sXG4gICAgJ1tbb3JkZXJdXSc6IHtcbiAgICAgIHZhbHVlOiBbXVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIG5leHQ7XG4gIHZhciBrZXk7XG4gIHZhciBpbmRleG9mO1xuICBpZiAoaXRlcmFibGUgJiYgaXNGdW5jdGlvbihpdGVyYWJsZVtzeW1ib2xJdGVyYXRvcl0pKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGVbc3ltYm9sSXRlcmF0b3JdKCk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICAgIGlmIChpc0FycmF5TGlrZShuZXh0LnZhbHVlKSA9PT0gZmFsc2UgfHwgbmV4dC52YWx1ZS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0l0ZXJhdG9yIHZhbHVlICcgKyBpc0FycmF5TGlrZShuZXh0LnZhbHVlKSArICcgaXMgbm90IGFuIGVudHJ5IG9iamVjdCdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAobmV4dC5kb25lID09PSBmYWxzZSkge1xuICAgICAga2V5ID0ga2luZCA9PT0gJ21hcCcgPyBuZXh0LnZhbHVlWzBdIDogbmV4dC52YWx1ZTtcbiAgICAgIGluZGV4b2YgPSBpbmRleE9mKFxuICAgICAgICBhc3NlcnRJc09iamVjdChjb250ZXh0KVsnW1trZXldXSddLFxuICAgICAgICBrZXksXG4gICAgICAgICdTYW1lVmFsdWVaZXJvJ1xuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4b2YgPCAwKSB7XG4gICAgICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgICAgIGNvbnRleHRbJ1tbdmFsdWVdXSddLnB1c2gobmV4dC52YWx1ZVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0WydbW2tleV1dJ10ucHVzaChrZXkpO1xuICAgICAgICBjb250ZXh0WydbW29yZGVyXV0nXS5wdXNoKGNvbnRleHRbJ1tbaWRdXSddLmdldCgpKTtcbiAgICAgICAgY29udGV4dFsnW1tpZF1dJ10ubmV4dCgpO1xuICAgICAgfSBlbHNlIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgICBjb250ZXh0WydbW3ZhbHVlXV0nXVtpbmRleG9mXSA9IG5leHQudmFsdWVbMV07XG4gICAgICB9XG5cbiAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkge1xuICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0l0ZXJhdG9yIHZhbHVlICcgKyBpdGVyYWJsZS5jaGFyQXQoMCkgKyAnIGlzIG5vdCBhbiBlbnRyeSBvYmplY3QnXG4gICAgICApO1xuICAgIH1cblxuICAgIG5leHQgPSAwO1xuICAgIHdoaWxlIChuZXh0IDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hhcjEgPSBpdGVyYWJsZS5jaGFyQXQobmV4dCk7XG4gICAgICB2YXIgY2hhcjIgPSBpdGVyYWJsZS5jaGFyQXQobmV4dCArIDEpO1xuICAgICAgaWYgKGlzU3Vycm9nYXRlUGFpcihjaGFyMSwgY2hhcjIpKSB7XG4gICAgICAgIGtleSA9IGNoYXIxICsgY2hhcjI7XG4gICAgICAgIG5leHQgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGNoYXIxO1xuICAgICAgfVxuXG4gICAgICBpbmRleG9mID0gaW5kZXhPZihcbiAgICAgICAgYXNzZXJ0SXNPYmplY3QoY29udGV4dClbJ1tba2V5XV0nXSxcbiAgICAgICAga2V5LFxuICAgICAgICAnU2FtZVZhbHVlWmVybydcbiAgICAgICk7XG5cbiAgICAgIGlmIChpbmRleG9mIDwgMCkge1xuICAgICAgICBjb250ZXh0WydbW2tleV1dJ10ucHVzaChrZXkpO1xuICAgICAgICBjb250ZXh0WydbW29yZGVyXV0nXS5wdXNoKGNvbnRleHRbJ1tbaWRdXSddLmdldCgpKTtcbiAgICAgICAgY29udGV4dFsnW1tpZF1dJ10ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IDE7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlMaWtlKGl0ZXJhYmxlKSkge1xuICAgIG5leHQgPSAwO1xuICAgIHdoaWxlIChuZXh0IDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGl0ZXJhYmxlW25leHRdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSXRlcmF0b3IgdmFsdWUgJyArIGlzQXJyYXlMaWtlKG5leHQudmFsdWUpICsgJyBpcyBub3QgYW4gZW50cnkgb2JqZWN0J1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBpdGVyYWJsZVtuZXh0XVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGl0ZXJhYmxlW25leHRdO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBraW5kID09PSAnbWFwJyA/IGl0ZXJhYmxlW25leHRdWzBdIDogaXRlcmFibGVbbmV4dF07XG4gICAgICBpbmRleG9mID0gaW5kZXhPZihcbiAgICAgICAgYXNzZXJ0SXNPYmplY3QoY29udGV4dClbJ1tba2V5XV0nXSxcbiAgICAgICAga2V5LFxuICAgICAgICAnU2FtZVZhbHVlWmVybydcbiAgICAgICk7XG5cbiAgICAgIGlmIChpbmRleG9mIDwgMCkge1xuICAgICAgICBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICAgICAgICBjb250ZXh0WydbW3ZhbHVlXV0nXS5wdXNoKGl0ZXJhYmxlW25leHRdWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHRbJ1tba2V5XV0nXS5wdXNoKGtleSk7XG4gICAgICAgIGNvbnRleHRbJ1tbb3JkZXJdXSddLnB1c2goY29udGV4dFsnW1tpZF1dJ10uZ2V0KCkpO1xuICAgICAgICBjb250ZXh0WydbW2lkXV0nXS5uZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdtYXAnKSB7XG4gICAgICAgIGNvbnRleHRbJ1tbdmFsdWVdXSddW2luZGV4b2ZdID0gaXRlcmFibGVbbmV4dF1bMV07XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gMTtcbiAgICB9XG4gIH1cblxuICBkZWZpbmVQcm9wZXJ0eShjb250ZXh0LCAnc2l6ZScsIHtcbiAgICB2YWx1ZTogY29udGV4dFsnW1trZXldXSddLmxlbmd0aCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIGJhc2UgZm9yRWFjaCBtZXRob2QgZXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBlYWNoIHZhbHVlXG4gKiBpbiB0aGUgTWFwL1NldCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgLSBFaXRoZXIgJ21hcCcgb3IgJ3NldCcuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIFRoZSBNYXAvU2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBNYXAvU2V0IG9iamVjdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbnZhciBiYXNlRm9yRWFjaCA9IGZ1bmN0aW9uIF9iYXNlRm9yRWFjaChraW5kLCBjb250ZXh0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICBhc3NlcnRJc09iamVjdChjb250ZXh0KTtcbiAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsYmFjayk7XG4gIHZhciBwb2ludGVycyA9IHtcbiAgICBpbmRleDogMCxcbiAgICBvcmRlcjogY29udGV4dFsnW1tvcmRlcl1dJ11bMF1cbiAgfTtcblxuICBjb250ZXh0WydbW2NoYW5nZV1dJ10gPSBmYWxzZTtcbiAgdmFyIGxlbmd0aCA9IGNvbnRleHRbJ1tba2V5XV0nXS5sZW5ndGg7XG4gIHdoaWxlIChwb2ludGVycy5pbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChoYXNPd24oY29udGV4dFsnW1trZXldXSddLCBwb2ludGVycy5pbmRleCkpIHtcbiAgICAgIHZhciBrZXkgPSBjb250ZXh0WydbW2tleV1dJ11bcG9pbnRlcnMuaW5kZXhdO1xuICAgICAgdmFyIHZhbHVlID0ga2luZCA9PT0gJ21hcCcgPyBjb250ZXh0WydbW3ZhbHVlXV0nXVtwb2ludGVycy5pbmRleF0gOiBrZXk7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0WydbW2NoYW5nZV1dJ10pIHtcbiAgICAgIGxlbmd0aCA9IGNvbnRleHRbJ1tba2V5XV0nXS5sZW5ndGg7XG4gICAgICBzb21lKGNvbnRleHRbJ1tbb3JkZXJdXSddLCBmdW5jdGlvbiBfc29tZTEoaWQsIGNvdW50KSB7XG4gICAgICAgIHBvaW50ZXJzLmluZGV4ID0gY291bnQ7XG4gICAgICAgIHJldHVybiBpZCA+IHBvaW50ZXJzLm9yZGVyO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnRleHRbJ1tbY2hhbmdlXV0nXSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVycy5pbmRleCArPSAxO1xuICAgIH1cblxuICAgIHBvaW50ZXJzLm9yZGVyID0gY29udGV4dFsnW1tvcmRlcl1dJ11bcG9pbnRlcnMuaW5kZXhdO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGhhcyBtZXRob2QgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aFxuICogdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgZXhpc3RzIGluIGEgTWFwL1NldCBvYmplY3Qgb3Igbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkvdmFsdWUgdG8gdGVzdCBmb3IgcHJlc2VuY2UgaW4gdGhlIE1hcC9TZXQgb2JqZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWVcbiAqICBleGlzdHMgaW4gdGhlIE1hcC9TZXQgb2JqZWN0OyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbnZhciBiYXNlSGFzID0gZnVuY3Rpb24gaGFzKGtleSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gIHJldHVybiBpbmRleE9mKGFzc2VydElzT2JqZWN0KHRoaXMpWydbW2tleV1dJ10sIGtleSwgJ1NhbWVWYWx1ZVplcm8nKSA+IC0xO1xufTtcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGVhciBtZXRob2QgcmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBhIE1hcC9TZXQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCAtIEVpdGhlciAnbWFwJyBvciAnc2V0Jy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICovXG52YXIgYmFzZUNsZWFyID0gZnVuY3Rpb24gX2Jhc2VDbGVhcihraW5kLCBjb250ZXh0KSB7XG4gIGFzc2VydElzT2JqZWN0KGNvbnRleHQpO1xuICBjb250ZXh0WydbW2lkXV0nXS5yZXNldCgpO1xuICBjb250ZXh0WydbW2NoYW5nZV1dJ10gPSB0cnVlO1xuICBjb250ZXh0LnNpemUgPSAwO1xuICBjb250ZXh0WydbW29yZGVyXV0nXS5sZW5ndGggPSAwO1xuICBjb250ZXh0WydbW2tleV1dJ10ubGVuZ3RoID0gMDtcbiAgaWYgKGtpbmQgPT09ICdtYXAnKSB7XG4gICAgY29udGV4dFsnW1t2YWx1ZV1dJ10ubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBUaGUgYmFzZSBkZWxldGUgbWV0aG9kIHJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGZyb20gYSBNYXAvU2V0IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgLSBFaXRoZXIgJ21hcCcgb3IgJ3NldCcuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIFRoZSBNYXAvU2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleS92YWx1ZSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUgZnJvbSBNYXAvU2V0IG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBNYXAvU2V0IG9iamVjdC5cbiAqL1xudmFyIGJhc2VEZWxldGUgPSBmdW5jdGlvbiBfYmFzZURlbGV0ZShraW5kLCBjb250ZXh0LCBrZXkpIHtcbiAgdmFyIGluZGV4b2YgPSBpbmRleE9mKFxuICAgIGFzc2VydElzT2JqZWN0KGNvbnRleHQpWydbW2tleV1dJ10sXG4gICAga2V5LFxuICAgICdTYW1lVmFsdWVaZXJvJ1xuICApO1xuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKGluZGV4b2YgPiAtMSkge1xuICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgY29udGV4dFsnW1t2YWx1ZV1dJ10uc3BsaWNlKGluZGV4b2YsIDEpO1xuICAgIH1cblxuICAgIGNvbnRleHRbJ1tba2V5XV0nXS5zcGxpY2UoaW5kZXhvZiwgMSk7XG4gICAgY29udGV4dFsnW1tvcmRlcl1dJ10uc3BsaWNlKGluZGV4b2YsIDEpO1xuICAgIGNvbnRleHRbJ1tbY2hhbmdlXV0nXSA9IHRydWU7XG4gICAgY29udGV4dC5zaXplID0gY29udGV4dFsnW1trZXldXSddLmxlbmd0aDtcbiAgICByZXN1bHQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGhlIGJhc2Ugc2V0IGFuZCBhZGQgbWV0aG9kLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCAtIEVpdGhlciAnbWFwJyBvciAnc2V0Jy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgLSBUaGUga2V5IG9yIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZC9zZXQgb24gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBNYXAgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGJhc2VBZGRTZXQgPSBmdW5jdGlvbiBfYmFzZUFkZFNldChraW5kLCBjb250ZXh0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBpbmRleCA9IGluZGV4T2YoXG4gICAgYXNzZXJ0SXNPYmplY3QoY29udGV4dClbJ1tba2V5XV0nXSxcbiAgICBrZXksXG4gICAgJ1NhbWVWYWx1ZVplcm8nXG4gICk7XG5cbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICAgIGNvbnRleHRbJ1tbdmFsdWVdXSddW2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICAgIGNvbnRleHRbJ1tbdmFsdWVdXSddLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnRleHRbJ1tba2V5XV0nXS5wdXNoKGtleSk7XG4gICAgY29udGV4dFsnW1tvcmRlcl1dJ10ucHVzaChjb250ZXh0WydbW2lkXV0nXS5nZXQoKSk7XG4gICAgY29udGV4dFsnW1tpZF1dJ10ubmV4dCgpO1xuICAgIGNvbnRleHRbJ1tbY2hhbmdlXV0nXSA9IHRydWU7XG4gICAgY29udGV4dC5zaXplID0gY29udGV4dFsnW1trZXldXSddLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBBbiBvYmplY3QgaXMgYW4gaXRlcmF0b3Igd2hlbiBpdCBrbm93cyBob3cgdG8gYWNjZXNzIGl0ZW1zIGZyb20gYVxuICogY29sbGVjdGlvbiBvbmUgYXQgYSB0aW1lLCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIGl0cyBjdXJyZW50IHBvc2l0aW9uXG4gKiB3aXRoaW4gdGhhdCBzZXF1ZW5jZS4gSW4gSmF2YVNjcmlwdCBhbiBpdGVyYXRvciBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlc1xuICogYSBuZXh0KCkgbWV0aG9kIHdoaWNoIHJldHVybnMgdGhlIG5leHQgaXRlbSBpbiB0aGUgc2VxdWVuY2UuIFRoaXMgbWV0aG9kXG4gKiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiBkb25lIGFuZCB2YWx1ZS4gT25jZSBjcmVhdGVkLFxuICogYW4gaXRlcmF0b3Igb2JqZWN0IGNhbiBiZSB1c2VkIGV4cGxpY2l0bHkgYnkgcmVwZWF0ZWRseSBjYWxsaW5nIG5leHQoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIFRoZSBTZXQgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGl0ZXJhdG9yS2luZCAtIFZhbHVlcyBhcmUgYHZhbHVlYCwgYGtleWAgb3IgYGtleSt2YWx1ZWAuXG4gKi9cbnZhciBTZXRJdCA9IGZ1bmN0aW9uIFNldEl0ZXJhdG9yKGNvbnRleHQsIGl0ZXJhdG9yS2luZCkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAnW1tJdGVyYXRvckhhc01vcmVdXSc6IHtcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgICdbW1NldF1dJzoge1xuICAgICAgdmFsdWU6IGFzc2VydElzT2JqZWN0KGNvbnRleHQpXG4gICAgfSxcbiAgICAnW1tTZXRJdGVyYXRpb25LaW5kXV0nOiB7XG4gICAgICB2YWx1ZTogaXRlcmF0b3JLaW5kIHx8ICd2YWx1ZSdcbiAgICB9LFxuICAgICdbW1NldE5leHRJbmRleF1dJzoge1xuICAgICAgdmFsdWU6IDAsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIE9uY2UgaW5pdGlhbGl6ZWQsIHRoZSBuZXh0KCkgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gYWNjZXNzIGtleS12YWx1ZVxuICogcGFpcnMgZnJvbSB0aGUgb2JqZWN0IGluIHR1cm4uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBuZXh0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiBkb25lIGFuZCB2YWx1ZS5cbiAqL1xuZGVmaW5lUHJvcGVydHkoU2V0SXQucHJvdG90eXBlLCAnbmV4dCcsIHtcbiAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhc3NlcnRJc09iamVjdCh0aGlzWydbW1NldF1dJ10pO1xuICAgIHZhciBpbmRleCA9IHRoaXNbJ1tbU2V0TmV4dEluZGV4XV0nXTtcbiAgICB2YXIgaXRlcmF0b3JLaW5kID0gdGhpc1snW1tTZXRJdGVyYXRpb25LaW5kXV0nXTtcbiAgICB2YXIgbW9yZSA9IHRoaXNbJ1tbSXRlcmF0b3JIYXNNb3JlXV0nXTtcbiAgICB2YXIgb2JqZWN0O1xuICAgIGlmIChpbmRleCA8IGNvbnRleHRbJ1tba2V5XV0nXS5sZW5ndGggJiYgbW9yZSkge1xuICAgICAgb2JqZWN0ID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgaWYgKGl0ZXJhdG9yS2luZCA9PT0gJ2tleSt2YWx1ZScpIHtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gW2NvbnRleHRbJ1tba2V5XV0nXVtpbmRleF0sIGNvbnRleHRbJ1tba2V5XV0nXVtpbmRleF1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gY29udGV4dFsnW1trZXldXSddW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdGhpc1snW1tTZXROZXh0SW5kZXhdXSddICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbJ1tbSXRlcmF0b3JIYXNNb3JlXV0nXSA9IGZhbHNlO1xuICAgICAgb2JqZWN0ID0ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBAQGl0ZXJhdG9yIHByb3BlcnR5IGlzIHRoZSBzYW1lIEl0ZXJhdG9yIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIHN5bUl0XG4gKiBAbWVtYmVyb2YgU2V0SXRlcmF0b3IucHJvdG90eXBlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGlzIEl0ZXJhdG9yIG9iamVjdC5cbiAqL1xuZGVmaW5lUHJvcGVydHkoU2V0SXQucHJvdG90eXBlLCBzeW1JdCwge1xuICB2YWx1ZTogZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gKiB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgU2V0IG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aGlzIFNldFxuICogQHJldHVybnMge09iamVjdH0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0LlxuICovXG52YXIgc2V0VmFsdWVzSXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gIHJldHVybiBuZXcgU2V0SXQodGhpcyk7XG59O1xuXG4vKipcbiAqIFRoZSBTZXQgb2JqZWN0IGxldHMgeW91IHN0b3JlIHVuaXF1ZSB2YWx1ZXMgb2YgYW55IHR5cGUsIHdoZXRoZXIgcHJpbWl0aXZlXG4gKiB2YWx1ZXMgb3Igb2JqZWN0IHJlZmVyZW5jZXMuXG4gKlxuICogQGNsYXNzIFNldFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW2l0ZXJhYmxlXSAtIElmIGFuIGl0ZXJhYmxlIG9iamVjdCBpcyBwYXNzZWQsIGFsbCBvZiBpdHMgZWxlbWVudHNcbiAqIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG5ldyBTZXQuIG51bGwgaXMgdHJlYXRlZCBhcyB1bmRlZmluZWQuXG4gKiBAZXhhbXBsZVxuICogdmFyIG15U2V0ID0gbmV3IFNldCgpO1xuICpcbiAqIG15U2V0LmFkZCgxKTtcbiAqIG15U2V0LmFkZCg1KTtcbiAqIG15U2V0LmFkZChcInNvbWUgdGV4dFwiKTtcbiAqIHZhciBvID0ge2E6IDEsIGI6IDJ9O1xuICogbXlTZXQuYWRkKG8pO1xuICpcbiAqIG15U2V0LmhhcygxKTsgLy8gdHJ1ZVxuICogbXlTZXQuaGFzKDMpOyAvLyBmYWxzZSwgMyBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIHNldFxuICogbXlTZXQuaGFzKDUpOyAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogbXlTZXQuaGFzKE1hdGguc3FydCgyNSkpOyAgLy8gdHJ1ZVxuICogbXlTZXQuaGFzKFwiU29tZSBUZXh0XCIudG9Mb3dlckNhc2UoKSk7IC8vIHRydWVcbiAqIG15U2V0LmhhcyhvKTsgLy8gdHJ1ZVxuICpcbiAqIG15U2V0LnNpemU7IC8vIDRcbiAqXG4gKiBteVNldC5kZWxldGUoNSk7IC8vIHJlbW92ZXMgNSBmcm9tIHRoZSBzZXRcbiAqIG15U2V0Lmhhcyg1KTsgICAgLy8gZmFsc2UsIDUgaGFzIGJlZW4gcmVtb3ZlZFxuICpcbiAqIG15U2V0LnNpemU7IC8vIDMsIHdlIGp1c3QgcmVtb3ZlZCBvbmUgdmFsdWVcbiAqXG4gKiAvLyBSZWxhdGlvbiB3aXRoIEFycmF5IG9iamVjdHNcbiAqXG4gKiB2YXIgbXlBcnJheSA9IFtcInZhbHVlMVwiLCBcInZhbHVlMlwiLCBcInZhbHVlM1wiXTtcbiAqXG4gKiAvLyBVc2UgdGhlIHJlZ3VsYXIgU2V0IGNvbnN0cnVjdG9yIHRvIHRyYW5zZm9ybSBhbiBBcnJheSBpbnRvIGEgU2V0XG4gKiB2YXIgbXlTZXQgPSBuZXcgU2V0KG15QXJyYXkpO1xuICpcbiAqIG15U2V0LmhhcyhcInZhbHVlMVwiKTsgLy8gcmV0dXJucyB0cnVlXG4gKlxuICogLy8gVXNlIHRoZSBzcHJlYWQgb3BlcmF0b3IgdG8gdHJhbnNmb3JtIGEgc2V0IGludG8gYW4gQXJyYXkuXG4gKiBjb25zb2xlLmxvZyh1bmV2YWwoWy4uLm15U2V0XSkpOyAvLyBXaWxsIHNob3cgeW91IGV4YWN0bHkgdGhlIHNhbWUgQXJyYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIG15QXJyYXlcbiAqL1xudmFyIFNldE9iamVjdCA9IGZ1bmN0aW9uIFNldCgpIHtcbiAgaWYgKEJvb2xlYW4odGhpcykgPT09IGZhbHNlIHx8ICh0aGlzIGluc3RhbmNlb2YgU2V0T2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJ1Y3RvciBTZXQgcmVxdWlyZXMgXFwnbmV3XFwnJyk7XG4gIH1cblxuICBwYXJzZUl0ZXJhYmxlKCdzZXQnLCB0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdm9pZCAwKTtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoU2V0T2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBtb2R1bGU6Y29sbGVjdGlvbnMteC5TZXQucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIFRoZSBhZGQoKSBtZXRob2QgYXBwZW5kcyBhIG5ldyBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQgdmFsdWUgdG8gdGhlIGVuZFxuICAgKiBvZiBhIFNldCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBSZXF1aXJlZC4gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgU2V0XG4gICAqICBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBTZXQgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLlNldFxuICAgKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gICAqXG4gICAqIG15U2V0LmFkZCgxKTtcbiAgICogbXlTZXQuYWRkKDUpLmFkZChcInNvbWUgdGV4dFwiKTsgLy8gY2hhaW5hYmxlXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKG15U2V0KTtcbiAgICogLy8gU2V0IFsxLCA1LCBcInNvbWUgdGV4dFwiXVxuICAgKi9cbiAgYWRkOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VBZGRTZXQoJ3NldCcsIHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgY2xlYXIoKSBtZXRob2QgcmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBhIFNldCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBTZXQgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLlNldFxuICAgKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gICAqIG15U2V0LmFkZCgxKTtcbiAgICogbXlTZXQuYWRkKFwiZm9vXCIpO1xuICAgKlxuICAgKiBteVNldC5zaXplOyAgICAgICAvLyAyXG4gICAqIG15U2V0LmhhcyhcImZvb1wiKTsgLy8gdHJ1ZVxuICAgKlxuICAgKiBteVNldC5jbGVhcigpO1xuICAgKlxuICAgKiBteVNldC5zaXplOyAgICAgICAvLyAwXG4gICAqIG15U2V0LmhhcyhcImJhclwiKSAgLy8gZmFsc2VcbiAgICovXG4gIGNsZWFyOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgcmV0dXJuIGJhc2VDbGVhcignc2V0JywgdGhpcyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIGRlbGV0ZSgpIG1ldGhvZCByZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIGEgU2V0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgU2V0IG9iamVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGluIHRoZSBTZXQgb2JqZWN0IGhhcyBiZWVuXG4gICAqICByZW1vdmVkIHN1Y2Nlc3NmdWxseTsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLlNldFxuICAgKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gICAqIG15U2V0LmFkZChcImZvb1wiKTtcbiAgICpcbiAgICogbXlTZXQuZGVsZXRlKFwiYmFyXCIpOyAvLyBSZXR1cm5zIGZhbHNlLiBObyBcImJhclwiIGVsZW1lbnQgZm91bmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgLy90byBiZSBkZWxldGVkLlxuICAgKiBteVNldC5kZWxldGUoXCJmb29cIik7IC8vIFJldHVybnMgdHJ1ZS4gIFN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuICAgKlxuICAgKiBteVNldC5oYXMoXCJmb29cIik7ICAgIC8vIFJldHVybnMgZmFsc2UuIFRoZSBcImZvb1wiIGVsZW1lbnQgaXMgbm9cbiAgICogICAgICAgICAgICAgICAgICAgICAgLy9sb25nZXIgcHJlc2VudC5cbiAgICovXG4gICdkZWxldGUnOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlMWV0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VEZWxldGUoJ3NldCcsIHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZW50cmllcygpIG1ldGhvZCByZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuXG4gICAqIGFycmF5IG9mIFt2YWx1ZSwgdmFsdWVdIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFNldCBvYmplY3QsIGluXG4gICAqIGluc2VydGlvbiBvcmRlci4gRm9yIFNldCBvYmplY3RzIHRoZXJlIGlzIG5vIGtleSBsaWtlIGluIE1hcCBvYmplY3RzLlxuICAgKiBIb3dldmVyLCB0byBrZWVwIHRoZSBBUEkgc2ltaWxhciB0byB0aGUgTWFwIG9iamVjdCwgZWFjaCBlbnRyeSBoYXMgdGhlXG4gICAqIHNhbWUgdmFsdWUgZm9yIGl0cyBrZXkgYW5kIHZhbHVlIGhlcmUsIHNvIHRoYXQgYW4gYXJyYXkgW3ZhbHVlLCB2YWx1ZV1cbiAgICogaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG5ldyBJdGVyYXRvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0XG4gICAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAgICogbXlTZXQuYWRkKFwiZm9vYmFyXCIpO1xuICAgKiBteVNldC5hZGQoMSk7XG4gICAqIG15U2V0LmFkZChcImJhelwiKTtcbiAgICpcbiAgICogdmFyIHNldEl0ZXIgPSBteVNldC5lbnRyaWVzKCk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gW1wiZm9vYmFyXCIsIFwiZm9vYmFyXCJdXG4gICAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gWzEsIDFdXG4gICAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gW1wiYmF6XCIsIFwiYmF6XCJdXG4gICAqL1xuICBlbnRyaWVzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gbmV3IFNldEl0KHRoaXMsICdrZXkrdmFsdWUnKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZm9yRWFjaCgpIG1ldGhvZCBleGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2ggdmFsdWVcbiAgICogaW4gdGhlIFNldCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBTZXQgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBmdW5jdGlvbiBsb2dTZXRFbGVtZW50cyh2YWx1ZTEsIHZhbHVlMiwgc2V0KSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcInNbXCIgKyB2YWx1ZTEgKyBcIl0gPSBcIiArIHZhbHVlMik7XG4gICAqIH1cbiAgICpcbiAgICogbmV3IFNldChbXCJmb29cIiwgXCJiYXJcIiwgdW5kZWZpbmVkXSkuZm9yRWFjaChsb2dTZXRFbGVtZW50cyk7XG4gICAqXG4gICAqIC8vIGxvZ3M6XG4gICAqIC8vIFwic1tmb29dID0gZm9vXCJcbiAgICogLy8gXCJzW2Jhcl0gPSBiYXJcIlxuICAgKiAvLyBcInNbdW5kZWZpbmVkXSA9IHVuZGVmaW5lZFwiXG4gICAqL1xuICBmb3JFYWNoOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yRWFjaCgnc2V0JywgdGhpcywgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBoYXMoKSBtZXRob2QgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGVcbiAgICogc3BlY2lmaWVkIHZhbHVlIGV4aXN0cyBpbiBhIFNldCBvYmplY3Qgb3Igbm90LlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0IGZvciBwcmVzZW5jZSBpbiB0aGUgU2V0IG9iamVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgKiAgZXhpc3RzIGluIHRoZSBTZXQgb2JqZWN0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0O1xuICAgKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gICAqIG15U2V0LmFkZChcImZvb1wiKTtcbiAgICpcbiAgICogbXlTZXQuaGFzKFwiZm9vXCIpOyAgLy8gcmV0dXJucyB0cnVlXG4gICAqIG15U2V0LmhhcyhcImJhclwiKTsgIC8vIHJldHVybnMgZmFsc2VcbiAgICovXG4gIGhhczoge1xuICAgIHZhbHVlOiBiYXNlSGFzXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUga2V5cygpIG1ldGhvZCBpcyBhbiBhbGlhcyBmb3IgdGhlIGB2YWx1ZXNgIG1ldGhvZCAoZm9yIHNpbWlsYXJpdHlcbiAgICogd2l0aCBNYXAgb2JqZWN0cyk7IGl0IGJlaGF2ZXMgZXhhY3RseSB0aGUgc2FtZSBhbmQgcmV0dXJucyB2YWx1ZXMgb2ZcbiAgICogU2V0IGVsZW1lbnRzLlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge09iamVjdH0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLlNldFxuICAgKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gICAqIG15U2V0LmFkZChcImZvb1wiKTtcbiAgICogbXlTZXQuYWRkKFwiYmFyXCIpO1xuICAgKiBteVNldC5hZGQoXCJiYXpcIik7XG4gICAqXG4gICAqIHZhciBzZXRJdGVyID0gbXlTZXQua2V5cygpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhzZXRJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFwiZm9vXCJcbiAgICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBcImJhclwiXG4gICAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCJiYXpcIlxuICAgKi9cbiAga2V5czoge1xuICAgIHZhbHVlOiBzZXRWYWx1ZXNJdGVyYXRvclxuICB9LFxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHNpemUgaXMgYW4gaW50ZWdlciByZXByZXNlbnRpbmcgaG93IG1hbnkgZW50cmllcyB0aGUgU2V0XG4gICAqIG9iamVjdCBoYXMuXG4gICAqXG4gICAqIEBuYW1lIHNpemVcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9ucy14LlNldFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIFNldCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5TZXRcbiAgICogdmFyIG15U2V0ID0gbmV3IFNldCgpO1xuICAgKiBteVNldC5hZGQoMSk7XG4gICAqIG15U2V0LmFkZCg1KTtcbiAgICogbXlTZXQuYWRkKFwic29tZSB0ZXh0XCIpO1xuICAgKlxuICAgKiBteVNldC5zaXplOyAvLyAzXG4gICAqL1xuICBzaXplOiB7XG4gICAgdmFsdWU6IDAsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZXMoKSBtZXRob2QgcmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAgICogdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFNldCBvYmplY3QgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge09iamVjdH0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLlNldFxuICAgKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gICAqIG15U2V0LmFkZChcImZvb1wiKTtcbiAgICogbXlTZXQuYWRkKFwiYmFyXCIpO1xuICAgKiBteVNldC5hZGQoXCJiYXpcIik7XG4gICAqXG4gICAqIHZhciBzZXRJdGVyID0gbXlTZXQudmFsdWVzKCk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCJmb29cIlxuICAgKiBjb25zb2xlLmxvZyhzZXRJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFwiYmFyXCJcbiAgICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBcImJhelwiXG4gICAqL1xuICB2YWx1ZXM6IHtcbiAgICB2YWx1ZTogc2V0VmFsdWVzSXRlcmF0b3JcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIEBAaXRlcmF0b3IgcHJvcGVydHkgaXMgdGhlIHNhbWUgZnVuY3Rpb24gb2JqZWN0XG4gKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgdmFsdWVzIHByb3BlcnR5LlxuICpcbiAqIEBmdW5jdGlvbiBzeW1JdFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9ucy14LlNldC5wcm90b3R5cGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLlNldCxcbiAqIHZhciBzeW1JdCA9IHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14Jykuc3ltSXQ7XG4gKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gKiBteVNldC5hZGQoXCIwXCIpO1xuICogbXlTZXQuYWRkKDEpO1xuICogbXlTZXQuYWRkKHt9KTtcbiAqXG4gKiB2YXIgc2V0SXRlciA9IG15U2V0W3N5bUl0XSgpO1xuICpcbiAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCIwXCJcbiAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gMVxuICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBPYmplY3RcbiAqL1xuZGVmaW5lUHJvcGVydHkoU2V0T2JqZWN0LnByb3RvdHlwZSwgc3ltSXQsIHtcbiAgdmFsdWU6IHNldFZhbHVlc0l0ZXJhdG9yXG59KTtcblxuLyoqXG4gKiBBbiBvYmplY3QgaXMgYW4gaXRlcmF0b3Igd2hlbiBpdCBrbm93cyBob3cgdG8gYWNjZXNzIGl0ZW1zIGZyb20gYVxuICogY29sbGVjdGlvbiBvbmUgYXQgYSB0aW1lLCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIGl0cyBjdXJyZW50IHBvc2l0aW9uXG4gKiB3aXRoaW4gdGhhdCBzZXF1ZW5jZS4gSW4gSmF2YVNjcmlwdCBhbiBpdGVyYXRvciBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlc1xuICogYSBuZXh0KCkgbWV0aG9kIHdoaWNoIHJldHVybnMgdGhlIG5leHQgaXRlbSBpbiB0aGUgc2VxdWVuY2UuIFRoaXMgbWV0aG9kXG4gKiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiBkb25lIGFuZCB2YWx1ZS4gT25jZSBjcmVhdGVkLFxuICogYW4gaXRlcmF0b3Igb2JqZWN0IGNhbiBiZSB1c2VkIGV4cGxpY2l0bHkgYnkgcmVwZWF0ZWRseSBjYWxsaW5nIG5leHQoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIFRoZSBNYXAgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGl0ZXJhdG9yS2luZCAtIFZhbHVlcyBhcmUgYHZhbHVlYCwgYGtleWAgb3IgYGtleSt2YWx1ZWAuXG4gKi9cbnZhciBNYXBJdCA9IGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKGNvbnRleHQsIGl0ZXJhdG9yS2luZCkge1xuICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAnW1tJdGVyYXRvckhhc01vcmVdXSc6IHtcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgICdbW01hcF1dJzoge1xuICAgICAgdmFsdWU6IGFzc2VydElzT2JqZWN0KGNvbnRleHQpXG4gICAgfSxcbiAgICAnW1tNYXBJdGVyYXRpb25LaW5kXV0nOiB7XG4gICAgICB2YWx1ZTogaXRlcmF0b3JLaW5kXG4gICAgfSxcbiAgICAnW1tNYXBOZXh0SW5kZXhdXSc6IHtcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBPbmNlIGluaXRpYWxpemVkLCB0aGUgbmV4dCgpIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIGFjY2VzcyBrZXktdmFsdWVcbiAqIHBhaXJzIGZyb20gdGhlIG9iamVjdCBpbiB0dXJuLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gbmV4dFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczogZG9uZSBhbmQgdmFsdWUuXG4gKi9cbmRlZmluZVByb3BlcnR5KE1hcEl0LnByb3RvdHlwZSwgJ25leHQnLCB7XG4gIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBjb250ZXh0ID0gYXNzZXJ0SXNPYmplY3QodGhpc1snW1tNYXBdXSddKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzWydbW01hcE5leHRJbmRleF1dJ107XG4gICAgdmFyIGl0ZXJhdG9yS2luZCA9IHRoaXNbJ1tbTWFwSXRlcmF0aW9uS2luZF1dJ107XG4gICAgdmFyIG1vcmUgPSB0aGlzWydbW0l0ZXJhdG9ySGFzTW9yZV1dJ107XG4gICAgdmFyIG9iamVjdDtcbiAgICBhc3NlcnRJc09iamVjdChjb250ZXh0KTtcbiAgICBpZiAoaW5kZXggPCBjb250ZXh0WydbW2tleV1dJ10ubGVuZ3RoICYmIG1vcmUpIHtcbiAgICAgIG9iamVjdCA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICAgIGlmIChpdGVyYXRvcktpbmQgPT09ICdrZXkrdmFsdWUnKSB7XG4gICAgICAgIG9iamVjdC52YWx1ZSA9IFtjb250ZXh0WydbW2tleV1dJ11baW5kZXhdLCBjb250ZXh0WydbW3ZhbHVlXV0nXVtpbmRleF1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gY29udGV4dFsnW1snICsgaXRlcmF0b3JLaW5kICsgJ11dJ11baW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB0aGlzWydbW01hcE5leHRJbmRleF1dJ10gKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1snW1tJdGVyYXRvckhhc01vcmVdXSddID0gZmFsc2U7XG4gICAgICBvYmplY3QgPSB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIEBAaXRlcmF0b3IgcHJvcGVydHkgaXMgdGhlIHNhbWUgSXRlcmF0b3Igb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gc3ltSXRcbiAqIEBtZW1iZXJvZiBNYXBJdGVyYXRvci5wcm90b3R5cGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoaXMgSXRlcmF0b3Igb2JqZWN0LlxuICovXG5kZWZpbmVQcm9wZXJ0eShNYXBJdC5wcm90b3R5cGUsIHN5bUl0LCB7XG4gIHZhbHVlOiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIE1hcCBvYmplY3QgaXMgYSBzaW1wbGUga2V5L3ZhbHVlIG1hcC4gQW55IHZhbHVlIChib3RoIG9iamVjdHMgYW5kXG4gKiBwcmltaXRpdmUgdmFsdWVzKSBtYXkgYmUgdXNlZCBhcyBlaXRoZXIgYSBrZXkgb3IgYSB2YWx1ZS5cbiAqXG4gKiBAY2xhc3MgTWFwXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbaXRlcmFibGVdIC0gSXRlcmFibGUgaXMgYW4gQXJyYXkgb3Igb3RoZXIgaXRlcmFibGUgb2JqZWN0IHdob3NlXG4gKiAgZWxlbWVudHMgYXJlIGtleS12YWx1ZSBwYWlycyAoMi1lbGVtZW50IEFycmF5cykuIEVhY2gga2V5LXZhbHVlIHBhaXIgaXNcbiAqICBhZGRlZCB0byB0aGUgbmV3IE1hcC4gbnVsbCBpcyB0cmVhdGVkIGFzIHVuZGVmaW5lZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgTWFwID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLk1hcDtcbiAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAqXG4gKiB2YXIga2V5U3RyaW5nID0gXCJhIHN0cmluZ1wiLFxuICogICAgIGtleU9iaiA9IHt9LFxuICogICAgIGtleUZ1bmMgPSBmdW5jdGlvbiAoKSB7fTtcbiAqXG4gKiAvLyBzZXR0aW5nIHRoZSB2YWx1ZXNcbiAqIG15TWFwLnNldChrZXlTdHJpbmcsIFwidmFsdWUgYXNzb2NpYXRlZCB3aXRoICdhIHN0cmluZydcIik7XG4gKiBteU1hcC5zZXQoa2V5T2JqLCBcInZhbHVlIGFzc29jaWF0ZWQgd2l0aCBrZXlPYmpcIik7XG4gKiBteU1hcC5zZXQoa2V5RnVuYywgXCJ2YWx1ZSBhc3NvY2lhdGVkIHdpdGgga2V5RnVuY1wiKTtcbiAqXG4gKiBteU1hcC5zaXplOyAvLyAzXG4gKlxuICogLy8gZ2V0dGluZyB0aGUgdmFsdWVzXG4gKiBteU1hcC5nZXQoa2V5U3RyaW5nKTsgICAgLy8gXCJ2YWx1ZSBhc3NvY2lhdGVkIHdpdGggJ2Egc3RyaW5nJ1wiXG4gKiBteU1hcC5nZXQoa2V5T2JqKTsgICAgICAgLy8gXCJ2YWx1ZSBhc3NvY2lhdGVkIHdpdGgga2V5T2JqXCJcbiAqIG15TWFwLmdldChrZXlGdW5jKTsgICAgICAvLyBcInZhbHVlIGFzc29jaWF0ZWQgd2l0aCBrZXlGdW5jXCJcbiAqXG4gKiBteU1hcC5nZXQoXCJhIHN0cmluZ1wiKTsgICAvLyBcInZhbHVlIGFzc29jaWF0ZWQgd2l0aCAnYSBzdHJpbmcnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGtleVN0cmluZyA9PT0gJ2Egc3RyaW5nJ1xuICogbXlNYXAuZ2V0KHt9KTsgICAgICAgICAgIC8vIHVuZGVmaW5lZCwgYmVjYXVzZSBrZXlPYmogIT09IHt9XG4gKiBteU1hcC5nZXQoZnVuY3Rpb24oKSB7fSkgLy8gdW5kZWZpbmVkLCBiZWNhdXNlIGtleUZ1bmMgIT09IGZ1bmN0aW9uICgpIHt9XG4gKlxuICogLy8gVXNpbmcgTmFOIGFzIE1hcCBrZXlzXG4gKiB2YXIgbXlNYXAgPSBuZXcgTWFwKCk7XG4gKiBteU1hcC5zZXQoTmFOLCBcIm5vdCBhIG51bWJlclwiKTtcbiAqXG4gKiBteU1hcC5nZXQoTmFOKTsgLy8gXCJub3QgYSBudW1iZXJcIlxuICpcbiAqIHZhciBvdGhlck5hTiA9IE51bWJlcihcImZvb1wiKTtcbiAqIG15TWFwLmdldChvdGhlck5hTik7IC8vIFwibm90IGEgbnVtYmVyXCJcbiAqXG4gKiAvLyBSZWxhdGlvbiB3aXRoIEFycmF5IG9iamVjdHNcbiAqIHZhciBrdkFycmF5ID0gW1tcImtleTFcIiwgXCJ2YWx1ZTFcIl0sIFtcImtleTJcIiwgXCJ2YWx1ZTJcIl1dO1xuICpcbiAqIC8vIFVzZSB0aGUgcmVndWxhciBNYXAgY29uc3RydWN0b3IgdG8gdHJhbnNmb3JtIGFcbiAqIC8vIDJEIGtleS12YWx1ZSBBcnJheSBpbnRvIGEgbWFwXG4gKiB2YXIgbXlNYXAgPSBuZXcgTWFwKGt2QXJyYXkpO1xuICpcbiAqIG15TWFwLmdldChcImtleTFcIik7IC8vIHJldHVybnMgXCJ2YWx1ZTFcIlxuICovXG52YXIgTWFwT2JqZWN0ID0gZnVuY3Rpb24gTWFwKCkge1xuICBpZiAoQm9vbGVhbih0aGlzKSA9PT0gZmFsc2UgfHwgKHRoaXMgaW5zdGFuY2VvZiBNYXBPYmplY3QpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnN0cnVjdG9yIE1hcCByZXF1aXJlcyBcXCduZXdcXCcnKTtcbiAgfVxuXG4gIHBhcnNlSXRlcmFibGUoJ21hcCcsIHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB2b2lkIDApO1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhNYXBPYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIG1vZHVsZTpjb2xsZWN0aW9ucy14Lk1hcC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogVGhlIGNsZWFyKCkgbWV0aG9kIHJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYSBNYXAgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgTWFwIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KFwiYmFyXCIsIFwiYmF6XCIpO1xuICAgKiBteU1hcC5zZXQoMSwgXCJmb29cIik7XG4gICAqXG4gICAqIG15TWFwLnNpemU7ICAgICAgIC8vIDJcbiAgICogbXlNYXAuaGFzKFwiYmFyXCIpOyAvLyB0cnVlXG4gICAqXG4gICAqIG15TWFwLmNsZWFyKCk7XG4gICAqXG4gICAqIG15TWFwLnNpemU7ICAgICAgIC8vIDBcbiAgICogbXlNYXAuaGFzKFwiYmFyXCIpICAvLyBmYWxzZVxuICAgKi9cbiAgY2xlYXI6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICByZXR1cm4gYmFzZUNsZWFyKCdtYXAnLCB0aGlzKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZGVsZXRlKCkgbWV0aG9kIHJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGZyb20gYSBNYXAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gdGhlIE1hcCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCBpbiB0aGUgTWFwIG9iamVjdCBoYXMgYmVlblxuICAgKiAgcmVtb3ZlZCBzdWNjZXNzZnVsbHkuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICAgKiB2YXIgbXlNYXAgPSBuZXcgTWFwKCk7XG4gICAqIG15TWFwLnNldChcImJhclwiLCBcImZvb1wiKTtcbiAgICpcbiAgICogbXlNYXAuZGVsZXRlKFwiYmFyXCIpOyAvLyBSZXR1cm5zIHRydWUuIFN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuICAgKiBteU1hcC5oYXMoXCJiYXJcIik7ICAgIC8vIFJldHVybnMgZmFsc2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImJhclwiIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAqL1xuICAnZGVsZXRlJzoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkZTFldGUoa2V5KSB7XG4gICAgICByZXR1cm4gYmFzZURlbGV0ZSgnbWFwJywgdGhpcywga2V5KTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZW50cmllcygpIG1ldGhvZCByZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgTWFwIG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KFwiMFwiLCBcImZvb1wiKTtcbiAgICogbXlNYXAuc2V0KDEsIFwiYmFyXCIpO1xuICAgKiBteU1hcC5zZXQoe30sIFwiYmF6XCIpO1xuICAgKlxuICAgKiB2YXIgbWFwSXRlciA9IG15TWFwLmVudHJpZXMoKTtcbiAgICpcbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBbXCIwXCIsIFwiZm9vXCJdXG4gICAqIGNvbnNvbGUubG9nKG1hcEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gWzEsIFwiYmFyXCJdXG4gICAqIGNvbnNvbGUubG9nKG1hcEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gW09iamVjdCwgXCJiYXpcIl1cbiAgICovXG4gIGVudHJpZXM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwSXQodGhpcywgJ2tleSt2YWx1ZScpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBmb3JFYWNoKCkgbWV0aG9kIGV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgZWFjaFxuICAgKiBrZXkvdmFsdWUgcGFpciBpbiB0aGUgTWFwIG9iamVjdCwgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC4uXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBNYXAgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgTWFwID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLk1hcDtcbiAgICogZnVuY3Rpb24gbG9nRWxlbWVudHModmFsdWUsIGtleSwgbWFwKSB7XG4gICAqICAgICAgY29uc29sZS5sb2coXCJtW1wiICsga2V5ICsgXCJdID0gXCIgKyB2YWx1ZSk7XG4gICAqIH1cbiAgICogdmFyIG15TWFwID0gbmV3IE1hcChbW1wiZm9vXCIsIDNdLCBbXCJiYXJcIiwge31dLCBbXCJiYXpcIiwgdW5kZWZpbmVkXV0pO1xuICAgKiBteU1hcC5mb3JFYWNoKGxvZ0VsZW1lbnRzKTtcbiAgICogLy8gbG9nczpcbiAgICogLy8gXCJtW2Zvb10gPSAzXCJcbiAgICogLy8gXCJtW2Jhcl0gPSBbb2JqZWN0IE9iamVjdF1cIlxuICAgKiAvLyBcIm1bYmF6XSA9IHVuZGVmaW5lZFwiXG4gICAqL1xuICBmb3JFYWNoOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yRWFjaCgnbWFwJywgdGhpcywgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBnZXQoKSBtZXRob2QgcmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gYSBNYXAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIE1hcCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBvclxuICAgKiAgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIE1hcCBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICAgKiB2YXIgbXlNYXAgPSBuZXcgTWFwKCk7XG4gICAqIG15TWFwLnNldChcImJhclwiLCBcImZvb1wiKTtcbiAgICpcbiAgICogbXlNYXAuZ2V0KFwiYmFyXCIpOyAgLy8gUmV0dXJucyBcImZvb1wiLlxuICAgKiBteU1hcC5nZXQoXCJiYXpcIik7ICAvLyBSZXR1cm5zIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleE9mKFxuICAgICAgICBhc3NlcnRJc09iamVjdCh0aGlzKVsnW1trZXldXSddLFxuICAgICAgICBrZXksXG4gICAgICAgICdTYW1lVmFsdWVaZXJvJ1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyB0aGlzWydbW3ZhbHVlXV0nXVtpbmRleF0gOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIGhhcygpIG1ldGhvZCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoXG4gICAqIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gdGVzdCBmb3IgcHJlc2VuY2UgaW4gdGhlXG4gICAqICBNYXAgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleVxuICAgKiAgZXhpc3RzIGluIHRoZSBNYXAgb2JqZWN0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICAgKiB2YXIgbXlNYXAgPSBuZXcgTWFwKCk7XG4gICAqIG15TWFwLnNldChcImJhclwiLCBcImZvb1wiKTtcbiAgICpcbiAgICogbXlNYXAuaGFzKFwiYmFyXCIpOyAgLy8gcmV0dXJucyB0cnVlXG4gICAqIG15TWFwLmhhcyhcImJhelwiKTsgIC8vIHJldHVybnMgZmFsc2VcbiAgICovXG4gIGhhczoge1xuICAgIHZhbHVlOiBiYXNlSGFzXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUga2V5cygpIG1ldGhvZCByZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBrZXlzXG4gICAqIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIE1hcCBvYmplY3QgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG5ldyBJdGVyYXRvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICAgKiB2YXIgbXlNYXAgPSBuZXcgTWFwKCk7XG4gICAqIG15TWFwLnNldChcIjBcIiwgXCJmb29cIik7XG4gICAqIG15TWFwLnNldCgxLCBcImJhclwiKTtcbiAgICogbXlNYXAuc2V0KHt9LCBcImJhelwiKTtcbiAgICpcbiAgICogdmFyIG1hcEl0ZXIgPSBteU1hcC5rZXlzKCk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKG1hcEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCIwXCJcbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyAxXG4gICAqIGNvbnNvbGUubG9nKG1hcEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gT2JqZWN0XG4gICAqL1xuICBrZXlzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcEl0KHRoaXMsICdrZXknKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgc2V0KCkgbWV0aG9kIGFkZHMgYSBuZXcgZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUgdG9cbiAgICogYSBNYXAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBNYXAgb2JqZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgTWFwIG9iamVjdC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIE1hcCBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICAgKiB2YXIgbXlNYXAgPSBuZXcgTWFwKCk7XG4gICAqXG4gICAqIC8vIEFkZCBuZXcgZWxlbWVudHMgdG8gdGhlIG1hcFxuICAgKiBteU1hcC5zZXQoXCJiYXJcIiwgXCJmb29cIik7XG4gICAqIG15TWFwLnNldCgxLCBcImZvb2JhclwiKTtcbiAgICpcbiAgICogLy8gVXBkYXRlIGFuIGVsZW1lbnQgaW4gdGhlIG1hcFxuICAgKiBteU1hcC5zZXQoXCJiYXJcIiwgXCJmdXV1XCIpO1xuICAgKi9cbiAgc2V0OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUFkZFNldCgnbWFwJywgdGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHNpemUgaXMgYW4gaW50ZWdlciByZXByZXNlbnRpbmcgaG93IG1hbnkgZW50cmllcyB0aGUgTWFwXG4gICAqIG9iamVjdCBoYXMuXG4gICAqXG4gICAqIEBuYW1lIHNpemVcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9ucy14Lk1hcFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KDEsIHRydWUpO1xuICAgKiBteU1hcC5zZXQoNSwgZmFsc2UpO1xuICAgKiBteU1hcC5zZXQoXCJzb21lIHRleHRcIiwgMSk7XG4gICAqXG4gICAqIG15TWFwLnNpemU7IC8vIDNcbiAgICovXG4gIHNpemU6IHtcbiAgICB2YWx1ZTogMCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVGhlIHZhbHVlcygpIG1ldGhvZCByZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgTWFwIG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KFwiMFwiLCBcImZvb1wiKTtcbiAgICogbXlNYXAuc2V0KDEsIFwiYmFyXCIpO1xuICAgKiBteU1hcC5zZXQoe30sIFwiYmF6XCIpO1xuICAgKlxuICAgKiB2YXIgbWFwSXRlciA9IG15TWFwLnZhbHVlcygpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhtYXBJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFwiZm9vXCJcbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBcImJhclwiXG4gICAqIGNvbnNvbGUubG9nKG1hcEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCJiYXpcIlxuICAgKi9cbiAgdmFsdWVzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwSXQodGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgQEBpdGVyYXRvciBwcm9wZXJ0eSBpcyB0aGUgc2FtZSBmdW5jdGlvbiBvYmplY3RcbiAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIHByb3BlcnR5LlxuICpcbiAqIEBmdW5jdGlvbiBzeW1JdFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9ucy14Lk1hcC5wcm90b3R5cGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgTWFwID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLk1hcDtcbiAqIHZhciBzeW1JdCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5zeW1JdDtcbiAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAqIG15TWFwLnNldChcIjBcIiwgXCJmb29cIik7XG4gKiBteU1hcC5zZXQoMSwgXCJiYXJcIik7XG4gKiBteU1hcC5zZXQoe30sIFwiYmF6XCIpO1xuICpcbiAqIHZhciBtYXBJdGVyID0gbXlNYXBbc3ltSXRdKCk7XG4gKlxuICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBbXCIwXCIsIFwiZm9vXCJdXG4gKiBjb25zb2xlLmxvZyhtYXBJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFsxLCBcImJhclwiXVxuICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBbT2JqZWN0LCBcImJhelwiXVxuICovXG5kZWZpbmVQcm9wZXJ0eShNYXBPYmplY3QucHJvdG90eXBlLCBzeW1JdCwge1xuICB2YWx1ZTogTWFwT2JqZWN0LnByb3RvdHlwZS5lbnRyaWVzXG59KTtcblxuLypcbiAqIERldGVybWluZSB3aGV0aGVyIHRvIHVzZSBzaGltIG9yIG5hdGl2ZS5cbiAqL1xuXG52YXIgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xudHJ5IHtcbiAgRXhwb3J0TWFwID0gbmV3IE1hcCgpID8gTWFwIDogTWFwT2JqZWN0O1xufSBjYXRjaCAoaWdub3JlKSB7fVxuXG52YXIgRXhwb3J0U2V0ID0gU2V0T2JqZWN0O1xudHJ5IHtcbiAgRXhwb3J0U2V0ID0gbmV3IFNldCgpID8gU2V0IDogU2V0T2JqZWN0O1xufSBjYXRjaCAoaWdub3JlKSB7fVxuXG52YXIgdGVzdE1hcDtcblxuaWYgKEV4cG9ydE1hcCAhPT0gTWFwT2JqZWN0KSB7XG4gIHRlc3RNYXAgPSBuZXcgRXhwb3J0TWFwKCk7XG4gIGlmIChpc051bWJlclR5cGUodGVzdE1hcC5zaXplKSA9PT0gZmFsc2UgfHwgdGVzdE1hcC5zaXplICE9PSAwKSB7XG4gICAgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIHZhciBwcm9wc01hcCA9IFtcbiAgICAgICdoYXMnLFxuICAgICAgJ3NldCcsXG4gICAgICAnY2xlYXInLFxuICAgICAgJ2RlbGV0ZScsXG4gICAgICAnZm9yRWFjaCcsXG4gICAgICAndmFsdWVzJyxcbiAgICAgICdlbnRyaWVzJyxcbiAgICAgICdrZXlzJyxcbiAgICAgIHN5bUl0XG4gICAgXTtcblxuICAgIHZhciBmYWlsZWRNYXAgPSBzb21lKHByb3BzTWFwLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbih0ZXN0TWFwW21ldGhvZF0pID09PSBmYWxzZTtcbiAgICB9KTtcblxuICAgIGlmIChmYWlsZWRNYXApIHtcbiAgICAgIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbiAgICB9XG4gIH1cbn1cblxuaWYgKEV4cG9ydE1hcCAhPT0gTWFwT2JqZWN0KSB7XG4gIC8vIFNhZmFyaSA4LCBmb3IgZXhhbXBsZSwgZG9lc24ndCBhY2NlcHQgYW4gaXRlcmFibGUuXG4gIHZhciBtYXBBY2NlcHRzQXJndW1lbnRzID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgbWFwQWNjZXB0c0FyZ3VtZW50cyA9IG5ldyBFeHBvcnRNYXAoW1sxLCAyXV0pLmdldCgxKSA9PT0gMjtcbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gIGlmIChtYXBBY2NlcHRzQXJndW1lbnRzID09PSBmYWxzZSkge1xuICAgIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbiAgfVxufVxuXG5pZiAoRXhwb3J0TWFwICE9PSBNYXBPYmplY3QpIHtcbiAgdGVzdE1hcCA9IG5ldyBFeHBvcnRNYXAoKTtcbiAgdmFyIG1hcFN1cHBvcnRzQ2hhaW5pbmcgPSB0ZXN0TWFwLnNldCgxLCAyKSA9PT0gdGVzdE1hcDtcbiAgaWYgKG1hcFN1cHBvcnRzQ2hhaW5pbmcgPT09IGZhbHNlKSB7XG4gICAgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xuICB9XG59XG5cbmlmIChFeHBvcnRNYXAgIT09IE1hcE9iamVjdCkge1xuICAvLyBDaHJvbWUgMzgtNDIsIG5vZGUgMC4xMS8wLjEyLCBpb2pzIDEvMiBhbHNvIGhhdmUgYSBidWcgd2hlbiB0aGUgTWFwIGhhcyBhIHNpemUgPiA0XG4gIHRlc3RNYXAgPSBuZXcgRXhwb3J0TWFwKFtcbiAgICBbMSwgMF0sXG4gICAgWzIsIDBdLFxuICAgIFszLCAwXSxcbiAgICBbNCwgMF1cbiAgXSk7XG4gIHRlc3RNYXAuc2V0KC0wLCB0ZXN0TWFwKTtcbiAgdmFyIGdldHMgPSB0ZXN0TWFwLmdldCgwKSA9PT0gdGVzdE1hcCAmJiB0ZXN0TWFwLmdldCgtMCkgPT09IHRlc3RNYXA7XG4gIHZhciBtYXBVc2VzU2FtZVZhbHVlWmVybyA9IGdldHMgJiYgdGVzdE1hcC5oYXMoMCkgJiYgdGVzdE1hcC5oYXMoLTApO1xuXG4gIGlmIChtYXBVc2VzU2FtZVZhbHVlWmVybyA9PT0gZmFsc2UpIHtcbiAgICBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG4gIH1cbn1cblxuaWYgKEV4cG9ydE1hcCAhPT0gTWFwT2JqZWN0KSB7XG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICB2YXIgTXlNYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICB0ZXN0TWFwID0gbmV3IEV4cG9ydE1hcChhcmcpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRlc3RNYXAsIE15TWFwLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gdGVzdE1hcDtcbiAgICB9O1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihNeU1hcCwgRXhwb3J0TWFwKTtcbiAgICBNeU1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV4cG9ydE1hcC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IE15TWFwIH0gfSk7XG5cbiAgICB2YXIgbWFwU3VwcG9ydHNTdWJjbGFzc2luZyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICB0ZXN0TWFwID0gbmV3IE15TWFwKFtdKTtcbiAgICAgIC8vIEZpcmVmb3ggMzIgaXMgb2sgd2l0aCB0aGUgaW5zdGFudGlhdGluZyB0aGUgc3ViY2xhc3MgYnV0IHdpbGxcbiAgICAgIC8vIHRocm93IHdoZW4gdGhlIG1hcCBpcyB1c2VkLlxuICAgICAgdGVzdE1hcC5zZXQoNDIsIDQyKTtcbiAgICAgIG1hcFN1cHBvcnRzU3ViY2xhc3NpbmcgPSB0ZXN0TWFwIGluc3RhbmNlb2YgTXlNYXA7XG4gICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgaWYgKG1hcFN1cHBvcnRzU3ViY2xhc3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG4gICAgfVxuICB9XG59XG5cbmlmIChFeHBvcnRNYXAgIT09IE1hcE9iamVjdCkge1xuICB2YXIgbWFwUmVxdWlyZXNOZXc7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICBtYXBSZXF1aXJlc05ldyA9IChFeHBvcnRNYXAoKSBpbnN0YW5jZW9mIEV4cG9ydE1hcCkgPT09IGZhbHNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbWFwUmVxdWlyZXNOZXcgPSBlIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG5cbiAgaWYgKG1hcFJlcXVpcmVzTmV3ID09PSBmYWxzZSkge1xuICAgIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbiAgfVxufVxuXG5pZiAoRXhwb3J0TWFwICE9PSBNYXBPYmplY3QpIHtcbiAgdGVzdE1hcCA9IG5ldyBFeHBvcnRNYXAoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxuICB2YXIgbWFwSXRlcmF0aW9uVGhyb3dzU3RvcEl0ZXJhdG9yO1xuICB0cnkge1xuICAgIG1hcEl0ZXJhdGlvblRocm93c1N0b3BJdGVyYXRvciA9IHRlc3RNYXAua2V5cygpLm5leHQoKS5kb25lID09PSBmYWxzZTtcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgbWFwSXRlcmF0aW9uVGhyb3dzU3RvcEl0ZXJhdG9yID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChtYXBJdGVyYXRpb25UaHJvd3NTdG9wSXRlcmF0b3IpIHtcbiAgICBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG4gIH1cbn1cblxuLy8gU2FmYXJpIDhcbmlmIChFeHBvcnRNYXAgIT09IE1hcE9iamVjdCAmJiBpc0Z1bmN0aW9uKG5ldyBFeHBvcnRNYXAoKS5rZXlzKCkubmV4dCkgPT09IGZhbHNlKSB7XG4gIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbn1cblxuaWYgKGhhc1JlYWxTeW1ib2xJdGVyYXRvciAmJiBFeHBvcnRNYXAgIT09IE1hcE9iamVjdCkge1xuICB2YXIgdGVzdE1hcFByb3RvID0gZ2V0UHJvdG90eXBlT2YobmV3IEV4cG9ydE1hcCgpLmtleXMoKSk7XG4gIHZhciBoYXNCdWdneU1hcEl0ZXJhdG9yID0gdHJ1ZTtcbiAgaWYgKHRlc3RNYXBQcm90bykge1xuICAgIGhhc0J1Z2d5TWFwSXRlcmF0b3IgPSBpc0Z1bmN0aW9uKHRlc3RNYXBQcm90b1tzeW1JdF0pID09PSBmYWxzZTtcbiAgfVxuXG4gIGlmIChoYXNCdWdneU1hcEl0ZXJhdG9yKSB7XG4gICAgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xuICB9XG59XG5cbnZhciB0ZXN0U2V0O1xuXG5pZiAoRXhwb3J0U2V0ICE9PSBTZXRPYmplY3QpIHtcbiAgdGVzdFNldCA9IG5ldyBFeHBvcnRTZXQoKTtcbiAgaWYgKGlzTnVtYmVyVHlwZSh0ZXN0U2V0LnNpemUpID09PSBmYWxzZSB8fCB0ZXN0U2V0LnNpemUgIT09IDApIHtcbiAgICBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByb3BzU2V0ID0gW1xuICAgICAgJ2hhcycsXG4gICAgICAnYWRkJyxcbiAgICAgICdjbGVhcicsXG4gICAgICAnZGVsZXRlJyxcbiAgICAgICdmb3JFYWNoJyxcbiAgICAgICd2YWx1ZXMnLFxuICAgICAgJ2VudHJpZXMnLFxuICAgICAgJ2tleXMnLFxuICAgICAgc3ltSXRcbiAgICBdO1xuXG4gICAgdmFyIGZhaWxlZFNldCA9IHNvbWUocHJvcHNTZXQsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRlc3RTZXRbbWV0aG9kXSkgPT09IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgaWYgKGZhaWxlZFNldCkge1xuICAgICAgRXhwb3J0U2V0ID0gU2V0T2JqZWN0O1xuICAgIH1cbiAgfVxufVxuXG5pZiAoRXhwb3J0U2V0ICE9PSBTZXRPYmplY3QpIHtcbiAgdGVzdFNldCA9IG5ldyBFeHBvcnRTZXQoKTtcbiAgdGVzdFNldFsnZGVsZXRlJ10oMCk7XG4gIHRlc3RTZXQuYWRkKC0wKTtcbiAgdmFyIHNldFVzZXNTYW1lVmFsdWVaZXJvID0gdGVzdFNldC5oYXMoMCkgJiYgdGVzdFNldC5oYXMoLTApO1xuICBpZiAoc2V0VXNlc1NhbWVWYWx1ZVplcm8gPT09IGZhbHNlKSB7XG4gICAgRXhwb3J0U2V0ID0gU2V0T2JqZWN0O1xuICB9XG59XG5cbmlmIChFeHBvcnRTZXQgIT09IFNldE9iamVjdCkge1xuICB0ZXN0U2V0ID0gbmV3IEV4cG9ydFNldCgpO1xuICB2YXIgc2V0U3VwcG9ydHNDaGFpbmluZyA9IHRlc3RTZXQuYWRkKDEpID09PSB0ZXN0U2V0O1xuICBpZiAoc2V0U3VwcG9ydHNDaGFpbmluZyA9PT0gZmFsc2UpIHtcbiAgICBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG4gIH1cbn1cblxuaWYgKEV4cG9ydFNldCAhPT0gU2V0T2JqZWN0KSB7XG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICB2YXIgTXlTZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICB0ZXN0U2V0ID0gbmV3IEV4cG9ydFNldChhcmcpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRlc3RTZXQsIE15U2V0LnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gdGVzdFNldDtcbiAgICB9O1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihNeVNldCwgRXhwb3J0U2V0KTtcbiAgICBNeVNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV4cG9ydFNldC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IE15U2V0IH0gfSk7XG5cbiAgICB2YXIgc2V0U3VwcG9ydHNTdWJjbGFzc2luZyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U2V0ID0gbmV3IE15U2V0KFtdKTtcbiAgICAgIHRlc3RTZXQuYWRkKDQyLCA0Mik7XG4gICAgICBzZXRTdXBwb3J0c1N1YmNsYXNzaW5nID0gdGVzdFNldCBpbnN0YW5jZW9mIE15U2V0O1xuICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgIGlmIChzZXRTdXBwb3J0c1N1YmNsYXNzaW5nID09PSBmYWxzZSkge1xuICAgICAgRXhwb3J0U2V0ID0gU2V0T2JqZWN0O1xuICAgIH1cbiAgfVxufVxuXG5pZiAoRXhwb3J0U2V0ICE9PSBTZXRPYmplY3QpIHtcbiAgdmFyIHNldFJlcXVpcmVzTmV3O1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgc2V0UmVxdWlyZXNOZXcgPSAoRXhwb3J0U2V0KCkgaW5zdGFuY2VvZiBFeHBvcnRTZXQpID09PSBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNldFJlcXVpcmVzTmV3ID0gZSBpbnN0YW5jZW9mIFR5cGVFcnJvcjtcbiAgfVxuXG4gIGlmIChzZXRSZXF1aXJlc05ldyA9PT0gZmFsc2UpIHtcbiAgICBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG4gIH1cbn1cblxuaWYgKEV4cG9ydFNldCAhPT0gU2V0T2JqZWN0KSB7XG4gIHRlc3RTZXQgPSBuZXcgRXhwb3J0U2V0KCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbiAgdmFyIHNldEl0ZXJhdGlvblRocm93c1N0b3BJdGVyYXRvcjtcbiAgdHJ5IHtcbiAgICBzZXRJdGVyYXRpb25UaHJvd3NTdG9wSXRlcmF0b3IgPSB0ZXN0U2V0LmtleXMoKS5uZXh0KCkuZG9uZSA9PT0gZmFsc2U7XG4gIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgIHNldEl0ZXJhdGlvblRocm93c1N0b3BJdGVyYXRvciA9IHRydWU7XG4gIH1cblxuICBpZiAoc2V0SXRlcmF0aW9uVGhyb3dzU3RvcEl0ZXJhdG9yKSB7XG4gICAgRXhwb3J0U2V0ID0gU2V0T2JqZWN0O1xuICB9XG59XG5cbi8vIFNhZmFyaSA4XG5pZiAoRXhwb3J0U2V0ICE9PSBTZXRPYmplY3QgJiYgaXNGdW5jdGlvbihuZXcgRXhwb3J0U2V0KCkua2V5cygpLm5leHQpID09PSBmYWxzZSkge1xuICBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG59XG5cbmlmIChoYXNSZWFsU3ltYm9sSXRlcmF0b3IgJiYgRXhwb3J0U2V0ICE9PSBTZXRPYmplY3QpIHtcbiAgdmFyIHRlc3RTZXRQcm90byA9IGdldFByb3RvdHlwZU9mKG5ldyBFeHBvcnRTZXQoKS5rZXlzKCkpO1xuICB2YXIgaGFzQnVnZ3lTZXRJdGVyYXRvciA9IHRydWU7XG4gIGlmICh0ZXN0U2V0UHJvdG8pIHtcbiAgICBoYXNCdWdneVNldEl0ZXJhdG9yID0gaXNGdW5jdGlvbih0ZXN0U2V0UHJvdG9bc3ltSXRdKSA9PT0gZmFsc2U7XG4gIH1cblxuICBpZiAoaGFzQnVnZ3lTZXRJdGVyYXRvcikge1xuICAgIEV4cG9ydFNldCA9IFNldE9iamVjdDtcbiAgfVxufVxuXG52YXIgaGFzQ29tbW9uID0gZnVuY3Rpb24gX2hhc0NvbW1vbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZShvYmplY3QpICYmIGlzRnVuY3Rpb24ob2JqZWN0W3N5bUl0XSkgJiYgaXNCb29sZWFuKG9iamVjdFsnW1tjaGFuZ2VkXV0nXSkgJiYgaXNPYmplY3RMaWtlKG9iamVjdFsnW1tpZF1dJ10pICYmIGlzQXJyYXkob2JqZWN0WydbW2tleV1dJ10pICYmIGlzQXJyYXkob2JqZWN0WydbW29yZGVyXV0nXSkgJiYgaXNOdW1iZXJUeXBlKG9iamVjdC5zaXplKTtcbn07XG5cbnZhciAkaXNNYXA7XG5pZiAoRXhwb3J0TWFwID09PSBNYXBPYmplY3QpIHtcbiAgJGlzTWFwID0gZnVuY3Rpb24gX2lzTWFwKG9iamVjdCkge1xuICAgIGlmIChpc01hcChvYmplY3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQ29tbW9uKG9iamVjdCkgJiYgaXNBcnJheShvYmplY3RbJ1tbdmFsdWVdXSddKTtcbiAgfTtcbn0gZWxzZSB7XG4gICRpc01hcCA9IGlzTWFwO1xufVxuXG52YXIgJGlzU2V0O1xuaWYgKEV4cG9ydFNldCA9PT0gU2V0T2JqZWN0KSB7XG4gICRpc1NldCA9IGZ1bmN0aW9uIF9pc1NldChvYmplY3QpIHtcbiAgICBpZiAoaXNTZXQob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc0NvbW1vbihvYmplY3QpICYmIGlzVW5kZWZpbmVkKG9iamVjdFsnW1t2YWx1ZV1dJ10pO1xuICB9O1xufSBlbHNlIHtcbiAgJGlzU2V0ID0gaXNTZXQ7XG59XG5cbi8qXG4gKiBFeHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGFuIGBvYmplY3RgIGlzIGEgYE1hcGAuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBgb2JqZWN0YCBpcyBhIGBNYXBgLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaXNNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuaXNNYXA7XG4gICAqIHZhciBtID0gbmV3IE1hcCgpO1xuICAgKlxuICAgKiBpc01hcChbXSk7IC8vIGZhbHNlXG4gICAqIGlzTWFwKHRydWUpOyAvLyBmYWxzZVxuICAgKiBpc01hcChtKTsgLy8gdHJ1ZVxuICAgKi9cbiAgaXNNYXA6ICRpc01hcCxcbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhbiBgb2JqZWN0YCBpcyBhIGBTZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYG9iamVjdGAgaXMgYSBgU2V0YCxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGlzU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpO1xuICAgKiB2YXIgcyA9IG5ldyBTZXQoKTtcbiAgICpcbiAgICogaXNTZXQoW10pOyAvLyBmYWxzZVxuICAgKiBpc1NldCh0cnVlKTsgLy8gZmFsc2VcbiAgICogaXNTZXQocyk7IC8vIHRydWVcbiAgICovXG4gIGlzU2V0OiAkaXNTZXQsXG4gIC8qKiBAYm9ycm93cyBNYXAgYXMgTWFwICovXG4gIE1hcDogRXhwb3J0TWFwLFxuICAvKiogQGJvcnJvd3MgU2V0IGFzIFNldCAqL1xuICBTZXQ6IEV4cG9ydFNldCxcbiAgLyoqXG4gICAqIFRoZSBpdGVyYXRvciBpZGVudGlmaWVyIHRoYXQgaXMgaW4gdXNlLlxuICAgKlxuICAgKiB0eXBlIHtTeW1ib2x8c3RyaW5nfVxuICAgKi9cbiAgc3ltSXQ6IHN5bUl0XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBrZXkuXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaGFzb3ducHJvcGVydHl8Ny4zLjExIEhhc093blByb3BlcnR5IChPLCBQKX1cbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBoYXMtb3duLXByb3BlcnR5LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCdlcy10by1wcmltaXRpdmUvZXM2Jyk7XG52YXIgc2FmZVRvU3RyaW5nID0gcmVxdWlyZSgnc2FmZS10by1zdHJpbmcteCcpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnaXMtc3ltYm9sJyk7XG52YXIgaG9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYGhhc093blByb3BlcnR5YCBtZXRob2QgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyXG4gKiB0aGUgYG9iamVjdGAgaGFzIHRoZSBzcGVjaWZpZWQgYHByb3BlcnR5YC4gRG9lcyBub3QgYXR0ZW1wdCB0byBmaXgga25vd25cbiAqIGlzc3VlcyBpbiBvbGRlciBicm93c2VycywgYnV0IGRvZXMgRVM2aWZ5IHRoZSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ3xTeW1ib2x9IHByb3BlcnR5IC0gVGhlIG5hbWUgb3IgU3ltYm9sIG9mIHRoZSBwcm9wZXJ0eSB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgc2V0IG9uIGBvYmplY3RgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGhhc093blByb3BlcnR5ID0gcmVxdWlyZSgnaGFzLW93bi1wcm9wZXJ0eS14Jyk7XG4gKiB2YXIgbyA9IHtcbiAqICAgZm9vOiAnYmFyJ1xuICogfTtcbiAqXG4gKlxuICogaGFzT3duUHJvcGVydHkobywgJ2JhcicpOyAvLyBmYWxzZVxuICogaGFzT3duUHJvcGVydHkobywgJ2ZvbycpOyAvLyB0cnVlXG4gKiBoYXNPd25Qcm9wZXJ0eSh1bmRlZmluZWQsICdmb28nKTtcbiAqICAgICAgICAgICAgICAgICAgIC8vIFR5cGVFcnJvcjogQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB2YXIgcHJvcCA9IGlzU3ltYm9sKHByb3BlcnR5KSA/IHByb3BlcnR5IDogc2FmZVRvU3RyaW5nKHRvUHJpbWl0aXZlKHByb3BlcnR5LCBTdHJpbmcpKTtcblxuICByZXR1cm4gaG9wLmNhbGwodG9PYmplY3Qob2JqZWN0KSwgcHJvcCk7XG59O1xuIiwiLyoqXG4gKiBAY2xhc3MgVGVtcGxhdGVUYWdcbiAqIEBjbGFzc2Rlc2MgQ29uc3VtZXMgYSBwaXBlbGluZSBvZiBjb21wb3NhYmxlIHRyYW5zZm9ybWVyIHBsdWdpbnMgYW5kIHByb2R1Y2VzIGEgdGVtcGxhdGUgdGFnLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wbGF0ZVRhZyB7XG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RzIGEgdGVtcGxhdGUgdGFnXG4gICAqIEBjb25zdHJ1Y3RzIFRlbXBsYXRlVGFnXG4gICAqIEBwYXJhbSAgey4uLk9iamVjdH0gWy4uLnRyYW5zZm9ybWVyc10gLSBhbiBhcnJheSBvciBhcmd1bWVudHMgbGlzdCBvZiB0cmFuc2Zvcm1lcnNcbiAgICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgICAtIGEgdGVtcGxhdGUgdGFnXG4gICAqL1xuICBjb25zdHJ1Y3RvciguLi50cmFuc2Zvcm1lcnMpIHtcbiAgICAvLyBpZiBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSwgZXh0cnVkZSBpdCBhcyBhIGxpc3Qgb2YgdHJhbnNmb3JtZXJzXG4gICAgaWYgKHRyYW5zZm9ybWVycy5sZW5ndGggPiAwICYmIEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZXJzWzBdKSkge1xuICAgICAgdHJhbnNmb3JtZXJzID0gdHJhbnNmb3JtZXJzWzBdO1xuICAgIH1cblxuICAgIC8vIGlmIGFueSB0cmFuc2Zvcm1lcnMgYXJlIGZ1bmN0aW9ucywgdGhpcyBtZWFucyB0aGV5IGFyZSBub3QgaW5pdGlhdGVkIC0gYXV0b21hdGljYWxseSBpbml0aWF0ZSB0aGVtXG4gICAgdGhpcy50cmFuc2Zvcm1lcnMgPSB0cmFuc2Zvcm1lcnMubWFwKHRyYW5zZm9ybWVyID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgdHJhbnNmb3JtZXIgPT09ICdmdW5jdGlvbicgPyB0cmFuc2Zvcm1lcigpIDogdHJhbnNmb3JtZXI7XG4gICAgfSk7XG5cbiAgICAvLyByZXR1cm4gYW4gRVMyMDE1IHRlbXBsYXRlIHRhZ1xuICAgIHJldHVybiB0aGlzLnRhZztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGFsbCB0cmFuc2Zvcm1lcnMgdG8gYSB0ZW1wbGF0ZSBsaXRlcmFsIHRhZ2dlZCB3aXRoIHRoaXMgbWV0aG9kLlxuICAgKiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGFzc3VtZXMgdGhlIGZ1bmN0aW9uIGlzIGEgdGVtcGxhdGUgdGFnXG4gICAqIGFuZCBhcHBsaWVzIGl0IHRvIHRoZSB0ZW1wbGF0ZSwgcmV0dXJuaW5nIGEgdGVtcGxhdGUgdGFnLlxuICAgKiBAcGFyYW0gIHsoRnVuY3Rpb258U3RyaW5nfEFycmF5PFN0cmluZz4pfSBzdHJpbmdzICAgICAgICAtIEVpdGhlciBhIHRlbXBsYXRlIHRhZyBvciBhbiBhcnJheSBjb250YWluaW5nIHRlbXBsYXRlIHN0cmluZ3Mgc2VwYXJhdGVkIGJ5IGlkZW50aWZpZXJcbiAgICogQHBhcmFtICB7Li4uKn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXhwcmVzc2lvbnMgLSBPcHRpb25hbCBsaXN0IG9mIHN1YnN0aXR1dGlvbiB2YWx1ZXMuXG4gICAqIEByZXR1cm4geyhTdHJpbmd8RnVuY3Rpb24pfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRWl0aGVyIGFuIGludGVybWVkaWFyeSB0YWcgZnVuY3Rpb24gb3IgdGhlIHJlc3VsdHMgb2YgcHJvY2Vzc2luZyB0aGUgdGVtcGxhdGUuXG4gICAqL1xuICB0YWcgPSAoc3RyaW5ncywgLi4uZXhwcmVzc2lvbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIHN0cmluZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgaXMgYSBmdW5jdGlvbiwgYXNzdW1lIGl0IGlzIGEgdGVtcGxhdGUgdGFnIGFuZCByZXR1cm5cbiAgICAgIC8vIGFuIGludGVybWVkaWFyeSB0YWcgdGhhdCBwcm9jZXNzZXMgdGhlIHRlbXBsYXRlIHVzaW5nIHRoZSBhZm9yZW1lbnRpb25lZCB0YWcsIHBhc3NpbmcgdGhlXG4gICAgICAvLyByZXN1bHQgdG8gb3VyIHRhZ1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJpbVRhZy5iaW5kKHRoaXMsIHN0cmluZ3MpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgaXMgYSBzdHJpbmcsIGp1c3QgdHJhbnNmb3JtIGl0XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FbmRSZXN1bHQoc3RyaW5ncyk7XG4gICAgfVxuXG4gICAgLy8gZWxzZSwgcmV0dXJuIGEgdHJhbnNmb3JtZWQgZW5kIHJlc3VsdCBvZiBwcm9jZXNzaW5nIHRoZSB0ZW1wbGF0ZSB3aXRoIG91ciB0YWdcbiAgICBzdHJpbmdzID0gc3RyaW5ncy5tYXAodGhpcy50cmFuc2Zvcm1TdHJpbmcuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRW5kUmVzdWx0KFxuICAgICAgc3RyaW5ncy5yZWR1Y2UodGhpcy5wcm9jZXNzU3Vic3RpdHV0aW9ucy5iaW5kKHRoaXMsIGV4cHJlc3Npb25zKSksXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQW4gaW50ZXJtZWRpYXJ5IHRlbXBsYXRlIHRhZyB0aGF0IHJlY2VpdmVzIGEgdGVtcGxhdGUgdGFnIGFuZCBwYXNzZXMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSB0ZW1wbGF0ZSB3aXRoIHRoZSByZWNlaXZlZFxuICAgKiB0ZW1wbGF0ZSB0YWcgdG8gb3VyIG93biB0ZW1wbGF0ZSB0YWcuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgbmV4dFRhZyAgICAgICAgICAtIHRoZSByZWNlaXZlZCB0ZW1wbGF0ZSB0YWdcbiAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gICB0ZW1wbGF0ZSAgICAgICAgIC0gdGhlIHRlbXBsYXRlIHRvIHByb2Nlc3NcbiAgICogQHBhcmFtICB7Li4uKn0gICAgICAgICAgICAuLi5zdWJzdGl0dXRpb25zIC0gYHN1YnN0aXR1dGlvbnNgIGlzIGFuIGFycmF5IG9mIGFsbCBzdWJzdGl0dXRpb25zIGluIHRoZSB0ZW1wbGF0ZVxuICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB0aGUgZmluYWwgcHJvY2Vzc2VkIHZhbHVlXG4gICAqL1xuICBpbnRlcmltVGFnKHByZXZpb3VzVGFnLCB0ZW1wbGF0ZSwgLi4uc3Vic3RpdHV0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRhZ2Ake3ByZXZpb3VzVGFnKHRlbXBsYXRlLCAuLi5zdWJzdGl0dXRpb25zKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGJ1bGsgcHJvY2Vzc2luZyBvbiB0aGUgdGFnZ2VkIHRlbXBsYXRlLCB0cmFuc2Zvcm1pbmcgZWFjaCBzdWJzdGl0dXRpb24gYW5kIHRoZW5cbiAgICogY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBpbnRvIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0gIHtBcnJheTwqPn0gc3Vic3RpdHV0aW9ucyAtIGFuIGFycmF5IG9mIGFsbCByZW1haW5pbmcgc3Vic3RpdHV0aW9ucyBwcmVzZW50IGluIHRoaXMgdGVtcGxhdGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIHJlc3VsdFNvRmFyICAgLSB0aGlzIGl0ZXJhdGlvbidzIHJlc3VsdCBzdHJpbmcgc28gZmFyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICByZW1haW5pbmdQYXJ0IC0gdGhlIHRlbXBsYXRlIGNodW5rIGFmdGVyIHRoZSBjdXJyZW50IHN1YnN0aXR1dGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAtIHRoZSByZXN1bHQgb2Ygam9pbmluZyB0aGlzIGl0ZXJhdGlvbidzIHByb2Nlc3NlZCBzdWJzdGl0dXRpb24gd2l0aCB0aGUgcmVzdWx0XG4gICAqL1xuICBwcm9jZXNzU3Vic3RpdHV0aW9ucyhzdWJzdGl0dXRpb25zLCByZXN1bHRTb0ZhciwgcmVtYWluaW5nUGFydCkge1xuICAgIGNvbnN0IHN1YnN0aXR1dGlvbiA9IHRoaXMudHJhbnNmb3JtU3Vic3RpdHV0aW9uKFxuICAgICAgc3Vic3RpdHV0aW9ucy5zaGlmdCgpLFxuICAgICAgcmVzdWx0U29GYXIsXG4gICAgKTtcbiAgICByZXR1cm4gJycuY29uY2F0KHJlc3VsdFNvRmFyLCBzdWJzdGl0dXRpb24sIHJlbWFpbmluZ1BhcnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHRyYW5zZm9ybWVyLCBhcHBseWluZyB0aGUgdHJhbnNmb3JtZXIncyBgb25TdHJpbmdgIG1ldGhvZCB0byB0aGUgdGVtcGxhdGVcbiAgICogc3RyaW5ncyBiZWZvcmUgYWxsIHN1YnN0aXR1dGlvbnMgYXJlIHByb2Nlc3NlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9ICBzdHIgLSBUaGUgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgIC0gVGhlIGZpbmFsIHJlc3VsdHMgb2YgcHJvY2Vzc2luZyBlYWNoIHRyYW5zZm9ybWVyXG4gICAqL1xuICB0cmFuc2Zvcm1TdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgY2IgPSAocmVzLCB0cmFuc2Zvcm0pID0+XG4gICAgICB0cmFuc2Zvcm0ub25TdHJpbmcgPyB0cmFuc2Zvcm0ub25TdHJpbmcocmVzKSA6IHJlcztcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcnMucmVkdWNlKGNiLCBzdHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBzdWJzdGl0dXRpb24gaXMgZW5jb3VudGVyZWQsIGl0ZXJhdGVzIHRocm91Z2ggZWFjaCB0cmFuc2Zvcm1lciBhbmQgYXBwbGllcyB0aGUgdHJhbnNmb3JtZXInc1xuICAgKiBgb25TdWJzdGl0dXRpb25gIG1ldGhvZCB0byB0aGUgc3Vic3RpdHV0aW9uLlxuICAgKiBAcGFyYW0gIHsqfSAgICAgIHN1YnN0aXR1dGlvbiAtIFRoZSBjdXJyZW50IHN1YnN0aXR1dGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHJlc3VsdFNvRmFyICAtIFRoZSByZXN1bHQgdXAgdG8gYW5kIGV4Y2x1ZGluZyB0aGlzIHN1YnN0aXR1dGlvbi5cbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgLSBUaGUgZmluYWwgcmVzdWx0IG9mIGFwcGx5aW5nIGFsbCBzdWJzdGl0dXRpb24gdHJhbnNmb3JtYXRpb25zLlxuICAgKi9cbiAgdHJhbnNmb3JtU3Vic3RpdHV0aW9uKHN1YnN0aXR1dGlvbiwgcmVzdWx0U29GYXIpIHtcbiAgICBjb25zdCBjYiA9IChyZXMsIHRyYW5zZm9ybSkgPT5cbiAgICAgIHRyYW5zZm9ybS5vblN1YnN0aXR1dGlvblxuICAgICAgICA/IHRyYW5zZm9ybS5vblN1YnN0aXR1dGlvbihyZXMsIHJlc3VsdFNvRmFyKVxuICAgICAgICA6IHJlcztcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcnMucmVkdWNlKGNiLCBzdWJzdGl0dXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCB0cmFuc2Zvcm1lciwgYXBwbHlpbmcgdGhlIHRyYW5zZm9ybWVyJ3MgYG9uRW5kUmVzdWx0YCBtZXRob2QgdG8gdGhlXG4gICAqIHRlbXBsYXRlIGxpdGVyYWwgYWZ0ZXIgYWxsIHN1YnN0aXR1dGlvbnMgaGF2ZSBmaW5pc2hlZCBwcm9jZXNzaW5nLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVuZFJlc3VsdCAtIFRoZSBwcm9jZXNzZWQgdGVtcGxhdGUsIGp1c3QgYmVmb3JlIGl0IGlzIHJldHVybmVkIGZyb20gdGhlIHRhZ1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAtIFRoZSBmaW5hbCByZXN1bHRzIG9mIHByb2Nlc3NpbmcgZWFjaCB0cmFuc2Zvcm1lclxuICAgKi9cbiAgdHJhbnNmb3JtRW5kUmVzdWx0KGVuZFJlc3VsdCkge1xuICAgIGNvbnN0IGNiID0gKHJlcywgdHJhbnNmb3JtKSA9PlxuICAgICAgdHJhbnNmb3JtLm9uRW5kUmVzdWx0ID8gdHJhbnNmb3JtLm9uRW5kUmVzdWx0KHJlcykgOiByZXM7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtZXJzLnJlZHVjZShjYiwgZW5kUmVzdWx0KTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnJvbSAnLi9UZW1wbGF0ZVRhZyc7XG4iLCJleHBvcnQgZGVmYXVsdCBmcm9tICcuLi9odG1sJztcbiIsImltcG9ydCBUZW1wbGF0ZVRhZyBmcm9tICcuLi9UZW1wbGF0ZVRhZyc7XG5pbXBvcnQgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lciBmcm9tICcuLi9zdHJpcEluZGVudFRyYW5zZm9ybWVyJztcbmltcG9ydCBpbmxpbmVBcnJheVRyYW5zZm9ybWVyIGZyb20gJy4uL2lubGluZUFycmF5VHJhbnNmb3JtZXInO1xuaW1wb3J0IHRyaW1SZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuXG5jb25zdCBjb21tYUxpc3RzID0gbmV3IFRlbXBsYXRlVGFnKFxuICBpbmxpbmVBcnJheVRyYW5zZm9ybWVyKHsgc2VwYXJhdG9yOiAnLCcgfSksXG4gIHN0cmlwSW5kZW50VHJhbnNmb3JtZXIsXG4gIHRyaW1SZXN1bHRUcmFuc2Zvcm1lcixcbik7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbW1hTGlzdHM7XG4iLCJleHBvcnQgZGVmYXVsdCBmcm9tICcuL2NvbW1hTGlzdHMnO1xuIiwiaW1wb3J0IFRlbXBsYXRlVGFnIGZyb20gJy4uL1RlbXBsYXRlVGFnJztcbmltcG9ydCBzdHJpcEluZGVudFRyYW5zZm9ybWVyIGZyb20gJy4uL3N0cmlwSW5kZW50VHJhbnNmb3JtZXInO1xuaW1wb3J0IGlubGluZUFycmF5VHJhbnNmb3JtZXIgZnJvbSAnLi4vaW5saW5lQXJyYXlUcmFuc2Zvcm1lcic7XG5pbXBvcnQgdHJpbVJlc3VsdFRyYW5zZm9ybWVyIGZyb20gJy4uL3RyaW1SZXN1bHRUcmFuc2Zvcm1lcic7XG5cbmNvbnN0IGNvbW1hTGlzdHNBbmQgPSBuZXcgVGVtcGxhdGVUYWcoXG4gIGlubGluZUFycmF5VHJhbnNmb3JtZXIoeyBzZXBhcmF0b3I6ICcsJywgY29uanVuY3Rpb246ICdhbmQnIH0pLFxuICBzdHJpcEluZGVudFRyYW5zZm9ybWVyLFxuICB0cmltUmVzdWx0VHJhbnNmb3JtZXIsXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBjb21tYUxpc3RzQW5kO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnJvbSAnLi9jb21tYUxpc3RzQW5kJztcbiIsImltcG9ydCBUZW1wbGF0ZVRhZyBmcm9tICcuLi9UZW1wbGF0ZVRhZyc7XG5pbXBvcnQgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lciBmcm9tICcuLi9zdHJpcEluZGVudFRyYW5zZm9ybWVyJztcbmltcG9ydCBpbmxpbmVBcnJheVRyYW5zZm9ybWVyIGZyb20gJy4uL2lubGluZUFycmF5VHJhbnNmb3JtZXInO1xuaW1wb3J0IHRyaW1SZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuXG5jb25zdCBjb21tYUxpc3RzT3IgPSBuZXcgVGVtcGxhdGVUYWcoXG4gIGlubGluZUFycmF5VHJhbnNmb3JtZXIoeyBzZXBhcmF0b3I6ICcsJywgY29uanVuY3Rpb246ICdvcicgfSksXG4gIHN0cmlwSW5kZW50VHJhbnNmb3JtZXIsXG4gIHRyaW1SZXN1bHRUcmFuc2Zvcm1lcixcbik7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbW1hTGlzdHNPcjtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vY29tbWFMaXN0c09yJztcbiIsImltcG9ydCBUZW1wbGF0ZVRhZyBmcm9tICcuLi9UZW1wbGF0ZVRhZyc7XG5pbXBvcnQgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lciBmcm9tICcuLi9zdHJpcEluZGVudFRyYW5zZm9ybWVyJztcbmltcG9ydCBpbmxpbmVBcnJheVRyYW5zZm9ybWVyIGZyb20gJy4uL2lubGluZUFycmF5VHJhbnNmb3JtZXInO1xuaW1wb3J0IHRyaW1SZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuaW1wb3J0IHNwbGl0U3RyaW5nVHJhbnNmb3JtZXIgZnJvbSAnLi4vc3BsaXRTdHJpbmdUcmFuc2Zvcm1lcic7XG5pbXBvcnQgcmVtb3ZlTm9uUHJpbnRpbmdWYWx1ZXNUcmFuc2Zvcm1lciBmcm9tICcuLi9yZW1vdmVOb25QcmludGluZ1ZhbHVlc1RyYW5zZm9ybWVyJztcblxuY29uc3QgaHRtbCA9IG5ldyBUZW1wbGF0ZVRhZyhcbiAgc3BsaXRTdHJpbmdUcmFuc2Zvcm1lcignXFxuJyksXG4gIHJlbW92ZU5vblByaW50aW5nVmFsdWVzVHJhbnNmb3JtZXIsXG4gIGlubGluZUFycmF5VHJhbnNmb3JtZXIsXG4gIHN0cmlwSW5kZW50VHJhbnNmb3JtZXIsXG4gIHRyaW1SZXN1bHRUcmFuc2Zvcm1lcixcbik7XG5cbmV4cG9ydCBkZWZhdWx0IGh0bWw7XG4iLCJleHBvcnQgZGVmYXVsdCBmcm9tICcuL2h0bWwnO1xuIiwiLy8gY29yZVxuZXhwb3J0IFRlbXBsYXRlVGFnIGZyb20gJy4vVGVtcGxhdGVUYWcnO1xuXG4vLyB0cmFuc2Zvcm1lcnNcbmV4cG9ydCB0cmltUmVzdWx0VHJhbnNmb3JtZXIgZnJvbSAnLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuZXhwb3J0IHN0cmlwSW5kZW50VHJhbnNmb3JtZXIgZnJvbSAnLi9zdHJpcEluZGVudFRyYW5zZm9ybWVyJztcbmV4cG9ydCByZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXIgZnJvbSAnLi9yZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXInO1xuZXhwb3J0IHJlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lciBmcm9tICcuL3JlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lcic7XG5leHBvcnQgcmVwbGFjZVN0cmluZ1RyYW5zZm9ybWVyIGZyb20gJy4vcmVwbGFjZVN0cmluZ1RyYW5zZm9ybWVyJztcbmV4cG9ydCBpbmxpbmVBcnJheVRyYW5zZm9ybWVyIGZyb20gJy4vaW5saW5lQXJyYXlUcmFuc2Zvcm1lcic7XG5leHBvcnQgc3BsaXRTdHJpbmdUcmFuc2Zvcm1lciBmcm9tICcuL3NwbGl0U3RyaW5nVHJhbnNmb3JtZXInO1xuZXhwb3J0IHJlbW92ZU5vblByaW50aW5nVmFsdWVzVHJhbnNmb3JtZXIgZnJvbSAnLi9yZW1vdmVOb25QcmludGluZ1ZhbHVlc1RyYW5zZm9ybWVyJztcblxuLy8gdGFnc1xuZXhwb3J0IGNvbW1hTGlzdHMgZnJvbSAnLi9jb21tYUxpc3RzJztcbmV4cG9ydCBjb21tYUxpc3RzQW5kIGZyb20gJy4vY29tbWFMaXN0c0FuZCc7XG5leHBvcnQgY29tbWFMaXN0c09yIGZyb20gJy4vY29tbWFMaXN0c09yJztcbmV4cG9ydCBodG1sIGZyb20gJy4vaHRtbCc7XG5leHBvcnQgY29kZUJsb2NrIGZyb20gJy4vY29kZUJsb2NrJztcbmV4cG9ydCBzb3VyY2UgZnJvbSAnLi9zb3VyY2UnO1xuZXhwb3J0IHNhZmVIdG1sIGZyb20gJy4vc2FmZUh0bWwnO1xuZXhwb3J0IG9uZUxpbmUgZnJvbSAnLi9vbmVMaW5lJztcbmV4cG9ydCBvbmVMaW5lVHJpbSBmcm9tICcuL29uZUxpbmVUcmltJztcbmV4cG9ydCBvbmVMaW5lQ29tbWFMaXN0cyBmcm9tICcuL29uZUxpbmVDb21tYUxpc3RzJztcbmV4cG9ydCBvbmVMaW5lQ29tbWFMaXN0c09yIGZyb20gJy4vb25lTGluZUNvbW1hTGlzdHNPcic7XG5leHBvcnQgb25lTGluZUNvbW1hTGlzdHNBbmQgZnJvbSAnLi9vbmVMaW5lQ29tbWFMaXN0c0FuZCc7XG5leHBvcnQgaW5saW5lTGlzdHMgZnJvbSAnLi9pbmxpbmVMaXN0cyc7XG5leHBvcnQgb25lTGluZUlubGluZUxpc3RzIGZyb20gJy4vb25lTGluZUlubGluZUxpc3RzJztcbmV4cG9ydCBzdHJpcEluZGVudCBmcm9tICcuL3N0cmlwSW5kZW50JztcbmV4cG9ydCBzdHJpcEluZGVudHMgZnJvbSAnLi9zdHJpcEluZGVudHMnO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnJvbSAnLi9pbmxpbmVBcnJheVRyYW5zZm9ybWVyJztcbiIsImNvbnN0IGRlZmF1bHRzID0ge1xuICBzZXBhcmF0b3I6ICcnLFxuICBjb25qdW5jdGlvbjogJycsXG4gIHNlcmlhbDogZmFsc2UsXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IHN1YnN0aXR1dGlvbiB0byBhIHN0cmluZyBjb250YWluaW5nIGEgbGlzdFxuICogQHBhcmFtICB7U3RyaW5nfSBbb3B0cy5zZXBhcmF0b3IgPSAnJ10gLSB0aGUgY2hhcmFjdGVyIHRoYXQgc2VwYXJhdGVzIGVhY2ggaXRlbVxuICogQHBhcmFtICB7U3RyaW5nfSBbb3B0cy5jb25qdW5jdGlvbiA9ICcnXSAgLSByZXBsYWNlIHRoZSBsYXN0IHNlcGFyYXRvciB3aXRoIHRoaXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRzLnNlcmlhbCA9IGZhbHNlXSAtIGluY2x1ZGUgdGhlIHNlcGFyYXRvciBiZWZvcmUgdGhlIGNvbmp1bmN0aW9uPyAoT3hmb3JkIGNvbW1hIHVzZS1jYXNlKVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAtIGEgVGVtcGxhdGVUYWcgdHJhbnNmb3JtZXJcbiAqL1xuY29uc3QgaW5saW5lQXJyYXlUcmFuc2Zvcm1lciA9IChvcHRzID0gZGVmYXVsdHMpID0+ICh7XG4gIG9uU3Vic3RpdHV0aW9uKHN1YnN0aXR1dGlvbiwgcmVzdWx0U29GYXIpIHtcbiAgICAvLyBvbmx5IG9wZXJhdGUgb24gYXJyYXlzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic3RpdHV0aW9uKSkge1xuICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBzdWJzdGl0dXRpb24ubGVuZ3RoO1xuICAgICAgY29uc3Qgc2VwYXJhdG9yID0gb3B0cy5zZXBhcmF0b3I7XG4gICAgICBjb25zdCBjb25qdW5jdGlvbiA9IG9wdHMuY29uanVuY3Rpb247XG4gICAgICBjb25zdCBzZXJpYWwgPSBvcHRzLnNlcmlhbDtcbiAgICAgIC8vIGpvaW4gZWFjaCBpdGVtIGluIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nIHdoZXJlIGVhY2ggaXRlbSBpcyBzZXBhcmF0ZWQgYnkgc2VwYXJhdG9yXG4gICAgICAvLyBiZSBzdXJlIHRvIG1haW50YWluIGluZGVudGF0aW9uXG4gICAgICBjb25zdCBpbmRlbnQgPSByZXN1bHRTb0Zhci5tYXRjaCgvKFxcbj9bXlxcU1xcbl0rKSQvKTtcbiAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgc3Vic3RpdHV0aW9uID0gc3Vic3RpdHV0aW9uLmpvaW4oc2VwYXJhdG9yICsgaW5kZW50WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnN0aXR1dGlvbiA9IHN1YnN0aXR1dGlvbi5qb2luKHNlcGFyYXRvciArICcgJyk7XG4gICAgICB9XG4gICAgICAvLyBpZiBjb25qdW5jdGlvbiBpcyBzZXQsIHJlcGxhY2UgdGhlIGxhc3Qgc2VwYXJhdG9yIHdpdGggY29uanVuY3Rpb24sIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgc3Vic3RpdHV0aW9uXG4gICAgICBpZiAoY29uanVuY3Rpb24gJiYgYXJyYXlMZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gc3Vic3RpdHV0aW9uLmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIHN1YnN0aXR1dGlvbiA9XG4gICAgICAgICAgc3Vic3RpdHV0aW9uLnNsaWNlKDAsIHNlcGFyYXRvckluZGV4KSArXG4gICAgICAgICAgKHNlcmlhbCA/IHNlcGFyYXRvciA6ICcnKSArXG4gICAgICAgICAgJyAnICtcbiAgICAgICAgICBjb25qdW5jdGlvbiArXG4gICAgICAgICAgc3Vic3RpdHV0aW9uLnNsaWNlKHNlcGFyYXRvckluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb247XG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaW5saW5lQXJyYXlUcmFuc2Zvcm1lcjtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vaW5saW5lTGlzdHMnO1xuIiwiaW1wb3J0IFRlbXBsYXRlVGFnIGZyb20gJy4uL1RlbXBsYXRlVGFnJztcbmltcG9ydCBzdHJpcEluZGVudFRyYW5zZm9ybWVyIGZyb20gJy4uL3N0cmlwSW5kZW50VHJhbnNmb3JtZXInO1xuaW1wb3J0IGlubGluZUFycmF5VHJhbnNmb3JtZXIgZnJvbSAnLi4vaW5saW5lQXJyYXlUcmFuc2Zvcm1lcic7XG5pbXBvcnQgdHJpbVJlc3VsdFRyYW5zZm9ybWVyIGZyb20gJy4uL3RyaW1SZXN1bHRUcmFuc2Zvcm1lcic7XG5cbmNvbnN0IGlubGluZUxpc3RzID0gbmV3IFRlbXBsYXRlVGFnKFxuICBpbmxpbmVBcnJheVRyYW5zZm9ybWVyLFxuICBzdHJpcEluZGVudFRyYW5zZm9ybWVyLFxuICB0cmltUmVzdWx0VHJhbnNmb3JtZXIsXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBpbmxpbmVMaXN0cztcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vb25lTGluZSc7XG4iLCJpbXBvcnQgVGVtcGxhdGVUYWcgZnJvbSAnLi4vVGVtcGxhdGVUYWcnO1xuaW1wb3J0IHRyaW1SZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuaW1wb3J0IHJlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi9yZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXInO1xuXG5jb25zdCBvbmVMaW5lID0gbmV3IFRlbXBsYXRlVGFnKFxuICByZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXIoLyg/Olxcbig/OlxccyopKSsvZywgJyAnKSxcbiAgdHJpbVJlc3VsdFRyYW5zZm9ybWVyLFxuKTtcblxuZXhwb3J0IGRlZmF1bHQgb25lTGluZTtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vb25lTGluZUNvbW1hTGlzdHMnO1xuIiwiaW1wb3J0IFRlbXBsYXRlVGFnIGZyb20gJy4uL1RlbXBsYXRlVGFnJztcbmltcG9ydCBpbmxpbmVBcnJheVRyYW5zZm9ybWVyIGZyb20gJy4uL2lubGluZUFycmF5VHJhbnNmb3JtZXInO1xuaW1wb3J0IHRyaW1SZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuaW1wb3J0IHJlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi9yZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXInO1xuXG5jb25zdCBvbmVMaW5lQ29tbWFMaXN0cyA9IG5ldyBUZW1wbGF0ZVRhZyhcbiAgaW5saW5lQXJyYXlUcmFuc2Zvcm1lcih7IHNlcGFyYXRvcjogJywnIH0pLFxuICByZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXIoLyg/OlxccyspL2csICcgJyksXG4gIHRyaW1SZXN1bHRUcmFuc2Zvcm1lcixcbik7XG5cbmV4cG9ydCBkZWZhdWx0IG9uZUxpbmVDb21tYUxpc3RzO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnJvbSAnLi9vbmVMaW5lQ29tbWFMaXN0c0FuZCc7XG4iLCJpbXBvcnQgVGVtcGxhdGVUYWcgZnJvbSAnLi4vVGVtcGxhdGVUYWcnO1xuaW1wb3J0IGlubGluZUFycmF5VHJhbnNmb3JtZXIgZnJvbSAnLi4vaW5saW5lQXJyYXlUcmFuc2Zvcm1lcic7XG5pbXBvcnQgdHJpbVJlc3VsdFRyYW5zZm9ybWVyIGZyb20gJy4uL3RyaW1SZXN1bHRUcmFuc2Zvcm1lcic7XG5pbXBvcnQgcmVwbGFjZVJlc3VsdFRyYW5zZm9ybWVyIGZyb20gJy4uL3JlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lcic7XG5cbmNvbnN0IG9uZUxpbmVDb21tYUxpc3RzQW5kID0gbmV3IFRlbXBsYXRlVGFnKFxuICBpbmxpbmVBcnJheVRyYW5zZm9ybWVyKHsgc2VwYXJhdG9yOiAnLCcsIGNvbmp1bmN0aW9uOiAnYW5kJyB9KSxcbiAgcmVwbGFjZVJlc3VsdFRyYW5zZm9ybWVyKC8oPzpcXHMrKS9nLCAnICcpLFxuICB0cmltUmVzdWx0VHJhbnNmb3JtZXIsXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBvbmVMaW5lQ29tbWFMaXN0c0FuZDtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vb25lTGluZUNvbW1hTGlzdHNPcic7XG4iLCJpbXBvcnQgVGVtcGxhdGVUYWcgZnJvbSAnLi4vVGVtcGxhdGVUYWcnO1xuaW1wb3J0IGlubGluZUFycmF5VHJhbnNmb3JtZXIgZnJvbSAnLi4vaW5saW5lQXJyYXlUcmFuc2Zvcm1lcic7XG5pbXBvcnQgdHJpbVJlc3VsdFRyYW5zZm9ybWVyIGZyb20gJy4uL3RyaW1SZXN1bHRUcmFuc2Zvcm1lcic7XG5pbXBvcnQgcmVwbGFjZVJlc3VsdFRyYW5zZm9ybWVyIGZyb20gJy4uL3JlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lcic7XG5cbmNvbnN0IG9uZUxpbmVDb21tYUxpc3RzT3IgPSBuZXcgVGVtcGxhdGVUYWcoXG4gIGlubGluZUFycmF5VHJhbnNmb3JtZXIoeyBzZXBhcmF0b3I6ICcsJywgY29uanVuY3Rpb246ICdvcicgfSksXG4gIHJlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lcigvKD86XFxzKykvZywgJyAnKSxcbiAgdHJpbVJlc3VsdFRyYW5zZm9ybWVyLFxuKTtcblxuZXhwb3J0IGRlZmF1bHQgb25lTGluZUNvbW1hTGlzdHNPcjtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vb25lTGluZUlubGluZUxpc3RzJztcbiIsImltcG9ydCBUZW1wbGF0ZVRhZyBmcm9tICcuLi9UZW1wbGF0ZVRhZyc7XG5pbXBvcnQgaW5saW5lQXJyYXlUcmFuc2Zvcm1lciBmcm9tICcuLi9pbmxpbmVBcnJheVRyYW5zZm9ybWVyJztcbmltcG9ydCB0cmltUmVzdWx0VHJhbnNmb3JtZXIgZnJvbSAnLi4vdHJpbVJlc3VsdFRyYW5zZm9ybWVyJztcbmltcG9ydCByZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXIgZnJvbSAnLi4vcmVwbGFjZVJlc3VsdFRyYW5zZm9ybWVyJztcblxuY29uc3Qgb25lTGluZUlubGluZUxpc3RzID0gbmV3IFRlbXBsYXRlVGFnKFxuICBpbmxpbmVBcnJheVRyYW5zZm9ybWVyLFxuICByZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXIoLyg/OlxccyspL2csICcgJyksXG4gIHRyaW1SZXN1bHRUcmFuc2Zvcm1lcixcbik7XG5cbmV4cG9ydCBkZWZhdWx0IG9uZUxpbmVJbmxpbmVMaXN0cztcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vb25lTGluZVRyaW0nO1xuIiwiaW1wb3J0IFRlbXBsYXRlVGFnIGZyb20gJy4uL1RlbXBsYXRlVGFnJztcbmltcG9ydCB0cmltUmVzdWx0VHJhbnNmb3JtZXIgZnJvbSAnLi4vdHJpbVJlc3VsdFRyYW5zZm9ybWVyJztcbmltcG9ydCByZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXIgZnJvbSAnLi4vcmVwbGFjZVJlc3VsdFRyYW5zZm9ybWVyJztcblxuY29uc3Qgb25lTGluZVRyaW0gPSBuZXcgVGVtcGxhdGVUYWcoXG4gIHJlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lcigvKD86XFxuXFxzKikvZywgJycpLFxuICB0cmltUmVzdWx0VHJhbnNmb3JtZXIsXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBvbmVMaW5lVHJpbTtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vcmVtb3ZlTm9uUHJpbnRpbmdWYWx1ZXNUcmFuc2Zvcm1lcic7XG4iLCJjb25zdCBpc1ZhbGlkVmFsdWUgPSB4ID0+XG4gIHggIT0gbnVsbCAmJiAhTnVtYmVyLmlzTmFOKHgpICYmIHR5cGVvZiB4ICE9PSAnYm9vbGVhbic7XG5cbmNvbnN0IHJlbW92ZU5vblByaW50aW5nVmFsdWVzVHJhbnNmb3JtZXIgPSAoKSA9PiAoe1xuICBvblN1YnN0aXR1dGlvbihzdWJzdGl0dXRpb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzdGl0dXRpb24pKSB7XG4gICAgICByZXR1cm4gc3Vic3RpdHV0aW9uLmZpbHRlcihpc1ZhbGlkVmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNWYWxpZFZhbHVlKHN1YnN0aXR1dGlvbikpIHtcbiAgICAgIHJldHVybiBzdWJzdGl0dXRpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZW1vdmVOb25QcmludGluZ1ZhbHVlc1RyYW5zZm9ybWVyO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnJvbSAnLi9yZXBsYWNlUmVzdWx0VHJhbnNmb3JtZXInO1xuIiwiLyoqXG4gKiBSZXBsYWNlcyB0YWJzLCBuZXdsaW5lcyBhbmQgc3BhY2VzIHdpdGggdGhlIGNob3NlbiB2YWx1ZSB3aGVuIHRoZXkgb2NjdXIgaW4gc2VxdWVuY2VzXG4gKiBAcGFyYW0gIHsoU3RyaW5nfFJlZ0V4cCl9IHJlcGxhY2VXaGF0IC0gdGhlIHZhbHVlIG9yIHBhdHRlcm4gdGhhdCBzaG91bGQgYmUgcmVwbGFjZWRcbiAqIEBwYXJhbSAgeyp9ICAgICAgICAgICAgICAgcmVwbGFjZVdpdGggLSB0aGUgcmVwbGFjZW1lbnQgdmFsdWVcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgLSBhIFRlbXBsYXRlVGFnIHRyYW5zZm9ybWVyXG4gKi9cbmNvbnN0IHJlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lciA9IChyZXBsYWNlV2hhdCwgcmVwbGFjZVdpdGgpID0+ICh7XG4gIG9uRW5kUmVzdWx0KGVuZFJlc3VsdCkge1xuICAgIGlmIChyZXBsYWNlV2hhdCA9PSBudWxsIHx8IHJlcGxhY2VXaXRoID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3JlcGxhY2VSZXN1bHRUcmFuc2Zvcm1lciByZXF1aXJlcyBhdCBsZWFzdCAyIGFyZ3VtZW50cy4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZFJlc3VsdC5yZXBsYWNlKHJlcGxhY2VXaGF0LCByZXBsYWNlV2l0aCk7XG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVwbGFjZVJlc3VsdFRyYW5zZm9ybWVyO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnJvbSAnLi9yZXBsYWNlU3RyaW5nVHJhbnNmb3JtZXInO1xuIiwiY29uc3QgcmVwbGFjZVN0cmluZ1RyYW5zZm9ybWVyID0gKHJlcGxhY2VXaGF0LCByZXBsYWNlV2l0aCkgPT4gKHtcbiAgb25TdHJpbmcoc3RyKSB7XG4gICAgaWYgKHJlcGxhY2VXaGF0ID09IG51bGwgfHwgcmVwbGFjZVdpdGggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAncmVwbGFjZVN0cmluZ1RyYW5zZm9ybWVyIHJlcXVpcmVzIGF0IGxlYXN0IDIgYXJndW1lbnRzLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIucmVwbGFjZShyZXBsYWNlV2hhdCwgcmVwbGFjZVdpdGgpO1xuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlcGxhY2VTdHJpbmdUcmFuc2Zvcm1lcjtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vcmVwbGFjZVN1YnN0aXR1dGlvblRyYW5zZm9ybWVyJztcbiIsImNvbnN0IHJlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lciA9IChyZXBsYWNlV2hhdCwgcmVwbGFjZVdpdGgpID0+ICh7XG4gIG9uU3Vic3RpdHV0aW9uKHN1YnN0aXR1dGlvbiwgcmVzdWx0U29GYXIpIHtcbiAgICBpZiAocmVwbGFjZVdoYXQgPT0gbnVsbCB8fCByZXBsYWNlV2l0aCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdyZXBsYWNlU3Vic3RpdHV0aW9uVHJhbnNmb3JtZXIgcmVxdWlyZXMgYXQgbGVhc3QgMiBhcmd1bWVudHMuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IHRvdWNoIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgaWYgKHN1YnN0aXR1dGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3Vic3RpdHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3Vic3RpdHV0aW9uLnRvU3RyaW5nKCkucmVwbGFjZShyZXBsYWNlV2hhdCwgcmVwbGFjZVdpdGgpO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZXBsYWNlU3Vic3RpdHV0aW9uVHJhbnNmb3JtZXI7XG4iLCJleHBvcnQgZGVmYXVsdCBmcm9tICcuL3NhZmVIdG1sJztcbiIsImltcG9ydCBUZW1wbGF0ZVRhZyBmcm9tICcuLi9UZW1wbGF0ZVRhZyc7XG5pbXBvcnQgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lciBmcm9tICcuLi9zdHJpcEluZGVudFRyYW5zZm9ybWVyJztcbmltcG9ydCBpbmxpbmVBcnJheVRyYW5zZm9ybWVyIGZyb20gJy4uL2lubGluZUFycmF5VHJhbnNmb3JtZXInO1xuaW1wb3J0IHRyaW1SZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuaW1wb3J0IHNwbGl0U3RyaW5nVHJhbnNmb3JtZXIgZnJvbSAnLi4vc3BsaXRTdHJpbmdUcmFuc2Zvcm1lcic7XG5pbXBvcnQgcmVwbGFjZVN1YnN0aXR1dGlvblRyYW5zZm9ybWVyIGZyb20gJy4uL3JlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lcic7XG5cbmNvbnN0IHNhZmVIdG1sID0gbmV3IFRlbXBsYXRlVGFnKFxuICBzcGxpdFN0cmluZ1RyYW5zZm9ybWVyKCdcXG4nKSxcbiAgaW5saW5lQXJyYXlUcmFuc2Zvcm1lcixcbiAgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lcixcbiAgdHJpbVJlc3VsdFRyYW5zZm9ybWVyLFxuICByZXBsYWNlU3Vic3RpdHV0aW9uVHJhbnNmb3JtZXIoLyYvZywgJyZhbXA7JyksXG4gIHJlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lcigvPC9nLCAnJmx0OycpLFxuICByZXBsYWNlU3Vic3RpdHV0aW9uVHJhbnNmb3JtZXIoLz4vZywgJyZndDsnKSxcbiAgcmVwbGFjZVN1YnN0aXR1dGlvblRyYW5zZm9ybWVyKC9cIi9nLCAnJnF1b3Q7JyksXG4gIHJlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lcigvJy9nLCAnJiN4Mjc7JyksXG4gIHJlcGxhY2VTdWJzdGl0dXRpb25UcmFuc2Zvcm1lcigvYC9nLCAnJiN4NjA7JyksXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBzYWZlSHRtbDtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4uL2h0bWwnO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnJvbSAnLi9zcGxpdFN0cmluZ1RyYW5zZm9ybWVyJztcbiIsImNvbnN0IHNwbGl0U3RyaW5nVHJhbnNmb3JtZXIgPSBzcGxpdEJ5ID0+ICh7XG4gIG9uU3Vic3RpdHV0aW9uKHN1YnN0aXR1dGlvbiwgcmVzdWx0U29GYXIpIHtcbiAgICBpZiAoc3BsaXRCeSAhPSBudWxsICYmIHR5cGVvZiBzcGxpdEJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBzdWJzdGl0dXRpb24gPT09ICdzdHJpbmcnICYmIHN1YnN0aXR1dGlvbi5pbmNsdWRlcyhzcGxpdEJ5KSkge1xuICAgICAgICBzdWJzdGl0dXRpb24gPSBzdWJzdGl0dXRpb24uc3BsaXQoc3BsaXRCeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gc3BlY2lmeSBhIHN0cmluZyBjaGFyYWN0ZXIgdG8gc3BsaXQgYnkuJyk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb247XG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3BsaXRTdHJpbmdUcmFuc2Zvcm1lcjtcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vc3RyaXBJbmRlbnQnO1xuIiwiaW1wb3J0IFRlbXBsYXRlVGFnIGZyb20gJy4uL1RlbXBsYXRlVGFnJztcbmltcG9ydCBzdHJpcEluZGVudFRyYW5zZm9ybWVyIGZyb20gJy4uL3N0cmlwSW5kZW50VHJhbnNmb3JtZXInO1xuaW1wb3J0IHRyaW1SZXN1bHRUcmFuc2Zvcm1lciBmcm9tICcuLi90cmltUmVzdWx0VHJhbnNmb3JtZXInO1xuXG5jb25zdCBzdHJpcEluZGVudCA9IG5ldyBUZW1wbGF0ZVRhZyhcbiAgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lcixcbiAgdHJpbVJlc3VsdFRyYW5zZm9ybWVyLFxuKTtcblxuZXhwb3J0IGRlZmF1bHQgc3RyaXBJbmRlbnQ7XG4iLCJleHBvcnQgZGVmYXVsdCBmcm9tICcuL3N0cmlwSW5kZW50VHJhbnNmb3JtZXInO1xuIiwiLyoqXG4gKiBzdHJpcHMgaW5kZW50YXRpb24gZnJvbSBhIHRlbXBsYXRlIGxpdGVyYWxcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSA9ICdpbml0aWFsJyAtIHdoZXRoZXIgdG8gcmVtb3ZlIGFsbCBpbmRlbnRhdGlvbiBvciBqdXN0IGxlYWRpbmcgaW5kZW50YXRpb24uIGNhbiBiZSAnYWxsJyBvciAnaW5pdGlhbCdcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAtIGEgVGVtcGxhdGVUYWcgdHJhbnNmb3JtZXJcbiAqL1xuY29uc3Qgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lciA9ICh0eXBlID0gJ2luaXRpYWwnKSA9PiAoe1xuICBvbkVuZFJlc3VsdChlbmRSZXN1bHQpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIHNob3J0ZXN0IGxlYWRpbmcgaW5kZW50YXRpb24gZnJvbSBlYWNoIGxpbmVcbiAgICAgIGNvbnN0IG1hdGNoID0gZW5kUmVzdWx0Lm1hdGNoKC9eW15cXFNcXG5dKig/PVxcUykvZ20pO1xuICAgICAgY29uc3QgaW5kZW50ID0gbWF0Y2ggJiYgTWF0aC5taW4oLi4ubWF0Y2gubWFwKGVsID0+IGVsLmxlbmd0aCkpO1xuICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKGBeLnske2luZGVudH19YCwgJ2dtJyk7XG4gICAgICAgIHJldHVybiBlbmRSZXN1bHQucmVwbGFjZShyZWdleHAsICcnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmRSZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYWxsJykge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBpbmRlbnRhdGlvbiBmcm9tIGVhY2ggbGluZVxuICAgICAgcmV0dXJuIGVuZFJlc3VsdC5yZXBsYWNlKC9eW15cXFNcXG5dKy9nbSwgJycpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZTogJHt0eXBlfWApO1xuICB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmlwSW5kZW50VHJhbnNmb3JtZXI7XG4iLCJleHBvcnQgZGVmYXVsdCBmcm9tICcuL3N0cmlwSW5kZW50cyc7XG4iLCJpbXBvcnQgVGVtcGxhdGVUYWcgZnJvbSAnLi4vVGVtcGxhdGVUYWcnO1xuaW1wb3J0IHN0cmlwSW5kZW50VHJhbnNmb3JtZXIgZnJvbSAnLi4vc3RyaXBJbmRlbnRUcmFuc2Zvcm1lcic7XG5pbXBvcnQgdHJpbVJlc3VsdFRyYW5zZm9ybWVyIGZyb20gJy4uL3RyaW1SZXN1bHRUcmFuc2Zvcm1lcic7XG5cbmNvbnN0IHN0cmlwSW5kZW50cyA9IG5ldyBUZW1wbGF0ZVRhZyhcbiAgc3RyaXBJbmRlbnRUcmFuc2Zvcm1lcignYWxsJyksXG4gIHRyaW1SZXN1bHRUcmFuc2Zvcm1lcixcbik7XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmlwSW5kZW50cztcbiIsImV4cG9ydCBkZWZhdWx0IGZyb20gJy4vdHJpbVJlc3VsdFRyYW5zZm9ybWVyJztcbiIsIi8qKlxuICogVGVtcGxhdGVUYWcgdHJhbnNmb3JtZXIgdGhhdCB0cmltcyB3aGl0ZXNwYWNlIG9uIHRoZSBlbmQgcmVzdWx0IG9mIGEgdGFnZ2VkIHRlbXBsYXRlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNpZGUgPSAnJyAtIFRoZSBzaWRlIG9mIHRoZSBzdHJpbmcgdG8gdHJpbS4gQ2FuIGJlICdzdGFydCcgb3IgJ2VuZCcgKGFsdGVybmF0aXZlbHkgJ2xlZnQnIG9yICdyaWdodCcpXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAtIGEgVGVtcGxhdGVUYWcgdHJhbnNmb3JtZXJcbiAqL1xuY29uc3QgdHJpbVJlc3VsdFRyYW5zZm9ybWVyID0gKHNpZGUgPSAnJykgPT4gKHtcbiAgb25FbmRSZXN1bHQoZW5kUmVzdWx0KSB7XG4gICAgaWYgKHNpZGUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gZW5kUmVzdWx0LnRyaW0oKTtcbiAgICB9XG5cbiAgICBzaWRlID0gc2lkZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHNpZGUgPT09ICdzdGFydCcgfHwgc2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICByZXR1cm4gZW5kUmVzdWx0LnJlcGxhY2UoL15cXHMqLywgJycpO1xuICAgIH1cblxuICAgIGlmIChzaWRlID09PSAnZW5kJyB8fCBzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4gZW5kUmVzdWx0LnJlcGxhY2UoL1xccyokLywgJycpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgU2lkZSBub3Qgc3VwcG9ydGVkOiAke3NpZGV9YCk7XG4gIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdHJpbVJlc3VsdFRyYW5zZm9ybWVyO1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLy8gQ29uc29sZS1wb2x5ZmlsbC4gTUlUIGxpY2Vuc2UuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL2NvbnNvbGUtcG9seWZpbGxcbi8vIE1ha2UgaXQgc2FmZSB0byBkbyBjb25zb2xlLmxvZygpIGFsd2F5cy5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAoIWdsb2JhbC5jb25zb2xlKSB7XG4gICAgZ2xvYmFsLmNvbnNvbGUgPSB7fTtcbiAgfVxuICB2YXIgY29uID0gZ2xvYmFsLmNvbnNvbGU7XG4gIHZhciBwcm9wLCBtZXRob2Q7XG4gIHZhciBkdW1teSA9IGZ1bmN0aW9uKCkge307XG4gIHZhciBwcm9wZXJ0aWVzID0gWydtZW1vcnknXTtcbiAgdmFyIG1ldGhvZHMgPSAoJ2Fzc2VydCxjbGVhcixjb3VudCxkZWJ1ZyxkaXIsZGlyeG1sLGVycm9yLGV4Y2VwdGlvbixncm91cCwnICtcbiAgICAgJ2dyb3VwQ29sbGFwc2VkLGdyb3VwRW5kLGluZm8sbG9nLG1hcmtUaW1lbGluZSxwcm9maWxlLHByb2ZpbGVzLHByb2ZpbGVFbmQsJyArXG4gICAgICdzaG93LHRhYmxlLHRpbWUsdGltZUVuZCx0aW1lbGluZSx0aW1lbGluZUVuZCx0aW1lU3RhbXAsdHJhY2Usd2FybicpLnNwbGl0KCcsJyk7XG4gIHdoaWxlIChwcm9wID0gcHJvcGVydGllcy5wb3AoKSkgaWYgKCFjb25bcHJvcF0pIGNvbltwcm9wXSA9IHt9O1xuICB3aGlsZSAobWV0aG9kID0gbWV0aG9kcy5wb3AoKSkgaWYgKCFjb25bbWV0aG9kXSkgY29uW21ldGhvZF0gPSBkdW1teTtcbiAgLy8gVXNpbmcgYHRoaXNgIGZvciB3ZWIgd29ya2VycyAmIHN1cHBvcnRzIEJyb3dzZXJpZnkgLyBXZWJwYWNrLlxufSkodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzIDogd2luZG93KTtcbiIsIi8qIVxuICogY29va2llXG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IFJvbWFuIFNodHlsbWFuXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG52YXIgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xudmFyIHBhaXJTcGxpdFJlZ0V4cCA9IC87ICovO1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBmaWVsZC1jb250ZW50IGluIFJGQyA3MjMwIHNlYyAzLjJcbiAqXG4gKiBmaWVsZC1jb250ZW50ID0gZmllbGQtdmNoYXIgWyAxKiggU1AgLyBIVEFCICkgZmllbGQtdmNoYXIgXVxuICogZmllbGQtdmNoYXIgICA9IFZDSEFSIC8gb2JzLXRleHRcbiAqIG9icy10ZXh0ICAgICAgPSAleDgwLUZGXG4gKi9cblxudmFyIGZpZWxkQ29udGVudFJlZ0V4cCA9IC9eW1xcdTAwMDlcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdKyQvO1xuXG4vKipcbiAqIFBhcnNlIGEgY29va2llIGhlYWRlci5cbiAqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gY29va2llIGhlYWRlciBzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqIFRoZSBvYmplY3QgaGFzIHRoZSB2YXJpb3VzIGNvb2tpZXMgYXMga2V5cyhuYW1lcykgPT4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7b2JqZWN0fVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHIgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgdmFyIG9iaiA9IHt9XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQocGFpclNwbGl0UmVnRXhwKTtcbiAgdmFyIGRlYyA9IG9wdC5kZWNvZGUgfHwgZGVjb2RlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgIHZhciBlcV9pZHggPSBwYWlyLmluZGV4T2YoJz0nKTtcblxuICAgIC8vIHNraXAgdGhpbmdzIHRoYXQgZG9uJ3QgbG9vayBsaWtlIGtleT12YWx1ZVxuICAgIGlmIChlcV9pZHggPCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gcGFpci5zdWJzdHIoMCwgZXFfaWR4KS50cmltKClcbiAgICB2YXIgdmFsID0gcGFpci5zdWJzdHIoKytlcV9pZHgsIHBhaXIubGVuZ3RoKS50cmltKCk7XG5cbiAgICAvLyBxdW90ZWQgdmFsdWVzXG4gICAgaWYgKCdcIicgPT0gdmFsWzBdKSB7XG4gICAgICB2YWwgPSB2YWwuc2xpY2UoMSwgLTEpO1xuICAgIH1cblxuICAgIC8vIG9ubHkgYXNzaWduIG9uY2VcbiAgICBpZiAodW5kZWZpbmVkID09IG9ialtrZXldKSB7XG4gICAgICBvYmpba2V5XSA9IHRyeURlY29kZSh2YWwsIGRlYyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgZGF0YSBpbnRvIGEgY29va2llIGhlYWRlci5cbiAqXG4gKiBTZXJpYWxpemUgdGhlIGEgbmFtZSB2YWx1ZSBwYWlyIGludG8gYSBjb29raWUgc3RyaW5nIHN1aXRhYmxlIGZvclxuICogaHR0cCBoZWFkZXJzLiBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCBzcGVjaWZpZWQgY29va2llIHBhcmFtZXRlcnMuXG4gKlxuICogc2VyaWFsaXplKCdmb28nLCAnYmFyJywgeyBodHRwT25seTogdHJ1ZSB9KVxuICogICA9PiBcImZvbz1iYXI7IGh0dHBPbmx5XCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShuYW1lLCB2YWwsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG4gIHZhciBlbmMgPSBvcHQuZW5jb2RlIHx8IGVuY29kZTtcblxuICBpZiAodHlwZW9mIGVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBlbmNvZGUgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG5hbWUgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gZW5jKHZhbCk7XG5cbiAgaWYgKHZhbHVlICYmICFmaWVsZENvbnRlbnRSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCB2YWwgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHN0ciA9IG5hbWUgKyAnPScgKyB2YWx1ZTtcblxuICBpZiAobnVsbCAhPSBvcHQubWF4QWdlKSB7XG4gICAgdmFyIG1heEFnZSA9IG9wdC5tYXhBZ2UgLSAwO1xuICAgIGlmIChpc05hTihtYXhBZ2UpKSB0aHJvdyBuZXcgRXJyb3IoJ21heEFnZSBzaG91bGQgYmUgYSBOdW1iZXInKTtcbiAgICBzdHIgKz0gJzsgTWF4LUFnZT0nICsgTWF0aC5mbG9vcihtYXhBZ2UpO1xuICB9XG5cbiAgaWYgKG9wdC5kb21haW4pIHtcbiAgICBpZiAoIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KG9wdC5kb21haW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gZG9tYWluIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgRG9tYWluPScgKyBvcHQuZG9tYWluO1xuICB9XG5cbiAgaWYgKG9wdC5wYXRoKSB7XG4gICAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChvcHQucGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBwYXRoIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgUGF0aD0nICsgb3B0LnBhdGg7XG4gIH1cblxuICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICBpZiAodHlwZW9mIG9wdC5leHBpcmVzLnRvVVRDU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gZXhwaXJlcyBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgc3RyICs9ICc7IEV4cGlyZXM9JyArIG9wdC5leHBpcmVzLnRvVVRDU3RyaW5nKCk7XG4gIH1cblxuICBpZiAob3B0Lmh0dHBPbmx5KSB7XG4gICAgc3RyICs9ICc7IEh0dHBPbmx5JztcbiAgfVxuXG4gIGlmIChvcHQuc2VjdXJlKSB7XG4gICAgc3RyICs9ICc7IFNlY3VyZSc7XG4gIH1cblxuICBpZiAob3B0LnNhbWVTaXRlKSB7XG4gICAgdmFyIHNhbWVTaXRlID0gdHlwZW9mIG9wdC5zYW1lU2l0ZSA9PT0gJ3N0cmluZydcbiAgICAgID8gb3B0LnNhbWVTaXRlLnRvTG93ZXJDYXNlKCkgOiBvcHQuc2FtZVNpdGU7XG5cbiAgICBzd2l0Y2ggKHNhbWVTaXRlKSB7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1TdHJpY3QnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xheCc6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1MYXgnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmljdCc6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1TdHJpY3QnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBzYW1lU2l0ZSBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBUcnkgZGVjb2RpbmcgYSBzdHJpbmcgdXNpbmcgYSBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZWNvZGVcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHJ5RGVjb2RlKHN0ciwgZGVjb2RlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZShzdHIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIiwiLyoqXG4gKiBjdWlkLmpzXG4gKiBDb2xsaXNpb24tcmVzaXN0YW50IFVJRCBnZW5lcmF0b3IgZm9yIGJyb3dzZXJzIGFuZCBub2RlLlxuICogU2VxdWVudGlhbCBmb3IgZmFzdCBkYiBsb29rdXBzIGFuZCByZWNlbmN5IHNvcnRpbmcuXG4gKiBTYWZlIGZvciBlbGVtZW50IElEcyBhbmQgc2VydmVyLXNpZGUgbG9va3Vwcy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSBDTENUUlxuICpcbiAqIENvcHlyaWdodCAoYykgRXJpYyBFbGxpb3R0IDIwMTJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxudmFyIGZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9saWIvZmluZ2VycHJpbnQuanMnKTtcbnZhciBwYWQgPSByZXF1aXJlKCcuL2xpYi9wYWQuanMnKTtcblxudmFyIGMgPSAwLFxuICBibG9ja1NpemUgPSA0LFxuICBiYXNlID0gMzYsXG4gIGRpc2NyZXRlVmFsdWVzID0gTWF0aC5wb3coYmFzZSwgYmxvY2tTaXplKTtcblxuZnVuY3Rpb24gcmFuZG9tQmxvY2sgKCkge1xuICByZXR1cm4gcGFkKChNYXRoLnJhbmRvbSgpICpcbiAgICBkaXNjcmV0ZVZhbHVlcyA8PCAwKVxuICAgIC50b1N0cmluZyhiYXNlKSwgYmxvY2tTaXplKTtcbn1cblxuZnVuY3Rpb24gc2FmZUNvdW50ZXIgKCkge1xuICBjID0gYyA8IGRpc2NyZXRlVmFsdWVzID8gYyA6IDA7XG4gIGMrKzsgLy8gdGhpcyBpcyBub3Qgc3VibGltaW5hbFxuICByZXR1cm4gYyAtIDE7XG59XG5cbmZ1bmN0aW9uIGN1aWQgKCkge1xuICAvLyBTdGFydGluZyB3aXRoIGEgbG93ZXJjYXNlIGxldHRlciBtYWtlc1xuICAvLyBpdCBIVE1MIGVsZW1lbnQgSUQgZnJpZW5kbHkuXG4gIHZhciBsZXR0ZXIgPSAnYycsIC8vIGhhcmQtY29kZWQgYWxsb3dzIGZvciBzZXF1ZW50aWFsIGFjY2Vzc1xuXG4gICAgLy8gdGltZXN0YW1wXG4gICAgLy8gd2FybmluZzogdGhpcyBleHBvc2VzIHRoZSBleGFjdCBkYXRlIGFuZCB0aW1lXG4gICAgLy8gdGhhdCB0aGUgdWlkIHdhcyBjcmVhdGVkLlxuICAgIHRpbWVzdGFtcCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkudG9TdHJpbmcoYmFzZSksXG5cbiAgICAvLyBQcmV2ZW50IHNhbWUtbWFjaGluZSBjb2xsaXNpb25zLlxuICAgIGNvdW50ZXIgPSBwYWQoc2FmZUNvdW50ZXIoKS50b1N0cmluZyhiYXNlKSwgYmxvY2tTaXplKSxcblxuICAgIC8vIEEgZmV3IGNoYXJzIHRvIGdlbmVyYXRlIGRpc3RpbmN0IGlkcyBmb3IgZGlmZmVyZW50XG4gICAgLy8gY2xpZW50cyAoc28gZGlmZmVyZW50IGNvbXB1dGVycyBhcmUgZmFyIGxlc3NcbiAgICAvLyBsaWtlbHkgdG8gZ2VuZXJhdGUgdGhlIHNhbWUgaWQpXG4gICAgcHJpbnQgPSBmaW5nZXJwcmludCgpLFxuXG4gICAgLy8gR3JhYiBzb21lIG1vcmUgY2hhcnMgZnJvbSBNYXRoLnJhbmRvbSgpXG4gICAgcmFuZG9tID0gcmFuZG9tQmxvY2soKSArIHJhbmRvbUJsb2NrKCk7XG5cbiAgcmV0dXJuIGxldHRlciArIHRpbWVzdGFtcCArIGNvdW50ZXIgKyBwcmludCArIHJhbmRvbTtcbn1cblxuY3VpZC5zbHVnID0gZnVuY3Rpb24gc2x1ZyAoKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoMzYpLFxuICAgIGNvdW50ZXIgPSBzYWZlQ291bnRlcigpLnRvU3RyaW5nKDM2KS5zbGljZSgtNCksXG4gICAgcHJpbnQgPSBmaW5nZXJwcmludCgpLnNsaWNlKDAsIDEpICtcbiAgICAgIGZpbmdlcnByaW50KCkuc2xpY2UoLTEpLFxuICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkuc2xpY2UoLTIpO1xuXG4gIHJldHVybiBkYXRlLnNsaWNlKC0yKSArXG4gICAgY291bnRlciArIHByaW50ICsgcmFuZG9tO1xufTtcblxuY3VpZC5pc0N1aWQgPSBmdW5jdGlvbiBpc0N1aWQgKHN0cmluZ1RvQ2hlY2spIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUb0NoZWNrICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICBpZiAoc3RyaW5nVG9DaGVjay5zdGFydHNXaXRoKCdjJykpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jdWlkLmlzU2x1ZyA9IGZ1bmN0aW9uIGlzU2x1ZyAoc3RyaW5nVG9DaGVjaykge1xuICBpZiAodHlwZW9mIHN0cmluZ1RvQ2hlY2sgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBzdHJpbmdUb0NoZWNrLmxlbmd0aDtcbiAgaWYgKHN0cmluZ0xlbmd0aCA+PSA3ICYmIHN0cmluZ0xlbmd0aCA8PSAxMCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmN1aWQuZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcblxubW9kdWxlLmV4cG9ydHMgPSBjdWlkO1xuIiwidmFyIHBhZCA9IHJlcXVpcmUoJy4vcGFkLmpzJyk7XG5cbnZhciBlbnYgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHNlbGY7XG52YXIgZ2xvYmFsQ291bnQgPSBPYmplY3Qua2V5cyhlbnYpLmxlbmd0aDtcbnZhciBtaW1lVHlwZXNMZW5ndGggPSBuYXZpZ2F0b3IubWltZVR5cGVzID8gbmF2aWdhdG9yLm1pbWVUeXBlcy5sZW5ndGggOiAwO1xudmFyIGNsaWVudElkID0gcGFkKChtaW1lVHlwZXNMZW5ndGggK1xuICBuYXZpZ2F0b3IudXNlckFnZW50Lmxlbmd0aCkudG9TdHJpbmcoMzYpICtcbiAgZ2xvYmFsQ291bnQudG9TdHJpbmcoMzYpLCA0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5nZXJwcmludCAoKSB7XG4gIHJldHVybiBjbGllbnRJZDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhZCAobnVtLCBzaXplKSB7XG4gIHZhciBzID0gJzAwMDAwMDAwMCcgKyBudW07XG4gIHJldHVybiBzLnN1YnN0cihzLmxlbmd0aCAtIHNpemUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJ2ZvbycpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIG9yaWdEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgb2JqID0ge307XG5cdHRyeSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0XHRmb3IgKHZhciBfIGluIG9iaikgeyAvLyBqc2NzOmlnbm9yZSBkaXNhbGxvd1VudXNlZFZhcmlhYmxlc1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqLnggPT09IG9iajtcblx0fSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIElFIDguICovXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBvcmlnRGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCAmJiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BzW2ldLCBtYXBbcHJvcHNbaV1dLCBwcmVkaWNhdGVzW3Byb3BzW2ldXSk7XG5cdH1cbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuIiwiLyohXG4gKiBlZS1maXJzdFxuICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpcnN0XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBldmVudCBpbiBhIHNldCBvZiBldmVudCBlbWl0dGVycyBhbmQgZXZlbnQgcGFpcnMuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3R1ZmZcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmVcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmaXJzdChzdHVmZiwgZG9uZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc3R1ZmYpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZyBtdXN0IGJlIGFuIGFycmF5IG9mIFtlZSwgZXZlbnRzLi4uXSBhcnJheXMnKVxuXG4gIHZhciBjbGVhbnVwcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHVmZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhcnIgPSBzdHVmZltpXVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikgfHwgYXJyLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlYWNoIGFycmF5IG1lbWJlciBtdXN0IGJlIFtlZSwgZXZlbnRzLi4uXScpXG5cbiAgICB2YXIgZWUgPSBhcnJbMF1cblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZXZlbnQgPSBhcnJbal1cbiAgICAgIHZhciBmbiA9IGxpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaylcblxuICAgICAgLy8gbGlzdGVuIHRvIHRoZSBldmVudFxuICAgICAgZWUub24oZXZlbnQsIGZuKVxuICAgICAgLy8gcHVzaCB0aGlzIGxpc3RlbmVyIHRvIHRoZSBsaXN0IG9mIGNsZWFudXBzXG4gICAgICBjbGVhbnVwcy5wdXNoKHtcbiAgICAgICAgZWU6IGVlLFxuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGZuOiBmbixcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgY2xlYW51cCgpXG4gICAgZG9uZS5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciB4XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVhbnVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IGNsZWFudXBzW2ldXG4gICAgICB4LmVlLnJlbW92ZUxpc3RlbmVyKHguZXZlbnQsIHguZm4pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGh1bmsoZm4pIHtcbiAgICBkb25lID0gZm5cbiAgfVxuXG4gIHRodW5rLmNhbmNlbCA9IGNsZWFudXBcblxuICByZXR1cm4gdGh1bmtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsaXN0ZW5lcihldmVudCwgZG9uZSkge1xuICByZXR1cm4gZnVuY3Rpb24gb25ldmVudChhcmcxKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICB2YXIgZWUgPSB0aGlzXG4gICAgdmFyIGVyciA9IGV2ZW50ID09PSAnZXJyb3InXG4gICAgICA/IGFyZzFcbiAgICAgIDogbnVsbFxuXG4gICAgLy8gY29weSBhcmdzIHRvIHByZXZlbnQgYXJndW1lbnRzIGVzY2FwaW5nIHNjb3BlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuXG4gICAgZG9uZShlcnIsIGVlLCBldmVudCwgYXJncylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcblxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcblx0aWYgKHR5cGVvZiBPID09PSAndW5kZWZpbmVkJyB8fCBPID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyBPKTtcblx0fVxuXHRpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IChoaW50ICE9PSAnbnVtYmVyJyAmJiBoaW50ICE9PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG5cdH1cblx0dmFyIG1ldGhvZE5hbWVzID0gaGludCA9PT0gJ3N0cmluZycgPyBbJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXSA6IFsndmFsdWVPZicsICd0b1N0cmluZyddO1xuXHR2YXIgbWV0aG9kLCByZXN1bHQsIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuXHRcdG1ldGhvZCA9IE9bbWV0aG9kTmFtZXNbaV1dO1xuXHRcdGlmIChpc0NhbGxhYmxlKG1ldGhvZCkpIHtcblx0XHRcdHJlc3VsdCA9IG1ldGhvZC5jYWxsKE8pO1xuXHRcdFx0aWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xufTtcblxudmFyIEdldE1ldGhvZCA9IGZ1bmN0aW9uIEdldE1ldGhvZChPLCBQKSB7XG5cdHZhciBmdW5jID0gT1tQXTtcblx0aWYgKGZ1bmMgIT09IG51bGwgJiYgdHlwZW9mIGZ1bmMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0aWYgKCFpc0NhbGxhYmxlKGZ1bmMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bmMgKyAnIHJldHVybmVkIGZvciBwcm9wZXJ0eSAnICsgUCArICcgb2Ygb2JqZWN0ICcgKyBPICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuYztcblx0fVxuXHRyZXR1cm4gdm9pZCAwO1xufTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG5cdGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblx0dmFyIGhpbnQgPSAnZGVmYXVsdCc7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdGlmIChhcmd1bWVudHNbMV0gPT09IFN0cmluZykge1xuXHRcdFx0aGludCA9ICdzdHJpbmcnO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzWzFdID09PSBOdW1iZXIpIHtcblx0XHRcdGhpbnQgPSAnbnVtYmVyJztcblx0XHR9XG5cdH1cblxuXHR2YXIgZXhvdGljVG9QcmltO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdGlmIChTeW1ib2wudG9QcmltaXRpdmUpIHtcblx0XHRcdGV4b3RpY1RvUHJpbSA9IEdldE1ldGhvZChpbnB1dCwgU3ltYm9sLnRvUHJpbWl0aXZlKTtcblx0XHR9IGVsc2UgaWYgKGlzU3ltYm9sKGlucHV0KSkge1xuXHRcdFx0ZXhvdGljVG9QcmltID0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mO1xuXHRcdH1cblx0fVxuXHRpZiAodHlwZW9mIGV4b3RpY1RvUHJpbSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xuXHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmFibGUgdG8gY29udmVydCBleG90aWMgb2JqZWN0IHRvIHByaW1pdGl2ZScpO1xuXHR9XG5cdGlmIChoaW50ID09PSAnZGVmYXVsdCcgJiYgKGlzRGF0ZShpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSkge1xuXHRcdGhpbnQgPSAnc3RyaW5nJztcblx0fVxuXHRyZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgaGludCA9PT0gJ2RlZmF1bHQnID8gJ251bWJlcicgOiBoaW50KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9lczIwMTUnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcblxudmFyIGFyciA9IFtdXG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlcikge1xuICBkZWNpcmMob2JqLCAnJywgW10sIHVuZGVmaW5lZClcbiAgdmFyIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcilcbiAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZnVuY3Rpb24gZGVjaXJjICh2YWwsIGssIHN0YWNrLCBwYXJlbnQpIHtcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgcGFyZW50W2tdID0gJ1tDaXJjdWxhcl0nXG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIHN0YWNrLCB2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIHN0YWNrLCB2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cbn1cblxuLy8gU3RhYmxlLXN0cmluZ2lmeVxuZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChhID4gYikge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSAob2JqLCByZXBsYWNlciwgc3BhY2VyKSB7XG4gIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgJycsIFtdLCB1bmRlZmluZWQpIHx8IG9ialxuICB2YXIgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmMgKHZhbCwgaywgc3RhY2ssIHBhcmVudCkge1xuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBwYXJlbnRba10gPSAnW0NpcmN1bGFyXSdcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIHN0YWNrLCB2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgdmFyIHRtcCA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIHN0YWNrLCB2YWwpXG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICAgICAgICBwYXJlbnRba10gPSB0bXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXBcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuIiwiLyoqXG4gKiBAZmlsZSBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZmluZC1pbmRleC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcEZpbmRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXg7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zcGFyc2UtYXJyYXlzXG52YXIgaW1wbGVtZW50ZWQgPSBwRmluZEluZGV4ICYmIChbLCAxXS5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xuICByZXR1cm4gaWR4ID09PSAwO1xufSkgPT09IDApO1xuXG52YXIgZmluZElkeDtcbmlmIChpbXBsZW1lbnRlZCkge1xuICBmaW5kSWR4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gW2NhbGxiYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBGaW5kSW5kZXguYXBwbHkoYXJyYXksIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbiAgdmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG4gIHZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcbiAgdmFyIHNwbGl0U3RyaW5nID0gcmVxdWlyZSgnaGFzLWJveGVkLXN0cmluZy14JykgPT09IGZhbHNlO1xuXG4gIGZpbmRJZHggPSBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxiYWNrKTtcbiAgICB2YXIgaXRlcmFibGUgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyhvYmplY3QpID8gb2JqZWN0LnNwbGl0KCcnKSA6IG9iamVjdDtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciB0aGlzQXJnO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xufVxuXG4vKipcbiAqIExpa2UgYGZpbmRJbmRleGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYW4gaW5kZXggaW4gdGhlIGFycmF5LCBpZiBhbiBlbGVtZW50XG4gKiBpbiB0aGUgYXJyYXkgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLiBPdGhlcndpc2UgLTEgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcnJheSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXksXG4gKiAgdGFraW5nIHRocmVlIGFyZ3VtZW50czogYGVsZW1lbnRgLCBgaW5kZXhgIGFuZCBgYXJyYXlgLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgY2FsbGJhY2tgIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBpbmRleCBvZiBwb3NpdGl2ZWx5IHRlc3RlZCBlbGVtZW50LCBvdGhlcndpc2UgLTEuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJ2ZpbmQtaW5kZXgteCcpO1xuICpcbiAqIGZ1bmN0aW9uIGlzUHJpbWUoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gKiAgIHZhciBzdGFydCA9IDI7XG4gKiAgIHdoaWxlIChzdGFydCA8PSBNYXRoLnNxcnQoZWxlbWVudCkpIHtcbiAqICAgICBpZiAoZWxlbWVudCAlIHN0YXJ0KysgPCAxKSB7XG4gKiAgICAgICByZXR1cm4gZmFsc2U7XG4gKiAgICAgfVxuICogICB9XG4gKiAgIHJldHVybiBlbGVtZW50ID4gMTtcbiAqIH1cbiAqXG4gKiBjb25zb2xlLmxvZyhmaW5kSW5kZXgoWzQsIDYsIDgsIDEyLCAxNF0sIGlzUHJpbWUpKTsgLy8gLTEsIG5vdCBmb3VuZFxuICogY29uc29sZS5sb2coZmluZEluZGV4KFs0LCA2LCA3LCAxMiwgMTNdLCBpc1ByaW1lKSk7IC8vIDJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmaW5kSWR4O1xuIiwiXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAob2JqLCBmbiwgY3R4KSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgbCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGwgPT09ICtsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiIsIi8vIHRoZXNlIGFyZSBrbm93biBhcyBcInBsYWNlaG9sZGVyIHRva2Vuc1wiLCBzZWUgdGhpcyBsaW5rIGZvciBtb3JlIGluZm86XG4vLyA8aHR0cHM6Ly9ub2RlanMub3JnL2FwaS91dGlsLmh0bWwjdXRpbF91dGlsX2Zvcm1hdF9mb3JtYXRfYXJncz5cbi8vXG4vLyBzaW5jZSB0aGV5IGFyZW4ndCBleHBvc2VkIChvciBkb24ndCBzZWVtIHRvIGJlKSBieSBub2RlIChhdCBsZWFzdCBub3QgeWV0KVxuLy8gd2UganVzdCBkZWZpbmUgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGVtIGZvciBub3dcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzE3NjAxPlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzdhZjFhZDBlYzE1NTQ2NzYxMjMzYzJlOTAwMDgzMTY1NTFkYjJiYmQvZG9jL2FwaS91dGlsLm1kI3V0aWxmb3JtYXRmb3JtYXQtYXJncz5cbm1vZHVsZS5leHBvcnRzID0gWyclcycsICclZCcsICclaScsICclZicsICclaicsICclbycsICclTycsICclJSddO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIvKipcbiAqIEBmaWxlIEdldCB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LWZ1bmN0aW9uLW5hbWUteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbi14Jyk7XG52YXIgZnVuY3Rpb25DdHIgPSBmdW5jdGlvbiAoKSB7fS5jb25zdHJ1Y3RvcjtcblxudmFyIGdldE5hbWU7XG52YXIgdCA9IGZ1bmN0aW9uIHRlc3QxKCkge307XG5pZiAodC5uYW1lID09PSAndGVzdDEnKSB7XG4gIHZhciBjcmVhdGVzQW5vbnltb3VzID0gZnVuY3Rpb25DdHIoKS5uYW1lID09PSAnYW5vbnltb3VzJztcbiAgZ2V0TmFtZSA9IGZ1bmN0aW9uIF9nZXROYW1lKGZuKSB7XG4gICAgcmV0dXJuIGNyZWF0ZXNBbm9ueW1vdXMgJiYgZm4ubmFtZSA9PT0gJ2Fub255bW91cycgPyAnJyA6IGZuLm5hbWU7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgcmVwbGFjZUNvbW1lbnRzID0gcmVxdWlyZSgncmVwbGFjZS1jb21tZW50cy14Jyk7XG4gIHZhciBmVG9TdHJpbmcgPSBmdW5jdGlvbkN0ci5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBub3JtYWxpc2UgPSByZXF1aXJlKCdub3JtYWxpemUtc3BhY2UteCcpLm5vcm1hbGl6ZVNwYWNlMjAxODtcbiAgdmFyIHJlTmFtZSA9IC9eKD86YXN5bmMgKT8oPzpmdW5jdGlvbnxjbGFzcykgPyg/OlxcKiApPyhbXFx3JF0rKS9pO1xuICB2YXIgc3RyaW5nTWF0Y2ggPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5TdHJpbmcucHJvdG90eXBlLm1hdGNoO1xuICBnZXROYW1lID0gZnVuY3Rpb24gX2dldE5hbWUoZm4pIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgIG1hdGNoID0gc3RyaW5nTWF0Y2guY2FsbChub3JtYWxpc2UocmVwbGFjZUNvbW1lbnRzKGZUb1N0cmluZy5jYWxsKGZuKSwgJyAnKSksIHJlTmFtZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdhbm9ueW1vdXMnID8gJycgOiBuYW1lO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgIHJldHVybiAnJztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiwgb3IgYHVuZGVmaW5lZGAgaWYgbm90XG4gKiBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgbmFtZSBvZi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24sICBvciBgdW5kZWZpbmVkYCBpZlxuICogIG5vdCBhIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBnZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCdnZXQtZnVuY3Rpb24tbmFtZS14Jyk7XG4gKlxuICogZ2V0RnVuY3Rpb25OYW1lKCk7IC8vIHVuZGVmaW5lZFxuICogZ2V0RnVuY3Rpb25OYW1lKE51bWJlci5NSU5fVkFMVUUpOyAvLyB1bmRlZmluZWRcbiAqIGdldEZ1bmN0aW9uTmFtZSgnYWJjJyk7IC8vIHVuZGVmaW5lZFxuICogZ2V0RnVuY3Rpb25OYW1lKHRydWUpOyAvLyB1bmRlZmluZWRcbiAqIGdldEZ1bmN0aW9uTmFtZSh7IG5hbWU6ICdhYmMnIH0pOyAvLyB1bmRlZmluZWRcbiAqIGdldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiAoKSB7fSk7IC8vICcnXG4gKiBnZXRGdW5jdGlvbk5hbWUobmV3IEZ1bmN0aW9uICgpKTsgLy8gJydcbiAqIGdldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiB0ZXN0MSgpIHt9KTsgLy8gJ3Rlc3QxJ1xuICogZ2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uKiB0ZXN0MigpIHt9KTsgLy8gJ3Rlc3QyJ1xuICogZ2V0RnVuY3Rpb25OYW1lKGNsYXNzIFRlc3Qge30pOyAvLyAnVGVzdCdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZm4sIHRydWUpID8gZ2V0TmFtZShmbikgOiB2b2lkIDA7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBMaWtlIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgYnV0IGdldHMgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKiBAdmVyc2lvbiAxLjAuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LW93bi1lbnVtZXJhYmxlLXByb3BlcnR5LXN5bWJvbHMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCdhcnJheS1maWx0ZXIteCcpO1xudmFyIGdldE9QUyA9IHJlcXVpcmUoJ2dldC1vd24tcHJvcGVydHktc3ltYm9scy14Jyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSByZXF1aXJlKCdwcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIG9ubHkgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnR5IHN5bWJvbHMgb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0LlxuICogQHRocm93cyB7dHlwZUVycm9yfSAtIElmIHRhcmdldCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGVudW1lcmFibGUgb3duIHByb3BlcnR5IHN5bWJvbHMuXG4gKiBAZXhhbXBsZVxuICogdmFyIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgPSByZXF1aXJlKCdnZXQtb3duLWVudW1lcmFibGUtcHJvcGVydHktc3ltYm9scy14Jyk7XG4gKlxuICogdmFyIG9iaiA9IHsgYmFyOiAxLCBmb286IDIgfTtcbiAqXG4gKiB2YXIgc3ltYm9sMSA9IFN5bWJvbCgnZmlyc3QnKTtcbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHN5bWJvMWwsIHtcbiAqICAgZW51bWVyYWJsZTogZmFsc2UsXG4gKiAgIHZhbHVlOiAnZmlyc3QnXG4gKiB9KTtcbiAqXG4gKiB2YXIgc3ltYm9sMiA9IFN5bWJvbCgnc2Vjb25kJyk7XG4gKiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBzeW1ib2wyLCB7XG4gKiAgIGVudW1lcmFibGU6IHRydWUsXG4gKiAgIHZhbHVlOiAnc2Vjb25kJ1xuICogfSk7XG4gKlxuICogZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyhvYmopOyAvLyBbc3ltYm9sMl1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgcmV0dXJuIGZpbHRlcihnZXRPUFMob2JqZWN0KSwgZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZShvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcbiIsIi8qKlxuICogQGZpbGUgQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHZlcnNpb24gMi4zLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFycmF5LWZpbHRlci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FjaGVkQ3RycyA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpO1xudmFyIEFycmF5Q3RyID0gY2FjaGVkQ3Rycy5BcnJheTtcbnZhciBjYXN0T2JqZWN0ID0gY2FjaGVkQ3Rycy5PYmplY3Q7XG52YXIgbmF0aXZGaWx0ZXIgPSB0eXBlb2YgQXJyYXlDdHIucHJvdG90eXBlLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheUN0ci5wcm90b3R5cGUuZmlsdGVyO1xuXG52YXIgaXNXb3JraW5nO1xuaWYgKG5hdGl2RmlsdGVyKSB7XG4gIHZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gIHZhciBzcHkgPSAwO1xuICB2YXIgcmVzID0gYXR0ZW1wdC5jYWxsKFsxLCAyXSwgbmF0aXZGaWx0ZXIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgc3B5ICs9IGl0ZW07XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAwICYmIHNweSA9PT0gMztcblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgc3B5ID0gJyc7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKGNhc3RPYmplY3QoJ2FiYycpLCBuYXRpdkZpbHRlciwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICBzcHkgKz0gaXRlbTtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gMTtcbiAgICB9KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDEgJiYgcmVzLnZhbHVlWzBdID09PSAnYicgJiYgc3B5ID09PSAnYWJjJztcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSAwO1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCgoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICB9KDEsIDIsIDMpKSwgbmF0aXZGaWx0ZXIsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgc3B5ICs9IGl0ZW07XG4gICAgICByZXR1cm4gaW5kZXggPT09IDI7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAxICYmIHJlcy52YWx1ZVswXSA9PT0gMyAmJiBzcHkgPT09IDY7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgc3B5ID0gMDtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoe1xuICAgICAgMDogMSxcbiAgICAgIDE6IDIsXG4gICAgICAzOiAzLFxuICAgICAgNDogNCxcbiAgICAgIGxlbmd0aDogNFxuICAgIH0sIG5hdGl2RmlsdGVyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc3B5ICs9IGl0ZW07XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAwICYmIHNweSA9PT0gNjtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICBzcHkgPSBudWxsO1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKGZyYWdtZW50LmNoaWxkTm9kZXMsIG5hdGl2RmlsdGVyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBzcHkgPSBpdGVtO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuXG4gICAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAxICYmIHJlcy52YWx1ZVswXSA9PT0gZGl2ICYmIHNweSA9PT0gZGl2O1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgaXNTdHJpY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcykgPT09IGZhbHNlO1xuICAgIH0oKSk7XG5cbiAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgIHNweSA9IG51bGw7XG4gICAgICByZXMgPSBhdHRlbXB0LmNhbGwoWzFdLCBuYXRpdkZpbHRlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gICAgICAgIHNweSA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgIH0sICd4Jyk7XG5cbiAgICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDAgJiYgc3B5ID09PSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSB7fTtcbiAgICB2YXIgZm4gPSBbXG4gICAgICAncmV0dXJuIG5hdGl2RmlsdGVyLmNhbGwoXCJmb29cIiwgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7JyxcbiAgICAgICdpZiAoQm9vbGVhbihjb250ZXh0KSA9PT0gZmFsc2UgfHwgdHlwZW9mIGNvbnRleHQgIT09IFwib2JqZWN0XCIpIHsnLFxuICAgICAgJ3NweS52YWx1ZSA9IHRydWU7fX0pOydcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgcmVzID0gYXR0ZW1wdChGdW5jdGlvbignbmF0aXZGaWx0ZXInLCAnc3B5JywgZm4pLCBuYXRpdkZpbHRlciwgc3B5KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDAgJiYgc3B5LnZhbHVlICE9PSB0cnVlO1xuICB9XG59XG5cbnZhciAkZmlsdGVyO1xuaWYgKG5hdGl2RmlsdGVyKSB7XG4gICRmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoYXJyYXksIGNhbGxCYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBhcmdzID0gW2NhbGxCYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2RmlsdGVyLmFwcGx5KGFycmF5LCBhcmdzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBzcGxpdElmQm94ZWRCdWcgPSByZXF1aXJlKCdzcGxpdC1pZi1ib3hlZC1idWcteCcpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpLnRvTGVuZ3RoMjAxODtcbiAgdmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcblxuICAkZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGFycmF5LCBjYWxsQmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsQmFjayk7XG4gICAgdmFyIGl0ZXJhYmxlID0gc3BsaXRJZkJveGVkQnVnKG9iamVjdCk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7XG4gICAgdmFyIHRoaXNBcmc7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuICAgIH1cblxuICAgIHZhciBub1RoaXMgPSBpc1VuZGVmaW5lZCh0aGlzQXJnKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgaWYgKG5vVGhpcyA/IGNhbGxCYWNrKGl0ZW0sIGksIG9iamVjdCkgOiBjYWxsQmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxCYWNrIC0gRnVuY3Rpb24gaXMgYSBwcmVkaWNhdGUsIHRvIHRlc3QgZWFjaCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2FycmF5fSBBIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbHRlciA9IHJlcXVpcmUoJ2FycmF5LWZpbHRlci14Jyk7XG4gKlxuICogZnVuY3Rpb24gaXNCaWdFbm91Z2godmFsdWUpIHtcbiAqICAgcmV0dXJuIHZhbHVlID49IDEwO1xuICogfVxuICpcbiAqIHZhciBmaWx0ZXJlZCA9IGZpbHRlcihbMTIsIDUsIDgsIDEzMCwgNDRdLCBpc0JpZ0Vub3VnaCk7XG4gKiAvLyBmaWx0ZXJlZCBpcyBbMTIsIDEzMCwgNDRdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGZpbHRlcjtcbiIsIi8qKlxuICogQGZpbGUgQ3JlYXRlcyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyAoZW51bWVyYWJsZSBvciBub3QpIGZvdW5kIGRpcmVjdGx5IHVwb24gYSBnaXZlbiBvYmplY3QuXG4gKiBAdmVyc2lvbiAxLjAuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIG5hdGl2ZUdPUE4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcblxudmFyICRnb3BuO1xuaWYgKHR5cGVvZiBuYXRpdmVHT1BOID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbiAgdmFyIG9iamVjdEdPUE5BY2NlcHRzUHJpbWl0aXZlcztcbiAgdHJ5IHtcbiAgICBuYXRpdmVHT1BOKCdmb28nKTtcbiAgICBvYmplY3RHT1BOQWNjZXB0c1ByaW1pdGl2ZXMgPSB0cnVlO1xuICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgaWYgKG9iamVjdEdPUE5BY2NlcHRzUHJpbWl0aXZlcykge1xuICAgICRnb3BuID0gbmF0aXZlR09QTjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCd0by1zdHJpbmctdGFnLXgnKTtcbiAgICB2YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbiAgICB2YXIgY2FjaGVkV2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IG5hdGl2ZUdPUE4od2luZG93KSA6IFtdO1xuXG4gICAgJGdvcG4gPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgICAgdmFyIHZhbCA9IHRvT2JqZWN0KG9iaik7XG4gICAgICBpZiAodG9TdHJpbmdUYWcodmFsKSA9PT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlR09QTih2YWwpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgICAvLyBJRSBidWcgd2hlcmUgbGF5b3V0IGVuZ2luZSBjYWxscyB1c2VybGFuZCBnT1BOIGZvciBjcm9zcy1kb21haW4gYHdpbmRvd2Agb2JqZWN0c1xuICAgICAgICAgIHJldHVybiBjb25jYXQuY2FsbChbXSwgY2FjaGVkV2luZG93TmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVHT1BOKHZhbCk7XG4gICAgfTtcbiAgfVxufSBlbHNlIHtcbiAgdmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cy14Jyk7XG4gICRnb3BuID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhvYmopO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgKGVudW1lcmFibGUgb3Igbm90KSBmb3VuZFxuICogZGlyZWN0bHkgdXBvbiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBvd25cbiAqICBwcm9wZXJ0aWVzIGFyZSB0byBiZSByZXR1cm5lZC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGFyZ2V0IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgcHJvcGVydGllcyBmb3VuZFxuICogIGRpcmVjdGx5IHVwb24gdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0T3duUHJvcGVydHlOYW1lID0gcmVxdWlyZSgnZ2V0LW93bi1wcm9wZXJ0eS1uYW1lLXgnKTtcbiAqXG4gKiBnZXRPd25Qcm9wZXJ0eU5hbWVzKCdmb28nKTsgLy8gW1wiMFwiLCBcIjFcIiwgXCIyXCIsIFwibGVuZ3RoXCJdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGdvcG47XG4iLCIvKipcbiAqIEBmaWxlIENyZWF0ZXMgYW4gYXJyYXkgb2YgYWxsIHN5bWJvbCBwcm9wZXJ0aWVzIGZvdW5kIGRpcmVjdGx5IHVwb24gYSBnaXZlbiBvYmplY3QuXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgbmF0aXZlR09QUyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaXNXb3JraW5nO1xuaWYgKHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14JykgJiYgbmF0aXZlR09QUyAmJiB0eXBlb2YgbmF0aXZlR09QUyA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCcnKTtcbiAgdmFyIHRlc3RPYmogPSB7IGE6IDEgfTtcbiAgdGVzdE9ialtzeW1ib2xdID0gMjtcbiAgdmFyIHIgPSByZXF1aXJlKCdhdHRlbXB0LXgnKShuYXRpdmVHT1BTLCB0ZXN0T2JqKTtcbiAgaXNXb3JraW5nID0gci50aHJldyA9PT0gZmFsc2UgJiYgci52YWx1ZSAmJiByLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiByLnZhbHVlWzBdID09PSBzeW1ib2w7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY3JlYXRlcyBhbiBhcnJheSBvZiBhbGwgc3ltYm9sIHByb3BlcnRpZXMgZm91bmQgZGlyZWN0bHkgdXBvbiBhXG4gKiBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3Qgd2hvc2Ugc3ltYm9sIHByb3BlcnRpZXMgYXJlIHRvIGJlIHJldHVybmVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGFsbCBzeW1ib2wgcHJvcGVydGllcyBmb3VuZCBkaXJlY3RseSB1cG9uIHRoZVxuICogIGdpdmVuIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnZ2V0LW93bi1wcm9wZXJ0eS1pc1dvcmtpbmcteCcpO1xuICpcbiAqIHZhciBzeW1ib2wgPSBTeW1ib2woJycpO1xuICogdmFyIHRlc3RPYmogPSB7IGE6IDEgfTtcbiAqIHRlc3RPYmpbc3ltYm9sXSA9IDI7XG4gKiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHModGVzdE9iaik7IC8vIFtzeW1ib2xdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3Qob2JqKTtcbiAgcmV0dXJuIGlzV29ya2luZyA/IG5hdGl2ZUdPUFMob2JqZWN0KSA6IFtdO1xufTtcbiIsIi8qKlxuICogQGZpbGUgU2hhbSBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gKiBAdmVyc2lvbiAxLjQuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LXByb3RvdHlwZS1vZi14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uLXgnKTtcbnZhciBpc051bGwgPSByZXF1aXJlKCdsb2Rhc2guaXNudWxsJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIGdwbyA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuaWYgKGdwbykge1xuICB0cnkge1xuICAgIGdwbyA9IGdwbyhPYmplY3QpID09PSBPYmplY3QucHJvdG90eXBlICYmIGdwbztcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgZ3BvID0gbnVsbDtcbiAgfVxufVxuXG5pZiAoZ3BvKSB7XG4gIHRyeSB7XG4gICAgZ3BvKDEpO1xuICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICB2YXIgJGdldFByb3RvdHlwZU9mID0gZ3BvO1xuICAgIGdwbyA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iaikge1xuICAgICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChvYmopKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICBncG8gPSBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihvYmopIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3Qob2JqKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cbiAgICB2YXIgcHJvdG8gPSBvYmplY3QuX19wcm90b19fO1xuICAgIGlmIChwcm90byB8fCBpc051bGwocHJvdG8pKSB7XG4gICAgICByZXR1cm4gcHJvdG87XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqZWN0LmNvbnN0cnVjdG9yKSkge1xuICAgICAgcmV0dXJuIG9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgcHJvdG90eXBlIChpLmUuIHRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJuYWwgW1tQcm90b3R5cGVdXSBwcm9wZXJ0eSlcbiAqIG9mIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIG9iamVjdCB3aG9zZSBwcm90b3R5cGUgaXMgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvdG90eXBlIG9mIHRoZSBnaXZlbiBvYmplY3QuIElmIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgcHJvcGVydGllcywgbnVsbCBpcyByZXR1cm5lZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdnZXQtcHJvdG90eXBlLW9mLXgnKTtcbiAqIGdldFByb3RvdHlwZU9mKCdmb28nKTsgLy8gU3RyaW5nLnByb3RvdHlwZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGdwbztcbiIsIi8qKlxuICogQGZpbGUgQ2hlY2sgc3VwcG9ydCBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMuXG4gKiBAdmVyc2lvbiAxLjEuMVxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaGFzLWJveGVkLXN0cmluZy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm94ZWRTdHJpbmcgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5PYmplY3QoJ2EnKTtcblxuLyoqXG4gKiBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuICogYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubykuXG4gKlxuICogYHRydWVgIGlmIG5vIGZhaWx1cmU7IG90aGVyd2lzZSBgZmFsc2VgLlxuICpcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBib3hlZFN0cmluZ1swXSA9PT0gJ2EnICYmICgwIGluIGJveGVkU3RyaW5nKTtcbiIsIi8qKlxuICogQGZpbGUgVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkga2V5LlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWhhc293bnByb3BlcnR5fDcuMy4xMSBIYXNPd25Qcm9wZXJ0eSAoTywgUCl9XG4gKiBAdmVyc2lvbiAzLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaGFzLW93bi1wcm9wZXJ0eS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCd0by1wcm9wZXJ0eS1rZXkteCcpO1xudmFyIGhvcCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGBoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kIHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlclxuICogdGhlIGBvYmplY3RgIGhhcyB0aGUgc3BlY2lmaWVkIGBwcm9wZXJ0eWAuIERvZXMgbm90IGF0dGVtcHQgdG8gZml4IGtub3duXG4gKiBpc3N1ZXMgaW4gb2xkZXIgYnJvd3NlcnMsIGJ1dCBkb2VzIEVTNmlmeSB0aGUgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBvYmplY3QgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge3N0cmluZ3xTeW1ib2x9IHByb3BlcnR5IC0gVGhlIG5hbWUgb3IgU3ltYm9sIG9mIHRoZSBwcm9wZXJ0eSB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgc2V0IG9uIGBvYmplY3RgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGhhc093blByb3BlcnR5ID0gcmVxdWlyZSgnaGFzLW93bi1wcm9wZXJ0eS14Jyk7XG4gKiB2YXIgbyA9IHtcbiAqICAgZm9vOiAnYmFyJ1xuICogfTtcbiAqXG4gKlxuICogaGFzT3duUHJvcGVydHkobywgJ2JhcicpOyAvLyBmYWxzZVxuICogaGFzT3duUHJvcGVydHkobywgJ2ZvbycpOyAvLyB0cnVlXG4gKiBoYXNPd25Qcm9wZXJ0eSh1bmRlZmluZWQsICdmb28nKTtcbiAqICAgICAgICAgICAgICAgICAgIC8vIFR5cGVFcnJvcjogQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gaG9wLmNhbGwodG9PYmplY3Qob2JqZWN0KSwgdG9Qcm9wZXJ0eUtleShwcm9wZXJ0eSkpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGVzdHMgaWYgRVM2IFJlZmxlY3QgaXMgc3VwcG9ydGVkLlxuICogQHZlcnNpb24gMS4xLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGhhcy1yZWZsZWN0LXN1cHBvcnQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgYFJlZmxlY3RgZXhpc3RzLlxuICogYHRydWVgLCBpZiBpdCBleGlzdHMgYW5kIGNyZWF0ZXMgdGhlIGNvcnJlY3QgdHlwZSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKlxuICogQHR5cGUgYm9vbGVhblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsO1xuIiwiLyoqXG4gKiBAZmlsZSBUZXN0cyBpZiBFUzYgU3ltYm9sIGlzIHN1cHBvcnRlZC5cbiAqIEB2ZXJzaW9uIDEuNC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBoYXMtc3ltYm9sLXN1cHBvcnQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgYFN5bWJvbGBleGlzdHMgYW5kIGNyZWF0ZXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqIGB0cnVlYCwgaWYgaXQgZXhpc3RzIGFuZCBjcmVhdGVzIHRoZSBjb3JyZWN0IHR5cGUsIG90aGVyd2lzZSBgZmFsc2VgLlxuICpcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJycpID09PSAnc3ltYm9sJztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMTddLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGVzdHMgaWYgRVM2IEBAdG9TdHJpbmdUYWcgaXMgc3VwcG9ydGVkLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLUBAdG9zdHJpbmd0YWd8MjYuMy4xIEBAdG9TdHJpbmdUYWd9XG4gKiBAdmVyc2lvbiAxLjQuMVxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaGFzLXRvLXN0cmluZy10YWcteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgYFN5bWJvbC50b1N0cmluZ1RhZ2BleGlzdHMgYW5kIGlzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKiBgdHJ1ZWAsIGlmIGl0IGV4aXN0cyBhbmQgaXMgdGhlIGNvcnJlY3QgdHlwZSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKlxuICogQHR5cGUgYm9vbGVhblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14JykgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIi8qKlxuICogQGZpbGUgQW4gZXh0ZW5kZWQgRVM2IGluZGV4T2YuXG4gKiBAdmVyc2lvbiAyLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaW5kZXgtb2YteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJ2lzLXN0cmluZycpO1xudmFyIGlzRmFsc2V5ID0gcmVxdWlyZSgnaXMtZmFsc2V5LXgnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpO1xudmFyIHNhbWVWYWx1ZVplcm8gPSByZXF1aXJlKCdzYW1lLXZhbHVlLXplcm8teCcpO1xudmFyIHNhbWVWYWx1ZSA9IHJlcXVpcmUoJ3NhbWUtdmFsdWUteCcpO1xudmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJ2ZpbmQtaW5kZXgteCcpO1xudmFyIGNhbGNGcm9tSW5kZXggPSByZXF1aXJlKCdjYWxjdWxhdGUtZnJvbS1pbmRleC14Jyk7XG52YXIgc3BsaXRJZkJveGVkQnVnID0gcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcbnZhciBwSW5kZXhPZiA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcblxudmFyIGlzV29ya2luZztcbmlmIChwSW5kZXhPZikge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICB2YXIgcmVzID0gYXR0ZW1wdC5jYWxsKFswLCAxXSwgcEluZGV4T2YsIDEsIDIpO1xuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gLTE7XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbChbMCwgMV0sIHBJbmRleE9mLCAxKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMTtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoWzAsIC0wXSwgcEluZGV4T2YsIC0wKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMDtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgdGVzdEFyciA9IFtdO1xuICAgIHRlc3RBcnIubGVuZ3RoID0gMjtcbiAgICB0ZXN0QXJyWzFdID0gdm9pZCAwO1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCh0ZXN0QXJyLCBwSW5kZXhPZiwgdm9pZCAwKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMTtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoJ2FiYycsIHBJbmRleE9mLCAnYycpO1xuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSAyO1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCgoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICB9KCdhJywgJ2InLCAnYycpKSwgcEluZGV4T2YsICdjJyk7XG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgPT09IDI7XG4gIH1cbn1cblxuaWYgKGlzV29ya2luZyAhPT0gdHJ1ZSkge1xuICBwSW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGkgPSBhcmd1bWVudHNbMV07XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGluZGV4IGluIHRoZSBhcnJheSwgaWYgYW4gZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAqIHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHNlYXJjaEVsZW1lbnQgLSBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleHRlbmRGbiAtIFRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgaW5kZXggb2YgZm91bmQgZWxlbWVudCwgb3RoZXJ3aXNlIC0xLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGZpbmRJZHhGcm9tID0gZnVuY3Rpb24gZmluZEluZGV4RnJvbShhcnJheSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4LCBleHRlbmRGbikge1xuICB2YXIgZklkeCA9IGZyb21JbmRleDtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGFycmF5Lmxlbmd0aCk7XG4gIHdoaWxlIChmSWR4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGZJZHggaW4gYXJyYXkgJiYgZXh0ZW5kRm4oYXJyYXlbZklkeF0sIHNlYXJjaEVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZklkeDtcbiAgICB9XG5cbiAgICBmSWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmRcbiAqIGluIHRoZSBhcnJheSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgYXJyYXlgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCAtIEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBgYXJyYXlgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXhdIC0gVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuIElmIHRoZVxuICogIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgYXJyYXkncyBsZW5ndGgsIC0xIGlzIHJldHVybmVkLFxuICogIHdoaWNoIG1lYW5zIHRoZSBhcnJheSB3aWxsIG5vdCBiZSBzZWFyY2hlZC4gSWYgdGhlIHByb3ZpZGVkIGluZGV4IHZhbHVlIGlzXG4gKiAgYSBuZWdhdGl2ZSBudW1iZXIsIGl0IGlzIHRha2VuIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAqICBOb3RlOiBpZiB0aGUgcHJvdmlkZWQgaW5kZXggaXMgbmVnYXRpdmUsIHRoZSBhcnJheSBpcyBzdGlsbCBzZWFyY2hlZCBmcm9tXG4gKiAgZnJvbnQgdG8gYmFjay4gSWYgdGhlIGNhbGN1bGF0ZWQgaW5kZXggaXMgbGVzcyB0aGFuIDAsIHRoZW4gdGhlIHdob2xlXG4gKiAgYXJyYXkgd2lsbCBiZSBzZWFyY2hlZC4gRGVmYXVsdDogMCAoZW50aXJlIGFycmF5IGlzIHNlYXJjaGVkKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXh0ZW5kXSAtIEV4dGVuc2lvbiB0eXBlOiBgU2FtZVZhbHVlYCBvciBgU2FtZVZhbHVlWmVyb2AuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGluZGV4IG9mIGZvdW5kIGVsZW1lbnQsIG90aGVyd2lzZSAtMS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4LW9mLXgnKTtcbiAqIHZhciBzdWJqZWN0ID0gWzIsIDMsIHVuZGVmaW5lZCwgdHJ1ZSwgJ2hlaicsIG51bGwsIDIsIGZhbHNlLCAwLCAtMCwgTmFOXTtcbiAqXG4gKiAvLyBTdGFuZGFyZCBtb2RlLCBvcGVyYXRlcyBqdXN0IGxpa2UgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYC5cbiAqIGluZGV4T2Yoc3ViamVjdCwgbnVsbCk7IC8vIDVcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsICcyJyk7IC8vIC0xXG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCBOYU4pOyAvLyAtMVxuICogaW5kZXhPZih0ZXN0U3ViamVjdCwgLTApOyAvLyA4XG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAyLCAyKTsgLy82XG4gKlxuICogLy8gYFNhbWVWYWx1ZVplcm9gIG1vZGUgZXh0ZW5kcyBgaW5kZXhPZmAgdG8gbWF0Y2ggYE5hTmAuXG4gKiBpbmRleE9mKHN1YmplY3QsIG51bGwsICdTYW1lVmFsdWVaZXJvJyk7IC8vIDVcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsICcyJywgJ1NhbWVWYWx1ZVplcm8nKTsgLy8gLTFcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsIE5hTiwgJ1NhbWVWYWx1ZVplcm8nKTsgLy8gMTBcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsIC0wLCAnU2FtZVZhbHVlWmVybycpOyAvLyA4XG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAyLCAyLCAnU2FtZVZhbHVlWmVybycpOyAvLzZcbiAqXG4gKiAvLyBgU2FtZVZhbHVlYCBtb2RlIGV4dGVuZHMgYGluZGV4T2ZgIHRvIG1hdGNoIGBOYU5gIGFuZCBzaWduZWQgYDBgLlxuICogaW5kZXhPZihzdWJqZWN0LCBudWxsLCAnU2FtZVZhbHVlJyk7IC8vIDVcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsICcyJywgJ1NhbWVWYWx1ZScpOyAvLyAtMVxuICogaW5kZXhPZih0ZXN0U3ViamVjdCwgTmFOLCAnU2FtZVZhbHVlJyk7IC8vIDEwXG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAtMCwgJ1NhbWVWYWx1ZScpOyAvLyA5XG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAyLCAyLCAnU2FtZVZhbHVlJyk7IC8vNlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHNlYXJjaEVsZW1lbnQpIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgdmFyIGl0ZXJhYmxlID0gc3BsaXRJZkJveGVkQnVnKG9iamVjdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICBpZiAobGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgZXh0ZW5kID0gYXJnTGVuZ3RoID4gMiAmJiBhcmdMZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogYXJndW1lbnRzWzJdO1xuICB2YXIgZXh0ZW5kRm47XG4gIGlmIChpc1N0cmluZyhleHRlbmQpKSB7XG4gICAgZXh0ZW5kID0gZXh0ZW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGV4dGVuZCA9PT0gJ3NhbWV2YWx1ZScpIHtcbiAgICAgIGV4dGVuZEZuID0gc2FtZVZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZXh0ZW5kID09PSAnc2FtZXZhbHVlemVybycpIHtcbiAgICAgIGV4dGVuZEZuID0gc2FtZVZhbHVlWmVybztcbiAgICB9XG4gIH1cblxuICB2YXIgZnJvbUluZGV4ID0gMDtcbiAgaWYgKGV4dGVuZEZuICYmIChzZWFyY2hFbGVtZW50ID09PSAwIHx8IG51bWJlcklzTmFOKHNlYXJjaEVsZW1lbnQpKSkge1xuICAgIGlmIChhcmdMZW5ndGggPiAzKSB7XG4gICAgICBmcm9tSW5kZXggPSBjYWxjRnJvbUluZGV4KGl0ZXJhYmxlLCBhcmd1bWVudHNbMl0pO1xuICAgICAgaWYgKGZyb21JbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcm9tSW5kZXggPiAwKSB7XG4gICAgICByZXR1cm4gZmluZElkeEZyb20oaXRlcmFibGUsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCwgZXh0ZW5kRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5kSW5kZXgoaXRlcmFibGUsIGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4IGluIGl0ZXJhYmxlICYmIGV4dGVuZEZuKHNlYXJjaEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFyZ0xlbmd0aCA+IDMgfHwgKGFyZ0xlbmd0aCA+IDIgJiYgaXNGYWxzZXkoZXh0ZW5kRm4pKSkge1xuICAgIGZyb21JbmRleCA9IGNhbGNGcm9tSW5kZXgoaXRlcmFibGUsIGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKGZyb21JbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcEluZGV4T2YuY2FsbChpdGVyYWJsZSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENhbGN1bGF0ZXMgYSBmcm9tSW5kZXggb2YgYSBnaXZlbiB2YWx1ZSBmb3IgYW4gYXJyYXkuXG4gKiBAdmVyc2lvbiAyLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgY2FsY3VsYXRlLWZyb20taW5kZXgteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14JykudG9MZW5ndGgyMDE4O1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTg7XG52YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCdpcy1hcnJheS1saWtlLXgnKTtcblxudmFyIGdldE1heCA9IGZ1bmN0aW9uIF9nZXRNYXgoYSwgYikge1xuICByZXR1cm4gYSA+PSBiID8gYSA6IGI7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgYSBmcm9tSW5kZXggb2YgYSBnaXZlbiB2YWx1ZSBmb3IgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgKiBUaGUgYXJyYXkgb24gd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBzdGFydGluZyBpbmRleC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4ICogVGhlIHBvc2l0aW9uIGluIHRoaXMgYXJyYXkgYXQgd2hpY2ggdG8gYmVnaW4uIEFcbiAqICBuZWdhdGl2ZSB2YWx1ZSBnaXZlcyB0aGUgaW5kZXggb2YgYXJyYXkubGVuZ3RoICsgZnJvbUluZGV4IGJ5IGFzYy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjYWxjdWxhdGVkIGZyb21JbmRleC4gRGVmYXVsdCBpcyAwLlxuICogQGV4YW1wbGVcbiAqIHZhciBjYWxjRnJvbUluZGV4ID0gcmVxdWlyZSgnY2FsY3VsYXRlLWZyb20taW5kZXgteCcpO1xuICpcbiAqIGNhbGNGcm9tSW5kZXgoWzEsIDIsIDNdLCAxKTsgLy8gMVxuICogY2FsY0Zyb21JbmRleChbMSwgMiwgM10sIEluZmluaXR5KTsgLy8gSW5maW5pdHlcbiAqIGNhbGNGcm9tSW5kZXgoWzEsIDIsIDNdLCAtSW5maW5pdHkpOyAvLyAwXG4gKiBjYWxjRnJvbUluZGV4KFsxLCAyLCAzXSwgLTEpOyAvLyAyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsY0Zyb21JbmRleChhcnJheSwgZnJvbUluZGV4KSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gIGlmIChpc0FycmF5TGlrZShvYmplY3QpID09PSBmYWxzZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG5cbiAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IGdldE1heCgwLCB0b0xlbmd0aChvYmplY3QubGVuZ3RoKSArIGluZGV4KTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFNoaW0gZm9yIE1hdGguc2lnbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1tYXRoLnNpZ258MjAuMi4yLjI5IE1hdGguc2lnbih4KX1cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBtYXRoLXNpZ24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYlRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciB0b051bWJlcjIwMTYgPSBsaWJUb051bWJlci50b051bWJlcjIwMTY7XG52YXIgdG9OdW1iZXIyMDE4ID0gbGliVG9OdW1iZXIudG9OdW1iZXIyMDE4O1xudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcblxudmFyICRzaWduMjAxNiA9IGZ1bmN0aW9uIHNpZ24yMDE2KHgpIHtcbiAgdmFyIG4gPSB0b051bWJlcjIwMTYoeCk7XG4gIGlmIChuID09PSAwIHx8IG51bWJlcklzTmFOKG4pKSB7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICByZXR1cm4gbiA+IDAgPyAxIDogLTE7XG59O1xuXG52YXIgJHNpZ24yMDE4ID0gZnVuY3Rpb24gc2lnbjIwMTgoeCkge1xuICB2YXIgbiA9IHRvTnVtYmVyMjAxOCh4KTtcbiAgaWYgKG4gPT09IDAgfHwgbnVtYmVySXNOYU4obikpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHJldHVybiBuID4gMCA/IDEgOiAtMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHNpZ24yMDE4LlxuICAgKi9cbiAgc2lnbjogJHNpZ24yMDE4LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBzaWduIG9mIGEgbnVtYmVyLCBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUgb3IgemVyby4gKEVTMjAxNilcbiAgICpcbiAgICogQHBhcmFtIHsqfSB4IC0gQSBudW1iZXIuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgc2lnbiBvZiB0aGUgZ2l2ZW4gYXJndW1lbnQuIElmIHRoZSBhcmd1bWVudFxuICAgKiBpcyBhIHBvc2l0aXZlIG51bWJlciwgbmVnYXRpdmUgbnVtYmVyLCBwb3NpdGl2ZSB6ZXJvIG9yIG5lZ2F0aXZlIHplcm8sIHRoZSBmdW5jdGlvbiB3aWxsXG4gICAqIHJldHVybiAxLCAtMSwgMCBvciAtMCByZXNwZWN0aXZlbHkuIE90aGVyd2lzZSwgTmFOIGlzIHJldHVybmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgbWF0aFNpZ24gPSByZXF1aXJlKCdtYXRoLXNpZ24teCcpLnNpZ24yMDE2O1xuICAgKlxuICAgKiBtYXRoU2lnbigzKTsgICAgIC8vICAxXG4gICAqIG1hdGhTaWduKC0zKTsgICAgLy8gLTFcbiAgICogbWF0aFNpZ24oJy0zJyk7ICAvLyAtMVxuICAgKiBtYXRoU2lnbigwKTsgICAgIC8vICAwXG4gICAqIG1hdGhTaWduKC0wKTsgICAgLy8gLTBcbiAgICogbWF0aFNpZ24oTmFOKTsgICAvLyBOYU5cbiAgICogbWF0aFNpZ24oJ2ZvbycpOyAvLyBOYU5cbiAgICogbWF0aFNpZ24oKTsgICAgICAvLyBOYU5cbiAgICovXG4gIHNpZ24yMDE2OiAkc2lnbjIwMTYsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXIsIGluZGljYXRpbmcgd2hldGhlciB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLFxuICAgKiBuZWdhdGl2ZSBvciB6ZXJvLiAoRVMyMDE4KVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHggLSBBIG51bWJlci5cbiAgICogQHJldHVybnMge251bWJlcn0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaWduIG9mIHRoZSBnaXZlbiBhcmd1bWVudC4gSWYgdGhlIGFyZ3VtZW50XG4gICAqIGlzIGEgcG9zaXRpdmUgbnVtYmVyLCBuZWdhdGl2ZSBudW1iZXIsIHBvc2l0aXZlIHplcm8gb3IgbmVnYXRpdmUgemVybywgdGhlIGZ1bmN0aW9uIHdpbGxcbiAgICogcmV0dXJuIDEsIC0xLCAwIG9yIC0wIHJlc3BlY3RpdmVseS4gT3RoZXJ3aXNlLCBOYU4gaXMgcmV0dXJuZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBtYXRoU2lnbiA9IHJlcXVpcmUoJ21hdGgtc2lnbi14Jykuc2lnbjIwMTg7XG4gICAqXG4gICAqIG1hdGhTaWduKDMpOyAgICAgLy8gIDFcbiAgICogbWF0aFNpZ24oLTMpOyAgICAvLyAtMVxuICAgKiBtYXRoU2lnbignLTMnKTsgIC8vIC0xXG4gICAqIG1hdGhTaWduKDApOyAgICAgLy8gIDBcbiAgICogbWF0aFNpZ24oLTApOyAgICAvLyAtMFxuICAgKiBtYXRoU2lnbihOYU4pOyAgIC8vIE5hTlxuICAgKiBtYXRoU2lnbignZm9vJyk7IC8vIE5hTlxuICAgKiBtYXRoU2lnbigpOyAgICAgIC8vIE5hTlxuICAgKi9cbiAgc2lnbjIwMTg6ICRzaWduMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgUGFyc2VzIGEgc3RyaW5nIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBwYXJzZS1pbnQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5hdGl2ZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG52YXIgTkFOID0gcmVxdWlyZSgnbmFuLXgnKTtcbnZhciB0b1N0ciA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG52YXIgdHJpbUxlZnQyMDE2ID0gcmVxdWlyZSgndHJpbS1sZWZ0LXgnKS50cmltTGVmdDIwMTY7XG52YXIgdHJpbUxlZnQyMDE4ID0gcmVxdWlyZSgndHJpbS1sZWZ0LXgnKS50cmltTGVmdDIwMTg7XG52YXIgY2hhY2hlZEN0cnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbnZhciBjYXN0TnVtYmVyID0gY2hhY2hlZEN0cnMuTnVtYmVyO1xudmFyIGNoYXJBdCA9IGNoYWNoZWRDdHJzLlN0cmluZy5wcm90b3R5cGUuY2hhckF0O1xudmFyIGhleFJlZ2V4ID0gL15bLStdPzBbeFhdLztcbnZhciB0ZXN0ID0gaGV4UmVnZXgudGVzdDtcblxudmFyICRwYXJzZUludDIwMTYgPSBmdW5jdGlvbiBwYXJzZUludDIwMTYoc3RyaW5nLCByYWRpeCkge1xuICB2YXIgc3RyID0gdHJpbUxlZnQyMDE2KHRvU3RyKHN0cmluZykpO1xuXG4gIHJldHVybiBuYXRpdmVQYXJzZUludChzdHIsIGNhc3ROdW1iZXIocmFkaXgpIHx8ICh0ZXN0LmNhbGwoaGV4UmVnZXgsIHN0cikgPyAxNiA6IDEwKSk7XG59O1xuXG52YXIgJHBhcnNlSW50MjAxOCA9IGZ1bmN0aW9uIHBhcnNlSW50MjAxOChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBzdHIgPSB0cmltTGVmdDIwMTgodG9TdHIoc3RyaW5nKSk7XG4gIGlmIChjaGFyQXQuY2FsbChzdHIsIDApID09PSAnXFx1MTgwRScpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG5cbiAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHN0ciwgY2FzdE51bWJlcihyYWRpeCkgfHwgKHRlc3QuY2FsbChoZXhSZWdleCwgc3RyKSA/IDE2IDogMTApKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHBhcnNlSW50MjAxOC5cbiAgICovXG4gIHBhcnNlSW50OiAkcGFyc2VJbnQyMDE4LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkXG4gICAqIHJhZGl4ICh0aGUgYmFzZSBpbiBtYXRoZW1hdGljYWwgbnVtZXJhbCBzeXN0ZW1zKS4gKEVTMjAxNilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS4gSWYgdGhlIHN0cmluZyBhcmd1bWVudCBpcyBub3QgYVxuICAgKiAgc3RyaW5nLCB0aGVuIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyAodXNpbmcgdGhlIFRvU3RyaW5nIGFic3RyYWN0XG4gICAqICBvcGVyYXRpb24pLiBMZWFkaW5nIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXggLSBBbiBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMzYgdGhhdCByZXByZXNlbnRzIHRoZSByYWRpeFxuICAgKiAgKHRoZSBiYXNlIGluIG1hdGhlbWF0aWNhbCBudW1lcmFsIHN5c3RlbXMpIG9mIHRoZSBhYm92ZSBtZW50aW9uZWQgc3RyaW5nLlxuICAgKiAgU3BlY2lmeSAxMCBmb3IgdGhlIGRlY2ltYWwgbnVtZXJhbCBzeXN0ZW0gY29tbW9ubHkgdXNlZCBieSBodW1hbnMuIEFsd2F5c1xuICAgKiAgc3BlY2lmeSB0aGlzIHBhcmFtZXRlciB0byBlbGltaW5hdGUgcmVhZGVyIGNvbmZ1c2lvbiBhbmQgdG8gZ3VhcmFudGVlXG4gICAqICBwcmVkaWN0YWJsZSBiZWhhdmlvci4gRGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHRzXG4gICAqICB3aGVuIGEgcmFkaXggaXMgbm90IHNwZWNpZmllZCwgdXN1YWxseSBkZWZhdWx0aW5nIHRoZSB2YWx1ZSB0byAxMC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgYSBTeW1ib2wgb3IgaXMgbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge251bWJlcn0gQW4gaW50ZWdlciBudW1iZXIgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gSWYgdGhlIGZpcnN0XG4gICAqICBjaGFyYWN0ZXIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgTmFOIGlzIHJldHVybmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgncGFyc2UtaW50LXgnKS5wYXJzZUludDIwMTY7XG4gICAqXG4gICAqIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgYWxsIHJldHVybiAxNVxuICAgKiAkcGFyc2VJbnQoJyAweEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnIEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnMTcnLCA4KTtcbiAgICogJHBhcnNlSW50KDAyMSwgOCk7XG4gICAqICRwYXJzZUludCgnMDE1JywgMTApOyAgIC8vICRwYXJzZUludCgwMTUsIDEwKTsgd2lsbCByZXR1cm4gMTVcbiAgICogJHBhcnNlSW50KDE1Ljk5LCAxMCk7XG4gICAqICRwYXJzZUludCgnMTUsMTIzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJ0ZYWDEyMycsIDE2KTtcbiAgICogJHBhcnNlSW50KCcxMTExJywgMik7XG4gICAqICRwYXJzZUludCgnMTUgKiAzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJzE1ZTInLCAxMCk7XG4gICAqICRwYXJzZUludCgnMTVweCcsIDEwKTtcbiAgICogJHBhcnNlSW50KCcxMicsIDEzKTtcbiAgICpcbiAgICogLy9UaGUgZm9sbG93aW5nIGV4YW1wbGVzIGFsbCByZXR1cm4gTmFOOlxuICAgKiAkcGFyc2VJbnQoJ0hlbGxvJywgOCk7IC8vIE5vdCBhIG51bWJlciBhdCBhbGxcbiAgICogJHBhcnNlSW50KCc1NDYnLCAyKTsgICAvLyBEaWdpdHMgYXJlIG5vdCB2YWxpZCBmb3IgYmluYXJ5IHJlcHJlc2VudGF0aW9uc1xuICAgKi9cbiAgcGFyc2VJbnQyMDE2OiAkcGFyc2VJbnQyMDE2LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkXG4gICAqIHJhZGl4ICh0aGUgYmFzZSBpbiBtYXRoZW1hdGljYWwgbnVtZXJhbCBzeXN0ZW1zKS4gKEVTMjAxOClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS4gSWYgdGhlIHN0cmluZyBhcmd1bWVudCBpcyBub3QgYVxuICAgKiAgc3RyaW5nLCB0aGVuIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyAodXNpbmcgdGhlIFRvU3RyaW5nIGFic3RyYWN0XG4gICAqICBvcGVyYXRpb24pLiBMZWFkaW5nIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXggLSBBbiBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMzYgdGhhdCByZXByZXNlbnRzIHRoZSByYWRpeFxuICAgKiAgKHRoZSBiYXNlIGluIG1hdGhlbWF0aWNhbCBudW1lcmFsIHN5c3RlbXMpIG9mIHRoZSBhYm92ZSBtZW50aW9uZWQgc3RyaW5nLlxuICAgKiAgU3BlY2lmeSAxMCBmb3IgdGhlIGRlY2ltYWwgbnVtZXJhbCBzeXN0ZW0gY29tbW9ubHkgdXNlZCBieSBodW1hbnMuIEFsd2F5c1xuICAgKiAgc3BlY2lmeSB0aGlzIHBhcmFtZXRlciB0byBlbGltaW5hdGUgcmVhZGVyIGNvbmZ1c2lvbiBhbmQgdG8gZ3VhcmFudGVlXG4gICAqICBwcmVkaWN0YWJsZSBiZWhhdmlvci4gRGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHRzXG4gICAqICB3aGVuIGEgcmFkaXggaXMgbm90IHNwZWNpZmllZCwgdXN1YWxseSBkZWZhdWx0aW5nIHRoZSB2YWx1ZSB0byAxMC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgYSBTeW1ib2wgb3IgaXMgbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge251bWJlcn0gQW4gaW50ZWdlciBudW1iZXIgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gSWYgdGhlIGZpcnN0XG4gICAqICBjaGFyYWN0ZXIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgTmFOIGlzIHJldHVybmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgncGFyc2UtaW50LXgnKS5wYXJzZUludDIwMTg7XG4gICAqXG4gICAqIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgYWxsIHJldHVybiAxNVxuICAgKiAkcGFyc2VJbnQoJyAweEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnIEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnMTcnLCA4KTtcbiAgICogJHBhcnNlSW50KDAyMSwgOCk7XG4gICAqICRwYXJzZUludCgnMDE1JywgMTApOyAgIC8vICRwYXJzZUludCgwMTUsIDEwKTsgd2lsbCByZXR1cm4gMTVcbiAgICogJHBhcnNlSW50KDE1Ljk5LCAxMCk7XG4gICAqICRwYXJzZUludCgnMTUsMTIzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJ0ZYWDEyMycsIDE2KTtcbiAgICogJHBhcnNlSW50KCcxMTExJywgMik7XG4gICAqICRwYXJzZUludCgnMTUgKiAzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJzE1ZTInLCAxMCk7XG4gICAqICRwYXJzZUludCgnMTVweCcsIDEwKTtcbiAgICogJHBhcnNlSW50KCcxMicsIDEzKTtcbiAgICpcbiAgICogLy9UaGUgZm9sbG93aW5nIGV4YW1wbGVzIGFsbCByZXR1cm4gTmFOOlxuICAgKiAkcGFyc2VJbnQoJ0hlbGxvJywgOCk7IC8vIE5vdCBhIG51bWJlciBhdCBhbGxcbiAgICogJHBhcnNlSW50KCc1NDYnLCAyKTsgICAvLyBEaWdpdHMgYXJlIG5vdCB2YWxpZCBmb3IgYmluYXJ5IHJlcHJlc2VudGF0aW9uc1xuICAgKi9cbiAgcGFyc2VJbnQyMDE4OiAkcGFyc2VJbnQyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUb0ludGVnZXIgY29udmVydHMgJ2FyZ3VtZW50JyB0byBhbiBpbnRlZ3JhbCBudW1lcmljIHZhbHVlLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50ZWdlcnw3LjEuNCBUb0ludGVnZXIgKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMy4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWludGVnZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYlRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciB0b051bWJlcjIwMTYgPSBsaWJUb051bWJlci50b051bWJlcjIwMTY7XG52YXIgdG9OdW1iZXIyMDE4ID0gbGliVG9OdW1iZXIudG9OdW1iZXIyMDE4O1xudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbnZhciBudW1iZXJJc0Zpbml0ZSA9IHJlcXVpcmUoJ2lzLWZpbml0ZS14Jyk7XG52YXIgbGliTWF0aFNpZ24gPSByZXF1aXJlKCdtYXRoLXNpZ24teCcpO1xudmFyIG1hdGhTaWduMjAxNiA9IGxpYk1hdGhTaWduLnNpZ24yMDE2O1xudmFyIG1hdGhTaWduMjAxOCA9IGxpYk1hdGhTaWduLnNpZ24yMDE4O1xudmFyIG1hdGhGbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG52YXIgJHRvSW50ZWdlcjIwMTYgPSBmdW5jdGlvbiB0b0ludGVnZXIyMDE2KHZhbHVlKSB7XG4gIHZhciBudW1iZXIgPSB0b051bWJlcjIwMTYodmFsdWUpO1xuICBpZiAobnVtYmVySXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gMCB8fCBudW1iZXJJc0Zpbml0ZShudW1iZXIpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICByZXR1cm4gbWF0aFNpZ24yMDE2KG51bWJlcikgKiBtYXRoRmxvb3IobWF0aEFicyhudW1iZXIpKTtcbn07XG5cbnZhciAkdG9JbnRlZ2VyMjAxOCA9IGZ1bmN0aW9uIHRvSW50ZWdlcjIwMTgodmFsdWUpIHtcbiAgdmFyIG51bWJlciA9IHRvTnVtYmVyMjAxOCh2YWx1ZSk7XG4gIGlmIChudW1iZXJJc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobnVtYmVyID09PSAwIHx8IG51bWJlcklzRmluaXRlKG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBtYXRoU2lnbjIwMTgobnVtYmVyKSAqIG1hdGhGbG9vcihtYXRoQWJzKG51bWJlcikpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdG9JbnRlZ2VyMjAxOC5cbiAgICovXG4gIHRvSW50ZWdlcjogJHRvSW50ZWdlcjIwMTgsXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci4gKEVTMjAxNilcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTY7XG4gICAqIHRvSW50ZWdlcigzKTsgLy8gM1xuICAgKiB0b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7IC8vIDBcbiAgICogdG9JbnRlZ2VyKEluZmluaXR5KTsgLy8gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICogdG9JbnRlZ2VyKCczJyk7IC8vIDNcbiAgICovXG4gIHRvSW50ZWdlcjIwMTY6ICR0b0ludGVnZXIyMDE2LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuIChFUzIwMTgpXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCd0by1pbnRlZ2VyLXgnKS50b0ludGVnZXIyMDE4O1xuICAgKiB0b0ludGVnZXIoMyk7IC8vIDNcbiAgICogdG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpOyAvLyAwXG4gICAqIHRvSW50ZWdlcihJbmZpbml0eSk7IC8vIDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAqIHRvSW50ZWdlcignMycpOyAvLyAzXG4gICAqL1xuICB0b0ludGVnZXIyMDE4OiAkdG9JbnRlZ2VyMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgU2hpbSBmb3IgVG9MZW5ndGguXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGh8Ny4xLjE1IFRvTGVuZ3RoICggYXJndW1lbnQgKX1cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1sZW5ndGgteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYlRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpO1xudmFyIHRvSW50ZWdlcjIwMTYgPSBsaWJUb0ludGVnZXIudG9JbnRlZ2VyMjAxNjtcbnZhciB0b0ludGVnZXIyMDE4ID0gbGliVG9JbnRlZ2VyLnRvSW50ZWdlcjIwMTg7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IHJlcXVpcmUoJ21heC1zYWZlLWludGVnZXInKTtcblxudmFyICR0b0xlbmd0aDIwMTYgPSBmdW5jdGlvbiB0b0xlbmd0aDIwMTYodmFsdWUpIHtcbiAgdmFyIGxlbiA9IHRvSW50ZWdlcjIwMTYodmFsdWUpO1xuICAvLyBpbmNsdWRlcyBjb252ZXJ0aW5nIC0wIHRvICswXG4gIGlmIChsZW4gPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59O1xuXG52YXIgJHRvTGVuZ3RoMjAxOCA9IGZ1bmN0aW9uIHRvTGVuZ3RoMjAxOCh2YWx1ZSkge1xuICB2YXIgbGVuID0gdG9JbnRlZ2VyMjAxOCh2YWx1ZSk7XG4gIC8vIGluY2x1ZGVzIGNvbnZlcnRpbmcgLTAgdG8gKzBcbiAgaWYgKGxlbiA8PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobGVuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRvTGVuZ3RoMjAxOC5cbiAgICovXG4gIHRvTGVuZ3RoOiAkdG9MZW5ndGgyMDE4LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAqIGFycmF5LWxpa2Ugb2JqZWN0LiAoRVMyMDE2KVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpLnRvTGVuZ3RoMjAxNjtcbiAgICogdG9MZW5ndGgoMyk7IC8vIDNcbiAgICogdG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7IC8vIDBcbiAgICogdG9MZW5ndGgoSW5maW5pdHkpOyAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgKiB0b0xlbmd0aCgnMycpOyAvLyAzXG4gICAqL1xuICB0b0xlbmd0aDIwMTY6ICR0b0xlbmd0aDIwMTYsXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICogYXJyYXktbGlrZSBvYmplY3QuIChFUzIwMTgpXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14JykudG9MZW5ndGgyMDE4O1xuICAgKiB0b0xlbmd0aCgzKTsgLy8gM1xuICAgKiB0b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gMFxuICAgKiB0b0xlbmd0aChJbmZpbml0eSk7IC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAqIHRvTGVuZ3RoKCczJyk7IC8vIDNcbiAgICovXG4gIHRvTGVuZ3RoMjAxODogJHRvTGVuZ3RoMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgQ29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci5cbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1udW1iZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhY2hlZEN0cnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbnZhciBjYXN0TnVtYmVyID0gY2FjaGVkQ3Rycy5OdW1iZXI7XG52YXIgUnggPSBjYWNoZWRDdHJzLlJlZ0V4cDtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ3RvLXByaW1pdGl2ZS14Jyk7XG52YXIgbGliVHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xudmFyIHRyaW0yMDE2ID0gbGliVHJpbS50cmltMjAxNjtcbnZhciB0cmltMjAxOCA9IGxpYlRyaW0udHJpbTIwMTg7XG52YXIgbGliUGFyc2VJbnQgPSByZXF1aXJlKCdwYXJzZS1pbnQteCcpO1xudmFyICRwYXJzZUludDIwMTYgPSBsaWJQYXJzZUludC5wYXJzZUludDIwMTY7XG52YXIgJHBhcnNlSW50MjAxOCA9IGxpYlBhcnNlSW50LnBhcnNlSW50MjAxODtcbnZhciBwU3RyU2xpY2UgPSBjYWNoZWRDdHJzLlN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgTkFOID0gcmVxdWlyZSgnbmFuLXgnKTtcblxudmFyIGJpbmFyeVJlZ2V4ID0gL14wYlswMV0rJC9pO1xuLy8gTm90ZSB0aGF0IGluIElFIDgsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCBkb2Vzbid0IHNlZW0gdG8gZXhpc3Q6IGllLCBcInRlc3RcIiBpc1xuLy8gYW4gb3duIHByb3BlcnR5IG9mIHJlZ2V4ZXMuIHd0Zi5cbnZhciB0ZXN0ID0gYmluYXJ5UmVnZXgudGVzdDtcbnZhciBpc0JpbmFyeSA9IGZ1bmN0aW9uIF9pc0JpbmFyeSh2YWx1ZSkge1xuICByZXR1cm4gdGVzdC5jYWxsKGJpbmFyeVJlZ2V4LCB2YWx1ZSk7XG59O1xuXG52YXIgb2N0YWxSZWdleCA9IC9eMG9bMC03XSskL2k7XG52YXIgaXNPY3RhbCA9IGZ1bmN0aW9uIF9pc09jdGFsKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwob2N0YWxSZWdleCwgdmFsdWUpO1xufTtcblxudmFyIG5vbldTcmVnZXgyMDE2ID0gbmV3IFJ4KCdbXFx1MDA4NVxcdTIwMGJcXHVmZmZlXScsICdnJyk7XG52YXIgaGFzTm9uV1MyMDE2ID0gZnVuY3Rpb24gX2hhc05vbldTKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwobm9uV1NyZWdleDIwMTYsIHZhbHVlKTtcbn07XG5cbnZhciBub25XU3JlZ2V4MjAxOCA9IG5ldyBSeCgnW1xcdTAwODVcXHUxODBlXFx1MjAwYlxcdWZmZmVdJywgJ2cnKTtcbnZhciBoYXNOb25XUzIwMTggPSBmdW5jdGlvbiBfaGFzTm9uV1ModmFsdWUpIHtcbiAgcmV0dXJuIHRlc3QuY2FsbChub25XU3JlZ2V4MjAxOCwgdmFsdWUpO1xufTtcblxudmFyIGludmFsaWRIZXhMaXRlcmFsID0gL15bLStdMHhbMC05YS1mXSskL2k7XG52YXIgaXNJbnZhbGlkSGV4TGl0ZXJhbCA9IGZ1bmN0aW9uIF9pc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoaW52YWxpZEhleExpdGVyYWwsIHZhbHVlKTtcbn07XG5cbnZhciAkdG9OdW1iZXIyMDE2ID0gZnVuY3Rpb24gdG9OdW1iZXIyMDE2KGFyZ3VtZW50KSB7XG4gIHZhciB2YWx1ZSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBOdW1iZXIpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc0JpbmFyeSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b051bWJlcjIwMTYoJHBhcnNlSW50MjAxNihwU3RyU2xpY2UuY2FsbCh2YWx1ZSwgMiksIDIpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPY3RhbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b051bWJlcjIwMTYoJHBhcnNlSW50MjAxNihwU3RyU2xpY2UuY2FsbCh2YWx1ZSwgMiksIDgpKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzTm9uV1MyMDE2KHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5BTjtcbiAgICB9XG5cbiAgICB2YXIgdHJpbW1lZCA9IHRyaW0yMDE2KHZhbHVlKTtcbiAgICBpZiAodHJpbW1lZCAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0b051bWJlcjIwMTYodHJpbW1lZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhc3ROdW1iZXIodmFsdWUpO1xufTtcblxudmFyICR0b051bWJlcjIwMTggPSBmdW5jdGlvbiB0b051bWJlcjIwMTgoYXJndW1lbnQpIHtcbiAgdmFyIHZhbHVlID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIE51bWJlcik7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyMjAxOCgkcGFyc2VJbnQyMDE4KHBTdHJTbGljZS5jYWxsKHZhbHVlLCAyKSwgMikpO1xuICAgIH1cblxuICAgIGlmIChpc09jdGFsKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyMjAxOCgkcGFyc2VJbnQyMDE4KHBTdHJTbGljZS5jYWxsKHZhbHVlLCAyKSwgOCkpO1xuICAgIH1cblxuICAgIGlmIChoYXNOb25XUzIwMTgodmFsdWUpIHx8IGlzSW52YWxpZEhleExpdGVyYWwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTkFOO1xuICAgIH1cblxuICAgIHZhciB0cmltbWVkID0gdHJpbTIwMTgodmFsdWUpO1xuICAgIGlmICh0cmltbWVkICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyMjAxOCh0cmltbWVkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FzdE51bWJlcih2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIHJlZmVyZW5jZSB0byB0b051bWJlcjIwMTguXG4gICAqL1xuICB0b051bWJlcjogJHRvTnVtYmVyMjAxOCxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci4gKEVTMjAxNilcblxuICAgKiBAcGFyYW0geyp9IGFyZ3VtZW50IC0gVGhlIGFyZ3VtZW50IHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gLSBJZiBhcmd1bWVudCBpcyBhIFN5bWJvbCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFyZ3VtZW50IGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKS50b051bWJlcjIwMTY7XG4gICAqXG4gICAqIHRvTnVtYmVyKCcxJyk7IC8vIDFcbiAgICogdG9OdW1iZXIobnVsbCk7IC8vIDBcbiAgICogdG9OdW1iZXIodHJ1ZSk7IC8vIDFcbiAgICogdG9OdW1iZXIoJzBvMTAnKTsgLy8gOFxuICAgKiB0b051bWJlcignMGIxMCcpOyAvLyAyXG4gICAqIHRvTnVtYmVyKCcweEYnKTsgLy8gMTZcbiAgICpcbiAgICogdG9OdW1iZXIoJyAxICcpOyAvLyAxXG4gICAqXG4gICAqIHRvTnVtYmVyKFN5bWJvbCgnJykpIC8vIFR5cGVFcnJvclxuICAgKiB0b051bWJlcihPYmplY3QuY3JlYXRlKG51bGwpKSAvLyBUeXBlRXJyb3JcbiAgICovXG4gIHRvTnVtYmVyMjAxNjogJHRvTnVtYmVyMjAxNixcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci4gKEVTMjAxOClcblxuICAgKiBAcGFyYW0geyp9IGFyZ3VtZW50IC0gVGhlIGFyZ3VtZW50IHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gLSBJZiBhcmd1bWVudCBpcyBhIFN5bWJvbCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFyZ3VtZW50IGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKS50b051bWJlcjIwMTg7XG4gICAqXG4gICAqIHRvTnVtYmVyKCcxJyk7IC8vIDFcbiAgICogdG9OdW1iZXIobnVsbCk7IC8vIDBcbiAgICogdG9OdW1iZXIodHJ1ZSk7IC8vIDFcbiAgICogdG9OdW1iZXIoJzBvMTAnKTsgLy8gOFxuICAgKiB0b051bWJlcignMGIxMCcpOyAvLyAyXG4gICAqIHRvTnVtYmVyKCcweEYnKTsgLy8gMTZcbiAgICpcbiAgICogdG9OdW1iZXIoJyAxICcpOyAvLyAxXG4gICAqXG4gICAqIHRvTnVtYmVyKFN5bWJvbCgnJykpIC8vIFR5cGVFcnJvclxuICAgKiB0b051bWJlcihPYmplY3QuY3JlYXRlKG51bGwpKSAvLyBUeXBlRXJyb3JcbiAgICovXG4gIHRvTnVtYmVyMjAxODogJHRvTnVtYmVyMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy5cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0cmltLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsaWJUcmltTGVmdCA9IHJlcXVpcmUoJ3RyaW0tbGVmdC14Jyk7XG52YXIgdHJpbUxlZnQyMDE2ID0gbGliVHJpbUxlZnQudHJpbUxlZnQyMDE2O1xudmFyIHRyaW1MZWZ0MjAxOCA9IGxpYlRyaW1MZWZ0LnRyaW1MZWZ0MjAxODtcbnZhciBsaWJUcmltUmlnaHQgPSByZXF1aXJlKCd0cmltLXJpZ2h0LXgnKTtcbnZhciB0cmltUmlnaHQyMDE2ID0gbGliVHJpbVJpZ2h0LnRyaW1SaWdodDIwMTY7XG52YXIgdHJpbVJpZ2h0MjAxOCA9IGxpYlRyaW1SaWdodC50cmltUmlnaHQyMDE2O1xuXG52YXIgJHRyaW0yMDE2ID0gZnVuY3Rpb24gdHJpbTIwMTYoc3RyaW5nKSB7XG4gIHJldHVybiB0cmltTGVmdDIwMTYodHJpbVJpZ2h0MjAxNihzdHJpbmcpKTtcbn07XG5cbnZhciAkdHJpbTIwMTggPSBmdW5jdGlvbiB0cmltMjAxOChzdHJpbmcpIHtcbiAgcmV0dXJuIHRyaW1MZWZ0MjAxOCh0cmltUmlnaHQyMDE4KHN0cmluZykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0cmltMjAxOC5cbiAgICovXG4gIHRyaW06ICR0cmltMjAxOCxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy5cbiAgICogKEVTMjAxNilcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHN0cmluZyBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0cmltID0gcmVxdWlyZSgndHJpbS14Jyk7XG4gICAqXG4gICAqIHRyaW0oJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSc7IC8vIHRydWVcbiAgICovXG4gIHRyaW0yMDE2OiAkdHJpbTIwMTYsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gICAqIChFUzIwMTgpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIHRyaW0gdGhlIHdoaXRlc3BhY2UgZnJvbS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xuICAgKlxuICAgKiB0cmltKCcgXFx0XFxuYSBcXHRcXG4nKSA9PT0gJ2EnOyAvLyB0cnVlXG4gICAqL1xuICB0cmltMjAxODogJHRyaW0yMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZmluZC1pbmRleC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcEZpbmRJbmRleCA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID09PSAnZnVuY3Rpb24nICYmIEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXg7XG5cbnZhciBpc1dvcmtpbmc7XG5pZiAocEZpbmRJbmRleCkge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICB2YXIgdGVzdEFyciA9IFtdO1xuICB0ZXN0QXJyLmxlbmd0aCA9IDI7XG4gIHRlc3RBcnJbMV0gPSAxO1xuICB2YXIgcmVzID0gYXR0ZW1wdC5jYWxsKHRlc3RBcnIsIHBGaW5kSW5kZXgsIGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICByZXR1cm4gaWR4ID09PSAwO1xuICB9KTtcblxuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMDtcblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKDEsIHBGaW5kSW5kZXgsIGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgIHJldHVybiBpZHggPT09IDA7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gLTE7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgaXNXb3JraW5nID0gYXR0ZW1wdC5jYWxsKFtdLCBwRmluZEluZGV4KS50aHJldztcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoJ2FiYycsIHBGaW5kSW5kZXgsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSA9PT0gJ2MnO1xuICAgIH0pO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgPT09IDI7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgIH0oJ2EnLCAnYicsICdjJykpLCBwRmluZEluZGV4LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gPT09ICdjJztcbiAgICB9KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSAyO1xuICB9XG59XG5cbnZhciBmaW5kSWR4O1xuaWYgKGlzV29ya2luZykge1xuICBmaW5kSWR4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gW2NhbGxiYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBGaW5kSW5kZXguYXBwbHkoYXJyYXksIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbiAgdmFyIGFzc2VydElzRnVuY3Rpb24gPSByZXF1aXJlKCdhc3NlcnQtaXMtZnVuY3Rpb24teCcpO1xuICB2YXIgc3BsaXRJZkJveGVkQnVnID0gcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcblxuICBmaW5kSWR4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gICAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsYmFjayk7XG4gICAgdmFyIGl0ZXJhYmxlID0gc3BsaXRJZkJveGVkQnVnKG9iamVjdCk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0FyZztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuXG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cblxuLyoqXG4gKiBMaWtlIGBmaW5kSW5kZXhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIGluZGV4IGluIHRoZSBhcnJheSwgaWYgYW4gZWxlbWVudFxuICogaW4gdGhlIGFycmF5IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LFxuICogIHRha2luZyB0aHJlZSBhcmd1bWVudHM6IGBlbGVtZW50YCwgYGluZGV4YCBhbmQgYGFycmF5YC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYGNhbGxiYWNrYCBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIC0gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgaW5kZXggb2YgcG9zaXRpdmVseSB0ZXN0ZWQgZWxlbWVudCwgb3RoZXJ3aXNlIC0xLlxuICogQGV4YW1wbGVcbiAqIHZhciBmaW5kSW5kZXggPSByZXF1aXJlKCdmaW5kLWluZGV4LXgnKTtcbiAqXG4gKiBmdW5jdGlvbiBpc1ByaW1lKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICogICB2YXIgc3RhcnQgPSAyO1xuICogICB3aGlsZSAoc3RhcnQgPD0gTWF0aC5zcXJ0KGVsZW1lbnQpKSB7XG4gKiAgICAgaWYgKGVsZW1lbnQgJSBzdGFydCsrIDwgMSkge1xuICogICAgICAgcmV0dXJuIGZhbHNlO1xuICogICAgIH1cbiAqICAgfVxuICogICByZXR1cm4gZWxlbWVudCA+IDE7XG4gKiB9XG4gKlxuICogY29uc29sZS5sb2coZmluZEluZGV4KFs0LCA2LCA4LCAxMiwgMTRdLCBpc1ByaW1lKSk7IC8vIC0xLCBub3QgZm91bmRcbiAqIGNvbnNvbGUubG9nKGZpbmRJbmRleChbNCwgNiwgNywgMTIsIDEzXSwgaXNQcmltZSkpOyAvLyAyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZmluZElkeDtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy5cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0cmltLXJpZ2h0LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcgPSByZXF1aXJlKCdyZXF1aXJlLWNvZXJjaWJsZS10by1zdHJpbmcteCcpO1xudmFyIFJ4ID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuUmVnRXhwO1xudmFyIHJlUmlnaHQyMDE2ID0gbmV3IFJ4KCdbJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcyMDE2ICsgJ10rJCcpO1xudmFyIHJlUmlnaHQyMDE4ID0gbmV3IFJ4KCdbJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcyMDE4ICsgJ10rJCcpO1xudmFyIHJlcGxhY2UgPSAnJy5yZXBsYWNlO1xuXG52YXIgJHRyaW1SaWdodDIwMTYgPSBmdW5jdGlvbiB0cmltUmlnaHQyMDE2KHN0cmluZykge1xuICByZXR1cm4gcmVwbGFjZS5jYWxsKHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyhzdHJpbmcpLCByZVJpZ2h0MjAxNiwgJycpO1xufTtcblxudmFyICR0cmltUmlnaHQyMDE4ID0gZnVuY3Rpb24gdHJpbVJpZ2h0MjAxOChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlcGxhY2UuY2FsbChyZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoc3RyaW5nKSwgcmVSaWdodDIwMTgsICcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogQSByZWZlcmVuY2UgdG8gdHJpbVJpZ2h0MjAxOC5cbiAgICovXG4gIHRyaW1SaWdodDogJHRyaW1SaWdodDIwMTgsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSByaWdodCBlbmQgb2YgYSBzdHJpbmcuIChFUzIwMTYpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIHRyaW0gdGhlIHJpZ2h0IGVuZCB3aGl0ZXNwYWNlIGZyb20uXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByaWdodCB0cmltbWVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRyaW1SaWdodCA9IHJlcXVpcmUoJ3RyaW0tcmlnaHQteCcpO1xuICAgKlxuICAgKiB0cmltUmlnaHQoJyBcXHRcXG5hIFxcdFxcbicpID09PSAnIFxcdFxcbmEnOyAvLyB0cnVlXG4gICAqL1xuICB0cmltUmlnaHQyMDE2OiAkdHJpbVJpZ2h0MjAxNixcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy4gKEVTMjAxOClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgcmlnaHQgZW5kIHdoaXRlc3BhY2UgZnJvbS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJpZ2h0IHRyaW1tZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdHJpbVJpZ2h0ID0gcmVxdWlyZSgndHJpbS1yaWdodC14Jyk7XG4gICAqXG4gICAqIHRyaW1SaWdodCgnIFxcdFxcbmEgXFx0XFxuJykgPT09ICcgXFx0XFxuYSc7IC8vIHRydWVcbiAgICovXG4gIHRyaW1SaWdodDIwMTg6ICR0cmltUmlnaHQyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBMaXN0IG9mIEVDTUFTY3JpcHQgd2hpdGUgc3BhY2UgY2hhcmFjdGVycy5cbiAqIEB2ZXJzaW9uIDMuMC4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB3aGl0ZS1zcGFjZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgcmVjb3JkIG9mIGEgd2hpdGUgc3BhY2UgY2hhcmFjdGVyLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYXJSZWNvcmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gVGhlIGNoYXJhY3RlciBjb2RlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY2hhcmFjdGVyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBlczUgLSBXaGV0aGVyIHRoZSBzcGVjIGxpc3RzIHRoaXMgYXMgYSB3aGl0ZSBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXMyMDE1IC0gV2hldGhlciB0aGUgc3BlYyBsaXN0cyB0aGlzIGFzIGEgd2hpdGUgc3BhY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVzMjAxNiAtIFdoZXRoZXIgdGhlIHNwZWMgbGlzdHMgdGhpcyBhcyBhIHdoaXRlIHNwYWNlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBlczIwMTcgLSBXaGV0aGVyIHRoZSBzcGVjIGxpc3RzIHRoaXMgYXMgYSB3aGl0ZSBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXMyMDE4IC0gV2hldGhlciB0aGUgc3BlYyBsaXN0cyB0aGlzIGFzIGEgd2hpdGUgc3BhY2UuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RyaW5nIC0gVGhlIGNoYXJhY3RlciBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBBbiBhcnJheSBvZiB0aGUgd2hpdGVzcGFjZSBjaGFyIGNvZGVzLCBzdHJpbmcsIGRlc2NyaXB0aW9ucyBhbmQgbGFuZ3VhZ2VcbiAqIHByZXNlbmNlIGluIHRoZSBzcGVjaWZpY2F0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUgQXJyYXkuPENoYXJSZWNvcmQ+XG4gKi9cbnZhciBsaXN0ID0gW1xuICB7XG4gICAgY29kZTogMHgwMDA5LFxuICAgIGRlc2NyaXB0aW9uOiAnVGFiJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTAwMDknXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGEsXG4gICAgZGVzY3JpcHRpb246ICdMaW5lIEZlZWQnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MDAwYSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAwYixcbiAgICBkZXNjcmlwdGlvbjogJ1ZlcnRpY2FsIFRhYicsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUwMDBiJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgwMDBjLFxuICAgIGRlc2NyaXB0aW9uOiAnRm9ybSBGZWVkJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTAwMGMnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGQsXG4gICAgZGVzY3JpcHRpb246ICdDYXJyaWFnZSBSZXR1cm4nLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MDAwZCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAyMCxcbiAgICBkZXNjcmlwdGlvbjogJ1NwYWNlJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTAwMjAnXG4gIH0sXG4gIC8qXG4gIHtcbiAgICBjb2RlOiAweDAwODUsXG4gICAgZGVzY3JpcHRpb246ICdOZXh0IGxpbmUnLFxuICAgIGVzNTogZmFsc2UsXG4gICAgZXMyMDE1OiBmYWxzZSxcbiAgICBlczIwMTY6IGZhbHNlLFxuICAgIGVzMjAxNzogZmFsc2UsXG4gICAgZXMyMDE4OiBmYWxzZSxcbiAgICBzdHJpbmc6ICdcXHUwMDg1J1xuICB9XG4gICovXG4gIHtcbiAgICBjb2RlOiAweDAwYTAsXG4gICAgZGVzY3JpcHRpb246ICdOby1icmVhayBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUwMGEwJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgxNjgwLFxuICAgIGRlc2NyaXB0aW9uOiAnT2doYW0gc3BhY2UgbWFyaycsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUxNjgwJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgxODBlLFxuICAgIGRlc2NyaXB0aW9uOiAnTW9uZ29saWFuIHZvd2VsIHNlcGFyYXRvcicsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiBmYWxzZSxcbiAgICBlczIwMTg6IGZhbHNlLFxuICAgIHN0cmluZzogJ1xcdTE4MGUnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDAsXG4gICAgZGVzY3JpcHRpb246ICdFbiBxdWFkJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTIwMDAnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDEsXG4gICAgZGVzY3JpcHRpb246ICdFbSBxdWFkJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTIwMDEnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDIsXG4gICAgZGVzY3JpcHRpb246ICdFbiBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDAyJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDAzLFxuICAgIGRlc2NyaXB0aW9uOiAnRW0gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwMydcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNCxcbiAgICBkZXNjcmlwdGlvbjogJ1RocmVlLXBlci1lbSBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDA0J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA1LFxuICAgIGRlc2NyaXB0aW9uOiAnRm91ci1wZXItZW0gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwNSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNixcbiAgICBkZXNjcmlwdGlvbjogJ1NpeC1wZXItZW0gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwNidcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNyxcbiAgICBkZXNjcmlwdGlvbjogJ0ZpZ3VyZSBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDA3J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA4LFxuICAgIGRlc2NyaXB0aW9uOiAnUHVuY3R1YXRpb24gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwOCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwOSxcbiAgICBkZXNjcmlwdGlvbjogJ1RoaW4gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwOSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwYSxcbiAgICBkZXNjcmlwdGlvbjogJ0hhaXIgc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwYSdcbiAgfSxcbiAgLypcbiAge1xuICAgIGNvZGU6IDB4MjAwYixcbiAgICBkZXNjcmlwdGlvbjogJ1plcm8gd2lkdGggc3BhY2UnLFxuICAgIGVzNTogZmFsc2UsXG4gICAgZXMyMDE1OiBmYWxzZSxcbiAgICBlczIwMTY6IGZhbHNlLFxuICAgIGVzMjAxNzogZmFsc2UsXG4gICAgZXMyMDE4OiBmYWxzZSxcbiAgICBzdHJpbmc6ICdcXHUyMDBiJ1xuICB9LFxuICAqL1xuICB7XG4gICAgY29kZTogMHgyMDI4LFxuICAgIGRlc2NyaXB0aW9uOiAnTGluZSBzZXBhcmF0b3InLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAyOCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAyOSxcbiAgICBkZXNjcmlwdGlvbjogJ1BhcmFncmFwaCBzZXBhcmF0b3InLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAyOSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAyZixcbiAgICBkZXNjcmlwdGlvbjogJ05hcnJvdyBuby1icmVhayBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDJmJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDVmLFxuICAgIGRlc2NyaXB0aW9uOiAnTWVkaXVtIG1hdGhlbWF0aWNhbCBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDVmJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgzMDAwLFxuICAgIGRlc2NyaXB0aW9uOiAnSWRlb2dyYXBoaWMgc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MzAwMCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4ZmVmZixcbiAgICBkZXNjcmlwdGlvbjogJ0J5dGUgT3JkZXIgTWFyaycsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHVmZWZmJ1xuICB9XG5dO1xuXG52YXIgc3RyaW5nRVMyMDE2ID0gJyc7XG52YXIgc3RyaW5nRVMyMDE4ID0gJyc7XG52YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gIGlmIChsaXN0W2ldLmVzMjAxNikge1xuICAgIHN0cmluZ0VTMjAxNiArPSBsaXN0W2ldLnN0cmluZztcbiAgfVxuXG4gIGlmIChsaXN0W2ldLmVzMjAxOCkge1xuICAgIHN0cmluZ0VTMjAxOCArPSBsaXN0W2ldLnN0cmluZztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHRoZSB3aGl0ZXNwYWNlIGNoYXIgY29kZXMsIHN0cmluZywgZGVzY3JpcHRpb25zIGFuZCBsYW5ndWFnZVxuICAgKiBwcmVzZW5jZSBpbiB0aGUgc3BlY2lmaWNhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIEFycmF5LjxDaGFyUmVjb3JkPlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgd2hpdGVTcGFjZSA9IHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKTtcbiAgICogd2hpdGVTcGFjZXMubGlzdC5mb3JlYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAqICAgY29uc29sZS5sb2cobGliLmRlc2NyaXB0aW9uLCBpdGVtLmNvZGUsIGl0ZW0uc3RyaW5nKTtcbiAgICogfSk7XG4gICAqL1xuICBsaXN0OiBsaXN0LFxuICAvKipcbiAgICogQSBzdHJpbmcgb2YgdGhlIEVTMjAxNyB0byBFUzIwMTggd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAdHlwZSBzdHJpbmdcbiAgICovXG4gIHN0cmluZzogc3RyaW5nRVMyMDE4LFxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB0aGUgRVM1IHRvIEVTMjAxNiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5nNTogc3RyaW5nRVMyMDE2LFxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB0aGUgRVM1IHRvIEVTMjAxNiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5nMjAxNTogc3RyaW5nRVMyMDE2LFxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB0aGUgRVM1IHRvIEVTMjAxNiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgd2hpdGVTcGFjZSA9IHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKTtcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgJ1xcdTAwMDknLFxuICAgKiAgICdcXHUwMDBhJyxcbiAgICogICAnXFx1MDAwYicsXG4gICAqICAgJ1xcdTAwMGMnLFxuICAgKiAgICdcXHUwMDBkJyxcbiAgICogICAnXFx1MDAyMCcsXG4gICAqICAgJ1xcdTAwYTAnLFxuICAgKiAgICdcXHUxNjgwJyxcbiAgICogICAnXFx1MTgwZScsXG4gICAqICAgJ1xcdTIwMDAnLFxuICAgKiAgICdcXHUyMDAxJyxcbiAgICogICAnXFx1MjAwMicsXG4gICAqICAgJ1xcdTIwMDMnLFxuICAgKiAgICdcXHUyMDA0JyxcbiAgICogICAnXFx1MjAwNScsXG4gICAqICAgJ1xcdTIwMDYnLFxuICAgKiAgICdcXHUyMDA3JyxcbiAgICogICAnXFx1MjAwOCcsXG4gICAqICAgJ1xcdTIwMDknLFxuICAgKiAgICdcXHUyMDBhJyxcbiAgICogICAnXFx1MjAyOCcsXG4gICAqICAgJ1xcdTIwMjknLFxuICAgKiAgICdcXHUyMDJmJyxcbiAgICogICAnXFx1MjA1ZicsXG4gICAqICAgJ1xcdTMwMDAnLFxuICAgKiAgICdcXHVmZWZmJ1xuICAgKiBdO1xuICAgKiB2YXIgd3MgPSBjaGFyYWN0ZXJzLmpvaW4oJycpO1xuICAgKiB2YXIgcmUxID0gbmV3IFJlZ0V4cCgnXlsnICsgd2hpdGVTcGFjZS5zdHJpbmcyMDE2ICsgJ10rJCknKTtcbiAgICogcmUxLnRlc3Qod3MpOyAvLyB0cnVlXG4gICAqL1xuICBzdHJpbmcyMDE2OiBzdHJpbmdFUzIwMTYsXG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHRoZSBFUzIwMTcgdG8gRVMyMDE4IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHR5cGUgc3RyaW5nXG4gICAqL1xuICBzdHJpbmcyMDE3OiBzdHJpbmdFUzIwMTgsXG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHRoZSBFUzIwMTcgdG8gRVMyMDE4IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHR5cGUgc3RyaW5nXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB3aGl0ZVNwYWNlID0gcmVxdWlyZSgnd2hpdGUtc3BhY2UteCcpO1xuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICAnXFx1MDAwOScsXG4gICAqICAgJ1xcdTAwMGEnLFxuICAgKiAgICdcXHUwMDBiJyxcbiAgICogICAnXFx1MDAwYycsXG4gICAqICAgJ1xcdTAwMGQnLFxuICAgKiAgICdcXHUwMDIwJyxcbiAgICogICAnXFx1MDBhMCcsXG4gICAqICAgJ1xcdTE2ODAnLFxuICAgKiAgICdcXHUyMDAwJyxcbiAgICogICAnXFx1MjAwMScsXG4gICAqICAgJ1xcdTIwMDInLFxuICAgKiAgICdcXHUyMDAzJyxcbiAgICogICAnXFx1MjAwNCcsXG4gICAqICAgJ1xcdTIwMDUnLFxuICAgKiAgICdcXHUyMDA2JyxcbiAgICogICAnXFx1MjAwNycsXG4gICAqICAgJ1xcdTIwMDgnLFxuICAgKiAgICdcXHUyMDA5JyxcbiAgICogICAnXFx1MjAwYScsXG4gICAqICAgJ1xcdTIwMjgnLFxuICAgKiAgICdcXHUyMDI5JyxcbiAgICogICAnXFx1MjAyZicsXG4gICAqICAgJ1xcdTIwNWYnLFxuICAgKiAgICdcXHUzMDAwJyxcbiAgICogICAnXFx1ZmVmZidcbiAgICogXTtcbiAgICogdmFyIHdzID0gY2hhcmFjdGVycy5qb2luKCcnKTtcbiAgICogdmFyIHJlMSA9IG5ldyBSZWdFeHAoJ15bJyArIHdoaXRlU3BhY2Uuc3RyaW5nMjAxOCArICddKyQpJyk7XG4gICAqIHJlMS50ZXN0KHdzKTsgLy8gdHJ1ZVxuICAgKi9cbiAgc3RyaW5nMjAxODogc3RyaW5nRVMyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUaGUgY29uc3RhbnQgdmFsdWUgSW5maW5pdHkuXG4gKiBAdmVyc2lvbiAxLjAuMlxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaW5maW5pdHkteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgY29uc3RhbnQgdmFsdWUgSW5maW5pdHkgZGVyaXZlZCBtYXRoZW1hdGljYWxseSBieSAxIC8gMC5cbiAqXG4gKiBAdHlwZSBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiB2YXIgSU5GSU5JVFkgPSByZXF1aXJlKCdpbmZpbml0eS14Jyk7XG4gKlxuICogSU5GSU5JVFkgPT09IEluZmluaXR5OyAvLyB0cnVlXG4gKiAtSU5GSU5JVFkgPT09IC1JbmZpbml0eTsgLy8gdHJ1ZVxuICogSU5GSU5JVFkgPT09IC1JbmZpbml0eTsgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAxIC8gMDtcbiIsIi8qKlxuICogQGZpbGUgQW4gaW1wbGVtZW50YXRpb24gb2Ygbm9kZSdzIEVTNiBpbnNwZWN0IG1vZHVsZS5cbiAqIEB2ZXJzaW9uIDEuOS4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3V0aWwuaHRtbCN1dGlsX3V0aWxfaW5zcGVjdF9vYmplY3Rfb3B0aW9uc1xuICogQG1vZHVsZSBpbnNwZWN0LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciBpc0FzeW5jRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1hc3luYy1mdW5jdGlvbi14Jyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCdpcy1yZWdleCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCdvYmplY3QtZGVmaW5lLXByb3BlcnRpZXMteCcpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ2lzLWFycmF5LWJ1ZmZlci14Jyk7XG52YXIgaXNTZXQgPSByZXF1aXJlKCdpcy1zZXQteCcpO1xudmFyIGlzTWFwID0gcmVxdWlyZSgnaXMtbWFwLXgnKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xudmFyIGlzRGF0YVZpZXcgPSByZXF1aXJlKCdpcy1kYXRhLXZpZXcteCcpO1xudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG52YXIgaXNOaWwgPSByZXF1aXJlKCdpcy1uaWwteCcpO1xudmFyIGlzTnVsbCA9IHJlcXVpcmUoJ2xvZGFzaC5pc251bGwnKTtcbnZhciBpc0Vycm9yID0gcmVxdWlyZSgnaXMtZXJyb3IteCcpO1xudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbnZhciBpc1Byb21pc2UgPSByZXF1aXJlKCdpcy1wcm9taXNlJyk7XG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2lzLW51bWJlci1vYmplY3QnKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCdpcy1ib29sZWFuLW9iamVjdCcpO1xudmFyIGlzTmVnWmVybyA9IHJlcXVpcmUoJ2lzLW5lZ2F0aXZlLXplcm8nKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJ2lzLXN5bWJvbCcpO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnaXMtcHJpbWl0aXZlJyk7XG52YXIgZ2V0RnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnZ2V0LWZ1bmN0aW9uLW5hbWUteCcpO1xudmFyIGhhc1N5bWJvbFN1cHBvcnQgPSByZXF1aXJlKCdoYXMtc3ltYm9sLXN1cHBvcnQteCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xudmFyIHdoaXRlU3BhY2UgPSByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jyk7XG52YXIgcmVTaW5nbGUgPSBuZXcgUmVnRXhwKCdcXFxce1snICsgd2hpdGVTcGFjZS5zdHJpbmcgKyAnXStcXFxcfScpO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNTZXQobmV3IFNldCgpKTtcbnZhciB0ZXN0U2V0ID0gaGFzU2V0ICYmIG5ldyBTZXQoWydTZXRTZW50aW5lbCddKTtcbnZhciBzRm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgc1ZhbHVlcyA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLnZhbHVlcztcbnZhciBoYXNNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIGlzTWFwKG5ldyBNYXAoKSk7XG52YXIgdGVzdE1hcCA9IGhhc01hcCAmJiBuZXcgTWFwKFtbMSwgJ01hcFNlbnRpbmVsJ11dKTtcbnZhciBtRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgbVZhbHVlcyA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLnZhbHVlcztcbnZhciBwU3ltVG9TdHIgPSBoYXNTeW1ib2xTdXBwb3J0ICYmIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcFN5bVZhbE9mID0gaGFzU3ltYm9sU3VwcG9ydCAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4LW9mLXgnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdhcnJheS1yZWR1Y2UteCcpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCdhcnJheS1mb3ItZWFjaC14Jyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnYXJyYXktZmlsdGVyLXgnKTtcbnZhciByZWZsZWN0T3duS2V5cyA9IHJlcXVpcmUoJ3JlZmxlY3Qtb3duLWtleXMteCcpO1xudmFyICRzdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uMycpLnN0cmluZ2lmeTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzLXgnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCdvYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLXgnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdnZXQtcHJvdG90eXBlLW9mLXgnKTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyICRpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJ2FycmF5LWluY2x1ZGVzLXgnKTtcbnZhciAkYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbi14Jyk7XG52YXIgJGlzTmFOID0gcmVxdWlyZSgnaXMtbmFuJyk7XG52YXIgcFJlZ0V4cFRvU3RyaW5nID0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBwRXJyb3JUb1N0cmluZyA9IEVycm9yLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBwTnVtYmVyVG9TdHJpbmcgPSBOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHBCb29sZWFuVG9TdHJpbmcgPSBCb29sZWFuLnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJ3RvLWlzby1zdHJpbmcteCcpO1xudmFyIGNvbGxlY3Rpb25zID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14Jyk7XG4vLyB2YXIgaGFzVG9TdHJpbmdUYWcgPSBoYXNTeW1ib2xTdXBwb3J0ICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGJwZSA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG52YXIgaW5zcGVjdDtcbnZhciBmbXRWYWx1ZTtcblxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSBoYXNTeW1ib2xTdXBwb3J0ID8gU3ltYm9sKCdpbnNwZWN0LmN1c3RvbScpIDogJ19pbnNwZWN0LmN1c3RvbV8nO1xuXG52YXIgc3VwcG9ydHNDbGFzc2VzO1xudHJ5IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIG5ldyBGdW5jdGlvbigncmV0dXJuIGNsYXNzIE15IHt9JykoKTtcbiAgc3VwcG9ydHNDbGFzc2VzID0gdHJ1ZTtcbn0gY2F0Y2ggKGUpIHt9XG5cbnZhciBzdXBwb3J0c0dldFNldDtcbnRyeSB7XG4gIHZhciB0ZXN0VmFyO1xuICB2YXIgdGVzdE9iamVjdCA9IGRlZmluZVByb3BlcnR5KHt9LCAnZGVmYXVsdE9wdGlvbnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBfZ2V0KCkge1xuICAgICAgcmV0dXJuIHRlc3RWYXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIF9zZXQodmFsKSB7XG4gICAgICB0ZXN0VmFyID0gdmFsO1xuICAgICAgcmV0dXJuIHRlc3RWYXI7XG4gICAgfVxuICB9KTtcblxuICB0ZXN0T2JqZWN0LmRlZmF1bHRPcHRpb25zID0gJ3Rlc3QnO1xuICBzdXBwb3J0c0dldFNldCA9IHRlc3RWYXIgPT09ICd0ZXN0JyAmJiB0ZXN0T2JqZWN0LmRlZmF1bHRPcHRpb25zID09PSAndGVzdCc7XG59IGNhdGNoIChpZ25vcmUpIHt9XG5cbnZhciAkc2VhbCA9IGlzRnVuY3Rpb24oT2JqZWN0LnNlYWwpID8gT2JqZWN0LnNlYWwgOiBmdW5jdGlvbiBzZWFsKG9iaikge1xuICByZXR1cm4gb2JqO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBpc0Z1bmN0aW9uKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5pZiAoJGdldE93blByb3BlcnR5U3ltYm9scykge1xuICB0cnkge1xuICAgIHZhciBnT1BTeW1ib2wgPSBoYXNTeW1ib2xTdXBwb3J0ICYmIFN5bWJvbCgnJyk7XG4gICAgdmFyIGdPUFNPYmogPSB7IGE6IDEgfTtcbiAgICBnT1BTT2JqW2dPUFN5bWJvbF0gPSAyO1xuXG4gICAgdmFyIGdPUFN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzKGdPUFNPYmopO1xuICAgIGlmIChnT1BTeW1ib2wpIHtcbiAgICAgIGlmIChnT1BTeW1ib2xzLmxlbmd0aCAhPT0gMSB8fCBnT1BTeW1ib2xzWzBdICE9PSBnT1BTeW1ib2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmF2bGlkIHJlc3VsdCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ09QU3ltYm9scy5sZW5ndGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5hdmxpZCByZXN1bHQnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBudWxsO1xuICB9XG59XG5cbnZhciBtaXNzaW5nRXJyb3I7XG52YXIgZXJyUHJvcHM7XG50cnkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Rlc3QnKTtcbn0gY2F0Y2ggKGUpIHtcbiAgZXJyUHJvcHMgPSAka2V5cyhlKTtcbiAgZm9yRWFjaCgka2V5cyhuZXcgRXJyb3IoKSksIGZ1bmN0aW9uIF9wdXNoZXIocCkge1xuICAgIGlmICgkaW5jbHVkZXMoZXJyUHJvcHMsIHApID09PSBmYWxzZSkge1xuICAgICAgZXJyUHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlcnJvclN0cmluZyA9IHBFcnJvclRvU3RyaW5nLmNhbGwoZSk7XG4gIHZhciBlcnJvclN0YWNrID0gZS5zdGFjaztcbiAgaWYgKGVycm9yU3RhY2spIHtcbiAgICB2YXIgZXJyb3JSeCA9IG5ldyBSZWdFeHAoJ14nICsgZXJyb3JTdHJpbmcpO1xuICAgIGlmIChlcnJvclJ4LnRlc3QoZXJyb3JTdGFjaykgPT09IGZhbHNlKSB7XG4gICAgICBtaXNzaW5nRXJyb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5pZiAoaXNEYXRlKERhdGUucHJvdG90eXBlKSkge1xuICBpc0RhdGUgPSBmdW5jdGlvbiBfaXNEYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGRhdGVQcm9wcyA9ICRrZXlzKERhdGUpO1xudmFyIHNoaW1tZWREYXRlO1xuaWYgKGRhdGVQcm9wcy5sZW5ndGggJiYgJGluY2x1ZGVzKGRhdGVQcm9wcywgJ25vdycpICYmICRpbmNsdWRlcyhkYXRlUHJvcHMsICdVVEMnKSAmJiAkaW5jbHVkZXMoZGF0ZVByb3BzLCAncGFyc2UnKSkge1xuICBzaGltbWVkRGF0ZSA9ICRpbmNsdWRlcygka2V5cyhuZXcgRGF0ZSgpKSwgJ2NvbnN0cnVjdG9yJyk7XG59XG5cbnZhciBpbnNwZWN0RGVmYXVsdE9wdGlvbnMgPSAkc2VhbCh7XG4gIGJyZWFrTGVuZ3RoOiA2MCxcbiAgY29sb3JzOiBmYWxzZSxcbiAgY3VzdG9tSW5zcGVjdDogdHJ1ZSxcbiAgZGVwdGg6IDIsXG4gIG1heEFycmF5TGVuZ3RoOiAxMDAsXG4gIHNob3dIaWRkZW46IGZhbHNlLFxuICBzaG93UHJveHk6IGZhbHNlXG59KTtcblxudmFyIGlzQm9vbGVhblR5cGUgPSBmdW5jdGlvbiBfaXNCb29sZWFuVHlwZShhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn07XG5cbnZhciBpc051bWJlclR5cGUgPSBmdW5jdGlvbiBfaXNOdW1iZXJUeXBlKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59O1xuXG52YXIgaXNTdHJpbmdUeXBlID0gZnVuY3Rpb24gX2lzU3RyaW5nVHlwZShhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufTtcblxudmFyIGlzU3ltYm9sVHlwZSA9IGZ1bmN0aW9uIF9pc1N5bWJvbFR5cGUoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn07XG5cbnZhciBpc01hcEl0ZXJhdG9yID0gZnVuY3Rpb24gX2lzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgaWYgKGhhc01hcCA9PT0gZmFsc2UgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB2YWx1ZS5uZXh0LmNhbGwobVZhbHVlcy5jYWxsKHRlc3RNYXApKS52YWx1ZSA9PT0gJ01hcFNlbnRpbmVsJztcbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpc1NldEl0ZXJhdG9yID0gZnVuY3Rpb24gX2lzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgaWYgKGhhc1NldCA9PT0gZmFsc2UgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB2YWx1ZS5uZXh0LmNhbGwoc1ZhbHVlcy5jYWxsKHRlc3RTZXQpKS52YWx1ZSA9PT0gJ1NldFNlbnRpbmVsJztcbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBmaWx0ZXJJbmRleGVzID0gZnVuY3Rpb24gX2ZpbHRlckluZGV4ZXMoa2V5cywgbGVuZ3RoKSB7XG4gIHZhciBpID0ga2V5cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoaSA+IC0xKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA+IC0xICYmIGtleSAlIDEgPT09IDAgJiYga2V5IDwgbGVuZ3RoICYmIGlzU3ltYm9sVHlwZShrZXkpID09PSBmYWxzZSkge1xuICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgaSAtPSAxO1xuICB9XG59O1xuXG52YXIgcHVzaFVuaXEgPSBmdW5jdGlvbiBfcHVzaFVuaXEoYXJyLCB2YWx1ZSkge1xuICBpZiAoJGluY2x1ZGVzKGFyciwgdmFsdWUpID09PSBmYWxzZSkge1xuICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgfVxufTtcblxudmFyIHVuc2hpZnRVbmlxID0gZnVuY3Rpb24gX3Vuc2hpZnRVbmlxKGFyciwgdmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnIsIHZhbHVlKTtcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGFyci51bnNoaWZ0KHZhbHVlKTtcbn07XG5cbnZhciBzdHlsaXplV2l0aENvbG9yID0gZnVuY3Rpb24gX3N0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgdmFyIGNvbG9ycyA9IGluc3BlY3QuY29sb3JzW3N0eWxlXTtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGNvbG9yc1swXSArICdtJyArIHN0ciArICdcXHUwMDFiWycgKyBjb2xvcnNbMV0gKyAnbSc7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxudmFyIHN0eWxpemVOb0NvbG9yID0gZnVuY3Rpb24gX3N0eWxpemVOb0NvbG9yKHN0cikge1xuICByZXR1cm4gc3RyO1xufTtcblxudmFyIGdldE5hbWVTZXAgPSBmdW5jdGlvbiBfZ2V0TmFtZVNlcChvYmopIHtcbiAgdmFyIG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUob2JqKTtcbiAgcmV0dXJuIG5hbWUgPyAnOiAnICsgbmFtZSA6IG5hbWU7XG59O1xuXG52YXIgY29sbGVjdGlvbkVhY2ggPSBmdW5jdGlvbiBfY29sbGVjdGlvbkVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKGlzTWFwKGNvbGxlY3Rpb24pKSB7XG4gICAgbUZvckVhY2guY2FsbChjb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoaXNTZXQoY29sbGVjdGlvbikpIHtcbiAgICBzRm9yRWFjaC5jYWxsKGNvbGxlY3Rpb24sIGNhbGxiYWNrKTtcbiAgfVxufTtcblxudmFyIGdldENvbnN0cnVjdG9yT2YgPSBmdW5jdGlvbiBfZ2V0Q29uc3RydWN0b3JPZihvYmopIHtcbiAgdmFyIG8gPSBvYmo7XG4gIHZhciBtYXhMb29wID0gMTAwO1xuICB3aGlsZSAoaXNOaWwobykgPT09IGZhbHNlICYmIG1heExvb3AgPiAtMSkge1xuICAgIG8gPSBPYmplY3Qobyk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgJ2NvbnN0cnVjdG9yJyk7XG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuXG4gICAgbyA9ICRnZXRQcm90b3R5cGVPZihvKTtcbiAgICBtYXhMb29wIC09IDE7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBpc1N1YiA9IGZ1bmN0aW9uIF9pc1N1Yih2YWx1ZSkge1xuICBpZiAoc3VwcG9ydHNDbGFzc2VzICE9PSB0cnVlIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yT2YodmFsdWUpO1xuICByZXR1cm4gaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgPT09IGZhbHNlICYmIGlzRnVuY3Rpb24oY29uc3RydWN0b3IsIHRydWUpO1xufTtcblxudmFyIGdldFN1Yk5hbWUgPSBmdW5jdGlvbiBfZ2V0U3ViTmFtZSh2YWx1ZSwgbmFtZSkge1xuICBpZiAoaXNTdWIodmFsdWUpKSB7XG4gICAgdmFyIHN1Yk5hbWUgPSBnZXRGdW5jdGlvbk5hbWUoZ2V0Q29uc3RydWN0b3JPZih2YWx1ZSkpO1xuICAgIGlmIChzdWJOYW1lICYmIHN1Yk5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBzdWJOYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lID8gbmFtZSA6IGdldEZ1bmN0aW9uTmFtZShnZXRDb25zdHJ1Y3Rvck9mKHZhbHVlKSk7XG59O1xuXG52YXIgZm10TnVtYmVyID0gZnVuY3Rpb24gX2ZtdE51bWJlcihjdHgsIHZhbHVlKSB7XG4gIC8vIEZvcm1hdCAtMCBhcyAnLTAnLlxuICByZXR1cm4gY3R4LnN0eWxpemUoaXNOZWdaZXJvKHZhbHVlKSA/ICctMCcgOiBwTnVtYmVyVG9TdHJpbmcuY2FsbCh2YWx1ZSksICdudW1iZXInKTtcbn07XG5cbnZhciBmbXRQcmltaXRpdmUgPSBmdW5jdGlvbiBfZm10UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzTmlsKHZhbHVlKSkge1xuICAgIHZhciBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzdHIsIHN0cik7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdUeXBlKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAkc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKS5yZXBsYWNlKC8nL2csICdcXFxcXFwnJykucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnXFwnJyArIHNpbXBsZSArICdcXCcnLCAnc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoaXNOdW1iZXJUeXBlKHZhbHVlKSkge1xuICAgIHJldHVybiBmbXROdW1iZXIoY3R4LCB2YWx1ZSk7XG4gIH1cblxuICBpZiAoaXNCb29sZWFuVHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUocEJvb2xlYW5Ub1N0cmluZy5jYWxsKHZhbHVlKSwgJ2Jvb2xlYW4nKTtcbiAgfVxuXG4gIC8vIGVzNiBzeW1ib2wgcHJpbWl0aXZlXG4gIGlmIChpc1N5bWJvbFR5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHBTeW1Ub1N0ci5jYWxsKHZhbHVlKSwgJ3N5bWJvbCcpO1xuICB9XG5cbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5cbnZhciBmbXRQcmltTm9Db2xvciA9IGZ1bmN0aW9uIF9mbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlKSB7XG4gIHZhciBzdHlsaXplID0gY3R4LnN0eWxpemU7XG4gIGN0eC5zdHlsaXplID0gc3R5bGl6ZU5vQ29sb3I7XG4gIHZhciBzdHIgPSBmbXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGN0eC5zdHlsaXplID0gc3R5bGl6ZTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbnZhciByZWN1cnNlID0gZnVuY3Rpb24gX3JlY3Vyc2UoZGVwdGgpIHtcbiAgcmV0dXJuIGlzTnVsbChkZXB0aCkgPyBudWxsIDogZGVwdGggLSAxO1xufTtcblxuLypcbnZhciBpc0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSk7XG59O1xuKi9cblxudmFyIGlzRGlnaXRzID0gZnVuY3Rpb24gX2lzRGlnaXRzKGtleSkge1xuICByZXR1cm4gKC9eXFxkKyQvKS50ZXN0KGtleSk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGZtdFByb3AgPSBmdW5jdGlvbiBfZm10UHJvcChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleSwgYXJyKSB7XG4gIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcblxuICAvKlxuICAvLyB0aGlzIGlzIGEgZml4IGZvciBicm9rZW4gRmlyZUZveCwgc2hvdWxkIG5vdCBiZSBuZWVkZWQgd2l0aCBlczYtc2hpbVxuICBpZiAoa2V5ID09PSAnc2l6ZScgJiYgaXNDb2xsZWN0aW9uKHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNpemUpKSB7XG4gICAgZGVzYy52YWx1ZSA9IHZhbHVlLnNpemUoKTtcbiAgfVxuICAqL1xuXG4gIHZhciBuYW1lO1xuICBpZiAoJGluY2x1ZGVzKHZpc2libGVLZXlzLCBrZXkpID09PSBmYWxzZSkge1xuICAgIGlmIChrZXkgPT09IGJwZSAmJiBCb29sZWFuKHZhbHVlW2JwZV0pID09PSBmYWxzZSAmJiBpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YXIgY29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvck9mKHZhbHVlKTtcbiAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBkZXNjLnZhbHVlID0gY29uc3RydWN0b3JbYnBlXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU3ltYm9sVHlwZShrZXkpKSB7XG4gICAgICBuYW1lID0gJ1snICsgY3R4LnN0eWxpemUocFN5bVRvU3RyLmNhbGwoa2V5KSwgJ3N5bWJvbCcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHI7XG4gIGlmIChkZXNjLmdldCkge1xuICAgIHN0ciA9IGN0eC5zdHlsaXplKGRlc2Muc2V0ID8gJ1tHZXR0ZXIvU2V0dGVyXScgOiAnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICB9IGVsc2UgaWYgKGRlc2Muc2V0KSB7XG4gICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBmbXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2UoZGVwdGgpKTtcbiAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgIHZhciByeCA9IGFyciA/IC9cXG4vZyA6IC8oXnxcXG4pL2c7XG4gICAgICB2YXIgclN0ciA9IGFyciA/ICdcXG4gICcgOiAnXFxuICAgJztcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHJ4LCByU3RyKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyICYmIGlzRGlnaXRzKGtleSkpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbmFtZSA9ICRzdHJpbmdpZnkoa2V5KTtcbiAgICBpZiAoL15cIltcXHckXStcIiQvLnRlc3QobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLnNsaWNlKDEsIC0xKSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCAnXFxcXFxcJycpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKS5yZXBsYWNlKC8oXlwifFwiJCkvZywgJ1xcJycpLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG52YXIgZm10T2JqZWN0ID0gZnVuY3Rpb24gX2ZtdE9iamVjdChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIF9wdXNoZXJGbU9iamVjdChrZXkpIHtcbiAgICBvdXQucHVzaChmbXRQcm9wKGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5LCBmYWxzZSkpO1xuICB9KTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbnZhciBmbXRBcnJheSA9IGZ1bmN0aW9uIF9mbXRBcnJheShjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgdmlzaWJsZUxlbmd0aCA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IHZhbHVlLmxlbmd0aCAmJiB2aXNpYmxlTGVuZ3RoIDwgY3R4Lm1heEFycmF5TGVuZ3RoKSB7XG4gICAgdmFyIGVtcHR5SXRlbXMgPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IHZhbHVlLmxlbmd0aCAmJiBoYXNPd24odmFsdWUsIHBOdW1iZXJUb1N0cmluZy5jYWxsKGluZGV4KSkgPT09IGZhbHNlKSB7XG4gICAgICBlbXB0eUl0ZW1zICs9IDE7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cblxuICAgIGlmIChlbXB0eUl0ZW1zID4gMCkge1xuICAgICAgdmFyIGVuZGluZyA9IGVtcHR5SXRlbXMgPiAxID8gJ3MnIDogJyc7XG4gICAgICB2YXIgbWVzc2FnZSA9ICc8JyArIGVtcHR5SXRlbXMgKyAnIGVtcHR5IGl0ZW0nICsgZW5kaW5nICsgJz4nO1xuICAgICAgb3V0cHV0LnB1c2goY3R4LnN0eWxpemUobWVzc2FnZSwgJ3VuZGVmaW5lZCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goZm10UHJvcChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIHBOdW1iZXJUb1N0cmluZy5jYWxsKGluZGV4KSwgdHJ1ZSkpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICB9XG5cbiAgICB2aXNpYmxlTGVuZ3RoICs9IDE7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gaW5kZXg7XG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goJy4uLiAnICsgcmVtYWluaW5nICsgJyBtb3JlIGl0ZW0nICsgKHJlbWFpbmluZyA+IDEgPyAncycgOiAnJykpO1xuICB9XG5cbiAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiBfcHVzaGVyRm10QXJyYXkoa2V5KSB7XG4gICAgaWYgKGlzU3ltYm9sVHlwZShrZXkpIHx8IGlzRGlnaXRzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICBvdXRwdXQucHVzaChmbXRQcm9wKGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbnZhciBmbXRUeXBlZEFycmF5ID0gZnVuY3Rpb24gX2ZtdFR5cGVkQXJyYXkoY3R4LCB2YWx1ZSwgZGVwdGgsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBtYXhMZW5ndGggPSBNYXRoLm1pbihNYXRoLm1heCgwLCBjdHgubWF4QXJyYXlMZW5ndGgpLCB2YWx1ZS5sZW5ndGgpO1xuICB2YXIgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICB2YXIgb3V0cHV0ID0gbmV3IEFycmF5KG1heExlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpICs9IDEpIHtcbiAgICBvdXRwdXRbaV0gPSBmbXROdW1iZXIoY3R4LCB2YWx1ZVtpXSk7XG4gIH1cblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKCcuLi4gJyArIHJlbWFpbmluZyArICcgbW9yZSBpdGVtJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpKTtcbiAgfVxuXG4gIGZvckVhY2goa2V5cywgZnVuY3Rpb24gX3B1c2hlckZtdFR5cGVkQXJyYXkoa2V5KSB7XG4gICAgaWYgKGlzU3ltYm9sVHlwZShrZXkpIHx8IGlzRGlnaXRzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICBvdXRwdXQucHVzaChmbXRQcm9wKGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbnZhciBmbXRTZXQgPSBmdW5jdGlvbiBfZm10U2V0KGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0ID0gW107XG4gIGNvbGxlY3Rpb25FYWNoKHZhbHVlLCBmdW5jdGlvbiBfcHVzaGVyRm10U2V0MSh2KSB7XG4gICAgb3V0LnB1c2goZm10VmFsdWUoY3R4LCB2LCByZWN1cnNlKGRlcHRoKSkpO1xuICB9KTtcblxuICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIF9wdXNoZXJGbXRTZXQyKGtleSkge1xuICAgIG91dC5wdXNoKGZtdFByb3AoY3R4LCB2YWx1ZSwgZGVwdGgsIHZpc2libGVLZXlzLCBrZXksIGZhbHNlKSk7XG4gIH0pO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGZtdE1hcCA9IGZ1bmN0aW9uIChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBjb2xsZWN0aW9uRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICB2YXIgciA9IHJlY3Vyc2UoZGVwdGgpO1xuICAgIG91dC5wdXNoKGZtdFZhbHVlKGN0eCwgaywgcikgKyAnID0+ICcgKyBmbXRWYWx1ZShjdHgsIHYsIHIpKTtcbiAgfSk7XG5cbiAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgb3V0LnB1c2goZm10UHJvcChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleSwgZmFsc2UpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbnZhciByZWR1Y2VUb1NpbmdsZVN0cmluZyA9IGZ1bmN0aW9uIF9yZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbGVuZ3RoID0gcmVkdWNlKG91dCwgZnVuY3Rpb24gX3JlZHVjZXIocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICB2YXIgcmVzdWx0O1xuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICAvLyBJZiB0aGUgb3BlbmluZyBcImJyYWNlXCIgaXMgdG9vIGxhcmdlLCBsaWtlIGluIHRoZSBjYXNlIG9mIFwiU2V0IHtcIixcbiAgICAvLyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIG9uIHRoZSBuZXh0IGxpbmUgb3IgdGhlXG4gICAgLy8gaXRlbXMgd2lsbCBub3QgbGluZSB1cCBjb3JyZWN0bHkuXG4gICAgdmFyIGxheW91dEJhc2UgPSBiYXNlID09PSAnJyAmJiBicmFjZXNbMF0ubGVuZ3RoID09PSAxID8gJycgOiBiYXNlICsgJ1xcbiAnO1xuICAgIHJlc3VsdCA9IGJyYWNlc1swXSArIGxheW91dEJhc2UgKyAnICcgKyBvdXQuam9pbignLFxcbiAgJykgKyAnICcgKyBicmFjZXNbMV07XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKHJlU2luZ2xlLCAne30nKTtcbn07XG5cbnZhciBmbXREYXRlID0gZnVuY3Rpb24gX2ZtdERhdGUodmFsdWUpIHtcbiAgcmV0dXJuICRpc05hTih2YWx1ZS5nZXRUaW1lKCkpID8gJ0ludmFsaWQgRGF0ZScgOiB0b0lTT1N0cmluZyh2YWx1ZSk7XG59O1xuXG52YXIgZm10RXJyb3IgPSBmdW5jdGlvbiBfZm10RXJyb3IodmFsdWUpIHtcbiAgdmFyIHN0YWNrID0gdmFsdWUuc3RhY2s7XG4gIGlmIChzdGFjaykge1xuICAgIGlmIChzdXBwb3J0c0NsYXNzZXMpIHtcbiAgICAgIHZhciBzdWJOYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSk7XG4gICAgICBpZiAoc3ViTmFtZSAmJiBzdGFjay5zdGFydHNXaXRoKHN1Yk5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgbXNnID0gdmFsdWUubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnJlcGxhY2UocEVycm9yVG9TdHJpbmcuY2FsbCh2YWx1ZSksIHN1Yk5hbWUgKyAobXNnID8gJzogJyArIG1zZyA6ICcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaXNzaW5nRXJyb3IpIHtcbiAgICAgIHJldHVybiBwRXJyb3JUb1N0cmluZy5jYWxsKHZhbHVlKSArICdcXG4nICsgc3RhY2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YWNrIHx8ICdbJyArIHBFcnJvclRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufTtcblxudmFyIGZpbHRlckRhdGVLZXlzID0gZnVuY3Rpb24gX2ZpbHRlckRhdGVLZXlzKGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAnY29uc3RydWN0b3InO1xufTtcblxudmFyIGZpbHRlckVycm9yS2V5cyA9IGZ1bmN0aW9uIF9maWx0ZXJFcnJvcktleXMoa2V5KSB7XG4gIHJldHVybiAkaW5jbHVkZXMoZXJyUHJvcHMsIGtleSkgPT09IGZhbHNlO1xufTtcblxudmFyIGdldFZpc2libGVLZXlzID0gZnVuY3Rpb24gX2dldFZpc2libGVLZXlzKHZhbHVlKSB7XG4gIHZhciBrZXlzID0gJGtleXModmFsdWUpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHNoaW1tZWREYXRlICYmIGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmaWx0ZXIoa2V5cywgZmlsdGVyRGF0ZUtleXMpO1xuICAgIH1cblxuICAgIGlmIChlcnJQcm9wcy5sZW5ndGggPiAwICYmIGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmlsdGVyKGtleXMsIGZpbHRlckVycm9yS2V5cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgZ2V0RW51bVN5bWJvbHMgPSBmdW5jdGlvbiBfZ2V0RW51bVN5bWJvbHModmFsdWUpIHtcbiAgaWYgKCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gZmlsdGVyKCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLCBmdW5jdGlvbiBfZmlsdGVyRW51bVN5bWJvbEtleXMoa2V5KSB7XG4gICAgICByZXR1cm4gJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIGtleSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gW107XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZm10VmFsdWUgPSBmdW5jdGlvbiBfZm10VmFsdWUoY3R4LCB2YWx1ZSwgZGVwdGgpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmIHZhbHVlKSB7XG4gICAgdmFyIG1heWJlQ3VzdG9tSW5zcGVjdCA9IHZhbHVlW2N1c3RvbUluc3BlY3RTeW1ib2xdIHx8IHZhbHVlLmluc3BlY3Q7XG4gICAgaWYgKGlzRnVuY3Rpb24obWF5YmVDdXN0b21JbnNwZWN0KSkge1xuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0cyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIGlmIChtYXliZUN1c3RvbUluc3BlY3QgIT09IGluc3BlY3QpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3JPZih2YWx1ZSk7XG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICB2YXIgaXNDaXJjdWxhciA9IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWU7XG4gICAgICAgIGlmIChpc0NpcmN1bGFyID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciByZXQgPSBtYXliZUN1c3RvbUluc3BlY3QuY2FsbCh2YWx1ZSwgZGVwdGgsIGN0eCk7XG4gICAgICAgICAgLy8gSWYgdGhlIGN1c3RvbSBpbnNwZWN0aW9uIG1ldGhvZCByZXR1cm5lZCBgdGhpc2AsIGRvbid0IGdvIGludG9cbiAgICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgIGlmIChyZXQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmdUeXBlKHJldCkgPyByZXQgOiBmbXRWYWx1ZShjdHgsIHJldCwgZGVwdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmbXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIgdmlzaWJsZUtleXMgPSBnZXRWaXNpYmxlS2V5cyh2YWx1ZSk7XG4gIHZhciBrZXlzO1xuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gcmVmbGVjdE93bktleXModmFsdWUpO1xuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgaWYgKCRpbmNsdWRlcyh2aXNpYmxlS2V5cywgJ21lc3NhZ2UnKSA9PT0gZmFsc2UgJiYgJGluY2x1ZGVzKGtleXMsICdtZXNzYWdlJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHVuc2hpZnRVbmlxKGtleXMsICdtZXNzYWdlJyk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBpZiAoaW5jbHVkZXModmlzaWJsZUtleXMsICduYW1lJykgPT09IGZhbHNlICYmIGluY2x1ZGVzKGtleXMsICduYW1lJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHVuc2hpZnRVbmlxKGtleXMsICduYW1lJyk7XG4gICAgICB9XG4gICAgICAqL1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gdmlzaWJsZUtleXMuY29uY2F0KGdldEVudW1TeW1ib2xzKHZhbHVlKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgLy8gZm9yIGJveGVkIFN0cmluZ3MsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSAwLW4gaW5kZXhlZCBlbnRyaWVzLFxuICAgIC8vIHNpbmNlIHRoZXkganVzdCBub2lzZXkgdXAgdGhlIG91dCBhbmQgYXJlIHJlZHVuZGFudFxuICAgIGZpbHRlckluZGV4ZXMoa2V5cywgdmFsdWUubGVuZ3RoKTtcbiAgICBmaWx0ZXJJbmRleGVzKHZpc2libGVLZXlzLCB2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgZmlsdGVySW5kZXhlcyhrZXlzLCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICBmaWx0ZXJJbmRleGVzKHZpc2libGVLZXlzLCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBuYW1lO1xuICB2YXIgZm9ybWF0dGVkO1xuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFRoaXMgY291bGQgYmUgYSBib3hlZCBwcmltaXRpdmUgKG5ldyBTdHJpbmcoKSwgZXRjLilcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoXG4gICAgICAgICdbJyArIGdldFN1Yk5hbWUodmFsdWUsICdTdHJpbmcnKSArICc6ICcgKyBmbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlLnZhbHVlT2YoKSkgKyAnXScsXG4gICAgICAgICdzdHJpbmcnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcbiAgICAgICAgJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ051bWJlcicpICsgJzogJyArIGZtdFByaW1Ob0NvbG9yKGN0eCwgdmFsdWUudmFsdWVPZigpKSArICddJyxcbiAgICAgICAgJ251bWJlcidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcbiAgICAgICAgJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ0Jvb2xlYW4nKSArICc6ICcgKyBmbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlLnZhbHVlT2YoKSkgKyAnXScsXG4gICAgICAgICdib29sZWFuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoXG4gICAgICAgICdbU3ltYm9sOiAnICsgZm10UHJpbU5vQ29sb3IoY3R4LCBwU3ltVmFsT2YuY2FsbCh2YWx1ZSkpICsgJ10nLFxuICAgICAgICAnc3ltYm9sJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbQXN5bmNGdW5jdGlvbicgKyBnZXROYW1lU2VwKHZhbHVlKSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0dlbmVyYXRvckZ1bmN0aW9uJyArIGdldE5hbWVTZXAodmFsdWUpICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbJyArIGdldFN1Yk5hbWUodmFsdWUsICdGdW5jdGlvbicpICsgZ2V0TmFtZVNlcCh2YWx1ZSkgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NlcyAmJiBpc0Z1bmN0aW9uKHZhbHVlLCB0cnVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbQ2xhc3MnICsgZ2V0TmFtZVNlcCh2YWx1ZSkgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHBSZWdFeHBUb1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cblxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSk7XG4gICAgICBmb3JtYXR0ZWQgPSBjdHguc3R5bGl6ZShmbXREYXRlKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICAgIGlmIChuYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbJyArIG5hbWUgKyAnOiAnICsgZm9ybWF0dGVkICsgJ10nLCAnZGF0ZScpO1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZtdEVycm9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IHBhdGggZm9yIEFycmF5QnVmZmVyLiBDYW4ndCBkbyB0aGUgc2FtZSBmb3IgRGF0YVZpZXcgYmVjYXVzZSBpdFxuICAgIC8vIGhhcyBhIG5vbi1wcmltaXRpdmUgYnVmZmVyIHByb3BlcnR5IHRoYXQgd2UgbmVlZCB0byByZWN1cnNlIGZvci5cbiAgICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBnZXRTdWJOYW1lKHZhbHVlLCAnQXJyYXlCdWZmZXInKSArICcgeyBieXRlTGVuZ3RoOiAnICsgZm10TnVtYmVyKGN0eCwgdmFsdWUuYnl0ZUxlbmd0aCkgKyAnIH0nO1xuICAgIH1cblxuICAgIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGdldFN1Yk5hbWUodmFsdWUsICdNYXBJdGVyYXRvcicpICsgJyB7fSc7XG4gICAgfVxuXG4gICAgaWYgKGlzU2V0SXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZ2V0U3ViTmFtZSh2YWx1ZSwgJ1NldEl0ZXJhdG9yJykgKyAnIHt9JztcbiAgICB9XG5cbiAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGdldFN1Yk5hbWUodmFsdWUsICdQcm9taXNlJykgKyAnIHt9JztcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnO1xuICB2YXIgZW1wdHkgPSBmYWxzZTtcbiAgdmFyIGJyYWNlcyA9IFsneycsICd9J107XG4gIHZhciBmbXR0ZXIgPSBmbXRPYmplY3Q7XG4gIC8vIFdlIGNhbid0IGNvbXBhcmUgY29uc3RydWN0b3JzIGZvciB2YXJpb3VzIG9iamVjdHMgdXNpbmcgYSBjb21wYXJpc29uXG4gIC8vIGxpa2UgYGNvbnN0cnVjdG9yID09PSBBcnJheWAgYmVjYXVzZSB0aGUgb2JqZWN0IGNvdWxkIGhhdmUgY29tZSBmcm9tIGFcbiAgLy8gZGlmZmVyZW50IGNvbnRleHQgYW5kIHRodXMgdGhlIGNvbnN0cnVjdG9yIHdvbid0IG1hdGNoLiBJbnN0ZWFkIHdlIGNoZWNrXG4gIC8vIHRoZSBjb25zdHJ1Y3RvciBuYW1lcyAoaW5jbHVkaW5nIHRob3NlIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gd2hlcmVcbiAgLy8gbmVlZGVkKSB0byBkZXRlcm1pbmUgb2JqZWN0IHR5cGVzLlxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgLy8gTWFrZSBib3hlZCBwcmltaXRpdmUgU3RyaW5ncyBsb29rIGxpa2Ugc3VjaFxuICAgIGJhc2UgPSAnWycgKyBnZXRTdWJOYW1lKHZhbHVlLCAnU3RyaW5nJykgKyAnOiAnICsgZm10UHJpbU5vQ29sb3IoY3R4LCB2YWx1ZS52YWx1ZU9mKCkpICsgJ10nO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgIC8vIE1ha2UgYm94ZWQgcHJpbWl0aXZlIE51bWJlcnMgbG9vayBsaWtlIHN1Y2hcbiAgICBiYXNlID0gJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ051bWJlcicpICsgJzogJyArIGZtdFByaW1Ob0NvbG9yKGN0eCwgdmFsdWUudmFsdWVPZigpKSArICddJztcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgLy8gTWFrZSBib3hlZCBwcmltaXRpdmUgQm9vbGVhbnMgbG9vayBsaWtlIHN1Y2hcbiAgICBiYXNlID0gJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ0Jvb2xlYW4nKSArICc6ICcgKyBmbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlLnZhbHVlT2YoKSkgKyAnXSc7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBiYXNlID0gJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ0Z1bmN0aW9uJykgKyBnZXROYW1lU2VwKHZhbHVlKSArICddJztcbiAgfSBlbHNlIGlmIChzdXBwb3J0c0NsYXNzZXMgJiYgaXNGdW5jdGlvbih2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBiYXNlID0gJ1tDbGFzcycgKyBnZXROYW1lU2VwKHZhbHVlKSArICddJztcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICAgIC8vIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlLCAnUmVnRXhwJyk7XG4gICAgYmFzZSA9IHBSZWdFeHBUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUpO1xuICAgIGZvcm1hdHRlZCA9IGZtdERhdGUodmFsdWUpO1xuICAgIGlmIChuYW1lID09PSAnRGF0ZScpIHtcbiAgICAgIGJhc2UgPSBmb3JtYXR0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnWycgKyBuYW1lICsgJzogJyArIGZvcm1hdHRlZCArICddJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSk7XG4gICAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICAgIGJhc2UgPSBmbXRFcnJvcih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoJGlzQXJyYXkodmFsdWUpKSB7XG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUpO1xuICAgIC8vIFVuc2V0IHRoZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IFwiQXJyYXkgWy4uLl1cIiBmb3Igb3JkaW5hcnkgYXJyYXlzLlxuICAgIG5hbWUgPSBuYW1lID09PSAnQXJyYXknID8gJycgOiBuYW1lO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gICAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgICB1bnNoaWZ0VW5pcShrZXlzLCAnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgZW1wdHkgPSB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgZm10dGVyID0gZm10QXJyYXk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUsICdTZXQnKTtcbiAgICBmbXR0ZXIgPSBmbXRTZXQ7XG4gICAgLy8gV2l0aCBgc2hvd0hpZGRlbmAsIGBsZW5ndGhgIHdpbGwgZGlzcGxheSBhcyBhIGhpZGRlbiBwcm9wZXJ0eSBmb3JcbiAgICAvLyBhcnJheXMuIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIGRvIHRoZSBzYW1lIGZvciBgc2l6ZWAsIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhpcyBwcm9wZXJ0eSBpc24ndCBzZWxlY3RlZCBieSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLlxuICAgIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgICAgdW5zaGlmdFVuaXEoa2V5cywgJ3NpemUnKTtcbiAgICB9XG5cbiAgICBlbXB0eSA9IHZhbHVlLnNpemUgPT09IDA7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUsICdNYXAnKTtcbiAgICBmbXR0ZXIgPSBmbXRNYXA7XG4gICAgLy8gV2l0aCBgc2hvd0hpZGRlbmAsIGBsZW5ndGhgIHdpbGwgZGlzcGxheSBhcyBhIGhpZGRlbiBwcm9wZXJ0eSBmb3JcbiAgICAvLyBhcnJheXMuIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIGRvIHRoZSBzYW1lIGZvciBgc2l6ZWAsIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhpcyBwcm9wZXJ0eSBpc24ndCBzZWxlY3RlZCBieSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLlxuICAgIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgICAgdW5zaGlmdFVuaXEoa2V5cywgJ3NpemUnKTtcbiAgICB9XG5cbiAgICBlbXB0eSA9IHZhbHVlLnNpemUgPT09IDA7XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSwgJ0FycmF5QnVmZmVyJyk7XG4gICAgdW5zaGlmdFVuaXEoa2V5cywgJ2J5dGVMZW5ndGgnKTtcbiAgICBwdXNoVW5pcSh2aXNpYmxlS2V5cywgJ2J5dGVMZW5ndGgnKTtcbiAgfSBlbHNlIGlmIChpc0RhdGFWaWV3KHZhbHVlKSkge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlLCAnRGF0YVZpZXcnKTtcbiAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnVmZmVyJyk7XG4gICAgdW5zaGlmdFVuaXEoa2V5cywgJ2J5dGVPZmZzZXQnKTtcbiAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnl0ZUxlbmd0aCcpO1xuICAgIHB1c2hVbmlxKHZpc2libGVLZXlzLCAnYnl0ZUxlbmd0aCcpO1xuICAgIHB1c2hVbmlxKHZpc2libGVLZXlzLCAnYnl0ZU9mZnNldCcpO1xuICAgIHB1c2hVbmlxKHZpc2libGVLZXlzLCAnYnVmZmVyJyk7XG4gIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlKTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIGZtdHRlciA9IGZtdFR5cGVkQXJyYXk7XG4gICAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnVmZmVyJyk7XG4gICAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnl0ZU9mZnNldCcpO1xuICAgICAgdW5zaGlmdFVuaXEoa2V5cywgJ2J5dGVMZW5ndGgnKTtcbiAgICAgIHVuc2hpZnRVbmlxKGtleXMsICdsZW5ndGgnKTtcbiAgICAgIHVuc2hpZnRVbmlxKGtleXMsIGJwZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSwgJ1Byb21pc2UnKTtcbiAgfSBlbHNlIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlLCAnTWFwSXRlcmF0b3InKTtcbiAgICBlbXB0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNTZXRJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSwgJ1NldEl0ZXJhdG9yJyk7XG4gICAgZW1wdHkgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlKTtcbiAgICAvLyBVbnNldCB0aGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBcIk9iamVjdCB7Li4ufVwiIGZvciBvcmRpbmFyeSBvYmplY3RzLlxuICAgIG5hbWUgPSBuYW1lID09PSAnT2JqZWN0JyA/ICcnIDogbmFtZTtcbiAgICBlbXB0eSA9IHRydWU7IC8vIE5vIG90aGVyIGRhdGEgdGhhbiBrZXlzLlxuICB9XG5cbiAgaWYgKGJhc2UpIHtcbiAgICBiYXNlID0gJyAnICsgYmFzZTtcbiAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgLy8gQWRkIGNvbnN0cnVjdG9yIG5hbWUgaWYgYXZhaWxhYmxlXG4gICAgYnJhY2VzWzBdID0gbmFtZSArICcgJyArIGJyYWNlc1swXTtcbiAgfVxuXG4gIGVtcHR5ID0gZW1wdHkgPT09IHRydWUgJiYga2V5cy5sZW5ndGggPT09IDA7XG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKGRlcHRoIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShwUmVnRXhwVG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2UgaWYgKCRpc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbQXJyYXldJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN0eC5zZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICB9XG5cbiAgY3R4LnNlZW4uYWRkKHZhbHVlKTtcbiAgdmFyIG91dCA9IGZtdHRlcihjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpO1xuICBjdHguc2VlblsnZGVsZXRlJ10odmFsdWUpO1xuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0LCBiYXNlLCBicmFjZXMpO1xufTtcblxuaW5zcGVjdCA9IGZ1bmN0aW9uIF9pbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBuZXcgY29sbGVjdGlvbnMuU2V0KCksXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcblxuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMyAmJiBpc1VuZGVmaW5lZChhcmd1bWVudHNbMl0pID09PSBmYWxzZSkge1xuICAgIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQgJiYgaXNVbmRlZmluZWQoYXJndW1lbnRzWzNdKSA9PT0gZmFsc2UpIHtcbiAgICBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfVxuXG4gIC8vIFNldCBkZWZhdWx0IGFuZCB1c2VyLXNwZWNpZmllZCBvcHRpb25zXG4gIGlmIChzdXBwb3J0c0dldFNldCkge1xuICAgIGN0eCA9ICRhc3NpZ24oe30sIGluc3BlY3QuZGVmYXVsdE9wdGlvbnMsIGN0eCwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgY3R4ID0gJGFzc2lnbih7fSwgaW5zcGVjdERlZmF1bHRPcHRpb25zLCBpbnNwZWN0LmRlZmF1bHRPcHRpb25zLCBjdHgsIG9wdHMpO1xuICB9XG5cbiAgaWYgKGN0eC5jb2xvcnMpIHtcbiAgICBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIH1cblxuICBpZiAoaXNOdWxsKGN0eC5tYXhBcnJheUxlbmd0aCkpIHtcbiAgICBjdHgubWF4QXJyYXlMZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIHJldHVybiBmbXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn07XG5cbmlmIChzdXBwb3J0c0dldFNldCkge1xuICBkZWZpbmVQcm9wZXJ0eShpbnNwZWN0LCAnZGVmYXVsdE9wdGlvbnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBfZ2V0KCkge1xuICAgICAgcmV0dXJuIGluc3BlY3REZWZhdWx0T3B0aW9ucztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gX3NldChvcHRpb25zKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJGFzc2lnbihpbnNwZWN0RGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBkZWZpbmVQcm9wZXJ0aWVzKGluc3BlY3QsIHtcbiAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgdmFsdWU6ICRhc3NpZ24oe30sIGluc3BlY3REZWZhdWx0T3B0aW9ucyksXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59XG5cbmRlZmluZVByb3BlcnRpZXMoaW5zcGVjdCwge1xuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcbiAgY29sb3JzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIGJsYWNrOiBbMzAsIDM5XSxcbiAgICAgIGJsdWU6IFszNCwgMzldLFxuICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgIGN5YW46IFszNiwgMzldLFxuICAgICAgZ3JlZW46IFszMiwgMzldLFxuICAgICAgZ3JleTogWzkwLCAzOV0sXG4gICAgICBpbnZlcnNlOiBbNywgMjddLFxuICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgbWFnZW50YTogWzM1LCAzOV0sXG4gICAgICByZWQ6IFszMSwgMzldLFxuICAgICAgdW5kZXJsaW5lOiBbNCwgMjRdLFxuICAgICAgd2hpdGU6IFszNywgMzldLFxuICAgICAgeWVsbG93OiBbMzMsIDM5XVxuICAgIH1cbiAgfSxcbiAgY3VzdG9tOiB7XG4gICAgdmFsdWU6IGN1c3RvbUluc3BlY3RTeW1ib2xcbiAgfSxcbiAgLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG4gIHN0eWxlczoge1xuICAgIHZhbHVlOiB7XG4gICAgICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAgICAgZGF0ZTogJ21hZ2VudGEnLFxuICAgICAgLy8gbmFtZTogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgJ251bGwnOiAnYm9sZCcsXG4gICAgICBudW1iZXI6ICd5ZWxsb3cnLFxuICAgICAgcmVnZXhwOiAncmVkJyxcbiAgICAgIHNwZWNpYWw6ICdjeWFuJyxcbiAgICAgIHN0cmluZzogJ2dyZWVuJyxcbiAgICAgIHN5bWJvbDogJ2dyZWVuJyxcbiAgICAgIHVuZGVmaW5lZDogJ2dyZXknXG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqIFZhbHVlcyBtYXkgc3VwcGx5IHRoZWlyIG93biBjdXN0b20gYGluc3BlY3QoZGVwdGgsIG9wdHMpYCBmdW5jdGlvbnMsXG4gKiB3aGVuIGNhbGxlZCB0aGV5IHJlY2VpdmUgdGhlIGN1cnJlbnQgZGVwdGggaW4gdGhlIHJlY3Vyc2l2ZSBpbnNwZWN0aW9uLFxuICogYXMgd2VsbCBhcyB0aGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIGBpbnNwZWN0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGluc3BlY3QgPSByZXF1aXJlKCdpbnNwZWN0LXgnKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhpbnNwZWN0KGluc3BlY3QsIHsgc2hvd0hpZGRlbjogdHJ1ZSwgZGVwdGg6IG51bGwgfSkpO1xuICogLy97IFtGdW5jdGlvbjogaW5zcGVjdF1cbiAqIC8vICBbbGVuZ3RoXTogMixcbiAqIC8vICBbbmFtZV06ICdpbnNwZWN0JyxcbiAqIC8vICBbcHJvdG90eXBlXTogaW5zcGVjdCB7IFtjb25zdHJ1Y3Rvcl06IFtDaXJjdWxhcl0gfSxcbiAqIC8vICBbY29sb3JzXTpcbiAqIC8vICAgeyBbYm9sZF06IFsgMSwgMjIsIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2l0YWxpY106IFsgMywgMjMsIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW3VuZGVybGluZV06IFsgNCwgMjQsIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2ludmVyc2VdOiBbIDcsIDI3LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFt3aGl0ZV06IFsgMzcsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFtncmV5XTogWyA5MCwgMzksIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2JsYWNrXTogWyAzMCwgMzksIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2JsdWVdOiBbIDM0LCAzOSwgW2xlbmd0aF06IDIgXSxcbiAqIC8vICAgICBbY3lhbl06IFsgMzYsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFtncmVlbl06IFsgMzIsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFttYWdlbnRhXTogWyAzNSwgMzksIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW3JlZF06IFsgMzEsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFt5ZWxsb3ddOiBbIDMzLCAzOSwgW2xlbmd0aF06IDIgXSB9LFxuICogLy8gIFtzdHlsZXNdOlxuICogLy8gICB7IFtzcGVjaWFsXTogJ2N5YW4nLFxuICogLy8gICAgIFtudW1iZXJdOiAneWVsbG93JyxcbiAqIC8vICAgICBbYm9vbGVhbl06ICd5ZWxsb3cnLFxuICogLy8gICAgIFt1bmRlZmluZWRdOiAnZ3JleScsXG4gKiAvLyAgICAgW251bGxdOiAnYm9sZCcsXG4gKiAvLyAgICAgW3N0cmluZ106ICdncmVlbicsXG4gKiAvLyAgICAgW3N5bWJvbF06ICdncmVlbicsXG4gKiAvLyAgICAgW2RhdGVdOiAnbWFnZW50YScsXG4gKiAvLyAgICAgW3JlZ2V4cF06ICdyZWQnIH0gfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG4iLCIvKipcbiAqIEBmaWxlIFNoYW0gZm9yIEVTNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0T1BERmFsbGJhY2s7XG5cbi8vIEVTNSAxNS4yLjMuM1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjNcblxudmFyIGRvZXNHT1BEV29yayA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdHJ5IHtcbiAgICBvYmplY3Quc2VudGluZWwgPSAwO1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgJ3NlbnRpbmVsJykudmFsdWUgPT09IDA7XG4gIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gY2hlY2sgd2hldGhlciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Igd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLCBzaGltIHBhcnRpYWxseS5cbmlmICgkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gIHZhciBnZXRPUERXb3Jrc09uT2JqZWN0ID0gZG9lc0dPUERXb3JrKHt9KTtcbiAgdmFyIGdldE9QRFdvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IGRvZXNHT1BEV29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gIGlmIChnZXRPUERXb3Jrc09uRG9tID09PSBmYWxzZSB8fCBnZXRPUERXb3Jrc09uT2JqZWN0ID09PSBmYWxzZSkge1xuICAgIGdldE9QREZhbGxiYWNrID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgfVxufVxuXG52YXIgdG9PYmplY3Q7XG5pZiAoJGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBCb29sZWFuKGdldE9QREZhbGxiYWNrKSA9PT0gZmFsc2UpIHtcbiAgdHJ5IHtcbiAgICAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKDQyLCAnbmFtZScpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gICAgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b09iamVjdChvYmplY3QpLCBwcm9wZXJ0eSk7XG4gICAgfTtcbiAgfVxufSBlbHNlIGlmIChCb29sZWFuKCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpID09PSBmYWxzZSB8fCBnZXRPUERGYWxsYmFjaykge1xuICB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBvd25zID0gcmVxdWlyZSgnaGFzLW93bi1wcm9wZXJ0eS14Jyk7XG4gIHZhciBwcm90b3R5cGVPZk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvdG90eXBlT2ZPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciBpc0VudW1lcmFibGUgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICB9O1xuXG4gIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxuICB2YXIgbG9va3VwR2V0dGVyO1xuICB2YXIgbG9va3VwU2V0dGVyO1xuICB2YXIgc3VwcG9ydHNBY2Nlc3NvcnMgPSBvd25zKHByb3RvdHlwZU9mT2JqZWN0LCAnX19kZWZpbmVHZXR0ZXJfXycpO1xuICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICB2YXIgbGcgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHZhciBscyA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwU2V0dGVyX187XG4gICAgbG9va3VwR2V0dGVyID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBsZy5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgIH07XG5cbiAgICBsb29rdXBTZXR0ZXIgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGxzLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgfTtcbiAgfVxuXG4gICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHZhciBvYmogPSB0b09iamVjdChvYmplY3QpO1xuXG4gICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgLy8gZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgIGlmIChnZXRPUERGYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdldE9QREZhbGxiYWNrLmNhbGwoT2JqZWN0LCBvYmosIHByb3BlcnR5KTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZXNjcmlwdG9yO1xuXG4gICAgLy8gSWYgb2JqZWN0IGRvZXMgbm90IG93bnMgcHJvcGVydHkgcmV0dXJuIHVuZGVmaW5lZCBpbW1lZGlhdGVseS5cbiAgICBpZiAob3ducyhvYmosIHByb3BlcnR5KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSB0aGVuIGl0J3MgZm9yIHN1cmUgYGNvbmZpZ3VyYWJsZWAsIGFuZFxuICAgIC8vIHByb2JhYmx5IGBlbnVtZXJhYmxlYC4gRGV0ZWN0IGVudW1lcmFiaWxpdHkgdGhvdWdoLlxuICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBpc0VudW1lcmFibGUob2JqLCBwcm9wZXJ0eSlcbiAgICB9O1xuXG4gICAgLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29yIHByb3BlcnRpZXMgdGhlbiBwcm9wZXJ0eSBtYXkgYmUgYVxuICAgIC8vIGdldHRlciBvciBzZXR0ZXIuXG4gICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBhIGdldHRlciBldmVuXG4gICAgICAvLyBpZiBvYmplY3QgaGFzIG93biBub24gZ2V0dGVyIHByb3BlcnR5IGFsb25nIHdpdGggYSBzYW1lIG5hbWVkXG4gICAgICAvLyBpbmhlcml0ZWQgZ2V0dGVyLiBUbyBhdm9pZCBtaXNiZWhhdmlvciB3ZSB0ZW1wb3JhcnkgcmVtb3ZlXG4gICAgICAvLyBgX19wcm90b19fYCBzbyB0aGF0IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBnZXR0ZXIgb25seVxuICAgICAgLy8gaWYgaXQncyBvd25lZCBieSBhbiBvYmplY3QuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cbiAgICAgIHZhciBwcm90b3R5cGUgPSBvYmouX19wcm90b19fO1xuICAgICAgdmFyIG5vdFByb3RvdHlwZU9mT2JqZWN0ID0gb2JqICE9PSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBwcm9ibGVtLCBicmVha2luZyBpbiBPcGVyYSBNaW5pIHdoZW5cbiAgICAgIC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJylcbiAgICAgIC8vIG9yIGFueSBvdGhlciBPYmplY3QucHJvdG90eXBlIGFjY2Vzc29yXG4gICAgICBpZiAobm90UHJvdG90eXBlT2ZPYmplY3QpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGdldHRlciA9IGxvb2t1cEdldHRlcihvYmosIHByb3BlcnR5KTtcbiAgICAgIHZhciBzZXR0ZXIgPSBsb29rdXBTZXR0ZXIob2JqLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChub3RQcm90b3R5cGVPZk9iamVjdCkge1xuICAgICAgICAvLyBPbmNlIHdlIGhhdmUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2UgY2FuIHB1dCB2YWx1ZXMgYmFjay5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgIG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXR0ZXIgfHwgc2V0dGVyKSB7XG4gICAgICAgIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IHNldHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IHdhcyBhY2Nlc3NvciBwcm9wZXJ0eSB3ZSdyZSBkb25lIGFuZCByZXR1cm4gaGVyZVxuICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBhZGRpbmcgYHZhbHVlYCB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHdlIGtub3cgdGhhdCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB0aGF0IGlzXG4gICAgLy8gbm90IGFuIGFjY2Vzc29yIHNvIHdlIHNldCBpdCBhcyBhIHZhbHVlIGFuZCByZXR1cm4gZGVzY3JpcHRvci5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqW3Byb3BlcnR5XTtcbiAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgYW4gb3duIHByb3BlcnR5ICh0aGF0IGlzLFxuICogb25lIGRpcmVjdGx5IHByZXNlbnQgb24gYW4gb2JqZWN0IGFuZCBub3QgaW4gdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbilcbiAqIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCBpbiB3aGljaCB0byBsb29rIGZvciB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0geyp9IHByb3BlcnR5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIGRlc2NyaXB0aW9uIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcHJvcGVydHkgZGVzY3JpcHRvciBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaWYgaXQgZXhpc3RzIG9uIHRoZSBvYmplY3QsIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICogdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJ29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteCcpO1xuICogdmFyIG9iaiA9IHsgYmFyOiA0MiB9O1xuICogdmFyIGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgJ2JhcicpO1xuICogLy8gZCBpcyB7XG4gKiAvLyAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAqIC8vICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAqIC8vICAgdmFsdWU6IDQyLFxuICogLy8gICB3cml0YWJsZTogdHJ1ZVxuICogLy8gfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHR0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIi8qKlxuICogQGZpbGUgRGV0ZWN0IHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBpcyBhbiBBcnJheUJ1ZmZlci5cbiAqIEB2ZXJzaW9uIDEuNy4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1hcnJheS1idWZmZXIteFxuICovXG5cbi8qIGdsb2JhbCBBcnJheUJ1ZmZlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG52YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnaXMtb2JqZWN0LWxpa2UteCcpO1xudmFyIGhhc0FCdWYgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG52YXIgYkxlbmd0aCA9IGZhbHNlO1xudmFyIHRvU3RyaW5nVGFnO1xudmFyIGFCdWZUYWc7XG5cbmlmIChoYXNBQnVmKSB7XG4gIGlmIChyZXF1aXJlKCdoYXMtdG8tc3RyaW5nLXRhZy14JykpIHtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14Jyk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQXJyYXlCdWZmZXIucHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGlmIChkZXNjcmlwdG9yICYmIHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJlcyA9IGF0dGVtcHQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXMudGhyZXcgPT09IGZhbHNlICYmIGlzT2JqZWN0TGlrZShyZXMudmFsdWUpKSB7XG4gICAgICAgIHJlcyA9IGF0dGVtcHQuY2FsbChyZXMudmFsdWUsIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgYkxlbmd0aCA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgdHlwZW9mIHJlcy52YWx1ZSA9PT0gJ251bWJlcicgJiYgZGVzY3JpcHRvci5nZXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGJMZW5ndGggPT09IGZhbHNlKSB7XG4gICAgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCd0by1zdHJpbmctdGFnLXgnKTtcbiAgICBhQnVmVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBgb2JqZWN0YCBpcyBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYG9iamVjdGAgaXMgYW4gYEFycmF5QnVmZmVyYCxcbiAqICBlbHNlIGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ2lzLWFycmF5LWJ1ZmZlci14Jyk7XG4gKlxuICogaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoNCkpOyAvLyB0cnVlXG4gKiBpc0FycmF5QnVmZmVyKG51bGwpOyAvLyBmYWxzZVxuICogaXNBcnJheUJ1ZmZlcihbXSk7IC8vIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihvYmplY3QpIHtcbiAgaWYgKGhhc0FCdWYgPT09IGZhbHNlIHx8IGlzT2JqZWN0TGlrZShvYmplY3QpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiTGVuZ3RoID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0b1N0cmluZ1RhZyhvYmplY3QpID09PSBhQnVmVGFnO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQuY2FsbChvYmplY3QsIGJMZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0LnRocmV3ID09PSBmYWxzZSAmJiB0eXBlb2YgcmVzdWx0LnZhbHVlID09PSAnbnVtYmVyJztcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFycmF5IGxpa2UuXG4gKiBAdmVyc2lvbiAxLjguMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtYXJyYXktbGlrZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOaWwgPSByZXF1aXJlKCdpcy1uaWwteCcpO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbi14Jyk7XG52YXIgaXNMZW5ndGggPSByZXF1aXJlKCdpcy1sZW5ndGgteCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB2YWx1ZSBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYGxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byAwIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIG9iamVjdCB0byBiZSB0ZXN0ZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgc3ViamVjdCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnaXMtYXJyYXktbGlrZS14Jyk7XG4gKlxuICogaXNBcnJheUxpa2UoWzEsIDIsIDNdKTsgLy8gdHJ1ZVxuICogaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7IC8vIHRydWVcbiAqIGlzQXJyYXlMaWtlKCdhYmMnKTsgLy8gdHJ1ZVxuICogaXNBcnJheUxpa2UoXy5ub29wKTsgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNOaWwodmFsdWUpID09PSBmYWxzZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLCB0cnVlKSA9PT0gZmFsc2UgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIEFycmF5LlxuICogQHZlcnNpb24gMS4yLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWFycmF5LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuYXRpdmVJc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicgJiYgQXJyYXkuaXNBcnJheTtcblxudmFyIHRlc3RSZXMgPSBuYXRpdmVJc0FycmF5ICYmIHJlcXVpcmUoJ2F0dGVtcHQteCcpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZUlzQXJyYXkoW10pID09PSB0cnVlICYmIG5hdGl2ZUlzQXJyYXkoeyBsZW5ndGg6IDAgfSkgPT09IGZhbHNlO1xufSk7XG5cbnZhciAkaXNBcnJheTtcbmlmICh0ZXN0UmVzICYmIHRlc3RSZXMudGhyZXcgPT09IGZhbHNlICYmIHRlc3RSZXMudmFsdWUgPT09IHRydWUpIHtcbiAgJGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5O1xufSBlbHNlIHtcbiAgdmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gICRpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWcob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgaXNBcnJheSgpIGZ1bmN0aW9uIGRldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIG9iamVjdCB0byBiZSBjaGVja2VkLi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBpcyBhbiBBcnJheTsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xuICpcbiAqIGlzQXJyYXkoW10pOyAvLyB0cnVlXG4gKiBpc0FycmF5KHt9KTsgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkaXNBcnJheTtcbiIsIi8qKlxuICogQGZpbGUgRGV0ZXJtaW5lIGlmIGEgZnVuY3Rpb24gaXMgYSBuYXRpdmUgYXluYyBmdW5jdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFzeW5jLWZ1bmN0aW9uLWRlZmluaXRpb25zfDE0LjYgQXN5bmMgRnVuY3Rpb24gRGVmaW5pdGlvbnN9XG4gKiBAdmVyc2lvbiAxLjcuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtYXN5bmMtZnVuY3Rpb24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgbm9ybWFsaXNlID0gcmVxdWlyZSgnbm9ybWFsaXplLXNwYWNlLXgnKS5ub3JtYWxpemVTcGFjZTIwMTg7XG52YXIgaXNGblJlZ2V4ID0gL15hc3luYyBmdW5jdGlvbi87XG52YXIgdGVzdCA9IGlzRm5SZWdleC50ZXN0O1xudmFyIHJlcGxhY2VDb21tZW50cyA9IHJlcXVpcmUoJ3JlcGxhY2UtY29tbWVudHMteCcpO1xudmFyIGZ1bmN0aW9uQ3RyID0gZnVuY3Rpb24gKCkge30uY29uc3RydWN0b3I7XG52YXIgZlRvU3RyaW5nID0gZnVuY3Rpb25DdHIucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2dldC1wcm90b3R5cGUtb2YteCcpO1xudmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcblxudmFyIHRlc3RSZXMgPSBhdHRlbXB0KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRnZXRQcm90b3R5cGVPZihmdW5jdGlvbkN0cigncmV0dXJuIGFzeW5jIGZ1bmN0aW9uKCkge30nKSgpKTtcbn0pO1xuXG52YXIgc3VwcG9ydHNBc3luYyA9IHRlc3RSZXMudGhyZXcgPT09IGZhbHNlO1xudmFyIGFzeW5jUHJvdG8gPSB0ZXN0UmVzLnZhbHVlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFzeW5jIEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSBmbiAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc0FzeW5jRnVuY3Rpb24gPSByZXF1aXJlKCdpcy0tYXN5bmMtZnVuY3Rpb24teCcpO1xuICpcbiAqIGlzQXN5bmNGdW5jdGlvbigpOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKE51bWJlci5NSU5fVkFMVUUpOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKCdhYmMnKTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbih0cnVlKTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbih7IG5hbWU6ICdhYmMnIH0pOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKGZ1bmN0aW9uICgpIHt9KTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbihuZXcgRnVuY3Rpb24gKCkpOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKGZ1bmN0aW9uKiB0ZXN0MSgpIHt9KTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbihmdW5jdGlvbiB0ZXN0MihhLCBiKSB7fSk7IC8vIGZhbHNlXG4gKiBpc0FzeW5jRnVuY3Rpb24oY2xhc3MgVGVzdCB7fSk7IC8vIGZhbHNlXG4gKiBpc0FzeW5jRnVuY3Rpb24oKHgsIHkpID0+IHtyZXR1cm4gdGhpczt9KTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbihhc3luYyBmdW5jdGluKCkge30pOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKGZuKSB7XG4gIGlmIChzdXBwb3J0c0FzeW5jID09PSBmYWxzZSB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3RyO1xuICB0cnkge1xuICAgIHN0ciA9IG5vcm1hbGlzZShyZXBsYWNlQ29tbWVudHMoZlRvU3RyaW5nLmNhbGwoZm4pLCAnICcpKTtcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRlc3QuY2FsbChpc0ZuUmVnZXgsIHN0cikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNUb1N0cmluZ1RhZyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWcoZm4pID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG4gIH1cblxuICByZXR1cm4gJGdldFByb3RvdHlwZU9mKGZuKSA9PT0gYXN5bmNQcm90bztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBib29sVG9TdHIgPSBCb29sZWFuLnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIHRyeUJvb2xlYW5PYmplY3QgPSBmdW5jdGlvbiB0cnlCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0Ym9vbFRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHsgcmV0dXJuIHRydWU7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeUJvb2xlYW5PYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IGJvb2xDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVjdCB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYSBEYXRhVmlldy5cbiAqIEB2ZXJzaW9uIDEuNi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1kYXRhLXZpZXcteFxuICovXG5cbi8qIGdsb2JhbCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbnZhciBoYXNEVmlldyA9IHR5cGVvZiBEYXRhVmlldyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBnZXRCeXRlTGVuZ3RoID0gZmFsc2U7XG52YXIgbGVnYWN5Q2hlY2s7XG5cbmlmIChoYXNEVmlldykge1xuICB2YXIgcmVzID0gYXR0ZW1wdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoNCkpO1xuICB9KTtcblxuICB2YXIgZGF0YVZpZXcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIGlzT2JqZWN0TGlrZShyZXMudmFsdWUpICYmIHJlcy52YWx1ZTtcblxuICBpZiAoZGF0YVZpZXcgJiYgcmVxdWlyZSgnaGFzLXRvLXN0cmluZy10YWcteCcpKSB7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJ29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteCcpO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKERhdGFWaWV3LnByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKTtcbiAgICBpZiAoZGVzY3JpcHRvciAmJiB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcyA9IGF0dGVtcHQuY2FsbChkYXRhVmlldywgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgZ2V0Qnl0ZUxlbmd0aCA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgdHlwZW9mIHJlcy52YWx1ZSA9PT0gJ251bWJlcicgJiYgZGVzY3JpcHRvci5nZXQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdldEJ5dGVMZW5ndGggPT09IGZhbHNlKSB7XG4gICAgdmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gICAgdmFyIGRWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcbiAgICBpZiAodG9TdHJpbmdUYWcoZGF0YVZpZXcpID09PSBkVmlld1RhZykge1xuICAgICAgbGVnYWN5Q2hlY2sgPSBmdW5jdGlvbiBfbGVnYWN5Q2hlY2sob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZ1RhZyhvYmplY3QpID09PSBkVmlld1RhZztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc0FycmF5QnVmZmVyID0gcmVxdWlyZSgnaXMtYXJyYXktYnVmZmVyLXgnKTtcbiAgICAgIGxlZ2FjeUNoZWNrID0gZnVuY3Rpb24gX2xlZ2FjeUNoZWNrKG9iamVjdCkge1xuICAgICAgICB2YXIgaXNCeXRlTGVuZ3RoID0gdHlwZW9mIG9iamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJztcbiAgICAgICAgdmFyIGlzQnl0ZU9mZnNldCA9IHR5cGVvZiBvYmplY3QuYnl0ZU9mZnNldCA9PT0gJ251bWJlcic7XG4gICAgICAgIHZhciBpc0dldEZsb2F0MzIgPSB0eXBlb2Ygb2JqZWN0LmdldEZsb2F0MzIgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHZhciBpc1NldEZsb2F0NjQgPSB0eXBlb2Ygb2JqZWN0LnNldEZsb2F0NjQgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBpc0J5dGVMZW5ndGggJiYgaXNCeXRlT2Zmc2V0ICYmIGlzR2V0RmxvYXQzMiAmJiBpc1NldEZsb2F0NjQgJiYgaXNBcnJheUJ1ZmZlcihvYmplY3QuYnVmZmVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGBvYmplY3RgIGlzIGFuIGBEYXRhVmlld2AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBgb2JqZWN0YCBpcyBhIGBEYXRhVmlld2AsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNEYXRhVmlldyA9IHJlcXVpcmUoJ2lzLWRhdGEtdmlldy14Jyk7XG4gKiB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gKiB2YXIgZHYgPSBuZXcgRGF0YVZpZXcoYWIpO1xuICpcbiAqIGlzRGF0YVZpZXcoYWIpOyAvLyBmYWxzZVxuICogaXNEYXRhVmlldyh0cnVlKTsgLy8gZmFsc2VcbiAqIGlzRGF0YVZpZXcoZHYpOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEYXRhVmlldyhvYmplY3QpIHtcbiAgaWYgKGhhc0RWaWV3ID09PSBmYWxzZSB8fCBpc09iamVjdExpa2Uob2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVnYWN5Q2hlY2spIHtcbiAgICByZXR1cm4gbGVnYWN5Q2hlY2sob2JqZWN0KTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0LmNhbGwob2JqZWN0LCBnZXRCeXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgdHlwZW9mIHJlc3VsdC52YWx1ZSA9PT0gJ251bWJlcic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RGF5ID0gRGF0ZS5wcm90b3R5cGUuZ2V0RGF5O1xudmFyIHRyeURhdGVPYmplY3QgPSBmdW5jdGlvbiB0cnlEYXRlT2JqZWN0KHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0Z2V0RGF5LmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEYXRlT2JqZWN0KHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlEYXRlT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBkYXRlQ2xhc3M7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSAgRGV0ZWN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBlcnJvci5cbiAqIEB2ZXJzaW9uIDEuNS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1lcnJvci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCd0by1zdHJpbmctdGFnLXgnKTtcbnZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCdpcy1vYmplY3QtbGlrZS14Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZ2V0LXByb3RvdHlwZS1vZi14Jyk7XG5cbnZhciBlcnJvckNoZWNrID0gZnVuY3Rpb24gY2hlY2tJZkVycm9yKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59O1xuXG5pZiAoZXJyb3JDaGVjayhFcnJvci5wcm90b3R5cGUpID09PSBmYWxzZSkge1xuICB2YXIgZXJyb3JQcm90byA9IEVycm9yLnByb3RvdHlwZTtcbiAgdmFyIHRlc3RTdHJpbmdUYWcgPSBlcnJvckNoZWNrO1xuICBlcnJvckNoZWNrID0gZnVuY3Rpb24gY2hlY2tJZkVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBlcnJvclByb3RvIHx8IHRlc3RTdHJpbmdUYWcodmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGdpdmVuIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAgdHlwZSxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzRXJyb3IgPSByZXF1aXJlKCdpcy1lcnJvci14Jyk7XG4gKlxuICogaXNFcnJvcigpOyAvLyBmYWxzZVxuICogaXNFcnJvcihOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gZmFsc2VcbiAqIGlzRXJyb3IoJ2FiYycpOyAvLyBmYWxzZVxuICogaXNFcnJvcihuZXcgRXJyb3IoKSk7IC8vdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG9iamVjdCA9IHZhbHVlO1xuICB2YXIgbWF4TG9vcCA9IDEwMDtcbiAgd2hpbGUgKG9iamVjdCAmJiBtYXhMb29wID4gLTEpIHtcbiAgICBpZiAoZXJyb3JDaGVjayhvYmplY3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvYmplY3QgPSAkZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBtYXhMb29wIC09IDE7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUZXN0IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgZmFsc2V5LlxuICogQHZlcnNpb24gMS4wLjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWZhbHNleS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9Cb29sZWFuID0gcmVxdWlyZSgndG8tYm9vbGVhbi14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGVzdHMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBmYWxzZXkuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgZmFsc2V5OiBvdGhlcndpc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNGYWxzZXkgPSByZXF1aXJlKCdpcy1mYWxzZXkteCcpO1xuICpcbiAqIGlzRmFsc2V5KCk7IC8vIHRydWVcbiAqIGlzRmFsc2V5KDApOyAvLyB0cnVlXG4gKiBpc0ZhbHNleSgnJyk7IC8vIHRydWVcbiAqIGlzRmFsc2V5KGZhbHNlKTsgLy8gdHJ1ZVxuICogaXNGYWxzZXkobnVsbCk7IC8vIHRydWVcbiAqXG4gKiBpc0ZhbHNleSh0cnVlKTsgLy8gZmFsc2VcbiAqIGlzRmFsc2V5KFtdKTsgLy8gZmFsc2VcbiAqIGlzRmFsc2V5KDEpOyAvLyBmYWxzZVxuICogaXNGYWxzZXkoZnVuY3Rpb24gKCkge30pOyAvLyBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRmFsc2V5KHZhbHVlKSB7XG4gIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpID09PSBmYWxzZTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEVTNi1jb21wbGlhbnQgc2hpbSBmb3IgTnVtYmVyLmlzRmluaXRlLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc2Zpbml0ZXwyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUgKCBudW1iZXIgKX1cbiAqIEB2ZXJzaW9uIDMuMC40XG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1maW5pdGUteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbnZhciBJTkZJTklUWSA9IHJlcXVpcmUoJ2luZmluaXR5LXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSBudW1iZXIgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBmaW5pdGVuZXNzLlxuICogQHJldHVybnMge2Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICogdmFyIG51bUlzRmluaXRlID0gcmVxdWlyZSgnaXMtZmluaXRlLXgnKTtcbiAqXG4gKiBudW1Jc0Zpbml0ZShJbmZpbml0eSk7ICAvLyBmYWxzZVxuICogbnVtSXNGaW5pdGUoTmFOKTsgICAgICAgLy8gZmFsc2VcbiAqIG51bUlzRmluaXRlKC1JbmZpbml0eSk7IC8vIGZhbHNlXG4gKlxuICogbnVtSXNGaW5pdGUoMCk7ICAgICAgICAgLy8gdHJ1ZVxuICogbnVtSXNGaW5pdGUoMmU2NCk7ICAgICAgLy8gdHJ1ZVxuICpcbiAqIG51bUlzRmluaXRlKCcwJyk7ICAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsIGlzRmluaXRlKCcwJylcbiAqIG51bUlzRmluaXRlKG51bGwpOyAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRmluaXRlKG51bWJlcikge1xuICByZXR1cm4gdHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicgJiYgbnVtYmVySXNOYU4obnVtYmVyKSA9PT0gZmFsc2UgJiYgbnVtYmVyICE9PSBJTkZJTklUWSAmJiBudW1iZXIgIT09IC1JTkZJTklUWTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbiBvYmplY3QuXG4gKiBAdmVyc2lvbiAzLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtZnVuY3Rpb24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbnZhciBmVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgdG9Cb29sZWFuID0gcmVxdWlyZSgndG8tYm9vbGVhbi14Jyk7XG52YXIgaXNGYWxzZXkgPSByZXF1aXJlKCdpcy1mYWxzZXkteCcpO1xudmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCdpcy1wcmltaXRpdmUnKTtcbnZhciBub3JtYWxpc2UgPSByZXF1aXJlKCdub3JtYWxpemUtc3BhY2UteCcpLm5vcm1hbGl6ZVNwYWNlO1xudmFyIGRlQ29tbWVudCA9IHJlcXVpcmUoJ3JlcGxhY2UtY29tbWVudHMteCcpO1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG52YXIgY3RyUnggPSAvXmNsYXNzIC87XG52YXIgdGVzdCA9IGN0clJ4LnRlc3Q7XG5cbnZhciBoYXNOYXRpdmVDbGFzcyA9IGF0dGVtcHQoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgcmV0dXJuIEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuIGNsYXNzIE15IHt9OycpKCk7XG59KS50aHJldyA9PT0gZmFsc2U7XG5cbnZhciB0ZXN0Q2xhc3NzdHJpbmcgPSBmdW5jdGlvbiBfdGVzdENsYXNzc3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoY3RyUngsIG5vcm1hbGlzZShkZUNvbW1lbnQoZlRvU3RyaW5nLmNhbGwodmFsdWUpLCAnICcpKSk7XG59O1xuXG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmModmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQodGVzdENsYXNzc3RyaW5nLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgcmVzdWx0LnZhbHVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93Q2xhc3MgLSBXaGV0aGVyIHRvIGZpbHRlciBFUzYgY2xhc3Nlcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogZWxzZSBgZmFsc2VgLlxuICovXG52YXIgdHJ5RnVuY1RvU3RyaW5nID0gZnVuY3Rpb24gZnVuY1RvU3RyaW5nKHZhbHVlLCBhbGxvd0NsYXNzKSB7XG4gIGlmIChoYXNOYXRpdmVDbGFzcyAmJiBhbGxvd0NsYXNzID09PSBmYWxzZSAmJiBpc0VTNkNsYXNzRm4odmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGF0dGVtcHQuY2FsbCh2YWx1ZSwgZlRvU3RyaW5nKS50aHJldyA9PT0gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dDbGFzcz1mYWxzZV0gLSBXaGV0aGVyIHRvIGZpbHRlciBFUzYgY2xhc3Nlcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xuICpcbiAqIGlzRnVuY3Rpb24oKTsgLy8gZmFsc2VcbiAqIGlzRnVuY3Rpb24oTnVtYmVyLk1JTl9WQUxVRSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKCdhYmMnKTsgLy8gZmFsc2VcbiAqIGlzRnVuY3Rpb24odHJ1ZSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKHsgbmFtZTogJ2FiYycgfSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKGZ1bmN0aW9uICgpIHt9KTsgLy8gdHJ1ZVxuICogaXNGdW5jdGlvbihuZXcgRnVuY3Rpb24gKCkpOyAvLyB0cnVlXG4gKiBpc0Z1bmN0aW9uKGZ1bmN0aW9uKiB0ZXN0MSgpIHt9KTsgLy8gdHJ1ZVxuICogaXNGdW5jdGlvbihmdW5jdGlvbiB0ZXN0MihhLCBiKSB7fSk7IC8vIHRydWVcbiAqIGlzRnVuY3Rpb24oYXN5bmMgZnVuY3Rpb24gdGVzdDMoKSB7fSk7IC8vIHRydWVcbiAqIGlzRnVuY3Rpb24oY2xhc3MgVGVzdCB7fSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKGNsYXNzIFRlc3Qge30sIHRydWUpOyAvLyB0cnVlXG4gKiBpc0Z1bmN0aW9uKCh4LCB5KSA9PiB7cmV0dXJuIHRoaXM7fSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaGFzVG9TdHJpbmdUYWcpIHtcbiAgICByZXR1cm4gdHJ5RnVuY1RvU3RyaW5nKHZhbHVlLCB0b0Jvb2xlYW4oYXJndW1lbnRzWzFdKSk7XG4gIH1cblxuICBpZiAoaGFzTmF0aXZlQ2xhc3MgJiYgaXNGYWxzZXkoYXJndW1lbnRzWzFdKSAmJiBpc0VTNkNsYXNzRm4odmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHN0clRhZyA9IHRvU3RyaW5nVGFnKHZhbHVlKTtcbiAgcmV0dXJuIHN0clRhZyA9PT0gZnVuY1RhZyB8fCBzdHJUYWcgPT09IGdlblRhZyB8fCBzdHJUYWcgPT09IGFzeW5jVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDoge307XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZSB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSB6ZXJvIGJhc2VkIGluZGV4LlxuICogQHZlcnNpb24gMS4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWluZGV4LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKCd0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTg7XG52YXIgdG9OdW1iZXIgPSByZXF1aXJlKCd0by1udW1iZXIteCcpLnRvTnVtYmVyMjAxODtcbnZhciBtYXRoQ2xhbXAgPSByZXF1aXJlKCdtYXRoLWNsYW1wLXgnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZSgnbWF4LXNhZmUtaW50ZWdlcicpO1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcbnZhciByeFRlc3QgPSByZUlzVWludC50ZXN0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgemVybyBiYXNlZCBpbmRleC5cbiAqIEphdmFTY3JpcHQgYXJyYXlzIGFyZSB6ZXJvLWluZGV4ZWQ6IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5IGlzIGF0XG4gKiBpbmRleCAwLCBhbmQgdGhlIGxhc3QgZWxlbWVudCBpcyBhdCB0aGUgaW5kZXggZXF1YWwgdG8gdGhlIHZhbHVlIG9mIHRoZVxuICogYXJyYXkncyBsZW5ndGggcHJvcGVydHkgbWludXMgMS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHRlc3RlZCBmb3IgYmVpbmcgYSB6ZXJvIGJhc2VkIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gLSBUaGUgbGVuZ3RoIHRoYXQgc2V0cyB0aGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHZhbHVlIGlzIGFcbiAqIHplcm8gYmFzZWQgaW5kZXggd2l0aGluIGJvdW5kcy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNJbmRleCA9IHJlcXVpcmUoJ2lzLWluZGV4LXgnKTtcbiAqXG4gKiBpc0luZGV4KDApOyAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNJbmRleCgxKTsgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzSW5kZXgoJzEwJyk7ICAgICAgICAgICAgICAgICAvLyB0cnVlXG4gKlxuICogaXNJbmRleCgtMTAwMDAwKTsgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KE1hdGgucG93KDIsIDUzKSk7ICAgICAgLy8gZmFsc2VcbiAqIGlzSW5kZXgoMC4xKTsgICAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNJbmRleChNYXRoLlBJKTsgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KE5hTik7ICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzSW5kZXgoSW5maW5pdHkpOyAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNJbmRleCgtSW5maW5pdHkpOyAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KHRydWUpOyAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzSW5kZXgoZmFsc2UpOyAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNJbmRleChbMV0pOyAgICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KDEwLCAxMCk7ICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0luZGV4KHZhbHVlKSB7XG4gIHZhciBzdHJpbmcgPSBzYWZlVG9TdHJpbmcodmFsdWUpO1xuICBpZiAocnhUZXN0LmNhbGwocmVJc1VpbnQsIHN0cmluZykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG51bWJlciA9IHRvTnVtYmVyKHN0cmluZyk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBudW1iZXIgPCBtYXRoQ2xhbXAodG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSksIE1BWF9TQUZFX0lOVEVHRVIpO1xuICB9XG5cbiAgcmV0dXJuIG51bWJlciA8IE1BWF9TQUZFX0lOVEVHRVI7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlcm1pbmUgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtaW50ZWdlci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbnVtYmVySXNGaW5pdGUgPSByZXF1aXJlKCdpcy1maW5pdGUteCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHRlc3RlZCBmb3IgYmVpbmcgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnaXMtaW50ZWdlci14Jyk7XG4gKlxuICogaXNJbnRlZ2VyKDApOyAgICAgICAgIC8vIHRydWVcbiAqIGlzSW50ZWdlcigxKTsgICAgICAgICAvLyB0cnVlXG4gKiBpc0ludGVnZXIoLTEwMDAwMCk7ICAgLy8gdHJ1ZVxuICpcbiAqIGlzSW50ZWdlcigwLjEpOyAgICAgICAvLyBmYWxzZVxuICogaXNJbnRlZ2VyKE1hdGguUEkpOyAgIC8vIGZhbHNlXG4gKlxuICogaXNJbnRlZ2VyKE5hTik7ICAgICAgIC8vIGZhbHNlXG4gKiBpc0ludGVnZXIoSW5maW5pdHkpOyAgLy8gZmFsc2VcbiAqIGlzSW50ZWdlcigtSW5maW5pdHkpOyAvLyBmYWxzZVxuICogaXNJbnRlZ2VyKCcxMCcpOyAgICAgIC8vIGZhbHNlXG4gKiBpc0ludGVnZXIodHJ1ZSk7ICAgICAgLy8gZmFsc2VcbiAqIGlzSW50ZWdlcihmYWxzZSk7ICAgICAvLyBmYWxzZVxuICogaXNJbnRlZ2VyKFsxXSk7ICAgICAgIC8vIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gIHJldHVybiBudW1iZXJJc0Zpbml0ZSh2YWx1ZSkgJiYgdG9JbnRlZ2VyKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICogQHZlcnNpb24gMi4yLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWxlbmd0aC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTYWZlSW50ZWdlciA9IHJlcXVpcmUoJ2lzLXNhZmUtaW50ZWdlci14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNMZW5ndGggPSByZXF1aXJlKCdpcy1sZW5ndGgteCcpO1xuICpcbiAqIGlzTGVuZ3RoKDMpOyAvLyA9PiB0cnVlXG4gKiBpc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gPT4gZmFsc2VcbiAqIGlzTGVuZ3RoKEluZmluaXR5KTsgLy8gPT4gZmFsc2VcbiAqIGlzTGVuZ3RoKCczJyk7IC8vID0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIGlzU2FmZUludGVnZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlY3Qgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIGFuIEVTNiBNYXAuXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtbWFwLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0ZhbHNleSA9IHJlcXVpcmUoJ2lzLWZhbHNleS14Jyk7XG52YXIgYXR0ZW1wdDtcbnZhciBpc09iamVjdExpa2U7XG52YXIgaXNMZW5ndGg7XG52YXIgZ2V0U2l6ZTtcblxuaWYgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCdvYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLXgnKShNYXAucHJvdG90eXBlLCAnc2l6ZScpO1xuICBpZiAoZGVzY3JpcHRvciAmJiB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnaXMtb2JqZWN0LWxpa2UteCcpO1xuICAgIHZhciByZXMgPSBhdHRlbXB0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfSk7XG5cbiAgICBpZiAocmVzLnRocmV3ID09PSBmYWxzZSAmJiBpc09iamVjdExpa2UocmVzLnZhbHVlKSkge1xuICAgICAgaXNMZW5ndGggPSByZXF1aXJlKCdpcy1sZW5ndGgteCcpO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKHJlcy52YWx1ZSwgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgaWYgKHJlcy50aHJldyA9PT0gZmFsc2UgJiYgaXNMZW5ndGgocmVzLnZhbHVlKSkge1xuICAgICAgICBnZXRTaXplID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYG9iamVjdGAgaXMgYSBgTWFwYC5cbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGBvYmplY3RgIGlzIGEgYE1hcGAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc01hcCA9IHJlcXVpcmUoJ2lzLW1hcC14Jyk7XG4gKiB2YXIgbSA9IG5ldyBNYXAoKTtcbiAqXG4gKiBpc01hcChbXSk7IC8vIGZhbHNlXG4gKiBpc01hcCh0cnVlKTsgLy8gZmFsc2VcbiAqIGlzTWFwKG0pOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNNYXAob2JqZWN0KSB7XG4gIGlmIChpc0ZhbHNleShnZXRTaXplKSB8fCBpc09iamVjdExpa2Uob2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdC5jYWxsKG9iamVjdCwgZ2V0U2l6ZSk7XG4gIHJldHVybiByZXN1bHQudGhyZXcgPT09IGZhbHNlICYmIGlzTGVuZ3RoKHJlc3VsdC52YWx1ZSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE51bWJlci5pc05hTiAtIHRoZSBnbG9iYWwgaXNOYU4gcmV0dXJucyBmYWxzZSBwb3NpdGl2ZXMuXG4gKiBAdmVyc2lvbiAxLjAuM1xuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtbmFuLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgTmFOIGFuZCBpdHMgdHlwZSBpc1xuICogYE51bWJlcmAuIEl0IGlzIGEgbW9yZSByb2J1c3QgdmVyc2lvbiBvZiB0aGUgb3JpZ2luYWwsIGdsb2JhbCBpc05hTigpLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBOYU4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBOYU4gYW5kIGl0cyB0eXBlIGlzIE51bWJlcjtcbiAqICBvdGhlcndpc2UsIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbiAqXG4gKiBudW1iZXJJc05hTihOYU4pOyAgICAgICAgLy8gdHJ1ZVxuICogbnVtYmVySXNOYU4oTnVtYmVyLk5hTik7IC8vIHRydWVcbiAqIG51bWJlcklzTmFOKDAgLyAwKTsgICAgICAvLyB0cnVlXG4gKlxuICogLy8gZS5nLiB0aGVzZSB3b3VsZCBoYXZlIGJlZW4gdHJ1ZSB3aXRoIGdsb2JhbCBpc05hTigpXG4gKiBudW1iZXJJc05hTignTmFOJyk7ICAgICAgLy8gZmFsc2VcbiAqIG51bWJlcklzTmFOKHVuZGVmaW5lZCk7ICAvLyBmYWxzZVxuICogbnVtYmVySXNOYU4oe30pOyAgICAgICAgIC8vIGZhbHNlXG4gKiBudW1iZXJJc05hTignYmxhYmxhJyk7ICAgLy8gZmFsc2VcbiAqXG4gKiAvLyBUaGVzZSBhbGwgcmV0dXJuIGZhbHNlXG4gKiBudW1iZXJJc05hTih0cnVlKTtcbiAqIG51bWJlcklzTmFOKG51bGwpO1xuICogbnVtYmVySXNOYU4oMzcpO1xuICogbnVtYmVySXNOYU4oJzM3Jyk7XG4gKiBudW1iZXJJc05hTignMzcuMzcnKTtcbiAqIG51bWJlcklzTmFOKCcnKTtcbiAqIG51bWJlcklzTmFOKCcgJyk7XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxuZGVmaW5lKGltcGxlbWVudGF0aW9uLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTnVtYmVySXNOYU4oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShOdW1iZXIsIHsgaXNOYU46IHBvbHlmaWxsIH0sIHsgaXNOYU46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE51bWJlci5pc05hTiAhPT0gcG9seWZpbGw7IH0gfSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG5cdHJldHVybiBudW1iZXIgPT09IDAgJiYgKDEgLyBudW1iZXIpID09PSAtSW5maW5pdHk7XG59O1xuXG4iLCIvKipcbiAqIEBmaWxlIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqIEB2ZXJzaW9uIDEuNC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1uaWwteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG52YXIgaXNOdWxsID0gcmVxdWlyZSgnbG9kYXNoLmlzbnVsbCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc05pbCA9IHJlcXVpcmUoJ2lzLW5pbC14Jyk7XG4gKlxuICogaXNOaWwobnVsbCk7IC8vID0+IHRydWVcbiAqIGlzTmlsKHZvaWQgMCk7IC8vID0+IHRydWVcbiAqIGlzTmlsKE5hTik7IC8vID0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVsbCh2YWx1ZSkgfHwgaXNVbmRlZmluZWQodmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bVRvU3RyID0gTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0cnlOdW1iZXJPYmplY3QgPSBmdW5jdGlvbiB0cnlOdW1iZXJPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRudW1Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbnVtQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHsgcmV0dXJuIHRydWU7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeU51bWJlck9iamVjdCh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gbnVtQ2xhc3M7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBvYmplY3QgbGlrZS5cbiAqIEB2ZXJzaW9uIDEuNy4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1vYmplY3QtbGlrZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGFcbiAqIHByaW1pdGl2ZSBhbmQgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbiAqXG4gKiBpc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBpc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNQcmltaXRpdmUodmFsdWUpID09PSBmYWxzZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLCB0cnVlKSA9PT0gZmFsc2U7XG59O1xuIiwiLyohXG4gKiBpcy1wcmltaXRpdmUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXByaW1pdGl2ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsID09PSBudWxsO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdmFsICE9PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8qIVxuICogaXMtcHJpbWl0aXZlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wcmltaXRpdmU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL3Rlc3RpbmctdmFsdWUtaXMtcHJpbWl0aXZlLzdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICByZXR1cm4gISFvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xudmFyIHJlZ2V4RXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIHRyeVJlZ2V4RXhlY0NhbGwgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgbGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuXHRcdHZhbHVlLmxhc3RJbmRleCA9IDA7XG5cblx0XHRyZWdleEV4ZWMuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0dmFsdWUubGFzdEluZGV4ID0gbGFzdEluZGV4O1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWdleENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7XG5cdH1cblxuXHR2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcblx0dmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzKGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuXHRpZiAoIWhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnlSZWdleEV4ZWNDYWxsKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIElzIHRoaXMgdmFsdWUgYSBKUyByZWdleD9cbiAqIEB2ZXJzaW9uIDIuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1yZWdleHAteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcblxudmFyIHRvU3RyaW5nVGFnO1xudmFyIHJlZ2V4Q2xhc3M7XG52YXIgaGFzO1xudmFyIGdPUEQ7XG52YXIgcmVnZXhFeGVjO1xudmFyIGRlZmluZVByb3BlcnR5O1xuXG5pZiAocmVxdWlyZSgnaGFzLXRvLXN0cmluZy10YWcteCcpKSB7XG4gIGhhcyA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xuICBnT1BEID0gcmVxdWlyZSgnb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14Jyk7XG4gIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14Jyk7XG4gIHJlZ2V4RXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbn0gZWxzZSB7XG4gIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxudmFyIHRyeVJlZ2V4RXhlY0NhbGwgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUsIGRlc2NyaXB0b3IpIHtcbiAgdHJ5IHtcbiAgICB2YWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgIHJlZ2V4RXhlYy5jYWxsKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ2xhc3RJbmRleCcsIGRlc2NyaXB0b3IpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHRlc3RzIGlmIGEgdmFsdWUgaXMgYSByZWdleC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHZhbHVlIGlzIGEgcmVnZXg7IG90aGVyd2lzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc1JlZ2V4ID0gcmVxdWlyZSgnaXMtcmVnZXhwLXgnKTtcbiAqXG4gKiBpc1JlZ2V4KHVuZGVmaW5lZCk7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KG51bGwpOyAvLyBmYWxzZVxuICogaXNSZWdleChmYWxzZSk7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KHRydWUpOyAvLyBmYWxzZVxuICogaXNSZWdleCg0Mik7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KCdmb28nKTsgLy8gZmFsc2VcbiAqIGlzUmVnZXgoZnVuY3Rpb24gKCkge30pOyAvLyBmYWxzZVxuICogaXNSZWdleChbXSk7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KHt9KSk7IC8vIGZhbHNlXG4gKlxuICogaXNSZWdleCgvYS9nKTsgLy8gdHJ1ZVxuICogaXNSZWdleChuZXcgUmVnRXhwKCdhJywgJ2cnKSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG4gIGlmIChpc09iamVjdExpa2UodmFsdWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0b1N0cmluZ1RhZykge1xuICAgIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7XG4gIH1cblxuICB2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcbiAgdmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzKGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuICBpZiAoaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5ICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRyeVJlZ2V4RXhlY0NhbGwodmFsdWUsIGRlc2NyaXB0b3IpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgSWYgSXNPYmplY3QodmFsdWUpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXNzZXJ0LWlzLW9iamVjdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2FmZVRvU3RyaW5nID0gcmVxdWlyZSgndG8tc3RyaW5nLXN5bWJvbHMtc3VwcG9ydGVkLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAgICogVGVzdHMgYHZhbHVlYCB0byBzZWUgaWYgaXQgaXMgYW4gb2JqZWN0LCB0aHJvd3MgYSBgVHlwZUVycm9yYCBpZiBpdCBpc1xuICAgKiBub3QuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIGFyZ3VtZW50IHRvIGJlIHRlc3RlZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBUaHJvd3MgaWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgIGlmIGl0IGlzIGFuIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGFzc2VydElzT2JqZWN0ID0gcmVxdWlyZSgnYXNzZXJ0LWlzLW9iamVjdC14Jyk7XG4gICAqIHZhciBwcmltaXRpdmUgPSB0cnVlO1xuICAgKiB2YXIgbXlTeW1ib2wgPSBTeW1ib2woJ215U3ltYm9sJyk7XG4gICAqIHZhciBzeW1PYmogPSBPYmplY3QobXlTeW1ib2wpO1xuICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAqIGZ1bmN0aW9uIGZuICgpIHt9XG4gICAqXG4gICAqIGFzc2VydElzT2JqZWN0KHByaW1pdGl2ZSk7IC8vIFR5cGVFcnJvciAndHJ1ZSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChteVN5bWJvbCk7IC8vIFR5cGVFcnJvciAnU3ltYm9sKG15U3ltYm9sKSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChzeW1PYmopOyAvLyBSZXR1cm5zIHN5bU9iai5cbiAgICogYXNzZXJ0SXNPYmplY3Qob2JqZWN0KTsgLy8gUmV0dXJucyBvYmplY3QuXG4gICAqIGFzc2VydElzT2JqZWN0KGZuKTsgLy8gUmV0dXJucyBmbi5cbiAgICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2VydElzT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFNoYW0gZm9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICogQHZlcnNpb24gNC4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG9iamVjdC1kZWZpbmUtcHJvcGVydHkteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbnZhciBpc0ZhbHNleSA9IHJlcXVpcmUoJ2lzLWZhbHNleS14Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCd0by1wcm9wZXJ0eS1rZXkteCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbi14Jyk7XG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCd2YWxpZGF0ZS5pby11bmRlZmluZWQnKTtcbnZhciBhc3NlcnRJc09iamVjdCA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1vYmplY3QteCcpO1xudmFyIG5hdGl2ZURlZlByb3AgPSB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrO1xuXG52YXIgdG9Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBfdG9Qcm9wZXJ0eURlc2NyaXB0b3IoZGVzYykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoZGVzYyk7XG4gIHZhciBkZXNjcmlwdG9yID0ge307XG4gIGlmIChoYXMob2JqZWN0LCAnZW51bWVyYWJsZScpKSB7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gQm9vbGVhbihvYmplY3QuZW51bWVyYWJsZSk7XG4gIH1cblxuICBpZiAoaGFzKG9iamVjdCwgJ2NvbmZpZ3VyYWJsZScpKSB7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSBCb29sZWFuKG9iamVjdC5jb25maWd1cmFibGUpO1xuICB9XG5cbiAgaWYgKGhhcyhvYmplY3QsICd2YWx1ZScpKSB7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IG9iamVjdC52YWx1ZTtcbiAgfVxuXG4gIGlmIChoYXMob2JqZWN0LCAnd3JpdGFibGUnKSkge1xuICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBCb29sZWFuKG9iamVjdC53cml0YWJsZSk7XG4gIH1cblxuICBpZiAoaGFzKG9iamVjdCwgJ2dldCcpKSB7XG4gICAgdmFyIGdldHRlciA9IG9iamVjdC5nZXQ7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGdldHRlcikgPT09IGZhbHNlICYmIGlzRnVuY3Rpb24oZ2V0dGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldHRlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgfVxuXG4gIGlmIChoYXMob2JqZWN0LCAnc2V0JykpIHtcbiAgICB2YXIgc2V0dGVyID0gb2JqZWN0LnNldDtcbiAgICBpZiAoaXNVbmRlZmluZWQoc2V0dGVyKSA9PT0gZmFsc2UgJiYgaXNGdW5jdGlvbihzZXR0ZXIpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2V0dGVyO1xuICB9XG5cbiAgaWYgKChoYXMoZGVzY3JpcHRvciwgJ2dldCcpIHx8IGhhcyhkZXNjcmlwdG9yLCAnc2V0JykpICYmIChoYXMoZGVzY3JpcHRvciwgJ3ZhbHVlJykgfHwgaGFzKGRlc2NyaXB0b3IsICd3cml0YWJsZScpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgZGVzY3JpcHRvci4gQ2Fubm90IGJvdGggc3BlY2lmeSBhY2Nlc3NvcnMgYW5kIGEgdmFsdWUgb3Igd3JpdGFibGUgYXR0cmlidXRlJyk7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbi8vIEVTNSAxNS4yLjMuNlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjZcblxuLy8gUGF0Y2ggZm9yIFdlYktpdCBhbmQgSUU4IHN0YW5kYXJkIG1vZGVcbi8vIERlc2lnbmVkIGJ5IGhheCA8aGF4LmdpdGh1Yi5jb20+XG4vLyByZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzI2lzc3VlLzVcbi8vIElFOCBSZWZlcmVuY2U6XG4vLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjgyOTAwLmFzcHhcbi8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyMjk5MTYuYXNweFxuLy8gV2ViS2l0IEJ1Z3M6XG4vLyAgICAgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTM2NDIzXG5cbnZhciAkZGVmaW5lUHJvcGVydHk7XG4vLyBjaGVjayB3aGV0aGVyIGRlZmluZVByb3BlcnR5IHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSwgc2hpbSBwYXJ0aWFsbHkuXG5pZiAobmF0aXZlRGVmUHJvcCkge1xuICB2YXIgdGVzdFdvcmtzV2l0aCA9IGZ1bmN0aW9uIF90ZXN0V29ya3NXaXRoKG9iamVjdCkge1xuICAgIHZhciB0ZXN0UmVzdWx0ID0gYXR0ZW1wdChuYXRpdmVEZWZQcm9wLCBvYmplY3QsICdzZW50aW5lbCcsIHt9KTtcbiAgICByZXR1cm4gdGVzdFJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgdGVzdFJlc3VsdC52YWx1ZSA9PT0gb2JqZWN0ICYmICdzZW50aW5lbCcgaW4gb2JqZWN0O1xuICB9O1xuXG4gIHZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50O1xuICBpZiAodGVzdFdvcmtzV2l0aCh7fSkgJiYgKGlzRmFsc2V5KGRvYykgfHwgdGVzdFdvcmtzV2l0aChkb2MuY3JlYXRlRWxlbWVudCgnZGl2JykpKSkge1xuICAgICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiBuYXRpdmVEZWZQcm9wKGFzc2VydElzT2JqZWN0KG9iamVjdCksIHRvUHJvcGVydHlLZXkocHJvcGVydHkpLCB0b1Byb3BlcnR5RGVzY3JpcHRvcihkZXNjcmlwdG9yKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrID0gbmF0aXZlRGVmUHJvcDtcbiAgfVxufVxuXG5pZiAoaXNGYWxzZXkobmF0aXZlRGVmUHJvcCkgfHwgZGVmaW5lUHJvcGVydHlGYWxsYmFjaykge1xuICB2YXIgcHJvdG90eXBlT2ZPYmplY3QgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxuICB2YXIgZGVmaW5lR2V0dGVyO1xuICB2YXIgZGVmaW5lU2V0dGVyO1xuICB2YXIgbG9va3VwR2V0dGVyO1xuICB2YXIgbG9va3VwU2V0dGVyO1xuICB2YXIgc3VwcG9ydHNBY2Nlc3NvcnMgPSBoYXMocHJvdG90eXBlT2ZPYmplY3QsICdfX2RlZmluZUdldHRlcl9fJyk7XG4gIGlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cbiAgICBkZWZpbmVHZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fO1xuICAgIGRlZmluZVNldHRlciA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX187XG4gICAgbG9va3VwR2V0dGVyID0gcHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBHZXR0ZXJfXztcbiAgICBsb29rdXBTZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuICB9XG5cbiAgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICAgIGFzc2VydElzT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIHByb3BLZXkgPSB0b1Byb3BlcnR5S2V5KHByb3BlcnR5KTtcbiAgICB2YXIgcHJvcERlc2MgPSB0b1Byb3BlcnR5RGVzY3JpcHRvcihkZXNjcmlwdG9yKTtcblxuICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnR5IGZvciBJRTgncyBET00gZWxlbWVudHMuXG4gICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0LmNhbGwoT2JqZWN0LCBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrLCBvYmplY3QsIHByb3BLZXksIHByb3BEZXNjKTtcbiAgICAgIGlmIChyZXN1bHQudGhyZXcgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgYSBkYXRhIHByb3BlcnR5LlxuICAgIGlmIChoYXMocHJvcERlc2MsICd2YWx1ZScpKSB7XG4gICAgICAvLyBmYWlsIHNpbGVudGx5IGlmICd3cml0YWJsZScsICdlbnVtZXJhYmxlJywgb3IgJ2NvbmZpZ3VyYWJsZScgYXJlIHJlcXVlc3RlZCBidXQgbm90IHN1cHBvcnRlZFxuICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzICYmIChsb29rdXBHZXR0ZXIuY2FsbChvYmplY3QsIHByb3BLZXkpIHx8IGxvb2t1cFNldHRlci5jYWxsKG9iamVjdCwgcHJvcEtleSkpKSB7XG4gICAgICAgIC8vIEFzIGFjY2Vzc29ycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gZW5naW5lcyBpbXBsZW1lbnRpbmdcbiAgICAgICAgLy8gYF9fcHJvdG9fX2Agd2UgY2FuIHNhZmVseSBvdmVycmlkZSBgX19wcm90b19fYCB3aGlsZSBkZWZpbmluZ1xuICAgICAgICAvLyBhIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGhpdCBhbiBpbmhlcml0ZWQgYWNjZXNzb3IuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgIHZhciBwcm90b3R5cGUgPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgIC8vIERlbGV0aW5nIGEgcHJvcGVydHkgYW55d2F5IHNpbmNlIGdldHRlciAvIHNldHRlciBtYXkgYmUgZGVmaW5lZCBvbiBvYmplY3QgaXRzZWxmLlxuICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BLZXldO1xuICAgICAgICBvYmplY3RbcHJvcEtleV0gPSBwcm9wRGVzYy52YWx1ZTtcbiAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W3Byb3BLZXldID0gcHJvcERlc2MudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycyA9PT0gZmFsc2UgJiYgKHByb3BEZXNjLmdldCB8fCBwcm9wRGVzYy5zZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldHRlcnMgJiBzZXR0ZXJzIGNhbiBub3QgYmUgZGVmaW5lZCBvbiB0aGlzIGphdmFzY3JpcHQgZW5naW5lJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGdvdCB0aGF0IGZhciB0aGVuIGdldHRlcnMgYW5kIHNldHRlcnMgY2FuIGJlIGRlZmluZWQgISFcbiAgICAgIGlmIChwcm9wRGVzYy5nZXQpIHtcbiAgICAgICAgZGVmaW5lR2V0dGVyLmNhbGwob2JqZWN0LCBwcm9wS2V5LCBwcm9wRGVzYy5nZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcERlc2Muc2V0KSB7XG4gICAgICAgIGRlZmluZVNldHRlci5jYWxsKG9iamVjdCwgcHJvcEtleSwgcHJvcERlc2Muc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlZmluZXMgYSBuZXcgcHJvcGVydHkgZGlyZWN0bHkgb24gYW4gb2JqZWN0LCBvciBtb2RpZmllcyBhblxuICogZXhpc3RpbmcgcHJvcGVydHkgb24gYW4gb2JqZWN0LCBhbmQgcmV0dXJucyB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgZGVmaW5lZCBvciBtb2RpZmllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIC0gVGhlIGRlc2NyaXB0b3IgZm9yIHRoZSBwcm9wZXJ0eSBiZWluZyBkZWZpbmVkIG9yIG1vZGlmaWVkLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ29iamVjdC1kZWZpbmUtcHJvcGVydHkteCcpO1xuICpcbiAqIHZhciBvID0ge307IC8vIENyZWF0ZXMgYSBuZXcgb2JqZWN0XG4gKlxuICogZGVmaW5lUHJvcGVydHkobywgJ2EnLCB7XG4gKiAgIHZhbHVlOiAzNyxcbiAqICAgd3JpdGFibGU6IHRydWVcbiAqIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWZpbmVQcm9wZXJ0eTtcbiIsIi8qKlxuICogQGZpbGUgRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHNhZmUgaW50ZWdlci5cbiAqIEB2ZXJzaW9uIDEuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1zYWZlLWludGVnZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJ2lzLWludGVnZXIteCcpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSByZXF1aXJlKCdtYXgtc2FmZS1pbnRlZ2VyJyk7XG52YXIgTUlOX1NBRkVfSU5URUdFUiA9IC1NQVhfU0FGRV9JTlRFR0VSO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIENhbiBiZSBleGFjdGx5IHJlcHJlc2VudGVkIGFzIGFuIElFRUUtNzU0IGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyLCBhbmRcbiAqIHdob3NlIElFRUUtNzU0IHJlcHJlc2VudGF0aW9uIGNhbm5vdCBiZSB0aGUgcmVzdWx0IG9mIHJvdW5kaW5nIGFueSBvdGhlclxuICogaW50ZWdlciB0byBmaXQgdGhlIElFRUUtNzU0IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBiZWluZyBhIHNhZmUgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYVxuICogIHNhZmUgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNTYWZlSW50ZWdlciA9IHJlcXVpcmUoJ2lzLXNhZmUtaW50ZWdlci14Jyk7XG4gKlxuICogaXNTYWZlSW50ZWdlcigwKTsgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzU2FmZUludGVnZXIoMSk7ICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1NhZmVJbnRlZ2VyKC0xMDAwMDApOyAgICAgICAgICAgICAgLy8gdHJ1ZVxuICpcbiAqIGlzU2FmZUludGVnZXIoTWF0aC5wb3coMiwgNTMpKTsgICAgICAvLyBmYWxzZVxuICogaXNTYWZlSW50ZWdlcigwLjEpOyAgICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc1NhZmVJbnRlZ2VyKE1hdGguUEkpOyAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqXG4gKiBpc1NhZmVJbnRlZ2VyKE5hTik7ICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzU2FmZUludGVnZXIoSW5maW5pdHkpOyAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNTYWZlSW50ZWdlcigtSW5maW5pdHkpOyAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc1NhZmVJbnRlZ2VyKCcxMCcpOyAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzU2FmZUludGVnZXIodHJ1ZSk7ICAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNTYWZlSW50ZWdlcihmYWxzZSk7ICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc1NhZmVJbnRlZ2VyKFsxXSk7ICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IE1JTl9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVjdCB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYW4gRVM2IFNFVC5cbiAqIEB2ZXJzaW9uIDEuNS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1zZXQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRmFsc2V5ID0gcmVxdWlyZSgnaXMtZmFsc2V5LXgnKTtcbnZhciBhdHRlbXB0O1xudmFyIGlzT2JqZWN0TGlrZTtcbnZhciBpc0xlbmd0aDtcbnZhciBnZXRTaXplO1xuXG5pZiAodHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJ29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteCcpKFNldC5wcm90b3R5cGUsICdzaXplJyk7XG4gIGlmIChkZXNjcmlwdG9yICYmIHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCdpcy1vYmplY3QtbGlrZS14Jyk7XG4gICAgdmFyIHJlcyA9IGF0dGVtcHQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICB9KTtcblxuICAgIGlmIChyZXMudGhyZXcgPT09IGZhbHNlICYmIGlzT2JqZWN0TGlrZShyZXMudmFsdWUpKSB7XG4gICAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJ2lzLWxlbmd0aC14Jyk7XG4gICAgICByZXMgPSBhdHRlbXB0LmNhbGwocmVzLnZhbHVlLCBkZXNjcmlwdG9yLmdldCk7XG4gICAgICBpZiAocmVzLnRocmV3ID09PSBmYWxzZSAmJiBpc0xlbmd0aChyZXMudmFsdWUpKSB7XG4gICAgICAgIGdldFNpemUgPSBkZXNjcmlwdG9yLmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBgb2JqZWN0YCBpcyBhIGBTZXRgLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYG9iamVjdGAgaXMgYSBgU2V0YCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzU2V0ID0gcmVxdWlyZSgnaXMtc2V0LXgnKTtcbiAqIHZhciBzID0gbmV3IFNldCgpO1xuICpcbiAqIGlzU2V0KFtdKTsgLy8gZmFsc2VcbiAqIGlzU2V0KHRydWUpOyAvLyBmYWxzZVxuICogaXNTZXQocyk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1NldChvYmplY3QpIHtcbiAgaWYgKGlzRmFsc2V5KGdldFNpemUpIHx8IGlzT2JqZWN0TGlrZShvYmplY3QpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0LmNhbGwob2JqZWN0LCBnZXRTaXplKTtcbiAgcmV0dXJuIHJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgaXNMZW5ndGgocmVzdWx0LnZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJWYWx1ZSA9IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZjtcbnZhciB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRzdHJWYWx1ZS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc3RyQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHRydWU7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeVN0cmluZ09iamVjdCh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gc3RyQ2xhc3M7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUZXN0cyBpZiAyIGNoYXJhY3RlcnMgdG9nZXRoZXIgYXJlIGEgc3Vycm9nYXRlIHBhaXIuXG4gKiBAdmVyc2lvbiAxLjQuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtc3Vycm9nYXRlLXBhaXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHR3byBjaGFyYWN0ZXIgYXJndW1lbnRzIGNvbWJpbmVkIGFyZSBhIHZhbGlkIFVURi0xNlxuICogc3Vycm9nYXRlIHBhaXIuXG4gKlxuICogQHBhcmFtIHsqfSBjaGFyMSAtIFRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdXNwZWN0ZWQgc3Vycm9nYXRlIHBhaXIuXG4gKiBAcGFyYW0geyp9IGNoYXIyIC0gVGhlIHNlY29uZCBjaGFyYWN0ZXIgb2YgYSBzdXNwZWN0ZWQgc3Vycm9nYXRlIHBhaXIuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gY2hhcmFjdGVycyBjcmVhdGUgYSB2YWxpZFxuICogICdVVEYtMTYnIHN1cnJvZ2F0ZSBwYWlyOyBvdGhlcndpc2UgZmFsc2UuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzU3Vycm9nYXRlUGFpciA9IHJlcXVpcmUoJ2lzLXN1cnJvZ2F0ZS1wYWlyLXgnKTtcbiAqXG4gKiB2YXIgdGVzdDEgPSAnYSc7XG4gKiB2YXIgdGVzdDIgPSAn8KCunyc7XG4gKlxuICogaXNTdXJyb2dhdGVQYWlyKHRlc3QxLmNoYXJBdCgwKSwgdGVzdDEuY2hhckF0KDEpKTsgLy8gZmFsc2VcbiAqIGlzU3Vycm9nYXRlUGFpcih0ZXN0Mi5jaGFyQXQoMCksIHRlc3QyLmNoYXJBdCgxKSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoY2hhcjEsIGNoYXIyKSB7XG4gIGlmIChpc1N0cmluZyhjaGFyMSkgJiYgY2hhcjEubGVuZ3RoID09PSAxICYmIGlzU3RyaW5nKGNoYXIyKSAmJiBjaGFyMi5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgY29kZTEgPSBjaGFyMS5jaGFyQ29kZUF0KCk7XG4gICAgaWYgKGNvZGUxID49IDB4RDgwMCAmJiBjb2RlMSA8PSAweERCRkYpIHtcbiAgICAgIHZhciBjb2RlMiA9IGNoYXIyLmNoYXJDb2RlQXQoKTtcbiAgICAgIGlmIChjb2RlMiA+PSAweERDMDAgJiYgY29kZTIgPD0gMHhERkZGKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxuaWYgKGhhc1N5bWJvbHMpIHtcblx0dmFyIHN5bVRvU3RyID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHN5bVN0cmluZ1JlZ2V4ID0gL15TeW1ib2xcXCguKlxcKSQvO1xuXHR2YXIgaXNTeW1ib2xPYmplY3QgPSBmdW5jdGlvbiBpc1JlYWxTeW1ib2xPYmplY3QodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YoKSAhPT0gJ3N5bWJvbCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHN5bVN0cmluZ1JlZ2V4LnRlc3Qoc3ltVG9TdHIuY2FsbCh2YWx1ZSkpO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuXHRcdC8vIHRoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTeW1ib2xzLlxuXHRcdHJldHVybiBmYWxzZSAmJiB2YWx1ZTtcblx0fTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG52YXIgdHlwZWRBcnJheXMgPSB7XG5cdEZsb2F0MzJBcnJheTogdHJ1ZSxcblx0RmxvYXQ2NEFycmF5OiB0cnVlLFxuXHRJbnQ4QXJyYXk6IHRydWUsXG5cdEludDE2QXJyYXk6IHRydWUsXG5cdEludDMyQXJyYXk6IHRydWUsXG5cdFVpbnQ4QXJyYXk6IHRydWUsXG5cdFVpbnQ4Q2xhbXBlZEFycmF5OiB0cnVlLFxuXHRVaW50MTZBcnJheTogdHJ1ZSxcblx0VWludDMyQXJyYXk6IHRydWVcbn07XG5cbnZhciBzbGljZSA9IFN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKF8sIHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdsb2JhbFt0eXBlZEFycmF5XSgpO1xuXHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXZhbEVycm9yKCd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArIHR5cGVkQXJyYXkgKyAnIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuJyk7XG5cdFx0fVxuXHRcdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdHZhciBzdXBlclByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0fVxuXHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5VHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiAhIXR5cGVkQXJyYXlzW3NsaWNlLmNhbGwodG9TdHIuY2FsbCh2YWx1ZSksIDgsIC0xKV07IH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS43LjAgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bGwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bGwodm9pZCAwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5T2Y7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuIiwidmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21PbWl0Q2xvbmU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwidmFyIGJhc2VQcm9wZXJ0eU9mID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5T2YnKTtcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlSHRtbENoYXI7XG4iLCIvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlU3RyaW5nQ2hhcjtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcblxubW9kdWxlLmV4cG9ydHMgPSByZUVzY2FwZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2c7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVFdmFsdWF0ZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlSW50ZXJwb2xhdGU7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFdpdGhcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICogfVxuICpcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAqXG4gKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbkluV2l0aDtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzRXJyb3IgPSByZXF1aXJlKCcuL2lzRXJyb3InKTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXR0ZW1wdDtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgZXNjYXBlSHRtbENoYXIgPSByZXF1aXJlKCcuL19lc2NhcGVIdG1sQ2hhcicpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpLFxuICAgIHZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmNsdWRlcztcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Vycm9yO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bGwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bGwodm9pZCAwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bWJlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAqIEBzZWUgXy5tYXBLZXlzXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IHtcbiAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gKiB9O1xuICpcbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVmFsdWVzO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpLFxuICAgIGJhc2VVbnNldCA9IHJlcXVpcmUoJy4vX2Jhc2VVbnNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGN1c3RvbU9taXRDbG9uZSA9IHJlcXVpcmUoJy4vX2N1c3RvbU9taXRDbG9uZScpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xudmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0pO1xuICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9taXQ7XG4iLCJ2YXIgYmFzZVBpY2sgPSByZXF1aXJlKCcuL19iYXNlUGljaycpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYXNzaWduSW5XaXRoID0gcmVxdWlyZSgnLi9hc3NpZ25JbldpdGgnKSxcbiAgICBhdHRlbXB0ID0gcmVxdWlyZSgnLi9hdHRlbXB0JyksXG4gICAgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBjdXN0b21EZWZhdWx0c0Fzc2lnbkluID0gcmVxdWlyZSgnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25JbicpLFxuICAgIGVzY2FwZVN0cmluZ0NoYXIgPSByZXF1aXJlKCcuL19lc2NhcGVTdHJpbmdDaGFyJyksXG4gICAgaXNFcnJvciA9IHJlcXVpcmUoJy4vaXNFcnJvcicpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyksXG4gICAgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vX3JlSW50ZXJwb2xhdGUnKSxcbiAgICB0ZW1wbGF0ZVNldHRpbmdzID0gcmVxdWlyZSgnLi90ZW1wbGF0ZVNldHRpbmdzJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaFxuICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAqL1xudmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gKlxuICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J3RlbXBsYXRlU291cmNlc1tuXSddXG4gKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICpcbiAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICpcbiAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gKlxuICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gKlxuICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAqIGNvbXBpbGVkKGRhdGEpO1xuICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAqXG4gKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAqIGNvbXBpbGVkLnNvdXJjZTtcbiAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAqIC8vICAgcmV0dXJuIF9fcDtcbiAqIC8vIH1cbiAqXG4gKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAqICAgdmFyIEpTVCA9IHtcXFxuICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gKiAgIH07XFxcbiAqICcpO1xuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgdmFyIHNldHRpbmdzID0gdGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzLl8udGVtcGxhdGVTZXR0aW5ncyB8fCB0ZW1wbGF0ZVNldHRpbmdzO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gIHZhciBpc0VzY2FwaW5nLFxuICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgLCAnZycpO1xuXG4gIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgdmFyIHNvdXJjZVVSTCA9ICdzb3VyY2VVUkwnIGluIG9wdGlvbnMgPyAnLy8jIHNvdXJjZVVSTD0nICsgb3B0aW9ucy5zb3VyY2VVUkwgKyAnXFxuJyA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gIH1cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcbiIsInZhciBlc2NhcGUgPSByZXF1aXJlKCcuL2VzY2FwZScpLFxuICAgIHJlRXNjYXBlID0gcmVxdWlyZSgnLi9fcmVFc2NhcGUnKSxcbiAgICByZUV2YWx1YXRlID0gcmVxdWlyZSgnLi9fcmVFdmFsdWF0ZScpLFxuICAgIHJlSW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuL19yZUludGVycG9sYXRlJyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZVNldHRpbmdzO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIGJhc2VWYWx1ZXMgPSByZXF1aXJlKCcuL19iYXNlVmFsdWVzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG4iLCIvKipcbiAqIEBmaWxlIENsYW1wIGEgbnVtYmVyIHRvIGxpbWl0cy5cbiAqIEB2ZXJzaW9uIDEuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBtYXRoLWNsYW1wLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b051bWJlciA9IHJlcXVpcmUoJ3RvLW51bWJlci14JykudG9OdW1iZXIyMDE4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNsYW1wIGEgbnVtYmVyIHRvIG1pbiBhbmQgbWF4IGxpbWl0cyBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIG51bWJlciB0byBiZSBjbGFtcGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gLSBUaGUgbWluaW11bSBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gbnVtYmVyLlxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgbWluID4gbWF4LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY2xhbXBlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hdGhDbGFtcCA9IHJlcXVpcmUoJ21hdGgtY2xhbXAteCcpO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNsYW1wKHZhbHVlKSB7XG4gIHZhciBudW1iZXIgPSB0b051bWJlcih2YWx1ZSk7XG4gIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGFyZ3NMZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHZhciBtaW4gPSB0b051bWJlcihhcmd1bWVudHNbMV0pO1xuICB2YXIgbWF4O1xuICBpZiAoYXJnc0xlbmd0aCA8IDMpIHtcbiAgICBtYXggPSBtaW47XG4gICAgbWluID0gMDtcbiAgfSBlbHNlIHtcbiAgICBtYXggPSB0b051bWJlcihhcmd1bWVudHNbMl0pO1xuICB9XG5cbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm1pblwiIG11c3QgYmUgbGVzcyB0aGFuIFwibWF4XCInKTtcbiAgfVxuXG4gIGlmIChudW1iZXIgPCBtaW4pIHtcbiAgICByZXR1cm4gbWluO1xuICB9XG5cbiAgaWYgKG51bWJlciA+IG1heCkge1xuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICByZXR1cm4gbnVtYmVyO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gOTAwNzE5OTI1NDc0MDk5MTtcbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBLUlNXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtQWRkaXRpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUNoYXJzZXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1EYXRldGltZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiaW5mb3JtYXRpb25hbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcwODldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuNF1bUkZDNzY5NCwgU2VjdGlvbiAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUZlYXR1cmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUxhbmd1YWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtUGF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU3ODldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtUG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwZXJtL2FjY2VwdC1wb3N0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbaHR0cHM6Ly93d3cudzMub3JnL1RSL2xkcC9dXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtUmFuZ2VzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gMi4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWxsb3dcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjQuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFMUE5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYzOSwgU2VjdGlvbiAyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWxzby1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMxODQ5XVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWx0LVN2Y1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3ODM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWx0LVVzZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzgzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsdGVybmF0ZS1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHRlcm5hdGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXBwbHktVG8tUmVkaXJlY3QtUmVmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0NDM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXBwcm92ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcmNoaXZlZC1BdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJ0aWNsZS1OYW1lc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTg0OV1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFydGljbGUtVXBkYXRlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTg0OV1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhlbnRpY2F0aW9uLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImV4cGVyaW1lbnRhbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwNTMsIFNlY3Rpb24gNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhlbnRpY2F0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYxNSwgU2VjdGlvbiAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0aGVudGljYXRpb24tUmVzdWx0c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjAxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0aG9yaXphdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM1LCBTZWN0aW9uIDQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dG8tU3VibWl0dGVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzM4MzQgc2VjdGlvbiA1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0b2ZvcndhcmRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dG9zdWJtaXR0ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJCYXNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMxODA4XVtSRkMyMDY4IFNlY3Rpb24gMTQuMTFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJCY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkJvZHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5vbmVcIixcbiAgICBcIlN0YXR1c1wiOiBcInJlc2VydmVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjA2OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkMtRXh0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQy1NYW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDLU9wdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkMtUEVQXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQy1QRVAtSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYWxEQVYtVGltZXpvbmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc4MDksIFNlY3Rpb24gNy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FuY2VsLUtleVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MzE1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FuY2VsLUxvY2tcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODMxNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDbG9zZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwicmVzZXJ2ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDguMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbW1lbnRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb21tZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29ubmVjdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDYuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtQWx0ZXJuYXRpdmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUJhc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzIwNjhdW1JGQzI2MTZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUJhc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzIxMTBdW1JGQzI1NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LURlc2NyaXB0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1EaXNwb3NpdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MjY2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1EaXNwb3NpdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRHVyYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjIuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtZmVhdHVyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtSWRlbnRpZmllclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTGVuZ3RoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gMy4zLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUxvY2F0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTG9jYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LU1ENVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1SYW5nZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtUmV0dXJuXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1TY3JpcHQtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtU3R5bGUtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVRyYW5zbGF0aW9uLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODI1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDMuMS4xLjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb252ZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udmVyc2lvbi1XaXRoLUxvc3NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb29raWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjI2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvb2tpZTJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzI5NjVdW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEQVNMXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEQVZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRMLUV4cGFuc2lvbi1IaXN0b3J5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS4xLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlLVJlY2VpdmVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMwODUwXVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVmYXVsdC1TdHlsZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlZmVycmVkLURlbGl2ZXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVsaXZlcnktRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlbHRhLUJhc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZXB0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVyaXZlZC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVzdGluYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpZmZlcmVudGlhbC1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpZ2VzdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc2NhcmRlZC1YNDAwLUlQTVMtRXh0ZW5zaW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc2NhcmRlZC1YNDAwLU1UUy1FeHRlbnNpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzY2xvc2UtUmVjaXBpZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc3Bvc2l0aW9uLU5vdGlmaWNhdGlvbi1PcHRpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzcG9zaXRpb24tTm90aWZpY2F0aW9uLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzdHJpYnV0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJES0lNLVNpZ25hdHVyZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2Mzc2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1CY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1EaXNwb3NpdGlvbi1Ob3RpZmljYXRpb24tVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUZpbmFsLVJlY2lwaWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1Jbi1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1NYWlsLUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLU1lc3NhZ2UtSWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtT3JpZ2luYWwtUmVjaXBpZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJjcHQtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlZmVyZW5jZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1CY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1DY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXR1cm4tUGF0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVhcmx5LURhdGFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODQ3MF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRW5jcnlwdGVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRVRhZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDIuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBpcnktRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZvbGxvd3VwLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGb3J3YXJkZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkdlbmVyYXRlLURlbGl2ZXJ5LVJlcG9ydFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkdldFByb2ZpbGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJIb2JhcmVnXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJleHBlcmltZW50YWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDg2LCBTZWN0aW9uIDYuMS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDUuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkhUVFAyLVNldHRpbmdzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc1NDAsIFNlY3Rpb24gMy4yLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJTVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1NYXRjaFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLU1vZGlmaWVkLVNpbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtTm9uZS1NYXRjaFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLVJhbmdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtU2NoZWR1bGUtVGFnLU1hdGNoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY2MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1Vbm1vZGlmaWVkLVNpbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW1wb3J0YW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluLVJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmNsdWRlLVJlZmVycmVkLVRva2VuLUJpbmRpbmctSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdG9rYmluZC1odHRwcy0xOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluY29tcGxldGUtQ29weVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluamVjdGlvbi1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmplY3Rpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiS2VlcC1BbGl2ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIktleXdvcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJLZXl3b3Jkc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGFiZWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxhc3QtTW9kaWZpZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAyLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMYXRlc3QtRGVsaXZlcnktVGltZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpbmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMzk3N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpbmtcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODI4OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtQXJjaGl2ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtSGVscFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LU93bmVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1Qb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1TdWJzY3JpYmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LVVuc3Vic2NyaWJlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInBlcm0vbGlzdC11bnN1YnNjcmliZVwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1VbnN1YnNjcmliZS1Qb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwNThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMb2NhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTG9jay1Ub2tlblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWFuXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWF4LUZvcndhcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4xLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZW1lbnRvLURhdGV0aW1lXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJpbmZvcm1hdGlvbmFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzA4OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtQ29udGV4dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ldGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTUlNRS1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIEFwcGVuZGl4IEEuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1JTUUtVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtRXhlbXB0ZWQtQWRkcmVzc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjEgYW5kIEFwcGVuZGl4IEIuMTA1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1FeHRlbmRlZC1BdXRob3Jpc2F0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4yIGFuZCBBcHBlbmRpeCBCLjEwNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtU3ViamVjdC1JbmRpY2F0b3ItQ29kZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4zIGFuZCBBcHBlbmRpeCBCLjEwN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtSGFuZGxpbmctSW5zdHJ1Y3Rpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuNCBhbmQgQXBwZW5kaXggQi4xMDhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU1lc3NhZ2UtSW5zdHJ1Y3Rpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuNSBhbmQgQXBwZW5kaXggQi4xMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUNvZHJlc3MtTWVzc2FnZS1JbmRpY2F0b3JcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS42IGFuZCBBcHBlbmRpeCBCLjExMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtT3JpZ2luYXRvci1SZWZlcmVuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS43IGFuZCBBcHBlbmRpeCBCLjExMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtUHJpbWFyeS1QcmVjZWRlbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuOCBhbmQgQXBwZW5kaXggQi4xMDFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUNvcHktUHJlY2VkZW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjkgYW5kIEFwcGVuZGl4IEIuMTAyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1NZXNzYWdlLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4xMCBhbmQgQXBwZW5kaXggQi4xMDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU90aGVyLVJlY2lwaWVudHMtSW5kaWNhdG9yLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMTIgYW5kIEFwcGVuZGl4IEIuMTEzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1PdGhlci1SZWNpcGllbnRzLUluZGljYXRvci1DQ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjEyIGFuZCBBcHBlbmRpeCBCLjExM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtQWNwMTI3LU1lc3NhZ2UtSWRlbnRpZmllclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjE0IGFuZCBBcHBlbmRpeCBCLjExNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtT3JpZ2luYXRvci1QTEFEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMTUgYW5kIEFwcGVuZGl4IEIuMTE3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTVQtUHJpb3JpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjc1OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5lZ290aWF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5ld3Nncm91cHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5OVFAtUG9zdGluZy1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTk5UUC1Qb3N0aW5nLUhvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzI5ODBdW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPYnNvbGV0ZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcHRpb25hbC1XV1ctQXV0aGVudGljYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJleHBlcmltZW50YWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDUzLCBTZWN0aW9uIDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmRlcmluZy1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmdhbml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcImluZm9ybWF0aW9uYWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjgxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JnYW5pemF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLUVuY29kZWQtSW5mb3JtYXRpb24tVHlwZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU3MDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1NZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtUmVjaXBpZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInBlcm0vb3JpZ2luYWwtcmVjaXBpZW50XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMzc5OF1bUkZDNTMzN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYXRvci1SZXR1cm4tQWRkcmVzc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLVN1YmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTcwM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk92ZXJ3cml0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUDNQXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUGF0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUEVQXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUElDUy1MYWJlbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBJQ1MtTGFiZWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQZXAtSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBvc2l0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQb3N0aW5nLVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzA4NTBdW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmFnbWFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmVmZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI0MF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByZWZlcmVuY2UtQXBwbGllZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjQwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJldmVudC1Ob25EZWxpdmVyeS1SZXBvcnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmlvcml0eVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb2ZpbGVPYmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm90b2NvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3RvY29sLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm90b2NvbC1RdWVyeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3RvY29sLVJlcXVlc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1BdXRoZW50aWNhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1BdXRoZW50aWNhdGlvbi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MTUsIFNlY3Rpb24gNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUF1dGhvcml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1GZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUluc3RydWN0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHVibGljXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHVibGljLUtleS1QaW5zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQdWJsaWMtS2V5LVBpbnMtUmVwb3J0LU9ubHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzQ2OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJhbmdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gMy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVjZWl2ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNTMyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlY2VpdmVkLVNQRlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjA4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVkaXJlY3QtUmVmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0NDM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuNS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVsYXktVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMDg1MF1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcGx5LUJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXF1aXJlLVJlY2lwaWVudC1WYWxpZC1TaW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjkzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUJjY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1NZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzY4NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJldHJ5LUFmdGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXR1cm4tUGF0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2FmZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNjaGVkdWxlLVJlcGx5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY2MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTY2hlZHVsZS1UYWdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjYzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1Ub2tlbi1CaW5kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXRva2JpbmQtaHR0cHMtMThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUFjY2VwdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUtleVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1Qcm90b2NvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWN1cml0eS1TY2hlbWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWUtQWxzb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTg0OV1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZW5zaXRpdml0eVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlcnZlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2V0LUNvb2tpZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MjY1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2V0LUNvb2tpZTJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzI5NjVdW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZXRQcm9maWxlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU0xVR1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU29hcEFjdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNvbGljaXRhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMzg2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN0YXR1cy1VUklcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY3OTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdW1tYXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdXBlcnNlZGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3VwZXJzZWRlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkMyMTU2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3Vycm9nYXRlLUNhcGFiaWxpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdXJyb2dhdGUtQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRDTlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRFXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNC4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVGltZW91dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVExTLVJlcG9ydC1Eb21haW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdXRhLXNtdHAtdGxzcnB0LTIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVExTLVJlcG9ydC1TdWJtaXR0ZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdXRhLXNtdHAtdGxzcnB0LTIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRvcGljXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVHJhaWxlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDQuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRyYW5zZmVyLUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gMy4zLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUVExcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODAzMCwgU2VjdGlvbiA1LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVcmdlbmN5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVVJJXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVXBncmFkZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDYuN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVzZXItQWdlbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVzZXItQWdlbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMjYxNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZhcmlhbnQtVmFyeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZhcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZCUi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWaWFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA1LjcuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJXYW50LURpZ2VzdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIldhcm5pbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLUNvbnRlbnQtSWRlbnRpZmllclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtQ29udGVudC1SZXR1cm5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLUNvbnRlbnQtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtTVRTLUlkZW50aWZpZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLU9yaWdpbmF0b3JcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLVJlY2VpdmVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1SZWNpcGllbnRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1UcmFjZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQ29udGVudC1UeXBlLU9wdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3gtY29udGVudC10eXBlLW9wdGlvbnMtaGVhZGVyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1GcmFtZS1PcHRpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJpbmZvcm1hdGlvbmFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzAzNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlhyZWZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2xcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1hbGxvdy1jcmVkZW50aWFsc1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLWFsbG93LW1ldGhvZHNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1hbGxvdy1vcmlnaW5cIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtbWF4LWFnZVwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBTVAtQ2FjaGUtVHJhbnNmb3JtXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltodHRwczovL2dpdGh1Yi5jb20vYW1wcHJvamVjdC9hbXBodG1sL2Jsb2IvbWFzdGVyL3NwZWMvYW1wLWNhY2hlLXRyYW5zZm9ybS5tZF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFwcGFyZW50bHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hcHBhcmVudGx5LXRvXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzIwNzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBUkMtQXV0aGVudGljYXRpb24tUmVzdWx0c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FyYy1hdXRoZW50aWNhdGlvbi1yZXN1bHRzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2RyYWZ0LWlldGYtZG1hcmMtYXJjLXByb3RvY29sXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQVJDLU1lc3NhZ2UtU2lnbmF0dXJlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYXJjLW1lc3NhZ2Utc2lnbmF0dXJlXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2RyYWZ0LWlldGYtZG1hcmMtYXJjLXByb3RvY29sXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQVJDLVNlYWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hcmMtc2VhbFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1pZXRmLWRtYXJjLWFyYy1wcm90b2NvbF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbXBsaWFuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVESUlOVC1GZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjAxN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVESUlOVC1GZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjAxN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVlc3N0LVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2ODFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFcnJvcnMtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9lcnJvcnMtdG9cIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjA3Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZvcm0tU3ViXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1sZXZpbmUtbWFpbGJvbWItaGVhZGVyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSmFiYmVyLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvamFiYmVyLWlkXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyNTldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJKYWJiZXItSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9qYWJiZXItaWRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI1OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXRob2QtQ2hlY2tcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9tZXRob2QtY2hlY2tcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWV0aG9kLUNoZWNrLUV4cGlyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9tZXRob2QtY2hlY2stZXhwaXJlc1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUF1dGhvcml6aW5nLVVzZXJzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3OTEyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTm9uLUNvbXBsaWFuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcHRpb25hbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByaXZpY29uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1rb2VuaWctcHJpdmljb25zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlci1Sb290XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvcmVmZXJlci1yb290XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc29sdXRpb24tSGludFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc29sdmVyLUxvY2F0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU0lPLUxhYmVsXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDQ0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU0lPLUxhYmVsLUhpc3RvcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NDRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJPS1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1YnN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVGl0bGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVQS1Db2xvclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVBLU1lZGlhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVUEtUGl4ZWxzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVUEtUmVzb2x1dGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVBLVdpbmRvd3BpeGVsc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLUFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1hcmNoaXZlZC1hdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTA2NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWFyY2hpdmVkLWF0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1EZXZpY2UtQWNjZXB0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1kZXZpY2UtYWNjZXB0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBNb2JpbGUgV2ViIEJlc3QgUHJhY3RpY2VzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLURldmljZS1BY2NlcHQtQ2hhcnNldFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLWFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBNb2JpbGUgV2ViIEJlc3QgUHJhY3RpY2VzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLURldmljZS1BY2NlcHQtRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWRldmljZS1hY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIE1vYmlsZSBXZWIgQmVzdCBQcmFjdGljZXMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtRGV2aWNlLUFjY2VwdC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLWFjY2VwdC1sYW5ndWFnZVwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgTW9iaWxlIFdlYiBCZXN0IFByYWN0aWNlcyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1EZXZpY2UtVXNlci1BZ2VudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLXVzZXItYWdlbnRcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIE1vYmlsZSBXZWIgQmVzdCBQcmFjdGljZXMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtTWl0dGVudGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVBHUC1TaWdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LXBncC1zaWdcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbZnRwOi8vZnRwLmlzYy5vcmcvcHViL3BncGNvbnRyb2wvRk9STUFUXVtodHRwczovL2Z0cC5pc2Mub3JnL3B1Yi9wZ3Bjb250cm9sL0ZPUk1BVF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtUmljZXZ1dGFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVJpZmVyaW1lbnRvLU1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVRpcG9SaWNldnV0YVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtVHJhc3BvcnRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MTA5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1WZXJpZmljYVNpY3VyZXp6YVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9XG5dIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpbmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMzk3N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2xcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWV0aG9kLUNoZWNrXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvbWV0aG9kLWNoZWNrXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ldGhvZC1DaGVjay1FeHBpcmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvbWV0aG9kLWNoZWNrLWV4cGlyZXNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlci1Sb290XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvcmVmZXJlci1yb290XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWFyY2hpdmVkLWF0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1BcmNoaXZlZC1BdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtYXJjaGl2ZWQtYXRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfVxuXSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBhbGw6IHJlcXVpcmUoJy4vYWxsLmpzb24nKSxcbiAgcGVybWFuZW50OiByZXF1aXJlKCcuL3Blcm1hbmVudC5qc29uJyksXG4gIHByb3Zpc2lvbmFsOiByZXF1aXJlKCcuL3Byb3Zpc2lvbmFsLmpzb24nKSxcbiAgc3RhbmRhcmQ6IHJlcXVpcmUoJy4vc3RhbmRhcmQuanNvbicpLFxuICBkZXByZWNhdGVkOiByZXF1aXJlKCcuL2RlcHJlY2F0ZWQuanNvbicpXG59O1xuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkEtSU1cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1BZGRpdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtQ2hhcnNldFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LURhdGV0aW1lXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJpbmZvcm1hdGlvbmFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzA4OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy40XVtSRkM3Njk0LCBTZWN0aW9uIDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtRmVhdHVyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1QYXRjaFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTc4OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1Qb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInBlcm0vYWNjZXB0LXBvc3RcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltodHRwczovL3d3dy53My5vcmcvVFIvbGRwL11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1SYW5nZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMywgU2VjdGlvbiAyLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbGxvd1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuNC4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQUxQTlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjM5LCBTZWN0aW9uIDJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHNvLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzE4NDldW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHQtU3ZjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc4MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHQtVXNlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3ODM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWx0ZXJuYXRlLVJlY2lwaWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsdGVybmF0ZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcHBseS1Uby1SZWRpcmVjdC1SZWZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ0MzddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcHByb3ZlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJjaGl2ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTA2NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcnRpY2xlLU5hbWVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMxODQ5XVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJ0aWNsZS1VcGRhdGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMxODQ5XVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0aGVudGljYXRpb24tQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZXhwZXJpbWVudGFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODA1MywgU2VjdGlvbiA0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0aGVudGljYXRpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjE1LCBTZWN0aW9uIDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRoZW50aWNhdGlvbi1SZXN1bHRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MDFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0by1TdWJtaXR0ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMzgzNCBzZWN0aW9uIDVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRvZm9yd2FyZGVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0b3N1Ym1pdHRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkJhc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzE4MDhdW1JGQzIwNjggU2VjdGlvbiAxNC4xMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkJjY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQm9keVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibm9uZVwiLFxuICAgIFwiU3RhdHVzXCI6IFwicmVzZXJ2ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MDY4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQy1FeHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDLU1hblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkMtT3B0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQy1QRVBcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDLVBFUC1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FjaGUtQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNhbERBVi1UaW1lem9uZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzgwOSwgU2VjdGlvbiA3LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYW5jZWwtS2V5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgzMTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYW5jZWwtTG9ja1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MzE1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNsb3NlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJyZXNlcnZlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gOC4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29tbWVudHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbW1lbnRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb25uZWN0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNi4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1BbHRlcm5hdGl2ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtQmFzZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjA2OF1bUkZDMjYxNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtQmFzZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjExMF1bUkZDMjU1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRGVzY3JpcHRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYyNjZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1EdXJhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuMi4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1mZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1JZGVudGlmaWVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDMuMS4zLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUxhbmd1YWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiAzLjMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTG9jYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1Mb2NhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1NRDVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVJhbmdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1SZXR1cm5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVNjcmlwdC1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1TdHlsZS1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHJhbnNsYXRpb24tVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MjU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjEuNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb252ZXJzaW9uLVdpdGgtTG9zc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvb2tpZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MjY1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29va2llMlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjk2NV1bUkZDNjI2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRBU0xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRBVlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiREwtRXhwYW5zaW9uLUhpc3RvcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjEuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRhdGUtUmVjZWl2ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzA4NTBdW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZWZhdWx0LVN0eWxlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVmZXJyZWQtRGVsaXZlcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZWxpdmVyeS1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVsdGEtQmFzZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlcHRoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZXJpdmVkLUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZXN0aW5hdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlmZmVyZW50aWFsLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlnZXN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzY2FyZGVkLVg0MDAtSVBNUy1FeHRlbnNpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzY2FyZGVkLVg0MDAtTVRTLUV4dGVuc2lvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaXNjbG9zZS1SZWNpcGllbnRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzcG9zaXRpb24tTm90aWZpY2F0aW9uLU9wdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaXNwb3NpdGlvbi1Ob3RpZmljYXRpb24tVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaXN0cmlidXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRLSU0tU2lnbmF0dXJlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYzNzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUJjY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtQ2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLURpc3Bvc2l0aW9uLU5vdGlmaWNhdGlvbi1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtRmluYWwtUmVjaXBpZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUluLVJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLU1haWwtRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtTWVzc2FnZS1JZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1PcmlnaW5hbC1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmNwdC1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LUJjY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LUNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXNlbnQtRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LVJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXNlbnQtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXNlbnQtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJldHVybi1QYXRoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1TZW5kZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRWFybHktRGF0YVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4NDcwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFbmNyeXB0ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFVGFnXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMi4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4xLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGlyeS1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXh0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRm9sbG93dXAtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZvcndhcmRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuNS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiR2VuZXJhdGUtRGVsaXZlcnktUmVwb3J0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiR2V0UHJvZmlsZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkhvYmFyZWdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImV4cGVyaW1lbnRhbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0ODYsIFNlY3Rpb24gNi4xLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJIb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNS40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSFRUUDItU2V0dGluZ3NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzU0MCwgU2VjdGlvbiAzLjIuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklNXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLU1hdGNoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtTW9kaWZpZWQtU2luY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1Ob25lLU1hdGNoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtUmFuZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMywgU2VjdGlvbiAzLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1TY2hlZHVsZS1UYWctTWF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjYzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLVVubW9kaWZpZWQtU2luY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbXBvcnRhbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW4tUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluY2x1ZGUtUmVmZXJyZWQtVG9rZW4tQmluZGluZy1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMtaWV0Zi10b2tiaW5kLWh0dHBzLTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW5jb21wbGV0ZS1Db3B5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW5qZWN0aW9uLURhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluamVjdGlvbi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJLZWVwLUFsaXZlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiS2V5d29yZHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIktleXdvcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMYWJlbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxhbmd1YWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGFzdC1Nb2RpZmllZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDIuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxhdGVzdC1EZWxpdmVyeS1UaW1lXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGluZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkMzOTc3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlua1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4Mjg4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1BcmNoaXZlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1IZWxwXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtT3duZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LVBvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LVN1YnNjcmliZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtVW5zdWJzY3JpYmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicGVybS9saXN0LXVuc3Vic2NyaWJlXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LVVuc3Vic2NyaWJlLVBvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODA1OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxvY2F0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMb2NrLVRva2VuXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNYW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNYXgtRm9yd2FyZHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjEuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lbWVudG8tRGF0ZXRpbWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImluZm9ybWF0aW9uYWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MDg5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVzc2FnZS1Db250ZXh0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVzc2FnZS1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWV0ZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNSU1FLVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgQXBwZW5kaXggQS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTUlNRS1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1FeGVtcHRlZC1BZGRyZXNzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMSBhbmQgQXBwZW5kaXggQi4xMDVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUV4dGVuZGVkLUF1dGhvcmlzYXRpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjIgYW5kIEFwcGVuZGl4IEIuMTA2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1TdWJqZWN0LUluZGljYXRvci1Db2Rlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjMgYW5kIEFwcGVuZGl4IEIuMTA3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1IYW5kbGluZy1JbnN0cnVjdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS40IGFuZCBBcHBlbmRpeCBCLjEwOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtTWVzc2FnZS1JbnN0cnVjdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS41IGFuZCBBcHBlbmRpeCBCLjEwOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtQ29kcmVzcy1NZXNzYWdlLUluZGljYXRvclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjYgYW5kIEFwcGVuZGl4IEIuMTEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1PcmlnaW5hdG9yLVJlZmVyZW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjcgYW5kIEFwcGVuZGl4IEIuMTExXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1QcmltYXJ5LVByZWNlZGVuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS44IGFuZCBBcHBlbmRpeCBCLjEwMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtQ29weS1QcmVjZWRlbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuOSBhbmQgQXBwZW5kaXggQi4xMDJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU1lc3NhZ2UtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjEwIGFuZCBBcHBlbmRpeCBCLjEwM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtT3RoZXItUmVjaXBpZW50cy1JbmRpY2F0b3ItVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4xMiBhbmQgQXBwZW5kaXggQi4xMTNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU90aGVyLVJlY2lwaWVudHMtSW5kaWNhdG9yLUNDXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMTIgYW5kIEFwcGVuZGl4IEIuMTEzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1BY3AxMjctTWVzc2FnZS1JZGVudGlmaWVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMTQgYW5kIEFwcGVuZGl4IEIuMTE2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1PcmlnaW5hdG9yLVBMQURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4xNSBhbmQgQXBwZW5kaXggQi4xMTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNVC1Qcmlvcml0eVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NzU4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTmVnb3RpYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTmV3c2dyb3Vwc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTk5UUC1Qb3N0aW5nLURhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJOTlRQLVBvc3RpbmctSG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjk4MF1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9ic29sZXRlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9wdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9wdGlvbmFsLVdXVy1BdXRoZW50aWNhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImV4cGVyaW1lbnRhbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwNTMsIFNlY3Rpb24gM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yZGVyaW5nLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yZ2FuaXphdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiaW5mb3JtYXRpb25hbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2ODFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmdhbml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtRW5jb2RlZC1JbmZvcm1hdGlvbi1UeXBlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTcwM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLU1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicGVybS9vcmlnaW5hbC1yZWNpcGllbnRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMzNzk4XVtSRkM1MzM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hdG9yLVJldHVybi1BZGRyZXNzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtU3ViamVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NzAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3ZlcndyaXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQM1BcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQYXRoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQRVBcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQSUNTLUxhYmVsXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUElDUy1MYWJlbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBlcC1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUG9zaXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBvc3RpbmctVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMDg1MF1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByYWdtYVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByZWZlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjQwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJlZmVyZW5jZS1BcHBsaWVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyNDBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmV2ZW50LU5vbkRlbGl2ZXJ5LVJlcG9ydFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByaW9yaXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJvZmlsZU9iamVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3RvY29sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJvdG9jb2wtSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3RvY29sLVF1ZXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJvdG9jb2wtUmVxdWVzdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUF1dGhlbnRpY2F0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM1LCBTZWN0aW9uIDQuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUF1dGhlbnRpY2F0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYxNSwgU2VjdGlvbiA0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktQXV0aG9yaXphdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM1LCBTZWN0aW9uIDQuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUZlYXR1cmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktSW5zdHJ1Y3Rpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQdWJsaWNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQdWJsaWMtS2V5LVBpbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzQ2OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlB1YmxpYy1LZXktUGlucy1SZXBvcnQtT25seVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDY5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmFuZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMywgU2VjdGlvbiAzLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWNlaXZlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM1MzIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVjZWl2ZWQtU1BGXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMDhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWRpcmVjdC1SZWZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ0MzddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWZlcmVuY2VzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWZlcmVuY2VzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWZlcmVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS41LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWxheS1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMwODUwXVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVwbHktQnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcXVpcmUtUmVjaXBpZW50LVZhbGlkLVNpbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyOTNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtQmNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtQ2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LU1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1TZW5kZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmV0cnktQWZ0ZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJldHVybi1QYXRoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTYWZlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2NoZWR1bGUtUmVwbHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjYzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNjaGVkdWxlLVRhZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NjM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVRva2VuLUJpbmRpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdG9rYmluZC1odHRwcy0xOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1XZWJTb2NrZXQtQWNjZXB0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1XZWJTb2NrZXQtS2V5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LVByb3RvY29sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlY3VyaXR5LVNjaGVtZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlZS1BbHNvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMxODQ5XVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzY4NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZW5kZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlbnNpdGl2aXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VydmVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy40LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZXQtQ29va2llXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZXQtQ29va2llMlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjk2NV1bUkZDNjI2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNldFByb2ZpbGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTTFVHXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwMjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTb2FwQWN0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU29saWNpdGF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMzODY1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3RhdHVzLVVSSVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN0cmljdC1UcmFuc3BvcnQtU2VjdXJpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjc5N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1YmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1YmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1bW1hcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1cGVyc2VkZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdXBlcnNlZGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzIxNTZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdXJyb2dhdGUtQ2FwYWJpbGl0eVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1cnJvZ2F0ZS1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVENOXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVEVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA0LjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUaW1lb3V0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUTFMtUmVwb3J0LURvbWFpblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMtaWV0Zi11dGEtc210cC10bHNycHQtMjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUTFMtUmVwb3J0LVN1Ym1pdHRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMtaWV0Zi11dGEtc210cC10bHNycHQtMjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVG9waWNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODAzMCwgU2VjdGlvbiA1LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUcmFpbGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNC40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVHJhbnNmZXItRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiAzLjMuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRUTFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDMwLCBTZWN0aW9uIDUuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVyZ2VuY3lcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODAzMCwgU2VjdGlvbiA1LjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVUklcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVcGdyYWRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNi43XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVXNlci1BZ2VudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuNS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVXNlci1BZ2VudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkMyNjE2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVmFyaWFudC1WYXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVmFyeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVkJSLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZpYVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDUuNy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiV1dXLUF1dGhlbnRpY2F0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM1LCBTZWN0aW9uIDQuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIldhbnQtRGlnZXN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiV2FybmluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtQ29udGVudC1JZGVudGlmaWVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1Db250ZW50LVJldHVyblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtQ29udGVudC1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1NVFMtSWRlbnRpZmllclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtT3JpZ2luYXRvclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtUmVjZWl2ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLVJlY2lwaWVudHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLVRyYWNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1Db250ZW50LVR5cGUtT3B0aW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jeC1jb250ZW50LXR5cGUtb3B0aW9ucy1oZWFkZXJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLUZyYW1lLU9wdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImluZm9ybWF0aW9uYWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MDM0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWHJlZlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH1cbl0iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLWFsbG93LWNyZWRlbnRpYWxzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVyc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLWFsbG93LWhlYWRlcnNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtYWxsb3ctbWV0aG9kc1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLWFsbG93LW9yaWdpblwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLU1heC1BZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1tYXgtYWdlXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLVJlcXVlc3QtSGVhZGVyc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFNUC1DYWNoZS1UcmFuc2Zvcm1cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2h0dHBzOi8vZ2l0aHViLmNvbS9hbXBwcm9qZWN0L2FtcGh0bWwvYmxvYi9tYXN0ZXIvc3BlYy9hbXAtY2FjaGUtdHJhbnNmb3JtLm1kXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXBwYXJlbnRseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FwcGFyZW50bHktdG9cIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjA3Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFSQy1BdXRoZW50aWNhdGlvbi1SZXN1bHRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYXJjLWF1dGhlbnRpY2F0aW9uLXJlc3VsdHNcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbZHJhZnQtaWV0Zi1kbWFyYy1hcmMtcHJvdG9jb2xdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBUkMtTWVzc2FnZS1TaWduYXR1cmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hcmMtbWVzc2FnZS1zaWduYXR1cmVcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbZHJhZnQtaWV0Zi1kbWFyYy1hcmMtcHJvdG9jb2xdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBUkMtU2VhbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FyYy1zZWFsXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2RyYWZ0LWlldGYtZG1hcmMtYXJjLXByb3RvY29sXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29tcGxpYW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRURJSU5ULUZlYXR1cmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MDE3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRURJSU5ULUZlYXR1cmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MDE3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRWVzc3QtVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzY4MV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVycm9ycy1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2Vycm9ycy10b1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMyMDc2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRm9ybS1TdWJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2RyYWZ0LWxldmluZS1tYWlsYm9tYi1oZWFkZXJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJKYWJiZXItSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9qYWJiZXItaWRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI1OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkphYmJlci1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2phYmJlci1pZFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjU5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ldGhvZC1DaGVja1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L21ldGhvZC1jaGVja1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXRob2QtQ2hlY2stRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L21ldGhvZC1jaGVjay1leHBpcmVzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtQXV0aG9yaXppbmctVXNlcnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc5MTJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJOb24tQ29tcGxpYW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9wdGlvbmFsXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJpdmljb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2RyYWZ0LWtvZW5pZy1wcml2aWNvbnNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWZlcmVyLVJvb3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9yZWZlcmVyLXJvb3RcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzb2x1dGlvbi1IaW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzb2x2ZXItTG9jYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTSU8tTGFiZWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NDRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTSU8tTGFiZWwtSGlzdG9yeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzQ0NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1Yk9LXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3Vic3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUaXRsZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVBLUNvbG9yXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVUEtTWVkaWFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVQS1QaXhlbHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVQS1SZXNvbHV0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVUEtV2luZG93cGl4ZWxzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWFyY2hpdmVkLWF0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1BcmNoaXZlZC1BdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtYXJjaGl2ZWQtYXRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLURldmljZS1BY2NlcHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWRldmljZS1hY2NlcHRcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIE1vYmlsZSBXZWIgQmVzdCBQcmFjdGljZXMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtRGV2aWNlLUFjY2VwdC1DaGFyc2V0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1kZXZpY2UtYWNjZXB0LWNoYXJzZXRcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIE1vYmlsZSBXZWIgQmVzdCBQcmFjdGljZXMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtRGV2aWNlLUFjY2VwdC1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLWFjY2VwdC1lbmNvZGluZ1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgTW9iaWxlIFdlYiBCZXN0IFByYWN0aWNlcyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1EZXZpY2UtQWNjZXB0LUxhbmd1YWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1kZXZpY2UtYWNjZXB0LWxhbmd1YWdlXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBNb2JpbGUgV2ViIEJlc3QgUHJhY3RpY2VzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLURldmljZS1Vc2VyLUFnZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1kZXZpY2UtdXNlci1hZ2VudFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgTW9iaWxlIFdlYiBCZXN0IFByYWN0aWNlcyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1NaXR0ZW50ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtUEdQLVNpZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtcGdwLXNpZ1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltmdHA6Ly9mdHAuaXNjLm9yZy9wdWIvcGdwY29udHJvbC9GT1JNQVRdW2h0dHBzOi8vZnRwLmlzYy5vcmcvcHViL3BncGNvbnRyb2wvRk9STUFUXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1SaWNldnV0YVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtUmlmZXJpbWVudG8tTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtVGlwb1JpY2V2dXRhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MTA5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1UcmFzcG9ydG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVZlcmlmaWNhU2ljdXJlenphXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MTA5XVwiXG4gIH1cbl0iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtQ2hhcnNldFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjRdW1JGQzc2OTQsIFNlY3Rpb24gM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy41XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LVBvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicGVybS9hY2NlcHQtcG9zdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2h0dHBzOi8vd3d3LnczLm9yZy9UUi9sZHAvXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LVJhbmdlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDIuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsbG93XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy40LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBTFBOXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MzksIFNlY3Rpb24gMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsdC1TdmNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzgzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsdC1Vc2VkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc4MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcHByb3ZlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJjaGl2ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTA2NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRoZW50aWNhdGlvbi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MTUsIFNlY3Rpb24gM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhlbnRpY2F0aW9uLVJlc3VsdHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYwMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhvcml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRvLVN1Ym1pdHRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMzODM0IHNlY3Rpb24gNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkJjY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FjaGUtQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNhbERBVi1UaW1lem9uZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzgwOSwgU2VjdGlvbiA3LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYW5jZWwtS2V5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgzMTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYW5jZWwtTG9ja1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MzE1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbW1lbnRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb21tZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29ubmVjdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDYuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjI2Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuMi4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDMuMS4zLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDMuMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1Mb2NhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDMuMS40LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVJhbmdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1UcmFuc2xhdGlvbi1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgyNTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuMS41XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29va2llXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEQVNMXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEQVZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuMS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVwdGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlc3RpbmF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaXN0cmlidXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRLSU0tU2lnbmF0dXJlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYzNzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUZpbmFsLVJlY2lwaWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1Jbi1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1NZXNzYWdlLUlkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLU9yaWdpbmFsLVJlY2lwaWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZWZlcmVuY2VzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFYXJseS1EYXRhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzg0NzBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFVGFnXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMi4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4xLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRm9sbG93dXAtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZvcndhcmRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuNS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDUuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkhUVFAyLVNldHRpbmdzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc1NDAsIFNlY3Rpb24gMy4yLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtTWF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLU5vbmUtTWF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1SYW5nZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLVNjaGVkdWxlLVRhZy1NYXRjaFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NjM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtVW5tb2RpZmllZC1TaW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluLVJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmNsdWRlLVJlZmVycmVkLVRva2VuLUJpbmRpbmctSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdG9rYmluZC1odHRwcy0xOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluamVjdGlvbi1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmplY3Rpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiS2V5d29yZHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIktleXdvcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMYXN0LU1vZGlmaWVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMi4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlua1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4Mjg4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1VbnN1YnNjcmliZS1Qb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwNThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMb2NhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTG9jay1Ub2tlblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWF4LUZvcndhcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4xLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNSU1FLVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgQXBwZW5kaXggQS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTVQtUHJpb3JpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjc1OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5ld3Nncm91cHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yZGVyaW5nLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yZ2FuaXphdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU3MDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicGVybS9vcmlnaW5hbC1yZWNpcGllbnRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMzNzk4XVtSRkM1MzM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1TdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU3MDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPdmVyd3JpdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBhdGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBvc2l0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmFnbWFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmVmZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI0MF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByZWZlcmVuY2UtQXBwbGllZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjQwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktQXV0aGVudGljYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktQXV0aGVudGljYXRpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjE1LCBTZWN0aW9uIDRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1BdXRob3JpemF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHVibGljLUtleS1QaW5zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQdWJsaWMtS2V5LVBpbnMtUmVwb3J0LU9ubHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzQ2OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJhbmdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gMy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVjZWl2ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNTMyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlY2VpdmVkLVNQRlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjA4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuNS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXF1aXJlLVJlY2lwaWVudC1WYWxpZC1TaW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjkzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUJjY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1NZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzY4NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJldHJ5LUFmdGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXR1cm4tUGF0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2NoZWR1bGUtUmVwbHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjYzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNjaGVkdWxlLVRhZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NjM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVRva2VuLUJpbmRpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdG9rYmluZC1odHRwcy0xOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1XZWJTb2NrZXQtQWNjZXB0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1XZWJTb2NrZXQtS2V5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LVByb3RvY29sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZXJ2ZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNldC1Db29raWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjI2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNMVUdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTAyM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN0cmljdC1UcmFuc3BvcnQtU2VjdXJpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjc5N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1YmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1YmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1bW1hcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1cGVyc2VkZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMjE1Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRFXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNC4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVGltZW91dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVExTLVJlcG9ydC1Eb21haW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdXRhLXNtdHAtdGxzcnB0LTIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVExTLVJlcG9ydC1TdWJtaXR0ZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdXRhLXNtdHAtdGxzcnB0LTIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRvcGljXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVHJhaWxlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDQuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRyYW5zZmVyLUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gMy4zLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUVExcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODAzMCwgU2VjdGlvbiA1LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVcmdlbmN5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVXBncmFkZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDYuN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVzZXItQWdlbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVzZXItQWdlbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMjYxNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZhcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZCUi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWaWFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA1LjcuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJXYXJuaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS41XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1Db250ZW50LVR5cGUtT3B0aW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jeC1jb250ZW50LXR5cGUtb3B0aW9ucy1oZWFkZXJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYcmVmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfVxuXSIsIi8qKlxuICogQGZpbGUgVGhlIGNvbnN0YW50IE5hTiBkZXJpdmVkIG1hdGhlbWF0aWNhbGx5IGJ5IDAgLyAwLlxuICogQHZlcnNpb24gMS4wLjJcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG5hbi14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBjb25zdGFudCBOYU4gZGVyaXZlZCBtYXRoZW1hdGljYWxseSBieSAwIC8gMC5cbiAqXG4gKiBAdHlwZSBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiB2YXIgTkFOID0gcmVxdWlyZSgnbmFuLXgnKTtcbiAqXG4gKiBOQU4gIT09IE5BTjsgLy8gdHJ1ZVxuICogTkFOID09PSBOQU47IC8vIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gMCAvIDA7XG4iLCIvKipcbiAqIEBmaWxlIFRyaW1zIGFuZCByZXBsYWNlcyBzZXF1ZW5jZXMgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGJ5IGEgc2luZ2xlIHNwYWNlLlxuICogQHZlcnNpb24gMy4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG5vcm1hbGl6ZS1zcGFjZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGliVHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xudmFyIHRyaW0yMDE2ID0gbGliVHJpbS50cmltMjAxNjtcbnZhciB0cmltMjAxOCA9IGxpYlRyaW0udHJpbTIwMTg7XG52YXIgUnggPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5SZWdFeHA7XG52YXIgbGliV2hpdGVTcGFjZSA9IHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKTtcbnZhciByZU5vcm1hbGl6ZTIwMTYgPSBuZXcgUngoJ1snICsgbGliV2hpdGVTcGFjZS5zdHJpbmcyMDE2ICsgJ10rJywgJ2cnKTtcbnZhciByZU5vcm1hbGl6ZTIwMTggPSBuZXcgUngoJ1snICsgbGliV2hpdGVTcGFjZS5zdHJpbmcyMDE4ICsgJ10rJywgJ2cnKTtcbnZhciByZXBsYWNlID0gJycucmVwbGFjZTtcblxudmFyICRub3JtYWxpemVTcGFjZTIwMTYgPSBmdW5jdGlvbiBub3JtYWxpemVTcGFjZTIwMTYoc3RyaW5nKSB7XG4gIHJldHVybiByZXBsYWNlLmNhbGwodHJpbTIwMTYoc3RyaW5nKSwgcmVOb3JtYWxpemUyMDE2LCAnICcpO1xufTtcblxudmFyICRub3JtYWxpemVTcGFjZTIwMTggPSBmdW5jdGlvbiBub3JtYWxpemVTcGFjZTIwMTgoc3RyaW5nKSB7XG4gIHJldHVybiByZXBsYWNlLmNhbGwodHJpbTIwMTgoc3RyaW5nKSwgcmVOb3JtYWxpemUyMDE4LCAnICcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gbm9ybWFsaXplU3BhY2UyMDE4LlxuICAgKi9cbiAgbm9ybWFsaXplU3BhY2U6ICRub3JtYWxpemVTcGFjZTIwMTgsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHN0cmlwcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZS1zcGFjZSBmcm9tIGEgc3RyaW5nLFxuICAgKiByZXBsYWNlcyBzZXF1ZW5jZXMgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGJ5IGEgc2luZ2xlIHNwYWNlLFxuICAgKiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHN0cmluZy4gKEVTMjAxNilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gYmUgbm9ybWFsaXplZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgbm9ybWFsaXplU3BhY2UgPSByZXF1aXJlKCdub3JtYWxpemUtc3BhY2UteCcpO1xuICAgKlxuICAgKiBub3JtYWxpemVTcGFjZSgnIFxcdFxcbmEgXFx0XFxuYiBcXHRcXG4nKSA9PT0gJ2EgYic7IC8vIHRydWVcbiAgICovXG4gIG5vcm1hbGl6ZVNwYWNlMjAxNjogJG5vcm1hbGl6ZVNwYWNlMjAxNixcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc3RyaXBzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlLXNwYWNlIGZyb20gYSBzdHJpbmcsXG4gICAqIHJlcGxhY2VzIHNlcXVlbmNlcyBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgYnkgYSBzaW5nbGUgc3BhY2UsXG4gICAqIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgc3RyaW5nLiAoRVMyMDE4KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBiZSBub3JtYWxpemVkLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHN0cmluZyBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBub3JtYWxpemVTcGFjZSA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1zcGFjZS14Jyk7XG4gICAqXG4gICAqIG5vcm1hbGl6ZVNwYWNlKCcgXFx0XFxuYSBcXHRcXG5iIFxcdFxcbicpID09PSAnYSBiJzsgLy8gdHJ1ZVxuICAgKi9cbiAgbm9ybWFsaXplU3BhY2UyMDE4OiAkbm9ybWFsaXplU3BhY2UyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBVc2VkIHRvIGNvcHkgdGhlIHZhbHVlcyBvZiBhbGwgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAqIEB2ZXJzaW9uIDEuMS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBvYmplY3QtYXNzaWduLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzLXgnKTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJ2FycmF5LXJlZHVjZS14Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJ2dldC1vd24tcHJvcGVydHktbmFtZXMteCcpO1xudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbnZhciBuYXRpdmVBc3NpZ24gPSBpc0Z1bmN0aW9uKE9iamVjdC5hc3NpZ24pICYmIE9iamVjdC5hc3NpZ247XG5cbnZhciB3b3JraW5nTmF0aXZlQXNzaWduID0gZnVuY3Rpb24gX25hdGl2ZVdvcmtzKCkge1xuICB2YXIgb2JqID0ge307XG4gIHZhciByZXMgPSBhdHRlbXB0KG5hdGl2ZUFzc2lnbiwgb2JqLCB7IDA6IDEgfSwgeyAxOiAyIH0pO1xuICByZXR1cm4gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgPT09IG9iaiAmJiBvYmplY3RLZXlzKG9iaikubGVuZ3RoID09PSAyICYmIG9ialswXSA9PT0gMSAmJiBvYmpbMV0gPT09IDI7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaWQtbGVuZ3RoXG52YXIgbGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyID0gZnVuY3Rpb24gX2VudW1PcmRlcigpIHtcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuICB2YXIgdGVzdDEgPSBPYmplY3QoJ2FiYycpO1xuICB0ZXN0MVs1XSA9ICdkZSc7XG4gIGlmIChnZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc3RyTnVtcyA9ICcwMTIzNDU2Nzg5JztcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuICB2YXIgdGVzdDIgPSByZWR1Y2Uoc3RyTnVtcy5zcGxpdCgnJyksIGZ1bmN0aW9uIChhY2MsIGlnbm9yZSwgaW5kZXgpIHtcbiAgICBhY2NbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpbmRleCldID0gaW5kZXg7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIHZhciBvcmRlciA9IHJlZHVjZShnZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKSwgZnVuY3Rpb24gKGFjYywgbmFtZSkge1xuICAgIHJldHVybiBhY2MgKyB0ZXN0MltuYW1lXTtcbiAgfSwgJycpO1xuXG4gIGlmIChvcmRlciAhPT0gc3RyTnVtcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuICB2YXIgbGV0dGVycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIHZhciB0ZXN0MyA9IHJlZHVjZShsZXR0ZXJzLnNwbGl0KCcnKSwgZnVuY3Rpb24gKGFjYywgbGV0dGVyKSB7XG4gICAgYWNjW2xldHRlcl0gPSBsZXR0ZXI7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0KG5hdGl2ZUFzc2lnbiwge30sIHRlc3QzKTtcbiAgcmV0dXJuIHJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgb2JqZWN0S2V5cyhyZXN1bHQudmFsdWUpLmpvaW4oJycpICE9PSBsZXR0ZXJzO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxudmFyIGFzc2lnbkhhc1BlbmRpbmdFeGNlcHRpb25zID0gZnVuY3Rpb24gX2V4Y2VwdGlvbnMoKSB7XG4gIGlmIChpc0Z1bmN0aW9uKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRmlyZWZveCAzNyBzdGlsbCBoYXMgXCJwZW5kaW5nIGV4Y2VwdGlvblwiIGxvZ2ljIGluIGl0cyBPYmplY3QuYXNzaWduIGltcGxlbWVudGF0aW9uLFxuICAvLyB3aGljaCBpcyA3MiUgc2xvd2VyIHRoYW4gb3VyIHNoaW0sIGFuZCBGaXJlZm94IDQwJ3MgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChPYmplY3QucHJldmVudEV4dGVuc2lvbnMsIHsgMTogMiB9KTtcbiAgaWYgKHJlc3VsdC50aHJldyB8fCBpc09iamVjdExpa2UocmVzdWx0LnZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdGhyb3dlciA9IHJlc3VsdC52YWx1ZTtcbiAgcmVzdWx0ID0gYXR0ZW1wdChuYXRpdmVBc3NpZ24sIHRocm93ZXIsICd4eScpO1xuICByZXR1cm4gcmVzdWx0LnRocmV3ID8gdGhyb3dlclsxXSA9PT0gJ3knIDogZmFsc2U7XG59O1xuXG52YXIgc2hvdWxkSW1wbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKG5hdGl2ZUFzc2lnbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh3b3JraW5nTmF0aXZlQXNzaWduKCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobGFja3NQcm9wZXJFbnVtZXJhdGlvbk9yZGVyKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59KCkpO1xuXG52YXIgJGFzc2lnbjtcbmlmIChzaG91bGRJbXBsZW1lbnQpIHtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbiAgdmFyIHNsaWNlID0gcmVxdWlyZSgnYXJyYXktc2xpY2UteCcpO1xuICB2YXIgaXNOaWwgPSByZXF1aXJlKCdpcy1uaWwteCcpO1xuICB2YXIgZ2V0T0VQUyA9IHJlcXVpcmUoJ2dldC1vd24tZW51bWVyYWJsZS1wcm9wZXJ0eS1zeW1ib2xzLXgnKTtcbiAgdmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG5cbiAgLy8gMTkuMS4zLjFcbiAgJGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICByZXR1cm4gcmVkdWNlKHNsaWNlKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIF9hc3NpZ25Tb3VyY2VzKHRndCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNOaWwoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGd0O1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gT2JqZWN0KHNvdXJjZSk7XG4gICAgICByZXR1cm4gcmVkdWNlKGNvbmNhdC5jYWxsKG9iamVjdEtleXMob2JqZWN0KSwgZ2V0T0VQUyhvYmplY3QpKSwgZnVuY3Rpb24gX2Fzc2lnblRvKHRhciwga2V5KSB7XG4gICAgICAgIHRhcltrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiB0YXI7XG4gICAgICB9LCB0Z3QpO1xuICAgIH0sIHRvT2JqZWN0KHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgJGFzc2lnbiA9IG5hdGl2ZUFzc2lnbjtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNvcHkgdGhlIHZhbHVlcyBvZiBhbGwgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyB0byBhIHRhcmdldCBvYmplY3QuIEl0IHdpbGwgcmV0dXJuIHRoZSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IFsuLi5zb3VyY2VdIC0gVGhlIHNvdXJjZSBvYmplY3QocykuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRhcmdldCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduLXgnKTtcbiAqXG4gKiB2YXIgb2JqID0geyBhOiAxIH07XG4gKiB2YXIgY29weSA9IGFzc2lnbih7fSwgb2JqKTtcbiAqIGNvbnNvbGUubG9nKGNvcHkpOyAvLyB7IGE6IDEgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRhc3NpZ247XG4iLCIvKipcbiAqIEBmaWxlIFJlZHVjZSBhbiBhcnJheSAoZnJvbSBsZWZ0IHRvIHJpZ2h0KSB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqIEB2ZXJzaW9uIDIuMS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBhcnJheS1yZWR1Y2UteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhY2hlZEN0cnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbnZhciBBcnJheUN0ciA9IGNhY2hlZEN0cnMuQXJyYXk7XG52YXIgY2FzdE9iamVjdCA9IGNhY2hlZEN0cnMuT2JqZWN0O1xudmFyIG5hdGl2ZVJlZHVjZSA9IHR5cGVvZiBBcnJheUN0ci5wcm90b3R5cGUucmVkdWNlID09PSAnZnVuY3Rpb24nICYmIEFycmF5Q3RyLnByb3RvdHlwZS5yZWR1Y2U7XG5cbi8vIEVTNSAxNS40LjQuMjFcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VcbnZhciBpc1dvcmtpbmc7XG5pZiAobmF0aXZlUmVkdWNlKSB7XG4gIHZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gIGlzV29ya2luZyA9IGF0dGVtcHQuY2FsbChbXSwgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjKSB7XG4gICAgcmV0dXJuIGFjYztcbiAgfSkudGhyZXc7XG5cbiAgdmFyIHJlcztcbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbChjYXN0T2JqZWN0KCdhYmMnKSwgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjLCBjKSB7XG4gICAgICByZXR1cm4gYWNjICsgYztcbiAgICB9LCAneCcpO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgPT09ICd4YWJjJztcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHM7XG4gICAgfSgxLCAyLCAzKSksIG5hdGl2ZVJlZHVjZSwgZnVuY3Rpb24gKGFjYywgYXJnKSB7XG4gICAgICByZXR1cm4gYWNjICsgYXJnO1xuICAgIH0sIDEpO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgPT09IDc7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKHtcbiAgICAgIDA6IDEsXG4gICAgICAxOiAyLFxuICAgICAgMzogMyxcbiAgICAgIDQ6IDQsXG4gICAgICBsZW5ndGg6IDRcbiAgICB9LCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChhY2MsIGFyZykge1xuICAgICAgcmV0dXJuIGFjYyArIGFyZztcbiAgICB9LCAyKTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSA4O1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50O1xuICAgIGlmIChkb2MpIHtcbiAgICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIHJlcyA9IGF0dGVtcHQuY2FsbChmcmFnbWVudC5jaGlsZE5vZGVzLCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICAgICAgYWNjW2FjYy5sZW5ndGhdID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIFtdKTtcblxuICAgICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAxICYmIHJlcy52YWx1ZVswXSA9PT0gZGl2O1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCgnYWInLCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgdHlwZW9mIHJlcy52YWx1ZSA9PT0gJ29iamVjdCc7XG4gIH1cbn1cblxudmFyICRyZWR1Y2U7XG5pZiAobmF0aXZlUmVkdWNlICYmIGlzV29ya2luZykge1xuICAkcmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGFycmF5LCBjYWxsQmFjayAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHZhciBhcmdzID0gW2NhbGxCYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVJlZHVjZS5hcHBseShhcnJheSwgYXJncyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuICAvLyBhbmQgZmFpbHVyZSBvZiBgMCBpbiBib3hlZFN0cmluZ2AgKFJoaW5vKVxuICB2YXIgc3BsaXRJZkJveGVkQnVnID0gcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKS50b0xlbmd0aDIwMTg7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcblxuICAkcmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGFycmF5LCBjYWxsQmFjayAvKiAsIGluaXRpYWxWYWx1ZSovKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgIGFzc2VydElzRnVuY3Rpb24oY2FsbEJhY2spO1xuICAgIHZhciBpdGVyYWJsZSA9IHNwbGl0SWZCb3hlZEJ1ZyhvYmplY3QpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJyYXlcbiAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3NMZW5ndGggPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKGFyZ3NMZW5ndGggPiAyKSB7XG4gICAgICByZXN1bHQgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKGkgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICh0cnVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEJhY2socmVzdWx0LCBpdGVyYWJsZVtpXSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYXBwbGllcyBhIGZ1bmN0aW9uIGFnYWluc3QgYW4gYWNjdW11bGF0b3IgYW5kIGVhY2ggZWxlbWVudCBpbiB0aGVcbiAqIGFycmF5IChmcm9tIGxlZnQgdG8gcmlnaHQpIHRvIHJlZHVjZSBpdCB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsQmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gLSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdFxuICogIGNhbGwgb2YgdGhlIGNhbGxiYWNrLiBJZiBubyBpbml0aWFsIHZhbHVlIGlzIHN1cHBsaWVkLCB0aGUgZmlyc3QgZWxlbWVudCBpblxuICogIHRoZSBhcnJheSB3aWxsIGJlIHVzZWQuIENhbGxpbmcgcmVkdWNlIG9uIGFuIGVtcHR5IGFycmF5IHdpdGhvdXQgYW4gaW5pdGlhbFxuICogIHZhbHVlIGlzIGFuIGVycm9yLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcnJheSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgY2FsbEJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxlZCBvbiBhbiBlbXB0eSBhcnJheSB3aXRob3V0IGFuIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIHJlZHVjZSA9IHJlcXVpcmUoJ2FycmF5LXJlZHVjZS14Jyk7XG4gKlxuICogdmFyIHN1bSA9IHJlZHVjZShbMCwgMSwgMiwgM10sIGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgIHJldHVybiBhICsgYjtcbiAqIH0sIDApO1xuICogLy8gc3VtIGlzIDZcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkcmVkdWNlO1xuIiwiLyoqXG4gKiBAZmlsZSBDcmVhdGVzIGFuIGFycmF5IG9mIGFsbCBwcm9wZXJ0aWVzIChlbnVtZXJhYmxlIG9yIG5vdCkgZm91bmQgZGlyZWN0bHkgdXBvbiBhIGdpdmVuIG9iamVjdC5cbiAqIEB2ZXJzaW9uIDIuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBnZXQtb3duLXByb3BlcnR5LW5hbWVzLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgbmF0aXZlR09QTiA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcblxudmFyIGdldE9QTjtcbmlmIChuYXRpdmVHT1BOKSB7XG4gIHZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xuICB2YXIgaXNDb3JyZWN0UmVzID0gZnVuY3Rpb24gX2lzQ29ycmVjdFJlcyhyLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gci50aHJldyA9PT0gZmFsc2UgJiYgaXNBcnJheShyLnZhbHVlKSAmJiByLnZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoO1xuICB9O1xuXG4gIHZhciBlaXRoZXIgPSBmdW5jdGlvbiBfZWl0aGVyKHIsIGEsIGIpIHtcbiAgICB2YXIgeCA9IHIudmFsdWVbMF07XG4gICAgdmFyIHkgPSByLnZhbHVlWzFdO1xuICAgIHJldHVybiAoeCA9PT0gYSAmJiB5ID09PSBiKSB8fCAoeCA9PT0gYiAmJiB5ID09PSBhKTtcbiAgfTtcblxuICB2YXIgcmVzID0gYXR0ZW1wdChuYXRpdmVHT1BOLCAnZm8nKTtcbiAgaWYgKGlzQ29ycmVjdFJlcyhyZXMsIDMpICYmIGVpdGhlcihyZXMsICcwJywgJzEnKSAmJiByZXMudmFsdWVbMl0gPT09ICdsZW5ndGgnKSB7XG4gICAgZ2V0T1BOID0gbmF0aXZlR09QTjtcbiAgfSBlbHNlIHtcbiAgICByZXMgPSBhdHRlbXB0KG5hdGl2ZUdPUE4sIHsgYTogMSwgYjogMiB9KTtcbiAgICBpZiAoaXNDb3JyZWN0UmVzKHJlcywgMikgJiYgZWl0aGVyKHJlcywgJ2EnLCAnYicpKSB7XG4gICAgICB2YXIgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCd0by1zdHJpbmctdGFnLXgnKTtcbiAgICAgIHZhciBhcnJheVNsaWNlID0gcmVxdWlyZSgnYXJyYXktc2xpY2UteCcpO1xuICAgICAgdmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdztcbiAgICAgIHZhciBjYWNoZWRXaW5kb3dOYW1lcyA9IHdpbiA/IG5hdGl2ZUdPUE4od2luKSA6IFtdO1xuXG4gICAgICBnZXRPUE4gPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgICAgICB2YXIgdmFsID0gdG9PYmplY3Qob2JqKTtcbiAgICAgICAgLy8gSUUgYnVnIHdoZXJlIGxheW91dCBlbmdpbmUgY2FsbHMgdXNlcmxhbmQgZ09QTiBmb3IgY3Jvc3MtZG9tYWluIGB3aW5kb3dgIG9iamVjdHNcbiAgICAgICAgaWYgKHdpbiAmJiB3aW4gIT09IHdpbmRvdyAmJiB0b1N0cmluZ1RhZyh2YWwpID09PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KG5hdGl2ZUdPUE4sIHZhbCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC50aHJldyA/IGFycmF5U2xpY2UoY2FjaGVkV2luZG93TmFtZXMpIDogcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUdPUE4odmFsKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgZ2V0T1BOICE9PSAnZnVuY3Rpb24nKSB7XG4gIHZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMteCcpO1xuICBnZXRPUE4gPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgIHJldHVybiBvYmplY3RLZXlzKG9iaik7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY3JlYXRlcyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyAoZW51bWVyYWJsZSBvciBub3QpIGZvdW5kXG4gKiBkaXJlY3RseSB1cG9uIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHdob3NlIGVudW1lcmFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIG93blxuICogIHByb3BlcnRpZXMgYXJlIHRvIGJlIHJldHVybmVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBwcm9wZXJ0aWVzIGZvdW5kXG4gKiAgZGlyZWN0bHkgdXBvbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWUgPSByZXF1aXJlKCdnZXQtb3duLXByb3BlcnR5LW5hbWUteCcpO1xuICpcbiAqIGdldE93blByb3BlcnR5TmFtZXMoJ2ZvbycpOyAvLyBbXCIwXCIsIFwiMVwiLCBcIjJcIiwgXCJsZW5ndGhcIl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBnZXRPUE47XG4iLCIvKipcbiAqIEBmaWxlIEFuIEVTNiBPYmplY3Qua2V5cyBzaGltLlxuICogQHZlcnNpb24gMi41LjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG9iamVjdC1rZXlzLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgbmF0aXZlS2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cztcblxudmFyIGlzV29ya2luZztcbnZhciB0aHJvd3NXaXRoTnVsbDtcbnZhciB3b3Jrc1dpdGhQcmltO1xudmFyIHdvcmtzV2l0aFJlZ2V4O1xudmFyIHdvcmtzV2l0aEFyZ3M7XG52YXIgd29ya3NXaXRoU3RyO1xuaWYgKG5hdGl2ZUtleXMpIHtcbiAgdmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheS14Jyk7XG4gIHZhciBpc0NvcnJlY3RSZXMgPSBmdW5jdGlvbiBfaXNDb3JyZWN0UmVzKHIsIGxlbmd0aCkge1xuICAgIHJldHVybiByLnRocmV3ID09PSBmYWxzZSAmJiBpc0FycmF5KHIudmFsdWUpICYmIHIudmFsdWUubGVuZ3RoID09PSBsZW5ndGg7XG4gIH07XG5cbiAgdmFyIGVpdGhlciA9IGZ1bmN0aW9uIF9laXRoZXIociwgYSwgYikge1xuICAgIHZhciB4ID0gci52YWx1ZVswXTtcbiAgICB2YXIgeSA9IHIudmFsdWVbMV07XG4gICAgcmV0dXJuICh4ID09PSBhICYmIHkgPT09IGIpIHx8ICh4ID09PSBiICYmIHkgPT09IGEpO1xuICB9O1xuXG4gIHZhciB0ZXN0T2JqID0geyBhOiAxLCBiOiAyIH07XG4gIHZhciByZXMgPSBhdHRlbXB0KG5hdGl2ZUtleXMsIHRlc3RPYmopO1xuICBpc1dvcmtpbmcgPSBpc0NvcnJlY3RSZXMocmVzLCAyKSAmJiBlaXRoZXIocmVzLCAnYScsICdiJyk7XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHRlc3RPYmogPSBPYmplY3QoJ2EnKTtcbiAgICB0ZXN0T2JqLnkgPSAxO1xuICAgIHJlcyA9IGF0dGVtcHQobmF0aXZlS2V5cywgdGVzdE9iaik7XG4gICAgaXNXb3JraW5nID0gaXNDb3JyZWN0UmVzKHJlcywgMikgJiYgZWl0aGVyKHJlcywgJzAnLCAneScpO1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHRocm93c1dpdGhOdWxsID0gYXR0ZW1wdChuYXRpdmVLZXlzLCBudWxsKS50aHJldztcbiAgICB3b3Jrc1dpdGhQcmltID0gaXNDb3JyZWN0UmVzKGF0dGVtcHQobmF0aXZlS2V5cywgNDIpLCAwKTtcbiAgICB3b3Jrc1dpdGhSZWdleCA9IGF0dGVtcHQobmF0aXZlS2V5cywgL2EvZykudGhyZXcgPT09IGZhbHNlO1xuXG4gICAgcmVzID0gYXR0ZW1wdChuYXRpdmVLZXlzLCAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICB9KDEsIDIpKSk7XG5cbiAgICB3b3Jrc1dpdGhBcmdzID0gaXNDb3JyZWN0UmVzKHJlcywgMikgJiYgZWl0aGVyKHJlcywgJzAnLCAnMScpO1xuXG4gICAgcmVzID0gYXR0ZW1wdChuYXRpdmVLZXlzLCBPYmplY3QoJ2FiJykpO1xuICAgIHdvcmtzV2l0aFN0ciA9IGlzQ29ycmVjdFJlcyhyZXMsIDIpICYmIGVpdGhlcihyZXMsICcwJywgJzEnKTtcbiAgfVxufVxuXG52YXIgb2JqZWN0S2V5cztcbmlmIChpc1dvcmtpbmcpIHtcbiAgaWYgKHRocm93c1dpdGhOdWxsICYmIHdvcmtzV2l0aFByaW0gJiYgd29ya3NXaXRoUmVnZXggJiYgd29ya3NXaXRoQXJncyAmJiB3b3Jrc1dpdGhTdHIpIHtcbiAgICBvYmplY3RLZXlzID0gbmF0aXZlS2V5cztcbiAgfSBlbHNlIHtcbiAgICB2YXIgaXNBcmd1bWVudHMgPSB3b3Jrc1dpdGhBcmdzICE9PSB0cnVlICYmIHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xuICAgIHZhciBhcnJheVNsaWNlID0gaXNBcmd1bWVudHMgJiYgcmVxdWlyZSgnYXJyYXktbGlrZS1zbGljZS14Jyk7XG4gICAgdmFyIHNwbGl0SWZCb3hlZCA9IHdvcmtzV2l0aFN0ciAhPT0gdHJ1ZSAmJiByZXF1aXJlKCdzcGxpdC1pZi1ib3hlZC1idWcteCcpO1xuICAgIHZhciBpc1N0cmluZyA9IHNwbGl0SWZCb3hlZCAmJiByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgICB2YXIgaXNSZWdleHAgPSB3b3Jrc1dpdGhSZWdleCAhPT0gdHJ1ZSAmJiByZXF1aXJlKCdpcy1yZWdleHAteCcpO1xuICAgIHZhciBoYXMgPSBpc1JlZ2V4cCAmJiByZXF1aXJlKCdoYXMtb3duLXByb3BlcnR5LXgnKTtcblxuICAgIG9iamVjdEtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgdmFyIG9iaiA9IHRvT2JqZWN0ID8gdG9PYmplY3Qob2JqZWN0KSA6IG9iamVjdDtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyAmJiBpc0FyZ3VtZW50cyhvYmopKSB7XG4gICAgICAgIG9iaiA9IGFycmF5U2xpY2Uob2JqKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcgJiYgaXNTdHJpbmcob2JqKSkge1xuICAgICAgICBvYmogPSBzcGxpdElmQm94ZWQob2JqKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWdleHAgJiYgaXNSZWdleHAob2JqKSkge1xuICAgICAgICB2YXIgcmVnZXhLZXlzID0gW107XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgIGlmIChoYXMob2JqLCBrKSkge1xuICAgICAgICAgICAgcmVnZXhLZXlzW3JlZ2V4S2V5cy5sZW5ndGhdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhLZXlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIH07XG4gIH1cbn0gZWxzZSB7XG4gIHZhciBvYmpLZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbiAgb2JqZWN0S2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iaktleXModG9PYmplY3Qob2JqZWN0KSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBhcnJheSBvZiBhIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gKiBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGF0IHByb3ZpZGVkIGJ5IGEgZm9yLi4uaW4gbG9vcCAodGhlIGRpZmZlcmVuY2UgYmVpbmdcbiAqIHRoYXQgYSBmb3ItaW4gbG9vcCBlbnVtZXJhdGVzIHByb3BlcnRpZXMgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBhcyB3ZWxsKS5cbiAqXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgb2JqZWN0IG9mIHdoaWNoIHRoZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIGFyZSB0byBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgcmVwcmVzZW50IGFsbCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cy14Jyk7XG4gKlxuICogdmFyIG9iaiA9IHtcbiAqICAgYXJyOiBbXSxcbiAqICAgYm9vbDogdHJ1ZSxcbiAqICAgJ251bGwnOiBudWxsLFxuICogICBudW06IDQyLFxuICogICBvYmo6IHsgfSxcbiAqICAgc3RyOiAnYm96JyxcbiAqICAgdW5kZWZpbmVkOiB2b2lkIDBcbiAqIH07XG4gKlxuICogb2JqZWN0S2V5cyhvYmopOyAvLyBbJ2FycicsICdib29sJywgJ251bGwnLCAnbnVtJywgJ29iaicsICdzdHInLCAndW5kZWZpbmVkJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RLZXlzO1xuIiwiLyoqXG4gKiBAZmlsZSBTaGFtIGZvciBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICogQHZlcnNpb24gMi4wLjRcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG9iamVjdC1kZWZpbmUtcHJvcGVydGllcy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2FycmF5LWZvci1lYWNoLXgnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzLXgnKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdvYmplY3QtZGVmaW5lLXByb3BlcnR5LXgnKTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjaztcblxuLy8gRVM1IDE1LjIuMy42XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuNlxuXG4vLyBQYXRjaCBmb3IgV2ViS2l0IGFuZCBJRTggc3RhbmRhcmQgbW9kZVxuLy8gRGVzaWduZWQgYnkgaGF4IDxoYXguZ2l0aHViLmNvbT5cbi8vIHJlbGF0ZWQgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMjaXNzdWUvNVxuLy8gSUU4IFJlZmVyZW5jZTpcbi8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyODI5MDAuYXNweFxuLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDIyOTkxNi5hc3B4XG4vLyBXZWJLaXQgQnVnczpcbi8vICAgICBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY0MjNcblxudmFyIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsgPSBmdW5jdGlvbiBfZG9lc0RlZmluZVByb3BlcnR5V29yayhvYmplY3QpIHtcbiAgdHJ5IHtcbiAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2VudGluZWwnLCB7fSk7XG4gICAgcmV0dXJuICdzZW50aW5lbCcgaW4gb2JqZWN0O1xuICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIGNoZWNrIHdoZXRoZXIgZGVmaW5lUHJvcGVydHkgd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLFxuLy8gc2hpbSBwYXJ0aWFsbHkuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbiAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCA9IGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoe30pO1xuICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgaWYgKGRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCA9PT0gZmFsc2UgfHwgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID09PSBmYWxzZSkge1xuICAgIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjayA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuICB9XG59XG5cbi8vIEVTNSAxNS4yLjMuN1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjdcbmlmIChCb29sZWFuKCRkZWZpbmVQcm9wZXJ0aWVzKSA9PT0gZmFsc2UgfHwgZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrKSB7XG4gICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBkZWZpbmVQcm9wZXJ0aWVzXG4gICAgaWYgKGRlZmluZVByb3BlcnRpZXNGYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvckVhY2goJGtleXMocHJvcGVydGllcyksIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgaWYgKHByb3BlcnR5ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgcHJvcGVydGllc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGVmaW5lcyBuZXcgb3IgbW9kaWZpZXMgZXhpc3RpbmcgcHJvcGVydGllcyBkaXJlY3RseSBvbiBhblxuICogb2JqZWN0LCByZXR1cm5pbmcgdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0byBkZWZpbmUgb3IgbW9kaWZ5IHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEFuIG9iamVjdCB3aG9zZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAgY29uc3RpdHV0ZSBkZXNjcmlwdG9ycyBmb3IgdGhlXG4gKiBwcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQgb3IgbW9kaWZpZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCdvYmplY3QtZGVmaW5lLXByb3BlcnRpZXMteCcpO1xuICpcbiAqIHZhciBvYmogPSB7fTtcbiAqIGRlZmluZVByb3BlcnRpZXMob2JqLCB7XG4gKiAgICdwcm9wZXJ0eTEnOiB7XG4gKiAgICAgdmFsdWU6IHRydWUsXG4gKiAgICAgd3JpdGFibGU6IHRydWVcbiAqICAgfSxcbiAqICAgJ3Byb3BlcnR5Mic6IHtcbiAqICAgICB2YWx1ZTogJ0hlbGxvJyxcbiAqICAgICB3cml0YWJsZTogdHJ1ZVxuICogICB9XG4gKiAgIC8vIGV0Yy4gZXRjLlxuICogfSk7XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnRpZXM7XG4iLCIvKipcbiAqIEBmaWxlIFNoYW0gZm9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICogQHZlcnNpb24gMi4xLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG9iamVjdC1kZWZpbmUtcHJvcGVydHkteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnaXMtcHJpbWl0aXZlJyk7XG52YXIgb3ducyA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIHByb3RvdHlwZU9mT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrO1xuLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29ycyBjcmVhdGluZyBzaG9ydGN1dHMuXG52YXIgZGVmaW5lR2V0dGVyO1xudmFyIGRlZmluZVNldHRlcjtcbnZhciBsb29rdXBHZXR0ZXI7XG52YXIgbG9va3VwU2V0dGVyO1xudmFyIHN1cHBvcnRzQWNjZXNzb3JzID0gb3ducyhwcm90b3R5cGVPZk9iamVjdCwgJ19fZGVmaW5lR2V0dGVyX18nKTtcbmlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG4gIGRlZmluZUdldHRlciA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lR2V0dGVyX187XG4gIGRlZmluZVNldHRlciA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX187XG4gIGxvb2t1cEdldHRlciA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwR2V0dGVyX187XG4gIGxvb2t1cFNldHRlciA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwU2V0dGVyX187XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xufVxuXG4vLyBFUzUgMTUuMi4zLjZcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy42XG5cbi8vIFBhdGNoIGZvciBXZWJLaXQgYW5kIElFOCBzdGFuZGFyZCBtb2RlXG4vLyBEZXNpZ25lZCBieSBoYXggPGhheC5naXRodWIuY29tPlxuLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS81XG4vLyBJRTggUmVmZXJlbmNlOlxuLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDI4MjkwMC5hc3B4XG4vLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjI5OTE2LmFzcHhcbi8vIFdlYktpdCBCdWdzOlxuLy8gICAgIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjQyM1xuXG52YXIgZG9lc0RlZmluZVByb3BlcnR5V29yayA9IGZ1bmN0aW9uIF9kb2VzRGVmaW5lUHJvcGVydHlXb3JrKG9iamVjdCkge1xuICB0cnkge1xuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICdzZW50aW5lbCcsIHt9KTtcbiAgICByZXR1cm4gJ3NlbnRpbmVsJyBpbiBvYmplY3Q7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gY2hlY2sgd2hldGhlciBkZWZpbmVQcm9wZXJ0eSB3b3JrcyBpZiBpdCdzIGdpdmVuLiBPdGhlcndpc2UsXG4vLyBzaGltIHBhcnRpYWxseS5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxuICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0ID0gZG9lc0RlZmluZVByb3BlcnR5V29yayh7fSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICBpZiAoZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0ID09PSBmYWxzZSB8fCBkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20gPT09IGZhbHNlKSB7XG4gICAgZGVmaW5lUHJvcGVydHlGYWxsYmFjayA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgfVxufVxuXG5pZiAoQm9vbGVhbigkZGVmaW5lUHJvcGVydHkpID09PSBmYWxzZSB8fCBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrKSB7XG4gIHZhciBFUlJfTk9OX09CSkVDVF9ERVNDUklQVE9SID0gJ1Byb3BlcnR5IGRlc2NyaXB0aW9uIG11c3QgYmUgYW4gb2JqZWN0OiAnO1xuICB2YXIgRVJSX05PTl9PQkpFQ1RfVEFSR0VUID0gJ09iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxsZWQgb24gbm9uLW9iamVjdDogJztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxuICB2YXIgRVJSX0FDQ0VTU09SU19OT1RfU1VQUE9SVEVEID0gJ2dldHRlcnMgJiBzZXR0ZXJzIGNhbiBub3QgYmUgZGVmaW5lZCBvbiB0aGlzIGphdmFzY3JpcHQgZW5naW5lJztcblxuICAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfVEFSR0VUICsgb2JqZWN0KTtcbiAgICB9XG4gICAgaWYgKGlzUHJpbWl0aXZlKGRlc2NyaXB0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUX0RFU0NSSVBUT1IgKyBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZGVmaW5lUHJvcGVydHlcbiAgICAvLyBmb3IgSTgncyBET00gZWxlbWVudHMuXG4gICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrLmNhbGwoT2JqZWN0LCBvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0J3MgYSBkYXRhIHByb3BlcnR5LlxuICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIC8vIGZhaWwgc2lsZW50bHkgaWYgJ3dyaXRhYmxlJywgJ2VudW1lcmFibGUnLCBvciAnY29uZmlndXJhYmxlJ1xuICAgICAgLy8gYXJlIHJlcXVlc3RlZCBidXQgbm90IHN1cHBvcnRlZFxuICAgICAgLypcbiAgICAgIC8vIGFsdGVybmF0ZSBhcHByb2FjaDpcbiAgICAgIGlmICggLy8gY2FuJ3QgaW1wbGVtZW50IHRoZXNlIGZlYXR1cmVzOyBhbGxvdyBmYWxzZSBidXQgbm90IHRydWVcbiAgICAgICAgICAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLndyaXRhYmxlKSB8fFxuICAgICAgICAgICgnZW51bWVyYWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB8fFxuICAgICAgICAgICgnY29uZmlndXJhYmxlJyBpbiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSlcbiAgICAgICkpXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAnVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lcyBub3Qgc3VwcG9ydCBjb25maWd1cmFibGUsIGVudW1lcmFibGUsIG9yIHdyaXRhYmxlLidcbiAgICAgICAgICApO1xuICAgICAgKi9cblxuICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzICYmIChsb29rdXBHZXR0ZXIuY2FsbChvYmplY3QsIHByb3BlcnR5KSB8fCBsb29rdXBTZXR0ZXIuY2FsbChvYmplY3QsIHByb3BlcnR5KSkpIHtcbiAgICAgICAgLy8gQXMgYWNjZXNzb3JzIGFyZSBzdXBwb3J0ZWQgb25seSBvbiBlbmdpbmVzIGltcGxlbWVudGluZ1xuICAgICAgICAvLyBgX19wcm90b19fYCB3ZSBjYW4gc2FmZWx5IG92ZXJyaWRlIGBfX3Byb3RvX19gIHdoaWxlIGRlZmluaW5nXG4gICAgICAgIC8vIGEgcHJvcGVydHkgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgaGl0IGFuIGluaGVyaXRlZFxuICAgICAgICAvLyBhY2Nlc3Nvci5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgLy8gRGVsZXRpbmcgYSBwcm9wZXJ0eSBhbnl3YXkgc2luY2UgZ2V0dGVyIC8gc2V0dGVyIG1heSBiZVxuICAgICAgICAvLyBkZWZpbmVkIG9uIG9iamVjdCBpdHNlbGYuXG4gICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoYXNHZXR0ZXIgPSAnZ2V0JyBpbiBkZXNjcmlwdG9yO1xuICAgICAgdmFyIGhhc1NldHRlciA9ICdzZXQnIGluIGRlc2NyaXB0b3I7XG4gICAgICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMgPT09IGZhbHNlICYmIChoYXNHZXR0ZXIgfHwgaGFzU2V0dGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnb3QgdGhhdCBmYXIgdGhlbiBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGNhbiBiZSBkZWZpbmVkICEhXG4gICAgICBpZiAoaGFzR2V0dGVyKSB7XG4gICAgICAgIGRlZmluZUdldHRlci5jYWxsKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNTZXR0ZXIpIHtcbiAgICAgICAgZGVmaW5lU2V0dGVyLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlZmluZXMgYSBuZXcgcHJvcGVydHkgZGlyZWN0bHkgb24gYW4gb2JqZWN0LCBvciBtb2RpZmllcyBhbiBleGlzdGluZyBwcm9wZXJ0eSBvbiBhbiBvYmplY3QsXG4gKiBhbmQgcmV0dXJucyB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgZGVmaW5lZCBvciBtb2RpZmllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIC0gVGhlIGRlc2NyaXB0b3IgZm9yIHRoZSBwcm9wZXJ0eSBiZWluZyBkZWZpbmVkIG9yIG1vZGlmaWVkLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ29iamVjdC1kZWZpbmUtcHJvcGVydHkteCcpO1xuICpcbiAqIHZhciBvID0ge307IC8vIENyZWF0ZXMgYSBuZXcgb2JqZWN0XG4gKlxuICogZGVmaW5lUHJvcGVydHkobywgJ2EnLCB7XG4gKiAgIHZhbHVlOiAzNyxcbiAqICAgd3JpdGFibGU6IHRydWVcbiAqIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWZpbmVQcm9wZXJ0eTtcbiIsIi8qKlxuICogQGZpbGUgU2hhbSBmb3IgRVM2IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAqIEB2ZXJzaW9uIDMuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBvYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJ3RvLXByb3BlcnR5LWtleS14Jyk7XG52YXIgaXNGYWxzZXkgPSByZXF1aXJlKCdpcy1mYWxzZXkteCcpO1xudmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcblxudmFyIG5hdGl2ZUdPUEQgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldE9QREZhbGxiYWNrMTtcbnZhciBnZXRPUERGYWxsYmFjazI7XG5cbi8vIEVTNSAxNS4yLjMuM1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjNcblxudmFyIGRvZXNHT1BEV29yayA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3ApIHtcbiAgb2JqZWN0W3RvUHJvcGVydHlLZXkocHJvcCldID0gMDtcbiAgdmFyIHRlc3RSZXN1bHQgPSBhdHRlbXB0KG5hdGl2ZUdPUEQsIG9iamVjdCwgcHJvcCk7XG4gIHJldHVybiB0ZXN0UmVzdWx0LnRocmV3ID09PSBmYWxzZSAmJiB0ZXN0UmVzdWx0LnZhbHVlLnZhbHVlID09PSAwO1xufTtcblxuLy8gY2hlY2sgd2hldGhlciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Igd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLCBzaGltIHBhcnRpYWxseS5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKG5hdGl2ZUdPUEQpIHtcbiAgdmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQ7XG4gIHZhciBnZXRPUERXb3Jrc09uRG9tID0gZG9jID8gZG9lc0dPUERXb3JrKGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSwgJ3NlbnRpbmVsJykgOiB0cnVlO1xuICBpZiAoZ2V0T1BEV29ya3NPbkRvbSkge1xuICAgIHZhciByZXMgPSBhdHRlbXB0KG5hdGl2ZUdPUEQsIE9iamVjdCgnYWJjJyksIDEpO1xuICAgIHZhciB3b3Jrc1dpdGhTdHIgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUudmFsdWUgPT09ICdiJztcbiAgICBpZiAod29ya3NXaXRoU3RyKSB7XG4gICAgICB2YXIgZ2V0T1BEV29ya3NPbk9iamVjdCA9IGRvZXNHT1BEV29yayh7fSwgJ3NlbnRpbmVsJyk7XG4gICAgICBpZiAoZ2V0T1BEV29ya3NPbk9iamVjdCkge1xuICAgICAgICB2YXIgd29ya3NXaXRoUHJpbSA9IGF0dGVtcHQobmF0aXZlR09QRCwgNDIsICduYW1lJykudGhyZXcgPT09IGZhbHNlO1xuICAgICAgICB2YXIgd29ya3NXaXRoT2JqU3ltID0gcmVxdWlyZSgnaGFzLXN5bWJvbC1zdXBwb3J0LXgnKSAmJiBkb2VzR09QRFdvcmsoe30sIE9iamVjdChTeW1ib2woJycpKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgaWYgKHdvcmtzV2l0aE9ialN5bSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICBpZiAod29ya3NXaXRoUHJpbSkge1xuICAgICAgICAgICAgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG5hdGl2ZUdPUEQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlR09QRCh0b09iamVjdChvYmplY3QpLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3b3Jrc1dpdGhQcmltKSB7XG4gICAgICAgICAgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlR09QRChvYmplY3QsIHRvUHJvcGVydHlLZXkocHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUdPUEQodG9PYmplY3Qob2JqZWN0KSwgdG9Qcm9wZXJ0eUtleShwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldE9QREZhbGxiYWNrMSA9IG5hdGl2ZUdPUEQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldE9QREZhbGxiYWNrMiA9IG5hdGl2ZUdPUEQ7XG4gICAgfVxuICB9XG59XG5cbmlmIChpc0ZhbHNleSgkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSB8fCBnZXRPUERGYWxsYmFjazEgfHwgZ2V0T1BERmFsbGJhY2syKSB7XG4gIHZhciBvd25zID0gcmVxdWlyZSgnaGFzLW93bi1wcm9wZXJ0eS14Jyk7XG4gIHZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuICB2YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgdmFyIGlzSW5kZXggPSByZXF1aXJlKCdpcy1pbmRleC14Jyk7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHJlcXVpcmUoJ3Byb3BlcnR5LWlzLWVudW1lcmFibGUteCcpO1xuICB2YXIgcHJvdG90eXBlT2ZPYmplY3QgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxuICB2YXIgbG9va3VwR2V0dGVyO1xuICB2YXIgbG9va3VwU2V0dGVyO1xuICB2YXIgc3VwcG9ydHNBY2Nlc3NvcnMgPSBvd25zKHByb3RvdHlwZU9mT2JqZWN0LCAnX19kZWZpbmVHZXR0ZXJfXycpO1xuICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICB2YXIgbGcgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHZhciBscyA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwU2V0dGVyX187XG4gICAgbG9va3VwR2V0dGVyID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBsZy5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgIH07XG5cbiAgICBsb29rdXBTZXR0ZXIgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGxzLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgfTtcbiAgfVxuXG4gICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHZhciBvYmogPSB0b09iamVjdChvYmplY3QpO1xuICAgIHZhciBwcm9wS2V5ID0gdG9Qcm9wZXJ0eUtleShwcm9wZXJ0eSk7XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciBmb3IgSTgncyBET00gZWxlbWVudHMuXG4gICAgaWYgKGdldE9QREZhbGxiYWNrMSkge1xuICAgICAgcmVzdWx0ID0gYXR0ZW1wdC5jYWxsKE9iamVjdCwgZ2V0T1BERmFsbGJhY2sxLCBvYmosIHByb3BLZXkpO1xuICAgICAgaWYgKHJlc3VsdC50aHJldyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgfVxuXG4gICAgdmFyIGlzU3RyaW5nSW5kZXggPSBpc1N0cmluZyhvYmopICYmIGlzSW5kZXgocHJvcEtleSwgb2JqLmxlbmd0aCk7XG4gICAgaWYgKGdldE9QREZhbGxiYWNrMiAmJiBpc1N0cmluZ0luZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmVzdWx0ID0gYXR0ZW1wdC5jYWxsKE9iamVjdCwgZ2V0T1BERmFsbGJhY2syLCBvYmosIHByb3BLZXkpO1xuICAgICAgaWYgKHJlc3VsdC50aHJldyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgfVxuXG4gICAgdmFyIGRlc2NyaXB0b3I7XG4gICAgLy8gSWYgb2JqZWN0IGRvZXMgbm90IG93bnMgcHJvcGVydHkgcmV0dXJuIHVuZGVmaW5lZCBpbW1lZGlhdGVseS5cbiAgICBpZiAoaXNTdHJpbmdJbmRleCA9PT0gZmFsc2UgJiYgb3ducyhvYmosIHByb3BLZXkpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxuXG4gICAgLy8gSWYgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoZW4gaXQncyBmb3Igc3VyZSBgY29uZmlndXJhYmxlYCwgYW5kXG4gICAgLy8gcHJvYmFibHkgYGVudW1lcmFibGVgLiBEZXRlY3QgZW51bWVyYWJpbGl0eSB0aG91Z2guXG4gICAgZGVzY3JpcHRvciA9IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogaXNQcmltaXRpdmUob2JqZWN0KSA9PT0gZmFsc2UgJiYgaXNTdHJpbmdJbmRleCA9PT0gZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBwcm9wZXJ0eUlzRW51bWVyYWJsZShvYmosIHByb3BLZXkpXG4gICAgfTtcblxuICAgIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvciBwcm9wZXJ0aWVzIHRoZW4gcHJvcGVydHkgbWF5IGJlIGFcbiAgICAvLyBnZXR0ZXIgb3Igc2V0dGVyLlxuICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAgICAgLy8gVW5mb3J0dW5hdGVseSBgX19sb29rdXBHZXR0ZXJfX2Agd2lsbCByZXR1cm4gYSBnZXR0ZXIgZXZlblxuICAgICAgLy8gaWYgb2JqZWN0IGhhcyBvd24gbm9uIGdldHRlciBwcm9wZXJ0eSBhbG9uZyB3aXRoIGEgc2FtZSBuYW1lZFxuICAgICAgLy8gaW5oZXJpdGVkIGdldHRlci4gVG8gYXZvaWQgbWlzYmVoYXZpb3Igd2UgdGVtcG9yYXJ5IHJlbW92ZVxuICAgICAgLy8gYF9fcHJvdG9fX2Agc28gdGhhdCBgX19sb29rdXBHZXR0ZXJfX2Agd2lsbCByZXR1cm4gZ2V0dGVyIG9ubHlcbiAgICAgIC8vIGlmIGl0J3Mgb3duZWQgYnkgYW4gb2JqZWN0LlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICB2YXIgcHJvdG90eXBlID0gb2JqLl9fcHJvdG9fXztcbiAgICAgIHZhciBub3RQcm90b3R5cGVPZk9iamVjdCA9IG9iaiAhPT0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAvLyBhdm9pZCByZWN1cnNpb24gcHJvYmxlbSwgYnJlYWtpbmcgaW4gT3BlcmEgTWluaSB3aGVuXG4gICAgICAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycpXG4gICAgICAvLyBvciBhbnkgb3RoZXIgT2JqZWN0LnByb3RvdHlwZSBhY2Nlc3NvclxuICAgICAgaWYgKG5vdFByb3RvdHlwZU9mT2JqZWN0KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b1xuICAgICAgICBvYmouX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIob2JqLCBwcm9wS2V5KTtcbiAgICAgIHZhciBzZXR0ZXIgPSBsb29rdXBTZXR0ZXIob2JqLCBwcm9wS2V5KTtcblxuICAgICAgaWYgKG5vdFByb3RvdHlwZU9mT2JqZWN0KSB7XG4gICAgICAgIC8vIE9uY2Ugd2UgaGF2ZSBnZXR0ZXIgYW5kIHNldHRlciB3ZSBjYW4gcHV0IHZhbHVlcyBiYWNrLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cbiAgICAgICAgb2JqLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldHRlciB8fCBzZXR0ZXIpIHtcbiAgICAgICAgaWYgKGdldHRlcikge1xuICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZ2V0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2V0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgd2FzIGFjY2Vzc29yIHByb3BlcnR5IHdlJ3JlIGRvbmUgYW5kIHJldHVybiBoZXJlXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIGFkZGluZyBgdmFsdWVgIHRvIHRoZSBkZXNjcmlwdG9yLlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgd2Uga25vdyB0aGF0IG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHRoYXQgaXNcbiAgICAvLyBub3QgYW4gYWNjZXNzb3Igc28gd2Ugc2V0IGl0IGFzIGEgdmFsdWUgYW5kIHJldHVybiBkZXNjcmlwdG9yLlxuICAgIGlmIChpc1N0cmluZ0luZGV4KSB7XG4gICAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqLmNoYXJBdChwcm9wS2V5KTtcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG9ialtwcm9wS2V5XTtcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBhbiBvd24gcHJvcGVydHkgKHRoYXQgaXMsXG4gKiBvbmUgZGlyZWN0bHkgcHJlc2VudCBvbiBhbiBvYmplY3QgYW5kIG5vdCBpbiB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluKVxuICogb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBUaGUgb2JqZWN0IGluIHdoaWNoIHRvIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7Kn0gcHJvcGVydHkgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hvc2UgZGVzY3JpcHRpb24gaXMgdG8gYmUgcmV0cmlldmVkLlxuICogQHJldHVybnMge09iamVjdH0gQSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eSBpZiBpdCBleGlzdHMgb24gdGhlIG9iamVjdCwgdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14Jyk7XG4gKiB2YXIgb2JqID0geyBiYXI6IDQyIH07XG4gKiB2YXIgZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCAnYmFyJyk7XG4gKiAvLyBkIGlzIHtcbiAqIC8vICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICogLy8gICBlbnVtZXJhYmxlOiB0cnVlLFxuICogLy8gICB2YWx1ZTogNDIsXG4gKiAvLyAgIHdyaXRhYmxlOiB0cnVlXG4gKiAvLyB9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiIsIi8qKlxuICogQGZpbGUgQW4gRVM2IE9iamVjdC5rZXlzIHNoaW0uXG4gKiBAdmVyc2lvbiAxLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgb2JqZWN0LWtleXMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG50cnkge1xuICB2YXIgYXJyID0gb3JpZ2luYWxLZXlzKHsgYTogMSwgYjogMiB9KTtcbiAgaWYgKGFyci5sZW5ndGggIT09IDIgfHwgYXJyWzBdICE9PSAnYScgfHwgYXJyWzFdICE9PSAnYicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCBrZXlzJyk7XG4gIH1cbn0gY2F0Y2ggKGlnbm9yZSkge1xuICBvcmlnaW5hbEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xufVxuXG52YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIFNhZmFyaSA1LjAgYnVnXG4gIHJldHVybiBvcmlnaW5hbEtleXMoYXJndW1lbnRzKS5sZW5ndGggPT09IDI7XG59KDEsIDIpKTtcblxudmFyIGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJnS2V5cyA9IG9yaWdpbmFsS2V5cyhhcmd1bWVudHMpO1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzWzBdICE9PSAxO1xufSgxKSk7XG5cbnZhciBvYmplY3RLZXlzO1xuaWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzIHx8IGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcpIHtcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIG9iamVjdEtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgIHZhciBvYmogPSB0b09iamVjdChvYmplY3QpO1xuICAgIGlmIChpc0FyZ3VtZW50cyhvYmplY3QpKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxLZXlzKGFycmF5U2xpY2UuY2FsbChvYmopKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ2luYWxLZXlzKG9iaik7XG4gIH07XG59IGVsc2Uge1xuICBvYmplY3RLZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxLZXlzKHRvT2JqZWN0KG9iamVjdCkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2YgYSBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhhdCBwcm92aWRlZCBieSBhIGZvci4uLmluIGxvb3AgKHRoZSBkaWZmZXJlbmNlIGJlaW5nXG4gKiB0aGF0IGEgZm9yLWluIGxvb3AgZW51bWVyYXRlcyBwcm9wZXJ0aWVzIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gYXMgd2VsbCkuXG4gKlxuICogQHBhcmFtIHsqfSBvYmogVGhlIG9iamVjdCBvZiB3aGljaCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBhcmUgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHJlcHJlc2VudCBhbGwgdGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMteCcpO1xuICpcbiAqIHZhciBvYmogPSB7XG4gKiAgIGFycjogW10sXG4gKiAgIGJvb2w6IHRydWUsXG4gKiAgICdudWxsJzogbnVsbCxcbiAqICAgbnVtOiA0MixcbiAqICAgb2JqOiB7IH0sXG4gKiAgIHN0cjogJ2JveicsXG4gKiAgIHVuZGVmaW5lZDogdm9pZCAwXG4gKiB9O1xuICpcbiAqIG9iamVjdEtleXMob2JqKTsgLy8gWydhcnInLCAnYm9vbCcsICdudWxsJywgJ251bScsICdvYmonLCAnc3RyJywgJ3VuZGVmaW5lZCddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0S2V5cztcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG52YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xudmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG52YXIgZG9udEVudW1zID0gW1xuXHQndG9TdHJpbmcnLFxuXHQndG9Mb2NhbGVTdHJpbmcnLFxuXHQndmFsdWVPZicsXG5cdCdoYXNPd25Qcm9wZXJ0eScsXG5cdCdpc1Byb3RvdHlwZU9mJyxcblx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0J2NvbnN0cnVjdG9yJ1xuXTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG59O1xudmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdCRjb25zb2xlOiB0cnVlLFxuXHQkZXh0ZXJuYWw6IHRydWUsXG5cdCRmcmFtZTogdHJ1ZSxcblx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0JGZyYW1lczogdHJ1ZSxcblx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdCRwYXJlbnQ6IHRydWUsXG5cdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHQkc2Nyb2xsWDogdHJ1ZSxcblx0JHNjcm9sbFk6IHRydWUsXG5cdCRzZWxmOiB0cnVlLFxuXHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdCR3aW5kb3c6IHRydWVcbn07XG52YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn0oKSk7XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdHZhciB0aGVLZXlzID0gW107XG5cblx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdH1cblxuXHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoZUtleXM7XG59O1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHRyZXR1cm4gKE9iamVjdC5rZXlzKGFyZ3VtZW50cykgfHwgJycpLmxlbmd0aCA9PT0gMjtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdHZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCIvKiFcbiAqIG9uLWZpbmlzaGVkXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE0IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uRmluaXNoZWRcbm1vZHVsZS5leHBvcnRzLmlzRmluaXNoZWQgPSBpc0ZpbmlzaGVkXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGZpcnN0ID0gcmVxdWlyZSgnZWUtZmlyc3QnKVxuXG4vKipcbiAqIFZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBkZWZlciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbidcbiAgPyBzZXRJbW1lZGlhdGVcbiAgOiBmdW5jdGlvbihmbil7IHByb2Nlc3MubmV4dFRpY2soZm4uYmluZC5hcHBseShmbiwgYXJndW1lbnRzKSkgfVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aGVuIHRoZSByZXNwb25zZSBoYXMgZmluaXNoZWQsIHVzZWZ1bCBmb3JcbiAqIGNsZWFuaW5nIHVwIHJlc291cmNlcyBhZnRlcndhcmRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtc2dcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb25GaW5pc2hlZChtc2csIGxpc3RlbmVyKSB7XG4gIGlmIChpc0ZpbmlzaGVkKG1zZykgIT09IGZhbHNlKSB7XG4gICAgZGVmZXIobGlzdGVuZXIsIG51bGwsIG1zZylcbiAgICByZXR1cm4gbXNnXG4gIH1cblxuICAvLyBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvIHRoZSBtZXNzYWdlXG4gIGF0dGFjaExpc3RlbmVyKG1zZywgbGlzdGVuZXIpXG5cbiAgcmV0dXJuIG1zZ1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBtZXNzYWdlIGlzIGFscmVhZHkgZmluaXNoZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1zZ1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBpc0ZpbmlzaGVkKG1zZykge1xuICB2YXIgc29ja2V0ID0gbXNnLnNvY2tldFxuXG4gIGlmICh0eXBlb2YgbXNnLmZpbmlzaGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBPdXRnb2luZ01lc3NhZ2VcbiAgICByZXR1cm4gQm9vbGVhbihtc2cuZmluaXNoZWQgfHwgKHNvY2tldCAmJiAhc29ja2V0LndyaXRhYmxlKSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgbXNnLmNvbXBsZXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBJbmNvbWluZ01lc3NhZ2VcbiAgICByZXR1cm4gQm9vbGVhbihtc2cudXBncmFkZSB8fCAhc29ja2V0IHx8ICFzb2NrZXQucmVhZGFibGUgfHwgKG1zZy5jb21wbGV0ZSAmJiAhbXNnLnJlYWRhYmxlKSlcbiAgfVxuXG4gIC8vIGRvbid0IGtub3dcbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEF0dGFjaCBhIGZpbmlzaGVkIGxpc3RlbmVyIHRvIHRoZSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtc2dcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGF0dGFjaEZpbmlzaGVkTGlzdGVuZXIobXNnLCBjYWxsYmFjaykge1xuICB2YXIgZWVNc2dcbiAgdmFyIGVlU29ja2V0XG4gIHZhciBmaW5pc2hlZCA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gb25GaW5pc2goZXJyb3IpIHtcbiAgICBlZU1zZy5jYW5jZWwoKVxuICAgIGVlU29ja2V0LmNhbmNlbCgpXG5cbiAgICBmaW5pc2hlZCA9IHRydWVcbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuXG4gIC8vIGZpbmlzaGVkIG9uIGZpcnN0IG1lc3NhZ2UgZXZlbnRcbiAgZWVNc2cgPSBlZVNvY2tldCA9IGZpcnN0KFtbbXNnLCAnZW5kJywgJ2ZpbmlzaCddXSwgb25GaW5pc2gpXG5cbiAgZnVuY3Rpb24gb25Tb2NrZXQoc29ja2V0KSB7XG4gICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgbXNnLnJlbW92ZUxpc3RlbmVyKCdzb2NrZXQnLCBvblNvY2tldClcblxuICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuXG4gICAgaWYgKGVlTXNnICE9PSBlZVNvY2tldCkgcmV0dXJuXG5cbiAgICAvLyBmaW5pc2hlZCBvbiBmaXJzdCBzb2NrZXQgZXZlbnRcbiAgICBlZVNvY2tldCA9IGZpcnN0KFtbc29ja2V0LCAnZXJyb3InLCAnY2xvc2UnXV0sIG9uRmluaXNoKVxuICB9XG5cbiAgaWYgKG1zZy5zb2NrZXQpIHtcbiAgICAvLyBzb2NrZXQgYWxyZWFkeSBhc3NpZ25lZFxuICAgIG9uU29ja2V0KG1zZy5zb2NrZXQpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyB3YWl0IGZvciBzb2NrZXQgdG8gYmUgYXNzaWduZWRcbiAgbXNnLm9uKCdzb2NrZXQnLCBvblNvY2tldClcblxuICBpZiAobXNnLnNvY2tldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbm9kZS5qcyAwLjggcGF0Y2hcbiAgICBwYXRjaEFzc2lnblNvY2tldChtc2csIG9uU29ja2V0KVxuICB9XG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBsaXN0ZW5lciB0byB0aGUgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbXNnXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoTGlzdGVuZXIobXNnLCBsaXN0ZW5lcikge1xuICB2YXIgYXR0YWNoZWQgPSBtc2cuX19vbkZpbmlzaGVkXG5cbiAgLy8gY3JlYXRlIGEgcHJpdmF0ZSBzaW5nbGUgbGlzdGVuZXIgd2l0aCBxdWV1ZVxuICBpZiAoIWF0dGFjaGVkIHx8ICFhdHRhY2hlZC5xdWV1ZSkge1xuICAgIGF0dGFjaGVkID0gbXNnLl9fb25GaW5pc2hlZCA9IGNyZWF0ZUxpc3RlbmVyKG1zZylcbiAgICBhdHRhY2hGaW5pc2hlZExpc3RlbmVyKG1zZywgYXR0YWNoZWQpXG4gIH1cblxuICBhdHRhY2hlZC5xdWV1ZS5wdXNoKGxpc3RlbmVyKVxufVxuXG4vKipcbiAqIENyZWF0ZSBsaXN0ZW5lciBvbiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtc2dcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lcihtc2cpIHtcbiAgZnVuY3Rpb24gbGlzdGVuZXIoZXJyKSB7XG4gICAgaWYgKG1zZy5fX29uRmluaXNoZWQgPT09IGxpc3RlbmVyKSBtc2cuX19vbkZpbmlzaGVkID0gbnVsbFxuICAgIGlmICghbGlzdGVuZXIucXVldWUpIHJldHVyblxuXG4gICAgdmFyIHF1ZXVlID0gbGlzdGVuZXIucXVldWVcbiAgICBsaXN0ZW5lci5xdWV1ZSA9IG51bGxcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlW2ldKGVyciwgbXNnKVxuICAgIH1cbiAgfVxuXG4gIGxpc3RlbmVyLnF1ZXVlID0gW11cblxuICByZXR1cm4gbGlzdGVuZXJcbn1cblxuLyoqXG4gKiBQYXRjaCBTZXJ2ZXJSZXNwb25zZS5wcm90b3R5cGUuYXNzaWduU29ja2V0IGZvciBub2RlLmpzIDAuOC5cbiAqXG4gKiBAcGFyYW0ge1NlcnZlclJlc3BvbnNlfSByZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhdGNoQXNzaWduU29ja2V0KHJlcywgY2FsbGJhY2spIHtcbiAgdmFyIGFzc2lnblNvY2tldCA9IHJlcy5hc3NpZ25Tb2NrZXRcblxuICBpZiAodHlwZW9mIGFzc2lnblNvY2tldCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuXG5cbiAgLy8gcmVzLm9uKCdzb2NrZXQnLCBjYWxsYmFjaykgaXMgYnJva2VuIGluIDAuOFxuICByZXMuYXNzaWduU29ja2V0ID0gZnVuY3Rpb24gX2Fzc2lnblNvY2tldChzb2NrZXQpIHtcbiAgICBhc3NpZ25Tb2NrZXQuY2FsbCh0aGlzLCBzb2NrZXQpXG4gICAgY2FsbGJhY2soc29ja2V0KVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gPGh0dHBzOi8vbGFja2UubW4vcmVkdWNlLXlvdXItYnVuZGxlLWpzLWZpbGUtc2l6ZS8+XG4vLyAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9iYWJlbC1wbHVnaW4tbG9kYXNoL2lzc3Vlcy8yMjE+XG52YXIgaXNFcnJvciA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Vycm9yJyk7XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoL2lzQXJyYXknKTtcblxudmFyIGlzRW1wdHkgPSByZXF1aXJlKCdsb2Rhc2gvaXNFbXB0eScpO1xuXG52YXIgcGljayA9IHJlcXVpcmUoJ2xvZGFzaC9waWNrJyk7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnbG9kYXNoL2lzRnVuY3Rpb24nKTsgLy8gd2Ugd2FudCB0byBzdXBwb3J0IHBhcnNpbmcgb3RoZXIgZmllbGRzIHRoYW4gdGhlIHN0YW5kYXJkOlxuLy8gPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycz5cbi8vIDxodHRwczovL2dpdGh1Yi5jb20vc3RyaXBlL3N0cmlwZS1ub2RlL2Jsb2IvM2MwN2Q4NTFjZjg5NzQ5MGQ4YjkzZGQ0NDU3ZGRhMGM0YzhlNjY3Zi9saWIvRXJyb3IuanMjTDMzPlxuXG5cbnZhciBwYXJzZUVyciA9IGZ1bmN0aW9uIHBhcnNlRXJyKGVycikge1xuICB2YXIgZmllbGRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgaWYgKCFpc0Vycm9yKGVycikpIHRocm93IG5ldyBFcnJvcignYGVycmAgbXVzdCBiZSBhbiBFcnJvcicpO1xuICBpZiAoIWlzQXJyYXkoZmllbGRzKSkgdGhyb3cgbmV3IEVycm9yKCdgZmllbGRzYCBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gIHZhciBrZXlzID0ge307XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGVycltrZXldKSkga2V5c1trZXldID0gZXJyW2tleV07XG4gIH0pO1xuICBpZiAoIWtleXMubmFtZSAmJiBlcnIuY29uc3RydWN0b3IubmFtZSkga2V5cy5uYW1lID0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIHJldHVybiBpc0FycmF5KGZpZWxkcykgJiYgIWlzRW1wdHkoZmllbGRzKSA/IHBpY2soa2V5cywgZmllbGRzKSA6IGtleXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlRXJyOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgVXJsID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG5cbnZhciBjb29raWUgPSByZXF1aXJlKCdjb29raWUnKTtcblxudmFyIHNhZmVTdHJpbmdpZnkgPSByZXF1aXJlKCdmYXN0LXNhZmUtc3RyaW5naWZ5Jyk7IC8vIDxodHRwczovL2xhY2tlLm1uL3JlZHVjZS15b3VyLWJ1bmRsZS1qcy1maWxlLXNpemUvPlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvYmFiZWwtcGx1Z2luLWxvZGFzaC9pc3N1ZXMvMjIxPlxuXG5cbnZhciBwaWNrID0gcmVxdWlyZSgnbG9kYXNoL3BpY2snKTtcblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnbG9kYXNoL2lzU3RyaW5nJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc09iamVjdCcpO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKCdsb2Rhc2gvY2xvbmUnKTtcblxudmFyIGNsb25lRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZURlZXAnKTtcblxudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgnbG9kYXNoL2lzVW5kZWZpbmVkJyk7XG5cbnZhciBpc051bGwgPSByZXF1aXJlKCdsb2Rhc2gvaXNOdWxsJyk7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnbG9kYXNoL2lzRnVuY3Rpb24nKTtcblxudmFyIGlzRW1wdHkgPSByZXF1aXJlKCdsb2Rhc2gvaXNFbXB0eScpO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5Jyk7XG5cbnZhciBtYXBWYWx1ZXMgPSByZXF1aXJlKCdsb2Rhc2gvbWFwVmFsdWVzJyk7XG5cbnZhciBoYXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJzsgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5MDg3NDc0XG5cbmZ1bmN0aW9uIG1hc2tQYXNzd29yZHMob2JqKSB7XG4gIHJldHVybiBtYXBWYWx1ZXMob2JqLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3QodmFsKSkgcmV0dXJuIG1hc2tQYXNzd29yZHModmFsKTtcbiAgICByZXR1cm4ga2V5ID09PSAncGFzc3dvcmQnICYmIGlzU3RyaW5nKHZhbCkgPyBuZXcgQXJyYXkodmFsLmxlbmd0aCArIDEpLmpvaW4oJyonKSA6IHZhbDtcbiAgfSk7XG59IC8vIGluc3BpcmVkIGJ5IHJhdmVuJ3MgcGFyc2VSZXF1ZXN0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbnZhciBwYXJzZVJlcXVlc3QgPSBmdW5jdGlvbiBwYXJzZVJlcXVlc3QoKSB7XG4gIHZhciBvcmlnaW5hbFJlcSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciB1c2VyRmllbGRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbJ2lkJywgJ2VtYWlsJywgJ2Z1bGxfbmFtZScsICdpcF9hZGRyZXNzJ107XG4gIHZhciByZXEgPSBjbG9uZURlZXAocGljayhvcmlnaW5hbFJlcSwgWydtZXRob2QnLCAncXVlcnknLCAnaGVhZGVyJywgJ2hlYWRlcnMnLCAnY29va2llcycsICdvcmlnaW5hbFVybCcsICd1cmwnLCAnaXAnLCAnY29ubmVjdGlvbiddKSk7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxLCAnaG9zdG5hbWUnKSAmJiBvcmlnaW5hbFJlcS5ob3N0KSByZXEuaG9zdCA9IGNsb25lKG9yaWdpbmFsUmVxLmhvc3QpO1xuICB2YXIgaGVhZGVycyA9IHJlcS5oZWFkZXJzIHx8IHJlcS5oZWFkZXIgfHwge307XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnOyAvLyBpbnNwaXJlZCBmcm9tIGBwcmVzZXJ2ZS1xc2AgcGFja2FnZVxuXG4gIHZhciBvcmlnaW5hbFVybCA9ICcnO1xuXG4gIGlmIChpc1N0cmluZyhyZXEub3JpZ2luYWxVcmwpKSB7XG4gICAgb3JpZ2luYWxVcmwgPSByZXEub3JpZ2luYWxVcmw7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcocmVxLnVybCkpIG9yaWdpbmFsVXJsID0gcmVxLnVybDtlbHNlIGlmIChoYXNXaW5kb3cpIG9yaWdpbmFsVXJsID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcblxuICBvcmlnaW5hbFVybCA9IG5ldyBVcmwob3JpZ2luYWxVcmwpOyAvLyBwYXJzZSBxdWVyeSwgcGF0aCwgYW5kIG9yaWdpbiB0byBwcmVwYXJlIGFic29sdXRlIFVybFxuXG4gIHZhciBxdWVyeSA9IGlzT2JqZWN0KHJlcS5xdWVyeSkgPyByZXEucXVlcnkgOiBVcmwucXMucGFyc2Uob3JpZ2luYWxVcmwucXVlcnkpO1xuICB2YXIgcGF0aCA9IG9yaWdpbmFsVXJsLm9yaWdpbiA9PT0gJ251bGwnID8gb3JpZ2luYWxVcmwucGF0aG5hbWUgOiBcIlwiLmNvbmNhdChvcmlnaW5hbFVybC5vcmlnaW4pLmNvbmNhdChvcmlnaW5hbFVybC5wYXRobmFtZSk7XG4gIHZhciBxcyA9IFVybC5xcy5zdHJpbmdpZnkocXVlcnksIHRydWUpO1xuICB2YXIgYWJzb2x1dGVVcmwgPSBwYXRoICsgcXM7IC8vIGRlZmF1bHQgdG8gdGhlIHVzZXIgb2JqZWN0XG5cbiAgdmFyIHVzZXIgPSBpc09iamVjdChvcmlnaW5hbFJlcS51c2VyKSA/IGlzRnVuY3Rpb24ob3JpZ2luYWxSZXEudXNlci50b09iamVjdCkgPyBvcmlnaW5hbFJlcS51c2VyLnRvT2JqZWN0KCkgOiBjbG9uZShvcmlnaW5hbFJlcS51c2VyKSA6IHt9O1xuICB2YXIgaXAgPSAnJztcblxuICBpZiAoaXNTdHJpbmcocmVxLmlwKSkge1xuICAgIGlwID0gcmVxLmlwO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlcS5jb25uZWN0aW9uKSAmJiBpc1N0cmluZyhyZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzKSkgaXAgPSByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzO1xuXG4gIGlmIChpcCAmJiAhaXNTdHJpbmcodXNlci5pcF9hZGRyZXNzKSkgdXNlci5pcF9hZGRyZXNzID0gaXA7XG4gIGlmIChpc0FycmF5KHVzZXJGaWVsZHMpICYmICFpc0VtcHR5KHVzZXJGaWVsZHMpKSB1c2VyID0gcGljayh1c2VyLCB1c2VyRmllbGRzKTtcbiAgdmFyIGJvZHkgPSAnJztcbiAgaWYgKCFbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXMobWV0aG9kKSAmJiAhaXNVbmRlZmluZWQob3JpZ2luYWxSZXEuYm9keSkpIGJvZHkgPSBpc1N0cmluZyhvcmlnaW5hbFJlcS5ib2R5KSA/IGNsb25lKG9yaWdpbmFsUmVxLmJvZHkpIDogY2xvbmVEZWVwKG9yaWdpbmFsUmVxLmJvZHkpOyAvLyByZWN1cnNpdmVseSBzZWFyY2ggdGhyb3VnaCBib2R5IGFuZCBmaWx0ZXIgb3V0IHBhc3N3b3JkcyBmcm9tIGl0XG5cbiAgaWYgKGlzT2JqZWN0KGJvZHkpKSBib2R5ID0gbWFza1Bhc3N3b3Jkcyhib2R5KTtcbiAgaWYgKCFpc1VuZGVmaW5lZChib2R5KSAmJiAhaXNOdWxsKGJvZHkpICYmICFpc1N0cmluZyhib2R5KSkgYm9keSA9IHNhZmVTdHJpbmdpZnkoYm9keSk7IC8vIHBvcHVsYXRlIHVzZXIgYWdlbnQgYW5kIHJlZmVycmVyIGlmXG4gIC8vIHdlJ3JlIGluIGEgYnJvd3NlciBhbmQgdGhleSdyZSB1bnNldFxuXG4gIGlmIChoYXNXaW5kb3cpIHtcbiAgICAvLyBzZXQgdXNlciBhZ2VudFxuICAgIGlmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNPYmplY3Qod2luZG93Lm5hdmlnYXRvcikgJiYgaXNTdHJpbmcod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpICYmICghaXNTdHJpbmcoaGVhZGVyc1sndXNlci1hZ2VudCddKSB8fCAhaGVhZGVyc1sndXNlci1hZ2VudCddKSkgaGVhZGVyc1sndXNlci1hZ2VudCddID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNPYmplY3Qod2luZG93LmRvY3VtZW50KSkge1xuICAgICAgLy8gc2V0IHJlZmVycmVyXG4gICAgICBpZiAoaXNTdHJpbmcod2luZG93LmRvY3VtZW50LnJlZmVycmVyKSAmJiAoIWlzU3RyaW5nKGhlYWRlcnMucmVmZXJlcikgfHwgIWhlYWRlcnMucmVmZXJlcikgJiYgKCFpc1N0cmluZyhoZWFkZXJzLnJlZmVycmVyKSB8fCAhaGVhZGVycy5yZWZlcnJlcikpIGhlYWRlcnMucmVmZXJlciA9IHdpbmRvdy5kb2N1bWVudC5yZWZlcnJlcjsgLy8gc2V0IGNvb2tpZVxuXG4gICAgICBpZiAoaXNTdHJpbmcod2luZG93LmRvY3VtZW50LmNvb2tpZSkgJiYgKCFpc1N0cmluZyhoZWFkZXJzLmNvb2tpZSkgfHwgIWhlYWRlcnMuY29va2llKSkgaGVhZGVycy5jb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgIH1cbiAgfSAvLyBwYXJzZSB0aGUgY29va2llcyAoaWYgYW55IHdlcmUgc2V0KVxuXG5cbiAgdmFyIGNvb2tpZXMgPSBjb29raWUucGFyc2UoaGVhZGVycy5jb29raWUgfHwgJycpO1xuICByZXR1cm4ge1xuICAgIHJlcXVlc3Q6IHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIGNvb2tpZXM6IGNvb2tpZXMsXG4gICAgICBib2R5OiBib2R5LFxuICAgICAgdXJsOiBhYnNvbHV0ZVVybFxuICAgIH0sXG4gICAgdXNlcjogdXNlclxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVJlcXVlc3Q7IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQGZpbGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyBlbnVtZXJhYmxlLlxuICogQHZlcnNpb24gMS4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHByb3BlcnR5LWlzLWVudW1lcmFibGUteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCd0by1wcm9wZXJ0eS1rZXkteCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpc1xuICogZW51bWVyYWJsZS4gRG9lcyBub3QgYXR0ZW1wdCB0byBmaXggYnVncyBpbiBJRTw5IG9yIG9sZCBPcGVyYSwgb3RoZXJ3aXNlIGl0XG4gKiBkb2VzIEVTNmlmeSB0aGUgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0byB0ZXN0IHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfFN5bWJvbH0gcHJvcGVydHkgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gdGVzdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGFyZ2V0IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybnMge2Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpc1xuICogIGVudW1lcmFibGUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcmVxdWlyZSgncHJvcGVydHktaXMtZW51bWVyYWJsZS14Jyk7XG4gKlxuICogdmFyIG8gPSB7fTtcbiAqIHZhciBhID0gW107XG4gKiBvLnByb3AgPSAnaXMgZW51bWVyYWJsZSc7XG4gKiBhWzBdID0gJ2lzIGVudW1lcmFibGUnO1xuICpcbiAqIHByb3BlcnR5SXNFbnVtZXJhYmxlKG8sICdwcm9wJyk7IC8vIHRydWVcbiAqIHByb3BlcnR5SXNFbnVtZXJhYmxlKGEsIDApOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUob2JqZWN0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gcHJvcElzRW51bWVyYWJsZS5jYWxsKHRvT2JqZWN0KG9iamVjdCksIHRvUHJvcGVydHlLZXkocHJvcGVydHkpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgdW5kZWY7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICBpZiAoa2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCIvKipcbiAqIEBmaWxlIFNoYW0gZm9yIFJlZmxlY3Qub3duS2V5c1xuICogQHZlcnNpb24gMS41LjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHJlZmxlY3Qtb3duLWtleXMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1JlZmxlY3QgPSByZXF1aXJlKCdoYXMtcmVmbGVjdC1zdXBwb3J0LXgnKTtcbnZhciByZWZsZWN0T3duS2V5cyA9IGhhc1JlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzO1xuXG5pZiAocmVmbGVjdE93bktleXMpIHtcbiAgdHJ5IHtcbiAgICB2YXIgayA9IHJlZmxlY3RPd25LZXlzKHsgYTogMSwgYjogMiB9KS5zb3J0KCk7XG4gICAgaWYgKGsubGVuZ3RoICE9PSAyIHx8IGtbMF0gIT09ICdhJyB8fCBrWzFdICE9PSAnYicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkJyk7XG4gICAgfVxuICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICByZWZsZWN0T3duS2V5cyA9IG51bGw7XG4gIH1cbn1cblxuaWYgKEJvb2xlYW4ocmVmbGVjdE93bktleXMpID09PSBmYWxzZSkge1xuICB2YXIgYXNzZXJ0SXNPYmplY3QgPSByZXF1aXJlKCdhc3NlcnQtaXMtb2JqZWN0LXgnKTtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCdnZXQtb3duLXByb3BlcnR5LW5hbWVzLXgnKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IHJlcXVpcmUoJ2dldC1vd24tcHJvcGVydHktc3ltYm9scy14Jyk7XG4gIHZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG4gIHJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgICBhc3NlcnRJc09iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiBjb25jYXQuY2FsbChnZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCksIGdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSB0YXJnZXQgb2JqZWN0J3Mgb3duIHByb3BlcnR5IGtleXMuXG4gKiBJdHMgcmV0dXJuIHZhbHVlIGlzIGVxdWl2YWxlbnQgdG9cbiAqIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSkuXG4gKlxuICogQHBhcmFtIHsqfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgb3duIGtleXMuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRhcmdldCBpcyBub3QgYW4gT2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gQW4gQXJyYXkgb2YgdGhlIHRhcmdldCBvYmplY3QncyBvd24gcHJvcGVydHkga2V5cy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcmVmbGVjdE93bktleXMgPSByZXF1aXJlKCdyZWZsZWN0LW93bi1rZXlzLXgnKTtcbiAqIHJlZmxlY3RPd25LZXlzKHsgYTogMSwgYjogMiB9KTsgLy8gWydhJywgJ2InXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RPd25LZXlzO1xuIiwiLyoqXG4gKiBAZmlsZSBSZXBsYWNlIHRoZSBjb21tZW50cyBpbiBhIHN0cmluZy5cbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSByZXBsYWNlLWNvbW1lbnRzLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG52YXIgcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nID0gcmVxdWlyZSgncmVxdWlyZS1jb2VyY2libGUtdG8tc3RyaW5nLXgnKTtcbnZhciBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcbnZhciByZXBsYWNlID0gJycucmVwbGFjZTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXBsYWNlcyBjb21tZW50cyBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byBiZSBzdHJpcHBlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVwbGFjZW1lbnRdIC0gVGhlIHN0cmluZyB0byBiZSB1c2VkIGFzIGEgcmVwbGFjZW1lbnQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHN0cmluZyBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBub3QgY29lcmNpYmxlLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiByZXBsYWNlbWVudCBpcyBub3QgY29lcmNpYmxlLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIG5ldyBzdHJpbmcgd2l0aCB0aGUgY29tbWVudHMgcmVwbGFjZWQuXG4gKiBAZXhhbXBsZVxuICogdmFyIHJlcGxhY2VDb21tZW50cyA9IHJlcXVpcmUoJ3JlcGxhY2UtY29tbWVudHMteCcpO1xuICpcbiAqIHJlcGxhY2VDb21tZW50cyh0ZXN0Oy8qIHRlc3QgKiAvLCAnJyksIC8vICd0ZXN0OydcbiAqIHJlcGxhY2VDb21tZW50cyh0ZXN0OyAvLyB0ZXN0LCAnJyksIC8vICd0ZXN0OydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBsYWNlQ29tbWVudHMoc3RyaW5nKSB7XG4gIHJldHVybiByZXBsYWNlLmNhbGwocmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKHN0cmluZyksIFNUUklQX0NPTU1FTlRTLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvU3RyKGFyZ3VtZW50c1sxXSkgOiAnJyk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBSZXF1aXJlcyBhbiBhcmd1bWVudCBpcyBjb3JlY2libGUgdGhlbiBjb252ZXJ0cyB1c2luZyBUb1N0cmluZy5cbiAqIEB2ZXJzaW9uIDEuMC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSByZXF1aXJlLWNvZXJjaWJsZS10by1zdHJpbmcteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCdyZXF1aXJlLW9iamVjdC1jb2VyY2libGUteCcpO1xudmFyIHRvU3RyID0gcmVxdWlyZSgndG8tc3RyaW5nLXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXF1aXJlcyBhbiBhcmd1bWVudCBpcyBjb3JlY2libGUgdGhlbiBjb252ZXJ0cyB1c2luZyBUb1N0cmluZy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnRlZCB0byBhIHN0cmluZy5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogdmFyIHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyA9IHJlcXVpcmUoJ3JlcXVpcmUtY29lcmNpYmxlLXRvLXN0cmluZy14Jyk7XG4gKlxuICogcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKCk7IC8vIFR5cGVFcnJvclxuICogcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKG51bGwpOyAvLyBUeXBlRXJyb3JcbiAqIHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyhTeW1ib2woJycpKTsgLy8gVHlwZUVycm9yXG4gKiByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoT2JqZWN0LmNyZWF0ZShudWxsKSk7IC8vIFR5cGVFcnJvclxuICogcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKDEpOyAvLyAnMSdcbiAqIHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyh0cnVlKTsgLy8gJ3RydWUnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cihyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHZhbHVlKSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIFJlcXVpcmVPYmplY3RDb2VyY2libGUuXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZXw3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlICggYXJndW1lbnQgKX1cbiAqIEB2ZXJzaW9uIDEuNC4zXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSByZXF1aXJlLW9iamVjdC1jb2VyY2libGUteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTmlsID0gcmVxdWlyZSgnaXMtbmlsLXgnKTtcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIFJlcXVpcmVPYmplY3RDb2VyY2libGUgdGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50XG4gKiBpcyBhIHZhbHVlIHRoYXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhbiBPYmplY3QgdXNpbmcgVG9PYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSBgdmFsdWVgIHRvIGNoZWNrLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIFJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCdyZXF1aXJlLW9iamVjdC1jb2VyY2libGUteCcpO1xuICpcbiAqIFJlcXVpcmVPYmplY3RDb2VyY2libGUoKTsgLy8gVHlwZUVycm9yXG4gKiBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKG51bGwpOyAvLyBUeXBlRXJyb3JcbiAqIFJlcXVpcmVPYmplY3RDb2VyY2libGUoJ2FiYycpOyAvLyAnYWJjJ1xuICogUmVxdWlyZU9iamVjdENvZXJjaWJsZSh0cnVlKTsgLy8gdHJ1ZVxuICogUmVxdWlyZU9iamVjdENvZXJjaWJsZShTeW1ib2woJ2ZvbycpKTsgLy8gU3ltYm9sKCdmb28nKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFJlcXVpcmVPYmplY3RDb2VyY2libGUodmFsdWUpIHtcbiAgaWYgKGlzTmlsKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIG1ldGhvZCBvbiAnICsgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBMaWtlIEVTNiBUb1N0cmluZyBidXQgaGFuZGxlcyBTeW1ib2xzIHRvby5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9Yb3RpYzc1MC90by1zdHJpbmcteHx0by1zdHJpbmcteH1cbiAqIEB2ZXJzaW9uIDEuNS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzYWZlLXRvLXN0cmluZy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcbnZhciBwVG9TdHJpbmcgPSByZXF1aXJlKCdoYXMtc3ltYm9sLXN1cHBvcnQteCcpICYmIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IG9wZXJhdGlvbiBgc2FmZVRvU3RyaW5nYCBjb252ZXJ0cyBhIGBTeW1ib2xgIGxpdGVyYWwgb3JcbiAqIG9iamVjdCB0byBgU3ltYm9sKClgIGluc3RlYWQgb2YgdGhyb3dpbmcgYSBgVHlwZUVycm9yYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29udmVydGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIHZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKCdzYWZlLXRvLXN0cmluZy14Jyk7XG4gKlxuICogc2FmZVRvU3RyaW5nKCk7IC8vICd1bmRlZmluZWQnXG4gKiBzYWZlVG9TdHJpbmcobnVsbCk7IC8vICdudWxsJ1xuICogc2FmZVRvU3RyaW5nKCdhYmMnKTsgLy8gJ2FiYydcbiAqIHNhZmVUb1N0cmluZyh0cnVlKTsgLy8gJ3RydWUnXG4gKiBzYWZlVG9TdHJpbmcoU3ltYm9sKCdmb28nKSk7IC8vICdTeW1ib2woZm9vKSdcbiAqIHNhZmVUb1N0cmluZyhTeW1ib2wuaXRlcmF0b3IpOyAvLyAnU3ltYm9sKFN5bWJvbC5pdGVyYXRvciknXG4gKiBzYWZlVG9TdHJpbmcoT2JqZWN0KFN5bWJvbC5pdGVyYXRvcikpOyAvLyAnU3ltYm9sKFN5bWJvbC5pdGVyYXRvciknXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2FmZVRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBwVG9TdHJpbmcgJiYgaXNTeW1ib2wodmFsdWUpID8gcFRvU3RyaW5nLmNhbGwodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZXMgd2hldGhlciB0d28gdmFsdWVzIGFyZSB0aGUgc2FtZSB2YWx1ZS5cbiAqIEB2ZXJzaW9uIDEuMC4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzYW1lLXZhbHVlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IHJlcXVpcmUoJ2lzLW5hbi14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgdGhlIGNvbXBhcmlzb24gYWJzdHJhY3Qgb3BlcmF0aW9uIFNhbWVWYWx1ZSh4LCB5KSwgd2hlcmUgeFxuICogYW5kIHkgYXJlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdmFsdWVzLCBwcm9kdWNlcyB0cnVlIG9yIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUxIC0gVGhlIGZpcnN0IHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IHZhbHVlMiAtIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIGFyZ3VtZW50cyBhcmVcbiAqICB0aGUgc2FtZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnc2FtZS12YWx1ZS14Jyk7XG4gKlxuICogc2FtZVZhbHVlKDEsIDEpOyAvLyB0cnVlXG4gKiBzYW1lVmFsdWUodHJ1ZSwgdHJ1ZSk7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZShOYU4sIE5hTik7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZSh0cnVlLCBmYWxzZSk7IC8vIGZhbHNlXG4gKiBzYW1lVmFsdWUoMCwgLTApOyAvLyBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhbWVWYWx1ZSh2YWx1ZTEsIHZhbHVlMikge1xuICBpZiAodmFsdWUxID09PSAwICYmIHZhbHVlMiA9PT0gMCkge1xuICAgIHJldHVybiAxIC8gdmFsdWUxID09PSAxIC8gdmFsdWUyO1xuICB9XG5cbiAgaWYgKHZhbHVlMSA9PT0gdmFsdWUyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gbnVtYmVySXNOYU4odmFsdWUxKSAmJiBudW1iZXJJc05hTih2YWx1ZTIpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgRVM2LWNvbXBsaWFudCBzaGltIGZvciBTYW1lVmFsdWVaZXJvLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm98Ny4yLjEwIFNhbWVWYWx1ZVplcm8oeCwgeSl9XG4gKiBAdmVyc2lvbiAxLjMuMlxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgc2FtZS12YWx1ZS16ZXJvLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCdzYW1lLXZhbHVlLXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgdmFsdWUuXG4gKiBTYW1lVmFsdWVaZXJvIGRpZmZlcnMgZnJvbSBTYW1lVmFsdWUgKGBPYmplY3QuaXNgKSBvbmx5IGluIGl0cyB0cmVhdG1lbnRcbiAqIG9mICswIGFuZCAtMC5cbiAqXG4gKiBAcGFyYW0geyp9IHggLSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0geSAtIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIGFyZ3VtZW50c1xuICogYXJlIHRoZSBzYW1lIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIHZhciBzYW1lVmFsdWVaZXJvID0gcmVxdWlyZSgnc2FtZS12YWx1ZS16ZXJvLXgnKTtcbiAqIHNhbWVWYWx1ZVplcm8oMCwgMCk7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZVplcm8oLTAsIC0wKTsgLy8gdHJ1ZVxuICogc2FtZVZhbHVlWmVybygwLCAtMCk7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZVplcm8oTmFOLCBOYU4pOyAvL3RydWVcbiAqIHNhbWVWYWx1ZVplcm8oSW5maW5pdHksIEluZmluaXR5KTsgLy8gdHJ1ZVxuICogc2FtZVZhbHVlWmVybygtSW5maW5pdHksIC1JbmZpbml0eSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzYW1lVmFsdWVaZXJvKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgfHwgc2FtZVZhbHVlKHgsIHkpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB3aXRoIHRoZSBib3hlZCBidWc7IHNwbGl0cyB0byBhbiBhcnJheS5cbiAqIEB2ZXJzaW9uIDEuMS4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzcGxpdC1pZi1ib3hlZC1idWcteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0clNwbGl0O1xudmFyIGlzU3RyaW5nO1xuaWYgKHJlcXVpcmUoJ2hhcy1ib3hlZC1zdHJpbmcteCcpID09PSBmYWxzZSkge1xuICBzdHJTcGxpdCA9ICcnLnNwbGl0O1xuICBpc1N0cmluZyA9IHR5cGVvZiBzdHJTcGxpdCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0ZXN0cyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIHdpdGggdGhlIGJveGVkIGJ1Zzsgc3BsaXRzIHRvIGFuXG4gKiBhcnJheSBmb3IgaXRlcmF0aW9uOyBvdGhlcndpc2UgcmV0dXJucyB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWQuXG4gKiBAcmV0dXJucyB7Kn0gQW4gYXJyYXkgb3IgY2hhcmFjdGVycyBpZiB2YWx1ZSB3YXMgYSBzdHJpbmcgd2l0aCB0aGUgYm94ZWQgYnVnO1xuICogIG90aGVyd2lzZSB0aGUgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHNwbGl0SWZCb3hlZEJ1ZyA9IHJlcXVpcmUoJ3NwbGl0LWlmLWJveGVkLWJ1Zy14Jyk7XG4gKlxuICogLy8gTm8gYm94ZWQgYnVnXG4gKiBzcGxpdElmQm94ZWRCdWcoJ2FiYycpOyAvLyAnYWJjJ1xuICpcbiAqIC8vIEJveGVkIGJ1Z1xuICogc3BsaXRJZkJveGVkQnVnKCdhYmMnKTsgLy8gWydhJywgJ2InLCAnYyddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3BsaXRJZkJveGVkQnVnKHZhbHVlKSB7XG4gIHJldHVybiBpc1N0cmluZyAmJiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJTcGxpdC5jYWxsKHZhbHVlLCAnJykgOiB2YWx1ZTtcbn07XG5cbiIsIi8qKlxuICogQGZpbGUgUGFkcyBhIHN0cmluZyB3aXRoIGFub3RoZXIgc3RyaW5nIChyZXBlYXRlZCwgaWYgbmVlZGVkKS5cbiAqIEB2ZXJzaW9uIDEuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzdHJpbmctcGFkLXN0YXJ0LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgncmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLXgnKTtcbnZhciB0b1N0ciA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpLnRvTGVuZ3RoMjAxODtcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xudmFyIHN0clNsaWNlID0gU3RyaW5nLnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBwYWRzIHRoZSBjdXJyZW50IHN0cmluZyB3aXRoIGFub3RoZXIgc3RyaW5nIChyZXBlYXRlZCwgaWYgbmVlZGVkKVxuICogc28gdGhhdCB0aGUgcmVzdWx0aW5nIHN0cmluZyByZWFjaGVzIHRoZSBnaXZlbiBsZW5ndGguIFRoZSBwYWRkaW5nIGlzIGFwcGxpZWRcbiAqIGZyb20gdGhlIHN0YXJ0IChsZWZ0KSBvZiB0aGUgY3VycmVudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gcGFkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0TGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHN0cmluZyBvbmNlIHRoZVxuICogIGN1cnJlbnQgc3RyaW5nIGhhcyBiZWVuIHBhZGRlZC4gSWYgdGhlIHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAqICBzdHJpbmcncyBsZW5ndGgsIHRoZSBjdXJyZW50IHN0cmluZyB3aWxsIGJlIHJldHVybmVkIGFzIGlzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYWRTdHJpbmddIC0gVGhlIHN0cmluZyB0byBwYWQgdGhlIGN1cnJlbnQgc3RyaW5nIHdpdGguIElmXG4gKiAgdGhpcyBzdHJpbmcgaXMgdG9vIGxvbmcgdG8gc3RheSB3aXRoaW4gdGhlIHRhcmdldCBsZW5ndGgsIGl0IHdpbGwgYmVcbiAqICB0cnVuY2F0ZWQgYW5kIHRoZSBsZWZ0LW1vc3QgcGFydCB3aWxsIGJlIGFwcGxpZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzXG4gKiAgcGFyYW1ldGVyIGlzIFwiIFwiIChVKzAwMjApLlxuICogQHJldHVybnMge3N0cmluZ30gQSBTdHJpbmcgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGggd2l0aCB0aGUgcGFkIHN0cmluZ1xuICogIGFwcGxpZWQgZnJvbSB0aGUgc3RhcnQuXG4gKiBAZXhhbXBsZVxuICogdmFyIHBhZFN0YXJ0ID0gcmVxdWlyZSgnc3RyaW5nLXBhZC1zdGFydC14Jyk7XG4gKlxuICogcGFkU3RhcnQoJ2EnLCAzLCAnYicpOyAvLyAnYmJhJ1xuICogcGFkU3RhcnQoJ2EnLCAzKTsgLy8gJyAgYSdcbiAqIHBhZFN0YXJ0KCdhJywgMiwgJ2JjJyk7IC8vICdiYSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIHRhcmdldExlbmd0aCkge1xuICB2YXIgc3RyID0gdG9TdHIocmVxdWlyZU9iamVjdENvZXJjaWJsZShzdHJpbmcpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IHRvTGVuZ3RoKHN0ci5sZW5ndGgpO1xuICB2YXIgZmlsbFN0cmluZztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgZmlsbFN0cmluZyA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIHZhciBmaWxsZXIgPSBpc1VuZGVmaW5lZChmaWxsU3RyaW5nKSA/ICcnIDogdG9TdHIoZmlsbFN0cmluZyk7XG4gIGlmIChmaWxsZXIgPT09ICcnKSB7XG4gICAgZmlsbGVyID0gJyAnO1xuICB9XG5cbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKHRhcmdldExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICB3aGlsZSAoZmlsbGVyLmxlbmd0aCA8IGZpbGxMZW4pIHtcbiAgICB2YXIgZkxlbiA9IGZpbGxlci5sZW5ndGg7XG4gICAgdmFyIHJlbWFpbmluZ0NvZGVVbml0cyA9IGZpbGxMZW4gLSBmTGVuO1xuICAgIGZpbGxlciArPSBmTGVuID4gcmVtYWluaW5nQ29kZVVuaXRzID8gc3RyU2xpY2UuY2FsbChmaWxsZXIsIDAsIHJlbWFpbmluZ0NvZGVVbml0cykgOiBmaWxsZXI7XG4gIH1cblxuICB2YXIgdHJ1bmNhdGVkU3RyaW5nRmlsbGVyID0gZmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4gPyBzdHJTbGljZS5jYWxsKGZpbGxlciwgMCwgZmlsbExlbikgOiBmaWxsZXI7XG5cbiAgcmV0dXJuIHRydW5jYXRlZFN0cmluZ0ZpbGxlciArIHN0cjtcbn07XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCIvKipcbiAqIEBmaWxlIENvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2YgdHlwZSBCb29sZWFuLlxuICogQHZlcnNpb24gMS4wLjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWJvb2xlYW4teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIFRvQm9vbGVhbiBjb252ZXJ0cyBhcmd1bWVudCB0byBhIHZhbHVlIG9mIHR5cGUgQm9vbGVhbi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSAndHJ1ZScgaWYgdmFsdWUgaXMgdHJ1dGh5OyBvdGhlcndpc2UgJ2ZhbHNlJy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9Cb29sZWFuID0gcmVxdWlyZSgndG8tYm9vbGVhbi14Jyk7XG4gKlxuICogdG9Cb29sZWFuKG51bGwpOyAvLyBmYWxzZVxuICogdG9Cb29sZWFuKCcnKTsgLy8gZmFsc2VcbiAqIHRvQm9vbGVhbigxKTsgLy8gdHJ1ZVxuICogdG9Cb29sZWFuKCcwJyk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDcm9zcy1icm93c2VyIHRvSVNPU3RyaW5nIHN1cHBvcnQuXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8taXNvLXN0cmluZy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmF0aXZlVG9JU09TdHJpbmcgPSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBpc1dvcmtpbmc7XG5pZiAobmF0aXZlVG9JU09TdHJpbmcpIHtcbiAgdmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbiAgdmFyIHJlcyA9IGF0dGVtcHQuY2FsbChuZXcgRGF0ZSgwKSwgbmF0aXZlVG9JU09TdHJpbmcpO1xuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gJzE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwWic7XG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwobmV3IERhdGUoLTYyMTk4NzU1MjAwMDAwKSwgbmF0aXZlVG9JU09TdHJpbmcpO1xuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlLmluZGV4T2YoJy0wMDAwMDEnKSA+IC0xO1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbChuZXcgRGF0ZSgtMSksIG5hdGl2ZVRvSVNPU3RyaW5nKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gJzE5NjktMTItMzFUMjM6NTk6NTkuOTk5Wic7XG4gIH1cbn1cblxudmFyICR0b0lTT1N0cmluZztcbmlmIChpc1dvcmtpbmcpIHtcbiAgJHRvSVNPU3RyaW5nID0gZnVuY3Rpb24gdG9JU09TdHJpbmcoZGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVUb0lTT1N0cmluZy5jYWxsKGRhdGUpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG4gIHZhciBwYWRTdGFydCA9IHJlcXVpcmUoJ3N0cmluZy1wYWQtc3RhcnQteCcpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnYXJyYXktbWFwLXgnKTtcbiAgdmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCdhcnJheS1zbGljZS14Jyk7XG4gIHZhciBqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG5cbiAgJHRvSVNPU3RyaW5nID0gZnVuY3Rpb24gdG9JU09TdHJpbmcoZGF0ZSkge1xuICAgIGlmIChpc0RhdGUoZGF0ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0lTT1N0cmluZyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyLicpO1xuICAgIH1cblxuICAgIGlmIChpc0Zpbml0ZShkYXRlKSA9PT0gZmFsc2UgfHwgaXNGaW5pdGUoZGF0ZS5nZXRUaW1lKCkpID09PSBmYWxzZSkge1xuICAgICAgLy8gQWRvcGUgUGhvdG9zaG9wIHJlcXVpcmVzIHRoZSBzZWNvbmQgY2hlY2suXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgIHllYXIgKz0gKG1vbnRoIC8gMTIpID4+IDA7IC8vIGZsb29yXG4gICAgbW9udGggPSAoKG1vbnRoICUgMTIpICsgMTIpICUgMTI7XG5cbiAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICB2YXIgcGFydHMgPSBbXG4gICAgICBtb250aCArIDEsXG4gICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKClcbiAgICBdO1xuXG4gICAgdmFyIHNpZ247XG4gICAgaWYgKHllYXIgPCAwKSB7XG4gICAgICBzaWduID0gJy0nO1xuICAgIH0gZWxzZSBpZiAoeWVhciA+IDk5OTkpIHtcbiAgICAgIHNpZ24gPSAnKyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ24gPSAnJztcbiAgICB9XG5cbiAgICB5ZWFyID0gc2lnbiArIHBhZFN0YXJ0KE1hdGguYWJzKHllYXIpLCBzaWduID8gNiA6IDQsICcwJyk7XG4gICAgdmFyIHJlc3VsdCA9IG1hcChwYXJ0cywgZnVuY3Rpb24gX21hcHBlcihpdGVtKSB7XG4gICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d28gZGlnaXRzLlxuICAgICAgcmV0dXJuIHBhZFN0YXJ0KGl0ZW0sIDIsICcwJyk7XG4gICAgfSk7XG5cbiAgICB2YXIgZGF0ZVN0ciA9IHllYXIgKyAnLScgKyBqb2luLmNhbGwoYXJyYXlTbGljZShyZXN1bHQsIDAsIDIpLCAnLScpO1xuICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgdmFyIG1zU3RyID0gcGFkU3RhcnQoZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoZGF0ZSksIDMsICcwJyk7XG4gICAgdmFyIHRpbWVTdHIgPSBqb2luLmNhbGwoYXJyYXlTbGljZShyZXN1bHQsIDIpLCAnOicpICsgJy4nICsgbXNTdHI7XG5cbiAgICByZXR1cm4gZGF0ZVN0ciArICdUJyArIHRpbWVTdHIgKyAnWic7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBpbiBzaW1wbGlmaWVkIGV4dGVuZGVkIElTTyBmb3JtYXQgKElTTyA4NjAxKSxcbiAqIHdoaWNoIGlzIGFsd2F5cyAyNCBvciAyNyBjaGFyYWN0ZXJzIGxvbmcgKFlZWVktTU0tRERUSEg6bW06c3Muc3NzWiBvclxuICogwrFZWVlZWVktTU0tRERUSEg6bW06c3Muc3NzWiwgcmVzcGVjdGl2ZWx5KS4gVGhlIHRpbWV6b25lIGlzIGFsd2F5cyB6ZXJvIFVUQ1xuICogb2Zmc2V0LCBhcyBkZW5vdGVkIGJ5IHRoZSBzdWZmaXggXCJaXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGUgQSBEYXRlIG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgZGF0ZSBpcyBub3QgYSBEYXRlIG9iamVjdC5cbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGRhdGUgaXMgaW52YWxpZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gR2l2ZW4gZGF0ZSBpbiB0aGUgSVNPIDg2MDEgZm9ybWF0IGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cblxuICogQGV4YW1wbGVcbiAqIHZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJ3RvLWlzby1zdHJpbmcteCcpO1xuICogdG9JU09TdHJpbmcobmV3IERhdGUoMCkpOyAvLyAnMTk3MC0wMS0wMVQwMDowMDowMC4wMDBaJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICR0b0lTT1N0cmluZztcbiIsIi8qKlxuICogQGZpbGUgRVM2LWNvbXBsaWFudCBzaGltIGZvciBUb09iamVjdC5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b29iamVjdHw3LjEuMTMgVG9PYmplY3QgKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMS41LjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLW9iamVjdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS14Jyk7XG52YXIgY2FzdE9iamVjdCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLk9iamVjdDtcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIFRvT2JqZWN0IGNvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2ZcbiAqIHR5cGUgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgYHZhbHVlYCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICogQHJldHVybnMgeyFPYmplY3R9IFRoZSBgdmFsdWVgIGNvbnZlcnRlZCB0byBhbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIFRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbiAqXG4gKiBUb09iamVjdCgpOyAvLyBUeXBlRXJyb3JcbiAqIFRvT2JqZWN0KG51bGwpOyAvLyBUeXBlRXJyb3JcbiAqIFRvT2JqZWN0KCdhYmMnKTsgLy8gT2JqZWN0KCdhYmMnKVxuICogVG9PYmplY3QodHJ1ZSk7IC8vIE9iamVjdCh0cnVlKVxuICogVG9PYmplY3QoU3ltYm9sKCdmb28nKSk7IC8vIE9iamVjdChTeW1ib2woJ2ZvbycpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjYXN0T2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUodmFsdWUpKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYSBwcmltaXRpdmUgdmFsdWUuXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8tcHJpbWl0aXZlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbC1zdXBwb3J0LXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCdyZXF1aXJlLW9iamVjdC1jb2VyY2libGUteCcpO1xudmFyIGlzTmlsID0gcmVxdWlyZSgnaXMtbmlsLXgnKTtcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xudmFyIHN5bVRvUHJpbWl0aXZlID0gaGFzU3ltYm9scyAmJiBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgc3ltVmFsdWVPZiA9IGhhc1N5bWJvbHMgJiYgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mO1xuXG52YXIgdG9TdHJpbmdPcmRlciA9IFsndG9TdHJpbmcnLCAndmFsdWVPZiddO1xudmFyIHRvTnVtYmVyT3JkZXIgPSBbJ3ZhbHVlT2YnLCAndG9TdHJpbmcnXTtcbnZhciBvcmRlckxlbmd0aCA9IDI7XG5cbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gX29yZGluYXJ5VG9QcmltaXRpdmUoTywgaGludCkge1xuICByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKE8pO1xuICBpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IChoaW50ICE9PSAnbnVtYmVyJyAmJiBoaW50ICE9PSAnc3RyaW5nJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG4gIH1cblxuICB2YXIgbWV0aG9kTmFtZXMgPSBoaW50ID09PSAnc3RyaW5nJyA/IHRvU3RyaW5nT3JkZXIgOiB0b051bWJlck9yZGVyO1xuICB2YXIgbWV0aG9kO1xuICB2YXIgcmVzdWx0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBtZXRob2QgPSBPW21ldGhvZE5hbWVzW2ldXTtcbiAgICBpZiAoaXNGdW5jdGlvbihtZXRob2QpKSB7XG4gICAgICByZXN1bHQgPSBtZXRob2QuY2FsbChPKTtcbiAgICAgIGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xufTtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIF9nZXRNZXRob2QoTywgUCkge1xuICB2YXIgZnVuYyA9IE9bUF07XG4gIGlmIChpc05pbChmdW5jKSA9PT0gZmFsc2UpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihmdW5jKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZnVuYyArICcgcmV0dXJuZWQgZm9yIHByb3BlcnR5ICcgKyBQICsgJyBvZiBvYmplY3QgJyArIE8gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cblxuICByZXR1cm4gdm9pZCAwO1xufTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5cbi8qKlxuICogVGhpcyBtZXRob2QgY29udmVydHMgYSBKYXZhU2NyaXB0IG9iamVjdCB0byBhIHByaW1pdGl2ZSB2YWx1ZS5cbiAqIE5vdGU6IFdoZW4gdG9QcmltaXRpdmUgaXMgY2FsbGVkIHdpdGggbm8gaGludCwgdGhlbiBpdCBnZW5lcmFsbHkgYmVoYXZlcyBhc1xuICogaWYgdGhlIGhpbnQgd2VyZSBOdW1iZXIuIEhvd2V2ZXIsIG9iamVjdHMgbWF5IG92ZXItcmlkZSB0aGlzIGJlaGF2aW91ciBieVxuICogZGVmaW5pbmcgYSBAQHRvUHJpbWl0aXZlIG1ldGhvZC4gT2YgdGhlIG9iamVjdHMgZGVmaW5lZCBpbiB0aGlzIHNwZWNpZmljYXRpb25cbiAqIG9ubHkgRGF0ZSBvYmplY3RzIChzZWUgMjAuMy40LjQ1KSBhbmQgU3ltYm9sIG9iamVjdHMgKHNlZSAxOS40LjMuNCkgb3Zlci1yaWRlXG4gKiB0aGUgZGVmYXVsdCBUb1ByaW1pdGl2ZSBiZWhhdmlvdXIuIERhdGUgb2JqZWN0cyB0cmVhdCBubyBoaW50IGFzIGlmIHRoZSBoaW50XG4gKiB3ZXJlIFN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyp9IGlucHV0IC0gVGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBbcHJlZmZlcmVkdHlwZV0gLSBUaGUgcHJlZmZlcmVkIHR5cGUgKFN0cmluZyBvciBOdW1iZXIpLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB1bmFibGUgdG8gY29udmVydCBpbnB1dCB0byBhIHByaW1pdGl2ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSBUaGUgY29udmVydGVkIGlucHV0IGFzIGEgcHJpbWl0aXZlLlxuICogQGV4YW1wbGVcbiAqIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ3RvLXByaW1pdGl2ZS14Jyk7XG4gKlxuICogdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAqIHRvUHJpbWl0aXZlKGRhdGUpKTsgLy8gVGh1IEphbiAwMSAxOTcwIDAxOjAwOjAwIEdNVCswMTAwIChDRVQpXG4gKiB0b1ByaW1pdGl2ZShkYXRlLCBTdHJpbmcpKTsgLy8gVGh1IEphbiAwMSAxOTcwIDAxOjAwOjAwIEdNVCswMTAwIChDRVQpXG4gKiB0b1ByaW1pdGl2ZShkYXRlLCBOdW1iZXIpKTsgLy8gMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvUHJpbWl0aXZlKGlucHV0LCBwcmVmZXJyZWRUeXBlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICB2YXIgaGludCA9ICdkZWZhdWx0JztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKHByZWZlcnJlZFR5cGUgPT09IFN0cmluZykge1xuICAgICAgaGludCA9ICdzdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAocHJlZmVycmVkVHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICBoaW50ID0gJ251bWJlcic7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV4b3RpY1RvUHJpbTtcbiAgaWYgKGhhc1N5bWJvbHMpIHtcbiAgICBpZiAoc3ltVG9QcmltaXRpdmUpIHtcbiAgICAgIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgc3ltVG9QcmltaXRpdmUpO1xuICAgIH0gZWxzZSBpZiAoaXNTeW1ib2woaW5wdXQpKSB7XG4gICAgICBleG90aWNUb1ByaW0gPSBzeW1WYWx1ZU9mO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZChleG90aWNUb1ByaW0pID09PSBmYWxzZSkge1xuICAgIHZhciByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgaGludCk7XG4gICAgaWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5hYmxlIHRvIGNvbnZlcnQgZXhvdGljIG9iamVjdCB0byBwcmltaXRpdmUnKTtcbiAgfVxuXG4gIGlmIChoaW50ID09PSAnZGVmYXVsdCcgJiYgKGlzRGF0ZShpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSkge1xuICAgIGhpbnQgPSAnc3RyaW5nJztcbiAgfVxuXG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSAnZGVmYXVsdCcgPyAnbnVtYmVyJyA6IGhpbnQpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgQ29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcHJvcGVydHkga2V5LlxuICogQHZlcnNpb24gMi4wLjJcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLXByb3BlcnR5LWtleS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCd0by1wcmltaXRpdmUteCcpO1xudmFyIHRvU3RyID0gcmVxdWlyZSgndG8tc3RyaW5nLXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBDb252ZXJ0cyBhcmd1bWVudCB0byBhIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBwcm9wZXJ0eSBrZXkuXG4gKlxuICogQHBhcmFtIHsqfSBhcmd1bWVudCAtIFRoZSBhcmd1bWVudCB0byBvbnZlcnQgdG8gYSBwcm9wZXJ0eSBrZXkuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50IGlzIG5vdCBhIHN5bWJvbCBhbmQgaXMgbm90IGNvZXJjaWJsZSB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBUaGUgY29udmVydGVkIGFyZ3VtZW50LlxuICogQGV4YW1wbGVcbiAqIHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgndG8tcHJvcGVydHkta2V5LXgnKTtcbiAqXG4gKiB0b1Byb3BlcnR5S2V5KCk7IC8vICd1bmRlZmluZWQnXG4gKiB0b1Byb3BlcnR5S2V5KDEpOyAvLyAnMSdcbiAqIHRvUHJvcGVydHlLZXkodHJ1ZSk7IC8vICd0cnVlJ1xuICpcbiAqIHZhciBzeW1ib2wgPSBTeW1ib2woJ2EnKTtcbiAqIHRvUHJvcGVydHlLZXkoc3ltYm9sKTsgLy8gc3ltYm9sXG4gKlxuICogdG9Qcm9wZXJ0eUtleShPYmplY3QuY3JlYXRlKG51bGwpKTsgLy8gVHlwZUVycm9yXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIFN0cmluZyk7XG4gIHJldHVybiBoYXNTeW1ib2xzICYmIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogdG9TdHIoa2V5KTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEVTNiBhYnN0cmFjdCBUb1N0cmluZyB3aXRoIFN5bWJvbCBjb252ZXJzaW9uIHN1cHBvcnQuXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9zdHJpbmd8Ny4xLjEyIFRvU3RyaW5nICggYXJndW1lbnQgKX1cbiAqIEB2ZXJzaW9uIDEuMC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhc3RTdHJpbmcgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5TdHJpbmc7XG52YXIgcFRvU3RyaW5nID0gcmVxdWlyZSgnaGFzLXN5bWJvbC1zdXBwb3J0LXgnKSAmJiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzU3ltYm9sID0gdHlwZW9mIHBUb1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1aXJlKCdpcy1zeW1ib2wnKTtcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIFRvU3RyaW5nIGNvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2YgdHlwZSBTdHJpbmcsXG4gKiBob3dldmVyIHRoZSBzcGVjaWZpY2F0aW9uIHN0YXRlcyB0aGF0IGlmIHRoZSBhcmd1bWVudCBpcyBhIFN5bWJvbCB0aGVuIGFcbiAqICdUeXBlRXJyb3InIGlzIHRocm93bi4gVGhpcyB2ZXJzaW9uIGFsc28gYWxsb3dzIFN5bWJvbHMgYmUgY29udmVydGVkIHRvXG4gKiBhIHN0cmluZy4gT3RoZXIgdW5jb2VyY2libGUgZXhvdGljcyB3aWxsIHN0aWxsIHRocm93IHRob3VnaC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29udmVydGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIHZhciB0b1N0cmluZ1N5bWJvbHNTdXBwb3J0ZWQgPSByZXF1aXJlKCd0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteCcpO1xuICpcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZCgpOyAvLyAndW5kZWZpbmVkJ1xuICogdG9TdHJpbmdTeW1ib2xzU3VwcG9ydGVkKG51bGwpOyAvLyAnbnVsbCdcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZCgnYWJjJyk7IC8vICdhYmMnXG4gKiB0b1N0cmluZ1N5bWJvbHNTdXBwb3J0ZWQodHJ1ZSk7IC8vICd0cnVlJ1xuICogdG9TdHJpbmdTeW1ib2xzU3VwcG9ydGVkKFN5bWJvbCgnZm9vJykpOyAvLyAnU3ltYm9sKCdmb28nKSdcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZChPYmplY3QoU3ltYm9sKCdmb28nKSkpOyAvLyAnU3ltYm9sKCdmb28nKSdcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZChPYmplY3QuY3JlYXRlKG51bGwpKTsgLy8gVHlwZUVycm9yXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9TdHJpbmdTeW1ib2xzU3VwcG9ydGVkKHZhbHVlKSB7XG4gIHJldHVybiBpc1N5bWJvbCAmJiBpc1N5bWJvbCh2YWx1ZSkgPyBwVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiBjYXN0U3RyaW5nKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEdldCBhbiBvYmplY3QncyBFUzYgQEB0b1N0cmluZ1RhZy5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nfDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKCApfVxuICogQHZlcnNpb24gMS40LjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLXN0cmluZy10YWcteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTnVsbCA9IHJlcXVpcmUoJ2xvZGFzaC5pc251bGwnKTtcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xudmFyIHRvU3RyID0ge30udG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGB0b1N0cmluZ1RhZ2AgbWV0aG9kIHJldHVybnMgXCJbb2JqZWN0IHR5cGVdXCIsIHdoZXJlIHR5cGUgaXMgdGhlXG4gKiBvYmplY3QgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIG9iamVjdCBvZiB3aGljaCB0byBnZXQgdGhlIG9iamVjdCB0eXBlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBvYmplY3QgdHlwZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gKlxuICogdmFyIG8gPSBuZXcgT2JqZWN0KCk7XG4gKiB0b1N0cmluZ1RhZyhvKTsgLy8gcmV0dXJucyAnW29iamVjdCBPYmplY3RdJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKHZhbHVlKSB7XG4gIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0IE51bGxdJztcbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG4gIH1cblxuICByZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIFRvU3RyaW5nLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvc3RyaW5nfDcuMS4xMiBUb1N0cmluZyAoIGFyZ3VtZW50ICl9XG4gKiBAdmVyc2lvbiAxLjQuNVxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8tc3RyaW5nLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXN0U3RyaW5nID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuU3RyaW5nO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnaXMtc3ltYm9sJyk7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IG9wZXJhdGlvbiBUb1N0cmluZyBjb252ZXJ0cyBhcmd1bWVudCB0byBhIHZhbHVlIG9mIHR5cGUgU3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIFN5bWJvbC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb252ZXJ0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogdmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG4gKlxuICogJHRvU3RyaW5nKCk7IC8vICd1bmRlZmluZWQnXG4gKiAkdG9TdHJpbmcobnVsbCk7IC8vICdudWxsJ1xuICogJHRvU3RyaW5nKCdhYmMnKTsgLy8gJ2FiYydcbiAqICR0b1N0cmluZyh0cnVlKTsgLy8gJ3RydWUnXG4gKiAkdG9TdHJpbmcoU3ltYm9sKCdmb28nKSk7IC8vIFR5cGVFcnJvclxuICogJHRvU3RyaW5nKFN5bWJvbC5pdGVyYXRvcik7IC8vIFR5cGVFcnJvclxuICogJHRvU3RyaW5nKE9iamVjdChTeW1ib2wuaXRlcmF0b3IpKTsgLy8gVHlwZUVycm9yXG4gKiAkdG9TdHJpbmcoT2JqZWN0LmNyZWF0ZShudWxsKSk7IC8vIFR5cGVFcnJvclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvU3RyaW5nKHZhbHVlKSB7XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICB9XG5cbiAgcmV0dXJuIGNhc3RTdHJpbmcodmFsdWUpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgZW5kIG9mIGEgc3RyaW5nLlxuICogQHZlcnNpb24gMy4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRyaW0tbGVmdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nID0gcmVxdWlyZSgncmVxdWlyZS1jb2VyY2libGUtdG8tc3RyaW5nLXgnKTtcbnZhciBSeCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLlJlZ0V4cDtcbnZhciByZUxlZnQyMDE2ID0gbmV3IFJ4KCdeWycgKyByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jykuc3RyaW5nMjAxNiArICddKycpO1xudmFyIHJlTGVmdDIwMTggPSBuZXcgUngoJ15bJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcyMDE4ICsgJ10rJyk7XG52YXIgcmVwbGFjZSA9ICcnLnJlcGxhY2U7XG5cbnZhciAkdHJpbUxlZnQyMDE2ID0gZnVuY3Rpb24gdHJpbUxlZnQyMDE2KHN0cmluZykge1xuICByZXR1cm4gcmVwbGFjZS5jYWxsKHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyhzdHJpbmcpLCByZUxlZnQyMDE2LCAnJyk7XG59O1xuXG52YXIgJHRyaW1MZWZ0MjAxOCA9IGZ1bmN0aW9uIHRyaW1MZWZ0MjAxOChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlcGxhY2UuY2FsbChyZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoc3RyaW5nKSwgcmVMZWZ0MjAxOCwgJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byBsZWZ0VHJpbTIwMTguXG4gICAqL1xuICB0cmltTGVmdDogJHRyaW1MZWZ0MjAxOCxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgZW5kIG9mIGEgc3RyaW5nLiAoRVMyMDE2KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byB0cmltIHRoZSBsZWZ0IGVuZCB3aGl0ZXNwYWNlIGZyb20uXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBsZWZ0IHRyaW1tZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdHJpbUxlZnQgPSByZXF1aXJlKCd0cmltLWxlZnQteCcpLnRyaW1MZWZ0MjAxNjtcbiAgICpcbiAgICogdHJpbUxlZnQoJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSBcXHRcXG4nOyAvLyB0cnVlXG4gICAqL1xuICB0cmltTGVmdDIwMTY6ICR0cmltTGVmdDIwMTYsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGVuZCBvZiBhIHN0cmluZy4gKEVTMjAxOClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgbGVmdCBlbmQgd2hpdGVzcGFjZSBmcm9tLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHN0cmluZyBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbGVmdCB0cmltbWVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRyaW1MZWZ0ID0gcmVxdWlyZSgndHJpbS1sZWZ0LXgnKS50cmltTGVmdDIwMTg7XG4gICAqXG4gICAqIHRyaW1MZWZ0KCcgXFx0XFxuYSBcXHRcXG4nKSA9PT0gJ2EgXFx0XFxuJzsgLy8gdHJ1ZVxuICAgKi9cbiAgdHJpbUxlZnQyMDE4OiAkdHJpbUxlZnQyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUaGlzIG1ldGhvZCByZW1vdmVzIHdoaXRlc3BhY2UgZnJvbSB0aGUgcmlnaHQgZW5kIG9mIGEgc3RyaW5nLlxuICogQHZlcnNpb24gMi4wLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRyaW0tcmlnaHQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyA9IHJlcXVpcmUoJ3JlcXVpcmUtY29lcmNpYmxlLXRvLXN0cmluZy14Jyk7XG52YXIgUnggPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5SZWdFeHA7XG52YXIgcmVSaWdodCA9IG5ldyBSeCgnWycgKyByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jykuc3RyaW5nICsgJ10rJCcpO1xudmFyIHJlcGxhY2UgPSAnJy5yZXBsYWNlO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgcmlnaHQgZW5kIHdoaXRlc3BhY2UgZnJvbS5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmlnaHQgdHJpbW1lZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRyaW1SaWdodCA9IHJlcXVpcmUoJ3RyaW0tcmlnaHQteCcpO1xuICpcbiAqIHRyaW1SaWdodCgnIFxcdFxcbmEgXFx0XFxuJykgPT09ICcgXFx0XFxuYSc7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmltUmlnaHQoc3RyaW5nKSB7XG4gIHJldHVybiByZXBsYWNlLmNhbGwocmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKHN0cmluZyksIHJlUmlnaHQsICcnKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gKiBAdmVyc2lvbiAyLjAuMlxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdHJpbS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJpbUxlZnQgPSByZXF1aXJlKCd0cmltLWxlZnQteCcpO1xudmFyIHRyaW1SaWdodCA9IHJlcXVpcmUoJ3RyaW0tcmlnaHQteCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmltbWVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xuICpcbiAqIHRyaW0oJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSc7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmltKHN0cmluZykge1xuICByZXR1cm4gdHJpbUxlZnQodHJpbVJpZ2h0KHN0cmluZykpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgZW5kIG9mIGEgc3RyaW5nLlxuICogQHZlcnNpb24gMi4wLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRyaW0tbGVmdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nID0gcmVxdWlyZSgncmVxdWlyZS1jb2VyY2libGUtdG8tc3RyaW5nLXgnKTtcbnZhciBSeCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLlJlZ0V4cDtcbnZhciByZUxlZnQgPSBuZXcgUngoJ15bJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcgKyAnXSsnKTtcbnZhciByZXBsYWNlID0gJycucmVwbGFjZTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZW1vdmVzIHdoaXRlc3BhY2UgZnJvbSB0aGUgbGVmdCBlbmQgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgbGVmdCBlbmQgd2hpdGVzcGFjZSBmcm9tLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBsZWZ0IHRyaW1tZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqIHZhciB0cmltTGVmdCA9IHJlcXVpcmUoJ3RyaW0tbGVmdC14Jyk7XG4gKlxuICogdHJpbUxlZnQoJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSBcXHRcXG4nOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJpbUxlZnQoc3RyaW5nKSB7XG4gIHJldHVybiByZXBsYWNlLmNhbGwocmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKHN0cmluZyksIHJlTGVmdCwgJycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2xvY2F0aW9uXSBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG4iLCIvKipcbiAqIEBmaWxlIEFuIGltcGxlbWVudGF0aW9uIG9mIG5vZGUncyB1dGlsLmZvcm1hdFxuICogQHZlcnNpb24gMS4zLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHV0aWwtZm9ybWF0LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnaW5zcGVjdC14Jyk7XG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpO1xudmFyIHNhZmVUb1N0cmluZyA9IHJlcXVpcmUoJ3NhZmUtdG8tc3RyaW5nLXgnKTtcbnZhciBpc051bGwgPSByZXF1aXJlKCdsb2Rhc2guaXNudWxsJyk7XG5cbnZhciBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFO1xudmFyIHRyeVN0cmluZ2lmeSA9IGZ1bmN0aW9uIF90cnlTdHJpbmdpZnkoYXJnKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04zLnN0cmluZ2lmeShhcmcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBQb3B1bGF0ZSB0aGUgY2lyY3VsYXIgZXJyb3IgbWVzc2FnZSBsYXppbHlcbiAgICBpZiAoIUNJUkNVTEFSX0VSUk9SX01FU1NBR0UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhID0ge307XG4gICAgICAgIGEuYSA9IGE7XG4gICAgICAgIEpTT04zLnN0cmluZ2lmeShhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSA9IGUubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIGVyci5tZXNzYWdlID09PSBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFKSB7XG4gICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbnZhciBmb3JtYXQgPSBmdW5jdGlvbiBfZm9ybWF0KGYpIHtcbiAgaWYgKHR5cGVvZiBmICE9PSAnc3RyaW5nJykge1xuICAgIHZhciBvYmplY3RzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBvYmplY3RzW2luZGV4XSA9IGluc3BlY3QoYXJndW1lbnRzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIGEgPSAxO1xuICB2YXIgbGFzdFBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZi5sZW5ndGg7KSB7XG4gICAgaWYgKGYuY2hhckNvZGVBdChpKSA9PT0gMzcvKiAnJScqLyAmJiBpICsgMSA8IGYubGVuZ3RoKSB7XG4gICAgICBpZiAoZi5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMzcvKiAnJScqLyAmJiBhID49IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChmLmNoYXJDb2RlQXQoaSArIDEpKSB7XG4gICAgICBjYXNlIDEwMDogLy8gJ2QnXG4gICAgICAgIGlmIChsYXN0UG9zIDwgaSkge1xuICAgICAgICAgIHN0ciArPSBmLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IE51bWJlcihhcmd1bWVudHNbYV0pO1xuICAgICAgICBhICs9IDE7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA1OiAvLyAnaSdcbiAgICAgICAgaWYgKGxhc3RQb3MgPCBpKSB7XG4gICAgICAgICAgc3RyICs9IGYuc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gcGFyc2VJbnQoYXJndW1lbnRzW2FdLCAxMCk7XG4gICAgICAgIGEgKz0gMTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDI6IC8vICdmJ1xuICAgICAgICBpZiAobGFzdFBvcyA8IGkpIHtcbiAgICAgICAgICBzdHIgKz0gZi5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBwYXJzZUZsb2F0KGFyZ3VtZW50c1thXSk7XG4gICAgICAgIGEgKz0gMTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDY6IC8vICdqJ1xuICAgICAgICBpZiAobGFzdFBvcyA8IGkpIHtcbiAgICAgICAgICBzdHIgKz0gZi5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSB0cnlTdHJpbmdpZnkoYXJndW1lbnRzW2FdKTtcbiAgICAgICAgYSArPSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDExNTogLy8gJ3MnXG4gICAgICAgIGlmIChsYXN0UG9zIDwgaSkge1xuICAgICAgICAgIHN0ciArPSBmLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IHNhZmVUb1N0cmluZyhhcmd1bWVudHNbYV0pO1xuICAgICAgICBhICs9IDE7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzc6IC8vICclJ1xuICAgICAgICBpZiAobGFzdFBvcyA8IGkpIHtcbiAgICAgICAgICBzdHIgKz0gZi5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSAnJSc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGFueSBvdGhlciBjaGFyYWN0ZXIgaXMgbm90IGEgY29ycmVjdCBwbGFjZWhvbGRlclxuICAgICAgICBpZiAobGFzdFBvcyA8IGkpIHtcbiAgICAgICAgICBzdHIgKz0gZi5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSAnJSc7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgbGFzdFBvcyA9IGk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgICBsYXN0UG9zID0gaTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICB9XG5cbiAgICBpICs9IDE7XG4gIH1cblxuICBpZiAobGFzdFBvcyA9PT0gMCkge1xuICAgIHN0ciA9IGY7XG4gIH0gZWxzZSBpZiAobGFzdFBvcyA8IGYubGVuZ3RoKSB7XG4gICAgc3RyICs9IGYuc2xpY2UobGFzdFBvcyk7XG4gIH1cblxuICB3aGlsZSAoYSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1thXTtcbiAgICBhICs9IDE7XG5cbiAgICBpZiAoaXNOdWxsKHgpIHx8ICh0eXBlb2YgeCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHggIT09ICdzeW1ib2wnKSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFRoZSBmb3JtYXQoKSBtZXRob2QgcmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgdXNpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IGFzIGFcbiAqIHByaW50Zi1saWtlIGZvcm1hdC5cbiAqXG4gKiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgY29udGFpbmluZyB6ZXJvIG9yIG1vcmUgcGxhY2Vob2xkZXIgdG9rZW5zLlxuICogRWFjaCBwbGFjZWhvbGRlciB0b2tlbiBpcyByZXBsYWNlZCB3aXRoIHRoZSBjb252ZXJ0ZWQgdmFsdWUgZnJvbSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgYXJndW1lbnQuIFN1cHBvcnRlZCBwbGFjZWhvbGRlcnMgYXJlOlxuICpcbiAqICVzIC0gU3RyaW5nLlxuICogJWQgLSBOdW1iZXIgKGludGVnZXIgb3IgZmxvYXRpbmcgcG9pbnQgdmFsdWUpLlxuICogJWkgLSBJbnRlZ2VyLlxuICogJWYgLSBGbG9hdGluZyBwb2ludCB2YWx1ZS5cbiAqICVqIC0gSlNPTi4gUmVwbGFjZWQgd2l0aCB0aGUgc3RyaW5nICdbQ2lyY3VsYXJdJyBpZiB0aGUgYXJndW1lbnQgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqICUlIC0gc2luZ2xlIHBlcmNlbnQgc2lnbiAoJyUnKS4gVGhpcyBkb2VzIG5vdCBjb25zdW1lIGFuIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmIC0gVGVtcGxhdGUuXG4gKiBAcGFyYW0geyp9IFsuLi5hcmdzXSAtIFZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdGFyZ2V0LlxuICogQGV4YW1wbGVcbiAqIHZhciBmb3JtYXQgPSByZXF1aXJlKCd1dGlsLWZvcm1hdC14Jyk7XG4gKlxuICogLy8gSWYgdGhlIHBsYWNlaG9sZGVyIGRvZXMgbm90IGhhdmUgYSBjb3JyZXNwb25kaW5nIGFyZ3VtZW50LFxuICogLy8gdGhlIHBsYWNlaG9sZGVyIGlzIG5vdCByZXBsYWNlZC5cbiAqIGZvcm1hdCgnJXM6JXMnLCAnZm9vJyk7IC8vIFJldHVybnM6ICdmb286JXMnXG4gKlxuICogLy8gSWYgdGhlcmUgYXJlIG1vcmUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZm9ybWF0KCkgbWV0aG9kIHRoYW4gdGhlIG51bWJlclxuICogLy8gb2YgcGxhY2Vob2xkZXJzLCB0aGUgZXh0cmEgYXJndW1lbnRzIGFyZSBjb2VyY2VkIGludG8gc3RyaW5ncyAoZm9yIG9iamVjdHNcbiAqIC8vIGFuZCBzeW1ib2xzLCBpbnNwZWN0KCkgaXMgdXNlZCkgdGhlbiBjb25jYXRlbmF0ZWQgdG8gdGhlIHJldHVybmVkXG4gKiAvLyBzdHJpbmcsIGVhY2ggZGVsaW1pdGVkIGJ5IGEgc3BhY2UuXG4gKiBmb3JtYXQoJyVzOiVzJywgJ2ZvbycsICdiYXInLCAnYmF6Jyk7IC8vICdmb286YmFyIGJheidcbiAqXG4gKiAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGEgZm9ybWF0IHN0cmluZyB0aGVuIGZvcm1hdCgpIHJldHVybnMgYVxuICogLy8gc3RyaW5nIHRoYXQgaXMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGFyZ3VtZW50cyBzZXBhcmF0ZWQgYnkgc3BhY2VzLlxuICogLy8gRWFjaCBhcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgdXNpbmcgaW5zcGVjdCgpLlxuICogZm9ybWF0KDEsIDIsIDMpOyAvLyAnMSAyIDMnXG4gKlxuICogLy8gSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkIHRvIGZvcm1hdCgpLCBpdCBpcyByZXR1cm5lZCBhcyBpdCBpc1xuICogLy93aXRob3V0IGFueSBmb3JtYXR0aW5nLlxuICogZm9ybWF0KCclJSAlcycpOyAvLyAnJSUgJXMnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0O1xuIiwiLyoqXG4qXG4qXHRWQUxJREFURTogdW5kZWZpbmVkXG4qXG4qXG4qXHRERVNDUklQVElPTjpcbipcdFx0LSBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWQuXG4qXG4qXG4qXHROT1RFUzpcbipcdFx0WzFdXG4qXG4qXG4qXHRUT0RPOlxuKlx0XHRbMV1cbipcbipcbipcdExJQ0VOU0U6XG4qXHRcdE1JVFxuKlxuKlx0Q29weXJpZ2h0IChjKSAyMDE0LiBBdGhhbiBSZWluZXMuXG4qXG4qXG4qXHRBVVRIT1I6XG4qXHRcdEF0aGFuIFJlaW5lcy4ga2dyeXRlQGdtYWlsLmNvbS4gMjAxNC5cbipcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4qIEZVTkNUSU9OOiBpc1VuZGVmaW5lZCggdmFsdWUgKVxuKlx0VmFsaWRhdGVzIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkLlxuKlxuKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gYmUgdmFsaWRhdGVkXG4qIEByZXR1cm5zIHtCb29sZWFufSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB2YWx1ZSBpcyB1bmRlZmluZWRcbiovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCggdmFsdWUgKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwO1xufSAvLyBlbmQgRlVOQ1RJT04gaXNVbmRlZmluZWQoKVxuXG5cbi8vIEVYUE9SVFMgLy9cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcbiIsIi8qKlxuICogQGZpbGUgTGlzdCBvZiBFQ01BU2NyaXB0NSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzLlxuICogQHZlcnNpb24gMi4wLjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHdoaXRlLXNwYWNlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgdGhlIEVTNSB3aGl0ZXNwYWNlIGNoYXIgY29kZXMsIHN0cmluZywgYW5kIHRoZWlyIGRlc2NyaXB0aW9ucy5cbiAqXG4gKiBAbmFtZSBsaXN0XG4gKiBAdHlwZSBBcnJheS48T2JqZWN0PlxuICogQGV4YW1wbGVcbiAqIHZhciB3aGl0ZVNwYWNlID0gcmVxdWlyZSgnd2hpdGUtc3BhY2UteCcpO1xuICogd2hpdGVTcGFjZXMubGlzdC5mb3JlYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gKiAgIGNvbnNvbGUubG9nKGxpYi5kZXNjcmlwdGlvbiwgaXRlbS5jb2RlLCBpdGVtLnN0cmluZyk7XG4gKiB9KTtcbiAqL1xudmFyIGxpc3QgPSBbXG4gIHtcbiAgICBjb2RlOiAweDAwMDksXG4gICAgZGVzY3JpcHRpb246ICdUYWInLFxuICAgIHN0cmluZzogJ1xcdTAwMDknXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGEsXG4gICAgZGVzY3JpcHRpb246ICdMaW5lIEZlZWQnLFxuICAgIHN0cmluZzogJ1xcdTAwMGEnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGIsXG4gICAgZGVzY3JpcHRpb246ICdWZXJ0aWNhbCBUYWInLFxuICAgIHN0cmluZzogJ1xcdTAwMGInXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGMsXG4gICAgZGVzY3JpcHRpb246ICdGb3JtIEZlZWQnLFxuICAgIHN0cmluZzogJ1xcdTAwMGMnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGQsXG4gICAgZGVzY3JpcHRpb246ICdDYXJyaWFnZSBSZXR1cm4nLFxuICAgIHN0cmluZzogJ1xcdTAwMGQnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMjAsXG4gICAgZGVzY3JpcHRpb246ICdTcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MDAyMCdcbiAgfSxcbiAgLypcbiAge1xuICAgIGNvZGU6IDB4MDA4NSxcbiAgICBkZXNjcmlwdGlvbjogJ05leHQgbGluZSAtIE5vdCBFUzUgd2hpdGVzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MDA4NSdcbiAgfVxuICAqL1xuICB7XG4gICAgY29kZTogMHgwMGEwLFxuICAgIGRlc2NyaXB0aW9uOiAnTm8tYnJlYWsgc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTAwYTAnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDE2ODAsXG4gICAgZGVzY3JpcHRpb246ICdPZ2hhbSBzcGFjZSBtYXJrJyxcbiAgICBzdHJpbmc6ICdcXHUxNjgwJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgxODBlLFxuICAgIGRlc2NyaXB0aW9uOiAnTW9uZ29saWFuIHZvd2VsIHNlcGFyYXRvcicsXG4gICAgc3RyaW5nOiAnXFx1MTgwZSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwMCxcbiAgICBkZXNjcmlwdGlvbjogJ0VuIHF1YWQnLFxuICAgIHN0cmluZzogJ1xcdTIwMDAnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDEsXG4gICAgZGVzY3JpcHRpb246ICdFbSBxdWFkJyxcbiAgICBzdHJpbmc6ICdcXHUyMDAxJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDAyLFxuICAgIGRlc2NyaXB0aW9uOiAnRW4gc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTIwMDInXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDMsXG4gICAgZGVzY3JpcHRpb246ICdFbSBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjAwMydcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNCxcbiAgICBkZXNjcmlwdGlvbjogJ1RocmVlLXBlci1lbSBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjAwNCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNSxcbiAgICBkZXNjcmlwdGlvbjogJ0ZvdXItcGVyLWVtIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDA1J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA2LFxuICAgIGRlc2NyaXB0aW9uOiAnU2l4LXBlci1lbSBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjAwNidcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNyxcbiAgICBkZXNjcmlwdGlvbjogJ0ZpZ3VyZSBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjAwNydcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwOCxcbiAgICBkZXNjcmlwdGlvbjogJ1B1bmN0dWF0aW9uIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDA4J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA5LFxuICAgIGRlc2NyaXB0aW9uOiAnVGhpbiBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjAwOSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwYSxcbiAgICBkZXNjcmlwdGlvbjogJ0hhaXIgc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTIwMGEnXG4gIH0sXG4gIC8qXG4gIHtcbiAgICBjb2RlOiAweDIwMGIsXG4gICAgZGVzY3JpcHRpb246ICdaZXJvIHdpZHRoIHNwYWNlIC0gTm90IEVTNSB3aGl0ZXNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDBiJ1xuICB9LFxuICAqL1xuICB7XG4gICAgY29kZTogMHgyMDI4LFxuICAgIGRlc2NyaXB0aW9uOiAnTGluZSBzZXBhcmF0b3InLFxuICAgIHN0cmluZzogJ1xcdTIwMjgnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMjksXG4gICAgZGVzY3JpcHRpb246ICdQYXJhZ3JhcGggc2VwYXJhdG9yJyxcbiAgICBzdHJpbmc6ICdcXHUyMDI5J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDJmLFxuICAgIGRlc2NyaXB0aW9uOiAnTmFycm93IG5vLWJyZWFrIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDJmJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDVmLFxuICAgIGRlc2NyaXB0aW9uOiAnTWVkaXVtIG1hdGhlbWF0aWNhbCBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjA1ZidcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MzAwMCxcbiAgICBkZXNjcmlwdGlvbjogJ0lkZW9ncmFwaGljIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUzMDAwJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHhmZWZmLFxuICAgIGRlc2NyaXB0aW9uOiAnQnl0ZSBPcmRlciBNYXJrJyxcbiAgICBzdHJpbmc6ICdcXHVmZWZmJ1xuICB9XG5dO1xuXG52YXIgc3RyaW5nID0gJyc7XG52YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gIHN0cmluZyArPSBsaXN0W2ldLnN0cmluZztcbn1cblxuLyoqXG4gKiBBIHN0cmluZyBvZiB0aGUgRVM1IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqXG4gKiBAbmFtZSBzdHJpbmdcbiAqIEB0eXBlIHN0cmluZ1xuICogQGV4YW1wbGVcbiAqIHZhciB3aGl0ZVNwYWNlID0gcmVxdWlyZSgnd2hpdGUtc3BhY2UteCcpO1xuICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gKiAgICdcXHUwMDA5JyxcbiAqICAgJ1xcdTAwMGEnLFxuICogICAnXFx1MDAwYicsXG4gKiAgICdcXHUwMDBjJyxcbiAqICAgJ1xcdTAwMGQnLFxuICogICAnXFx1MDAyMCcsXG4gKiAgICdcXHUwMGEwJyxcbiAqICAgJ1xcdTE2ODAnLFxuICogICAnXFx1MTgwZScsXG4gKiAgICdcXHUyMDAwJyxcbiAqICAgJ1xcdTIwMDEnLFxuICogICAnXFx1MjAwMicsXG4gKiAgICdcXHUyMDAzJyxcbiAqICAgJ1xcdTIwMDQnLFxuICogICAnXFx1MjAwNScsXG4gKiAgICdcXHUyMDA2JyxcbiAqICAgJ1xcdTIwMDcnLFxuICogICAnXFx1MjAwOCcsXG4gKiAgICdcXHUyMDA5JyxcbiAqICAgJ1xcdTIwMGEnLFxuICogICAnXFx1MjAyOCcsXG4gKiAgICdcXHUyMDI5JyxcbiAqICAgJ1xcdTIwMmYnLFxuICogICAnXFx1MjA1ZicsXG4gKiAgICdcXHUzMDAwJyxcbiAqICAgJ1xcdWZlZmYnXG4gKiBdO1xuICogdmFyIHdzID0gY2hhcmFjdGVycy5qb2luKCcnKTtcbiAqIHZhciByZTEgPSBuZXcgUmVnRXhwKCdeWycgKyB3aGl0ZVNwYWNlLnN0cmluZyArICddKyQpJyk7XG4gKiByZTEudGVzdCh3cyk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxpc3Q6IGxpc3QsXG4gIHN0cmluZzogc3RyaW5nXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge307IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSB9XG5cbmZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdCgpIHtcbiAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgICAgICB7eyByZXEuaXAgfX1cXHhBMFxcbiAgICAgICAgICBbe3sgcmVxLmlkID8gcmVxLmlkIDogbmV3IERhdGUoKS50b1VUQ1N0cmluZygpIH19XVxceEEwXFxuICAgICAgICAgIFxcXCJcXG4gICAgICAgICAge3sgcmVxLm1ldGhvZCB9fVxceEEwXFxuICAgICAgICAgIHt7IHJlcS51cmwgfX1cXHhBMFxcbiAgICAgICAgICBIVFRQL3t7IHJlcS5odHRwVmVyc2lvbk1ham9yIH19Lnt7IHJlcS5odHRwVmVyc2lvbk1pbm9yIH19XFxuICAgICAgICAgIFxcXCJcXHhBMFxcbiAgICAgICAgICB7eyByZXMuc3RhdHVzQ29kZSB9fVxceEEwXFxuICAgICAgICAgIHt7IHJlcy5nZXQoJ1gtUmVzcG9uc2UtVGltZScpIH19XFxuICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICB7eyByZXEuaXAgfX1cXFxcdTAwQTBcXG4gICAgICAgICAgW3t7IHJlcS5pZCA/IHJlcS5pZCA6IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKSB9fV1cXFxcdTAwQTBcXG4gICAgICAgICAgXFxcIlxcbiAgICAgICAgICB7eyByZXEubWV0aG9kIH19XFxcXHUwMEEwXFxuICAgICAgICAgIHt7IHJlcS51cmwgfX1cXFxcdTAwQTBcXG4gICAgICAgICAgSFRUUC97eyByZXEuaHR0cFZlcnNpb25NYWpvciB9fS57eyByZXEuaHR0cFZlcnNpb25NaW5vciB9fVxcbiAgICAgICAgICBcXFwiXFxcXHUwMEEwXFxuICAgICAgICAgIHt7IHJlcy5zdGF0dXNDb2RlIH19XFxcXHUwMEEwXFxuICAgICAgICAgIHt7IHJlcy5nZXQoJ1gtUmVzcG9uc2UtVGltZScpIH19XFxuICAgICAgICBcIl0pO1xuXG4gIF90ZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdCgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChzdHJpbmdzLCByYXcpIHsgaWYgKCFyYXcpIHsgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTsgfSByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7IHJhdzogeyB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpIH0gfSkpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgQXhlID0gcmVxdWlyZSgnYXhlJyk7XG5cbnZhciBwYXJzZVJlcXVlc3QgPSByZXF1aXJlKCdwYXJzZS1yZXF1ZXN0Jyk7XG5cbnZhciBwYXJzZUVyciA9IHJlcXVpcmUoJ3BhcnNlLWVycicpO1xuXG52YXIgb25GaW5pc2hlZCA9IHJlcXVpcmUoJ29uLWZpbmlzaGVkJyk7XG5cbnZhciBzYWZlU3RyaW5naWZ5ID0gcmVxdWlyZSgnZmFzdC1zYWZlLXN0cmluZ2lmeScpOyAvLyA8aHR0cHM6Ly9sYWNrZS5tbi9yZWR1Y2UteW91ci1idW5kbGUtanMtZmlsZS1zaXplLz5cbi8vIDxodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2JhYmVsLXBsdWdpbi1sb2Rhc2gvaXNzdWVzLzIyMT5cblxuXG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCdsb2Rhc2gvaXNVbmRlZmluZWQnKTtcblxudmFyIGlzTnVsbCA9IHJlcXVpcmUoJ2xvZGFzaC9pc051bGwnKTtcblxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdsb2Rhc2gvaXNGdW5jdGlvbicpO1xuXG52YXIgaXNFcnJvciA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Vycm9yJyk7XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnbG9kYXNoL2lzQXJyYXknKTtcblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnbG9kYXNoL2lzU3RyaW5nJyk7XG5cbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2xvZGFzaC9pc051bWJlcicpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNPYmplY3QnKTtcblxudmFyIGlzRW1wdHkgPSByZXF1aXJlKCdsb2Rhc2gvaXNFbXB0eScpO1xuXG52YXIgdG1wbCA9IHJlcXVpcmUoJ2xvZGFzaC90ZW1wbGF0ZScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdjb21tb24tdGFncycpLFxuICAgIG9uZUxpbmVUcmltID0gX3JlcXVpcmUub25lTGluZVRyaW07XG5cbnZhciBhcHBJbmZvID0gcmVxdWlyZSgnLi9hcHAtaW5mbycpO1xuXG52YXIgQ2FiaW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYWJpbihjb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhYmluKTtcblxuICAgIHRoaXMuY29uZmlnID0gX29iamVjdFNwcmVhZCh7XG4gICAgICBrZXk6ICcnLFxuICAgICAgYXhlOiB7fSxcbiAgICAgIGxvZ2dlcjogbnVsbCxcbiAgICAgIG1ldGE6IHt9LFxuICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9uaWZ0eWxldHR1Y2UvcGFyc2UtcmVxdWVzdD5cbiAgICAgIHVzZXJGaWVsZHM6IHVuZGVmaW5lZCxcbiAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vbmlmdHlsZXR0dWNlL3BhcnNlLWVycj5cbiAgICAgIGZpZWxkczogW10sXG4gICAgICBtZXNzYWdlOiBvbmVMaW5lVHJpbShfdGVtcGxhdGVPYmplY3QoKSksXG4gICAgICAvLyA8aHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MjdGVtcGxhdGU+XG4gICAgICB0ZW1wbGF0ZVNldHRpbmdzOiB7XG4gICAgICAgIGludGVycG9sYXRlOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICB9XG4gICAgfSwgY29uZmlnKTsgLy8gb3ZlcnJpZGUga2V5IHdpdGggcm9vdCBrZXkgaW4gY2FzZSB1c2VyIGZvcmdvdFxuXG4gICAgaWYgKCFpc0VtcHR5KHRoaXMuY29uZmlnLmF4ZSkgJiYgdGhpcy5jb25maWcua2V5KSB0aGlzLmNvbmZpZy5heGUua2V5ID0gdGhpcy5jb25maWcua2V5O1xuICAgIGlmICghaXNFbXB0eSh0aGlzLmNvbmZpZy5heGUpKSB0aGlzLmNvbmZpZy5sb2dnZXIgPSBuZXcgQXhlKHRoaXMuY29uZmlnLmF4ZSk7ZWxzZSBpZiAodGhpcy5jb25maWcua2V5KSB0aGlzLmNvbmZpZy5sb2dnZXIgPSBuZXcgQXhlKHtcbiAgICAgIGtleTogdGhpcy5jb25maWcua2V5XG4gICAgfSk7XG4gICAgaWYgKCFpc09iamVjdCh0aGlzLmNvbmZpZy5sb2dnZXIpKSB0aGlzLmNvbmZpZy5sb2dnZXIgPSBuZXcgQXhlKCk7IC8vIGJpbmQgdGhlIGxvZ2dlclxuXG4gICAgdGhpcy5sb2dnZXIgPSB0aGlzLmNvbmZpZy5sb2dnZXI7IC8vIHBhcnNlIGFyZyBoZWxwZXJcblxuICAgIHRoaXMucGFyc2VBcmcgPSB0aGlzLnBhcnNlQXJnLmJpbmQodGhpcyk7IC8vIGJpbmQgaGVscGVyIGZ1bmN0aW9ucyBmb3IgZWFjaCBsb2cgbGV2ZWxcblxuICAgIE9iamVjdC5rZXlzKHRoaXMubG9nZ2VyKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oX3RoaXMubG9nZ2VyW2tleV0pO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICBfdGhpc1tsZXZlbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyRsb2dnZXI7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3NbMV0gPSBfdGhpcy5wYXJzZUFyZyhhcmdzWzFdKTtcblxuICAgICAgICAoX3RoaXMkbG9nZ2VyID0gX3RoaXMubG9nZ2VyKVtsZXZlbF0uYXBwbHkoX3RoaXMkbG9nZ2VyLCBfdG9Db25zdW1hYmxlQXJyYXkoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgfTtcbiAgICB9KTsgLy8gYWxpYXNlc1xuXG4gICAgdGhpcy5lcnIgPSB0aGlzLmVycm9yO1xuICAgIHRoaXMud2FybmluZyA9IHRoaXMud2FybjsgLy8gd2UnZCB1c2UgYGF1dG8tYmluZGAgcGFja2FnZSBidXQgdW5mb3J0dW5hdGVseSBpdFxuICAgIC8vIGRvZXNuJ3QgaGF2ZSBhIGNvbXBpbGVkIHZlcnNpb24gd2l0aG91dCBgY29uc3RgIGV0Y1xuXG4gICAgdGhpcy5zZXRNZXRhID0gdGhpcy5zZXRNZXRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRVc2VyID0gdGhpcy5zZXRVc2VyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5taWRkbGV3YXJlID0gdGhpcy5taWRkbGV3YXJlLmJpbmQodGhpcyk7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgYGdldE1ldGFgIG1ldGhvZFxuXG4gICAgdGhpcy5nZXRNZXRhID0gcGFyc2VSZXF1ZXN0OyAvLyBleHBvc2UgcGFyc2VSZXF1ZXN0IGFuZCBwYXJzZUVyclxuXG4gICAgdGhpcy5wYXJzZVJlcXVlc3QgPSBwYXJzZVJlcXVlc3Q7XG4gICAgdGhpcy5wYXJzZUVyciA9IHBhcnNlRXJyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhYmluLCBbe1xuICAgIGtleTogXCJwYXJzZUFyZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUFyZyhhcmcpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChhcmcpIHx8IGlzTnVsbChhcmcpKSBhcmcgPSB7fTtcbiAgICAgIGlmIChpc0Vycm9yKGFyZykpIGFyZyA9IHtcbiAgICAgICAgZXJyOiBwYXJzZUVycihhcmcsIHRoaXMuY29uZmlnLmZpZWxkcylcbiAgICAgIH07XG4gICAgICBpZiAoaXNBcnJheShhcmcpKSBhcmcgPSB7XG4gICAgICAgIHZhbHVlOiBhcmdcbiAgICAgIH07XG4gICAgICBpZiAoaXNTdHJpbmcoYXJnKSkgYXJnID0ge1xuICAgICAgICB2YWx1ZTogYXJnXG4gICAgICB9O1xuICAgICAgaWYgKGlzTnVtYmVyKGFyZykpIGFyZyA9IHtcbiAgICAgICAgdmFsdWU6IGFyZ1xuICAgICAgfTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZykpIGFyZyA9IHtcbiAgICAgICAgdmFsdWU6IGFyZy50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgaWYgKCFpc09iamVjdChhcmcpKSBhcmcgPSB7fTtcbiAgICAgIE9iamVjdC5hc3NpZ24oYXJnLCB0aGlzLmNvbmZpZy5tZXRhKTtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1ldGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWV0YSgpIHtcbiAgICAgIHZhciBtZXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHRoaXMuY29uZmlnLm1ldGEgPSBtZXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVc2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVzZXIoKSB7XG4gICAgICB2YXIgdXNlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB0aGlzLmNvbmZpZy5tZXRhLnVzZXIgPSB1c2VyO1xuICAgIH0gLy8gVE9ETzogdGhpcyBzaG91bGQgcHJvYmFibHkgbm90IGJlIGluIHRoZSBicm93c2VyIGJ1bmRsZWQgdmVyc2lvblxuICAgIC8vIGFuZCB3ZSBzaG91bGQgZG8gc29tZSBgcmVxdWlyZSgnLi9taWRkbGV3YXJlJylgIHdpdGggYVxuICAgIC8vIGBcImJyb3dzZXJcIjogeyBcIi4vbWlkZGxld2FyZVwiOiB9YCByZXdyaXRlIHRoYXQgaW5jbHVkZXNcbiAgICAvLyBzb21ldGhpbmcgZWxzZSB0aGF0IGNhbiBiZSBjb25zdW1lZCBieSB4aG9vayBvciBzb21ldGhpbmdcblxuICB9LCB7XG4gICAga2V5OiBcIm1pZGRsZXdhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWlkZGxld2FyZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNFeHByZXNzID0gIWlzVW5kZWZpbmVkKGFyZ3NbMl0pICYmIGlzRnVuY3Rpb24oYXJnc1syXSk7XG4gICAgICB2YXIgcmVxID0gaXNFeHByZXNzID8gYXJnc1swXSA6IGFyZ3NbMF0ucmVxO1xuICAgICAgdmFyIHJlcyA9IGlzRXhwcmVzcyA/IGFyZ3NbMV0gOiBhcmdzWzBdLnJlcztcbiAgICAgIHZhciBuZXh0ID0gaXNFeHByZXNzID8gYXJnc1syXSA6IGFyZ3NbMV07XG4gICAgICB2YXIgbG9nZ2VyID0ge307XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmxvZ2dlcikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oX3RoaXMyLmxvZ2dlcltrZXldKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBsb2dnZXJba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyJGxvZ2dlcjtcblxuICAgICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFyZ3NbMV0gPSBfdGhpczIucGFyc2VBcmcoYXJnc1sxXSk7IC8vIGFkZCBgYXBwYCBvYmplY3QgdG8gbWV0YWRhdGFcblxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXJnc1sxXSwgYXBwSW5mbyk7IC8vIGFkZCBgcmVxdWVzdGAgb2JqZWN0IHRvIG1ldGFkYXRhXG5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKGFyZ3NbMV0sIHBhcnNlUmVxdWVzdChyZXEsIF90aGlzMi5jb25maWcudXNlckZpZWxkcykpO1xuXG4gICAgICAgICAgKF90aGlzMiRsb2dnZXIgPSBfdGhpczIubG9nZ2VyKVtrZXldLmFwcGx5KF90aGlzMiRsb2dnZXIsIF90b0NvbnN1bWFibGVBcnJheShbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgICAgIH07XG4gICAgICB9KTsgLy8gc3RvcmUgYSBjb3B5IG9mIHRoZSByZXF1ZXN0IGJvZHlcbiAgICAgIC8vIGluIGNhc2Ugd2UgbW9kaWZpZWQgaXQgaW4gb3VyIG1pZGRsZXdhcmVcbiAgICAgIC8vIChhIGNvbW1vbiBwcmFjdGljZSB1bmZvcnR1bmF0ZWx5KVxuXG4gICAgICB2YXIgYm9keSA9IHNhZmVTdHJpbmdpZnkocmVxLmJvZHkpOyAvLyB1cG9uIGNvbXBsZXRpb24gb2YgYSByZXNwb25zZSB3ZSBuZWVkIHRvIGxvZyBpdFxuXG4gICAgICBvbkZpbmlzaGVkKHJlcywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgdmFyIGxldmVsID0gJ2luZm8nO1xuICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNTAwKSBsZXZlbCA9ICdlcnJvcic7ZWxzZSBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNDAwKSBsZXZlbCA9ICd3YXJuJztcbiAgICAgICAgbG9nZ2VyW2xldmVsXSh0bXBsKF90aGlzMi5jb25maWcubWVzc2FnZSwgX29iamVjdFNwcmVhZCh7fSwgX3RoaXMyLmNvbmZpZy50ZW1wbGF0ZVNldHRpbmdzKSkoe1xuICAgICAgICAgIHJlcTogX29iamVjdFNwcmVhZCh7fSwgcmVxLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcmVzOiBpc0V4cHJlc3MgPyByZXMgOiBhcmdzWzBdLnJlc3BvbnNlXG4gICAgICAgIH0pLnRyaW0oKSk7XG4gICAgICB9KTsgLy8gYWRkIGBsb2dgIChzaG9ydGhhbmQpIGFuZCBgbG9nZ2VyYCBtZXRob2RzXG4gICAgICAvLyBgcmVxLmxvZ2BcbiAgICAgIC8vIGByZXMubG9nYFxuICAgICAgLy8gYGN0eC5yZXFgXG4gICAgICAvLyBgY3R4LnJlc2BcbiAgICAgIC8vIGBjdHgucmVxdWVzdGBcbiAgICAgIC8vIGBjdHgucmVzcG9uc2VgXG4gICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9rb2EtcGluby1sb2dnZXIvaXNzdWVzLzE0PlxuICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9waW5vanMva29hLXBpbm8tbG9nZ2VyL2Jsb2IvbWFzdGVyL2xvZ2dlci5qcyNMMTE+XG4gICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vLWh0dHAvYmxvYi9tYXN0ZXIvbG9nZ2VyLmpzI0w1NT5cblxuICAgICAgcmVxLmxvZyA9IGxvZ2dlcjtcbiAgICAgIHJlcy5sb2cgPSBsb2dnZXI7XG4gICAgICByZXEubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgcmVzLmxvZ2dlciA9IGxvZ2dlcjtcblxuICAgICAgaWYgKCFpc0V4cHJlc3MpIHtcbiAgICAgICAgdmFyIGN0eCA9IGFyZ3NbMF07XG4gICAgICAgIGN0eC5sb2cgPSBsb2dnZXI7XG4gICAgICAgIGN0eC5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIGN0eC5yZXF1ZXN0LmxvZyA9IGxvZ2dlcjtcbiAgICAgICAgY3R4LnJlcXVlc3QubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICBjdHgucmVzcG9uc2UubG9nID0gbG9nZ2VyO1xuICAgICAgICBjdHgucmVzcG9uc2UubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYWJpbjtcbn0oKTtcblxuQ2FiaW4uQXhlID0gQXhlO1xuQ2FiaW4ucGFyc2VSZXF1ZXN0ID0gcGFyc2VSZXF1ZXN0O1xuQ2FiaW4ucGFyc2VFcnIgPSBwYXJzZUVycjtcbm1vZHVsZS5leHBvcnRzID0gQ2FiaW47Il19
