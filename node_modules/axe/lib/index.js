"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var format = require('util-format-x');

var superagent = require('@ladjs/superagent');

var cuid = require('cuid');

var parseErr = require('parse-err');

var safeStringify = require('fast-safe-stringify'); // <https://lacke.mn/reduce-your-bundle-js-file-size/>
// <https://github.com/lodash/babel-plugin-lodash/issues/221>


var isError = require('lodash/isError');

var isObject = require('lodash/isObject');

var isString = require('lodash/isString');

var includes = require('lodash/includes');

var omit = require('lodash/omit');

var isEmpty = require('lodash/isEmpty');

var isPlainObject = require('lodash/isPlainObject');

var isUndefined = require('lodash/isUndefined');

var isNull = require('lodash/isNull');

var boolean = require('boolean');

var _require = require('message-headers'),
    standard = _require.standard;

var formatSpecifiers = require('format-specifiers');

var standardHeaders = standard.map(function (o) {
  return o['Header Field Name'].toLowerCase();
});
var hasWindow = typeof window !== 'undefined' && typeof window.document !== 'undefined'; // eslint-disable-next-line import/no-unassigned-import

require('console-polyfill');

var levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
var endpoint = 'https://api.cabinjs.com';
var env = process.env.NODE_ENV || 'development';

var Axe =
/*#__PURE__*/
function () {
  function Axe() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Axe);

    this.config = _objectSpread({
      key: '',
      endpoint: endpoint,
      headers: {},
      timeout: 5000,
      retry: 3,
      showStack: boolean(process.env.SHOW_STACK || env !== 'production'),
      showMeta: boolean(process.env.SHOW_META),
      silent: false,
      logger: console,
      levels: ['info', 'warn', 'error', 'fatal'],
      capture: env === 'production'
    }, config);
    Object.assign(this, omit(this.config.logger, ['config', 'log'])); // we could have used `auto-bind` but it's not compiled for browser

    this.log = this.log.bind(this); // bind helper functions for each log level

    levels.forEach(function (level) {
      _this[level] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this.log.apply(_this, _toConsumableArray([level].concat([].slice.call(args))));
      };
    }); // aliases

    this.err = this.error;
    this.warning = this.warn;
  } // eslint-disable-next-line complexity


  _createClass(Axe, [{
    key: "log",
    value: function log(level, message, meta) {
      var _this2 = this;

      var originalArgs = [level, message];
      if (!isUndefined(meta)) originalArgs.push(meta);

      for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        args[_key2 - 3] = arguments[_key2];
      }

      originalArgs = originalArgs.concat([].slice.call(args));
      var config = this.config;
      var modifier = 0;
      if (level === 'warning') level = 'warn';
      if (level === 'err') level = 'error';

      if (isError(level)) {
        meta = message;
        message = level;
        level = 'error';
      } else if (!isString(level) || !includes(levels, level)) {
        meta = message;
        message = level;
        level = 'info';
        modifier = -1;
      } // if there are four or more args
      // then infer to use util.format on everything


      if (originalArgs.length >= 4 + modifier) {
        message = format.apply(void 0, _toConsumableArray(originalArgs.slice(1 + modifier)));
        meta = {};
      } else if (originalArgs.length === 3 + modifier && isString(message) && formatSpecifiers.some(function (t) {
        return includes(message, t);
      })) {
        // otherwise if there are three args and if the `message` contains
        // a placeholder token (e.g. '%s' or '%d' - see above `formatSpecifiers` variable)
        // then we can infer that the `meta` arg passed is used for formatting
        message = format(message, meta);
        meta = {};
      } else if (!isError(message)) {
        if (isError(meta)) {
          meta = {
            err: parseErr(meta)
          };
        } else if (!isPlainObject(meta) && !isUndefined(meta) && !isNull(meta)) {
          // if the `meta` variable passed was not an Object then convert it
          message = format(message, meta);
          meta = {};
        } else if (!isString(message)) {
          // if the message is not a string then we should run `util.format` on it
          // assuming we're formatting it like it was another argument
          // (as opposed to using something like fast-json-stringify)
          message = format(message);
        }
      }

      if (!isPlainObject(meta)) meta = {};
      var err;

      if (isError(message)) {
        err = message;
        if (!isObject(meta.err)) meta.err = parseErr(err);
        var _message = message;
        message = _message.message;
      } // set default level on meta


      meta.level = level; // set the body used for returning with and sending logs
      // (and also remove circular references)

      var body = safeStringify({
        message: message,
        meta: meta
      }); // send to Cabin or other logging service here the `message` and `meta`

      if (config.capture && includes(config.levels, level) && (!isError(err) || !err._captureFailed)) {
        // if the user didn't specify a key
        // and they are using the default endpoint
        // then we should throw an error to them
        if (config.endpoint === endpoint && !config.key) throw new Error("Cabin API key required (e.g. `{ key: 'YOUR-CABIN-API-KEY' })`)\n<https://cabinjs.com>"); // capture the log over HTTP

        var req = superagent.post(config.endpoint).set('X-Request-Id', cuid()).timeout(config.timeout); // basic auth (e.g. Cabin API key)

        if (config.key) req.auth(config.key); // set headers if any

        if (!isEmpty(config.headers)) {
          var headers = config.headers;
          if (hasWindow) headers = Object.keys(config.headers).reduce(function (memo, header) {
            if (!includes(standardHeaders, config.headers[header].toLowerCase())) memo[header] = config.headers[header];
            return memo;
          }, {});
          req.set(headers);
        }

        req.retry(config.retry).send(body).end(function (err) {
          if (err) {
            err._captureFailed = true;

            _this2.config.logger.error(err);
          }
        });
      } // Suppress logs if it was silent


      if (config.silent) return body; // if there was meta information then output it

      var omitted = omit(meta, ['level', 'err']); // fatal should use error (e.g. in browser)

      if (level === 'fatal') level = 'error'; // if we didn't pass a level as a method
      // (e.g. console.info), then we should still
      // use the logger's `log` method to output

      if (modifier === -1) level = 'log'; // show stack trace if necessary (along with any metadata)

      if (level === 'error' && isError(err) && config.showStack) {
        if (!config.showMeta || isEmpty(omitted)) this.config.logger.error(err);else this.config.logger.error(err, omitted);
      } else if (!config.showMeta || isEmpty(omitted)) {
        this.config.logger[level](message);
      } else {
        this.config.logger[level](message, omitted);
      } // return the parsed body in case we need it


      return body;
    }
  }]);

  return Axe;
}();

module.exports = Axe;