(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Axe = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function Agent() {
  this._defaults = [];
}

['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert'].forEach(function (fn) {
  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._defaults.push({
      fn: fn,
      args: args
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, _toConsumableArray(def.args));
  });
};

module.exports = Agent;
},{}],2:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Root reference for iframes.
 */
var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self !== 'undefined') {
  // Web Worker
  root = self;
} else {
  // Other environments
  console.warn('Using browser-only version of superagent in non-browser environment');
  root = void 0;
}

var Emitter = require('component-emitter');

var RequestBase = require('./request-base');

var isObject = require('./is-object');

var ResponseBase = require('./response-base');

var Agent = require('./agent-base');
/**
 * Noop.
 */


function noop() {}
/**
 * Expose `request`.
 */


var request = exports = module.exports = function (method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (arguments.length == 1) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || root.location.protocol != 'file:' || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  }

  try {
    return new ActiveXObject('Microsoft.XMLHTTP');
  } catch (e) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.6.0');
  } catch (e) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.3.0');
  } catch (e) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP');
  } catch (e) {}

  throw new Error('Browser-only version of superagent could not find XHR');
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */


var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];

  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */


function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function (v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for (var subkey in val) {
        pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}
/**
 * Expose serialization method.
 */


request.serializeObject = serialize;
/**
 * Parse the given x-www-form-urlencoded `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}
/**
 * Expose parser.
 */


request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  form: 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};
/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(str){
 *       return { object parsed from str };
 *     };
 *
 */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */


function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders()); // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (this.text === null && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
  }
}

ResponseBase(Response.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, str);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var msg = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;
  return err;
};
/**
 * Expose `Response`.
 */


request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType === 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);
    var new_err;

    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (custom_err) {
      new_err = custom_err; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */


Emitter(Request.prototype);
RequestBase(Request.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: typeof btoa === 'function' ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if (typeof btoa === 'function') {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (val) {
  if (typeof val !== 'string') val = serialize(val);
  if (val) this._query.push(val);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */


Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;
  err.status = this.status;
  err.method = this.method;
  err.url = this.url;
  this.callback(err);
}; // This only warns, because the request is still likely to work


Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
  console.warn('This is not supported in browser version of superagent');
  return this;
}; // This throws, because it can't send/receive data as expected


Request.prototype.pipe = Request.prototype.write = function () {
  throw new Error('Streaming is not supported in browser version of superagent');
};
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */


Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && _typeof(obj) === 'object' && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn('Warning: .end() was called twice. This is not supported in superagent');
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function () {
  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (readyState != 4) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (e) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }; // progress


  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.addEventListener('progress', handleProgress.bind(null, 'download'));

      if (xhr.upload) {
        xhr.upload.addEventListener('progress', handleProgress.bind(null, 'upload'));
      }
    } catch (e) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && this.method != 'GET' && this.method != 'HEAD' && typeof data !== 'string' && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];

    var _serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!_serialize && isJSON(contentType)) {
      _serialize = request.serialize['application/json'];
    }

    if (_serialize) data = _serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (this.header[field] == null) continue;
    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = function () {
  return new Agent();
};

['GET', 'POST', 'OPTIONS', 'PATCH', 'PUT', 'DELETE'].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);

    this._setDefaults(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype.delete;
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.head = function (url, data, fn) {
  var req = request('HEAD', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


function del(url, data, fn) {
  var req = request('DELETE', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request.del = del;
request.delete = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.post = function (url, data, fn) {
  var req = request('POST', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.put = function (url, data, fn) {
  var req = request('PUT', url);
  if (typeof data === 'function') fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
},{"./agent-base":1,"./is-object":3,"./request-base":4,"./response-base":5,"component-emitter":43}],3:[function(require,module,exports){
'use strict';
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isObject(obj) {
  return obj !== null && _typeof(obj) === 'object';
}

module.exports = isObject;
},{}],4:[function(require,module,exports){
'use strict';
/**
 * Module of mixed-in functions shared between node and client code
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isObject = require('./is-object');
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }

  return obj;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function _clearTimeout() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function parse(fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function serialize(fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function timeout(options) {
  if (!options || _typeof(options) !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for (var option in options) {
    switch (option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;

      case 'response':
        this._responseTimeout = options.response;
        break;

      default:
        console.warn('Unknown timeout option', option);
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function retry(count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];
/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (e) {
      console.error(e);
    }
  }

  if (res && res.status && res.status >= 500 && res.status != 501) return true;

  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true; // Superagent timeout

    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }

    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
      self.on('error', innerReject);
      self.end(function (err, res) {
        if (err) innerReject(err);else innerResolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if (typeof cb !== 'function') throw new Error('Callback required');
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};
/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }

    return this;
  } // val should be defined now


  if (val === null || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if (typeof val === 'boolean') {
    val = String(val);
  }

  this._getFormData().append(name, val);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser

  this.req && this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', "Bearer ".concat(user));
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  } // merge


  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];

    if (type == 'application/x-www-form-urlencoded') {
      this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');

      if (typeof this._sort === 'function') {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }

      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.trace('Unsupported');
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error("".concat(reason + timeout, "ms exceeded"));
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};
},{"./is-object":3}],5:[function(require,module,exports){
'use strict';
/**
 * Module dependencies.
 */

var utils = require('./utils');
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.status = this.statusCode = status;
  this.statusType = type; // basics

  this.info = type == 1;
  this.ok = type == 2;
  this.redirect = type == 3;
  this.clientError = type == 4;
  this.serverError = type == 5;
  this.error = type == 4 || type == 5 ? this.toError() : false; // sugar

  this.created = status == 201;
  this.accepted = status == 202;
  this.noContent = status == 204;
  this.badRequest = status == 400;
  this.unauthorized = status == 401;
  this.notAcceptable = status == 406;
  this.forbidden = status == 403;
  this.notFound = status == 404;
  this.unprocessableEntity = status == 422;
};
},{"./utils":6}],6:[function(require,module,exports){
'use strict';
/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();
    if (key && val) obj[key] = val;
    return obj;
  }, {});
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host; // secuirty

  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }

  return header;
};
},{}],7:[function(require,module,exports){
/**
 * @file Creates an array with all elements that pass the test by the provided function.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-filter-x
 */

'use strict';

var toObject = require('to-object-x');
var assertIsFunction = require('assert-is-function-x');
var some = require('array-some-x');

var $filter = function filter(array, callBack /* , thisArg */) {
  var object = toObject(array);
  // If no callback function or if callback is not a callable function
  assertIsFunction(callBack);
  var result = [];
  var wrapped = function _wrapped(item, idx, obj) {
    // eslint-disable-next-line no-invalid-this
    if (callBack.call(this, item, idx, obj)) {
      result[result.length] = item;
    }
  };

  var args = [object, wrapped];
  if (arguments.length > 2) {
    args[2] = arguments[2];
  }

  some.apply(void 0, args);
  return result;
};

/**
 * This method creates a new array with all elements that pass the test
 * implemented by the provided function.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function is a predicate, to test each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {array} A new array with the elements that pass the test.
 * @example
 * var filter = require('array-filter-x');
 *
 * function isBigEnough(value) {
 *   return value >= 10;
 * }
 *
 * var filtered = filter([12, 5, 8, 130, 44], isBigEnough);
 * // filtered is [12, 130, 44]
 */
module.exports = $filter;

},{"array-some-x":25,"assert-is-function-x":30,"to-object-x":344}],8:[function(require,module,exports){
/**
 * @file Executes a provided function once for each array element.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-for-each-x
 */

'use strict';

var toObject = require('to-object-x');
var assertIsFunction = require('assert-is-function-x');
var some = require('array-some-x');

var $forEach = function forEach(array, callBack /* , thisArg */) {
  var object = toObject(array);
  // If no callback function or if callback is not a callable function
  assertIsFunction(callBack);
  var wrapped = function _wrapped(item, idx, obj) {
    // eslint-disable-next-line no-invalid-this
    callBack.call(this, item, idx, obj);
  };

  var args = [object, wrapped];
  if (arguments.length > 2) {
    args[2] = arguments[2];
  }

  some.apply(void 0, args);
};

/**
 * This method executes a provided function once for each array element.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to execute for each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @example
 * var forEach = require('array-for-each-x');
 *
 * var items = ['item1', 'item2', 'item3'];
 * var copy = [];
 *
 * forEach(items, function(item){
 *   copy.push(item)
 * });
 */
module.exports = $forEach;

},{"array-some-x":25,"assert-is-function-x":30,"to-object-x":344}],9:[function(require,module,exports){
/**
 * @file Determines whether an array includes a certain element.
 * @version 1.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-includes-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeIncludes = Array.prototype.includes;
var $includes;

if (nativeIncludes) {
  var arr = {
    1: 'a',
    2: NaN,
    3: -0,
    length: 5
  };

  try {
    if (nativeIncludes.call(arr, void 0, -1) && nativeIncludes.call(arr, NaN) && nativeIncludes.call('abc', 'c')) {
      $includes = function includes(array, searchElement) {
        var object = toObject(array);
        var args = [searchElement];
        if (arguments.length > 2) {
          args[1] = arguments[2];
        }

        return nativeIncludes.apply(object, args);
      };
    }
  } catch (ignore) {}
}

if (Boolean($includes) === false) {
  var isString = require('is-string');
  var isUndefined = require('validate.io-undefined');
  var toLength = require('to-length-x');
  var sameValueZero = require('same-value-zero-x');
  var findIndex = require('find-index-x');
  var splitString = require('has-boxed-string-x') === false;
  var indexOf = require('index-of-x');
  var calcFromIndex = require('calculate-from-index-x');

  /*
   * This method returns an index in the array, if an element in the array
   * satisfies the provided testing function. Otherwise -1 is returned.
   *
   * @private
   * @param {Array} object - The array to search.
   * @param {*} searchElement - Element to locate in the array.
   * @param {number} fromIndex - The index to start the search at.
   * @returns {number} Returns index of found element, otherwise -1.
   */
  var findIdxFrom = function findIndexFrom(object, searchElement, fromIndex) {
    var fIdx = fromIndex;
    var length = toLength(object.length);
    while (fIdx < length) {
      if (sameValueZero(object[fIdx], searchElement)) {
        return fIdx;
      }

      fIdx += 1;
    }

    return -1;
  };

  $includes = function includes(array, searchElement) {
    var object = toObject(array);
    var iterable = splitString && isString(object) ? object.split('') : object;
    var length = toLength(iterable.length);
    if (length < 1) {
      return -1;
    }

    if (isUndefined(searchElement)) {
      var fromIndex = calcFromIndex(iterable, arguments[2]);
      if (fromIndex >= length) {
        return -1;
      }

      if (fromIndex < 0) {
        fromIndex = 0;
      }

      if (fromIndex > 0) {
        return findIdxFrom(iterable, searchElement, fromIndex) > -1;
      }

      return findIndex(iterable, function (element) {
        return sameValueZero(searchElement, element);
      }) > -1;
    }

    return indexOf(iterable, searchElement, arguments[2], 'samevaluezero') > -1;
  };
}

/**
 * This method determines whether an array includes a certain element,
 * returning true or false as appropriate.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If `array` is `null` or `undefined`.
 * @param {*} searchElement - Element to locate in the `array`.
 * @param {number} [fromIndex] - The position in this array at which to begin
 *  searching for searchElement. A negative value searches from the index of
 *  array.length + fromIndex by asc. Defaults to 0.
 * @returns {boolean} `true` if searched element is included; otherwise `false`.
 * @example
 * var includes = require('array-includes-x');
 *
 * var subject = [2, 3, undefined, true, 'hej', null, 2, false, 0, -0, NaN];
 * includes(subject, undefined); // true
 * includes(subject, undefined, 3); // false
 * includes(subject, NaN); // true
 * includes(subject, 10); // false
 *
 */
module.exports = $includes;

},{"calculate-from-index-x":36,"find-index-x":53,"has-boxed-string-x":69,"index-of-x":77,"is-string":134,"same-value-zero-x":333,"to-length-x":13,"to-object-x":344,"validate.io-undefined":356}],10:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Number.isFinite.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-number.isfinite|20.1.2.2 Number.isFinite ( number )}
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-finite-x
 */

'use strict';

var $isNaN = require('is-nan');

var $isFinite;
if (typeof Number.isFinite === 'function') {
  var MAX_SAFE_INTEGER = require('max-safe-integer');
  try {
    if (Number.isFinite(MAX_SAFE_INTEGER) && Number.isFinite(Infinity) === false) {
      $isFinite = Number.isFinite;
    }
  } catch (ignore) {}
}

/**
 * This method determines whether the passed value is a finite number.
 *
 * @param {*} number - The value to be tested for finiteness.
 * @returns {boolean} A Boolean indicating whether or not the given value is a finite number.
 * @example
 * var numIsFinite = require('is-finite-x');
 *
 * numIsFinite(Infinity);  // false
 * numIsFinite(NaN);       // false
 * numIsFinite(-Infinity); // false
 *
 * numIsFinite(0);         // true
 * numIsFinite(2e64);      // true
 *
 * numIsFinite('0');       // false, would've been true with
 *                         // global isFinite('0')
 * numIsFinite(null);      // false, would've been true with
 */
module.exports = $isFinite || function isFinite(number) {
  return !(typeof number !== 'number' || $isNaN(number) || number === Infinity || number === -Infinity);
};

},{"is-nan":118,"max-safe-integer":300}],11:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Math.sign.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-math.sign|20.2.2.29 Math.sign(x)}
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-sign-x
 */

'use strict';

var $isNaN = require('is-nan');

var $sign;
if (typeof Math.sign === 'function') {
  try {
    if (Math.sign(10) === 1 && Math.sign(-10) === -1 && Math.sign(0) === 0) {
      $sign = Math.sign;
    }
  } catch (ignore) {}
}

/**
 * This method returns the sign of a number, indicating whether the number is positive,
 * negative or zero.
 *
 * @param {*} x - A number.
 * @returns {number} A number representing the sign of the given argument. If the argument
 * is a positive number, negative number, positive zero or negative zero, the function will
 * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
 * @example
 * var mathSign = require('math-sign-x');
 *
 * mathSign(3);     //  1
 * mathSign(-3);    // -1
 * mathSign('-3');  // -1
 * mathSign(0);     //  0
 * mathSign(-0);    // -0
 * mathSign(NaN);   // NaN
 * mathSign('foo'); // NaN
 * mathSign();      // NaN
 */
module.exports = $sign || function sign(x) {
  var n = Number(x);
  if (n === 0 || $isNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

},{"is-nan":118}],12:[function(require,module,exports){
/**
 * @file ToInteger converts 'argument' to an integral numeric value.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger|7.1.4 ToInteger ( argument )}
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-integer-x
 */

'use strict';

var $isNaN = require('is-nan');
var $isFinite = require('is-finite-x');
var $sign = require('math-sign-x');

/**
 * Converts `value` to an integer.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 *
 * @example
 * var toInteger = require('to-integer-x');
 * toInteger(3); // 3
 * toInteger(Number.MIN_VALUE); // 0
 * toInteger(Infinity); // 1.7976931348623157e+308
 * toInteger('3'); // 3
 */
module.exports = function ToInteger(value) {
  var number = Number(value);
  if ($isNaN(number)) {
    return 0;
  }

  if (number === 0 || $isFinite(number) === false) {
    return number;
  }

  return $sign(number) * Math.floor(Math.abs(number));
};

},{"is-finite-x":10,"is-nan":118,"math-sign-x":11}],13:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToLength.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tolength|7.1.15 ToLength ( argument )}
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-length-x
 */

'use strict';

var toInteger = require('to-integer-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 * var toLength = require('to-length-x');
 * toLength(3); // 3
 * toLength(Number.MIN_VALUE); // 0
 * toLength(Infinity); // Number.MAX_SAFE_INTEGER
 * toLength('3'); // 3
 */
module.exports = function ToLength(value) {
  var len = toInteger(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

},{"max-safe-integer":300,"to-integer-x":12}],14:[function(require,module,exports){
/**
 * @file Cross-browser array-like slicer.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-like-slice-x
 */

'use strict';

var toObject = require('to-object-x');
var toInteger = require('to-integer-x').toInteger2018;
var toLength = require('to-length-x').toLength2018;
var isUndefined = require('validate.io-undefined');
var splitIfBoxedBug = require('split-if-boxed-bug-x');

var getMax = function _getMax(a, b) {
  return a >= b ? a : b;
};

var getMin = function _getMin(a, b) {
  return a <= b ? a : b;
};

var setRelative = function _setRelative(value, length) {
  return value < 0 ? getMax(length + value, 0) : getMin(value, length);
};

/**
 * The slice() method returns a shallow copy of a portion of an array into a new
 * array object selected from begin to end (end not included). The original
 * array will not be modified.
 *
 * @param {!Object} argsObject - The `arguments` to slice.
 * @param {number} [start] - Zero-based index at which to begin extraction.
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(-2) extracts the last two elements in the sequence.
 *  If begin is undefined, slice begins from index 0.
 * @param {number} [end] - Zero-based index before which to end extraction.
 *  Slice extracts up to but not including end. For example, slice([0,1,2,3,4],1,4)
 *  extracts the second element through the fourth element (elements indexed
 *  1, 2, and 3).
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(2,-1) extracts the third element through the second-to-last
 *  element in the sequence.
 *  If end is omitted, slice extracts through the end of the sequence (arr.length).
 *  If end is greater than the length of the sequence, slice extracts through
 *  the end of the sequence (arr.length).
 * @returns {Array} A new array containing the extracted elements.
 * @example
 * var arrayLikeSlice = require('array-like-slice-x');
 * var args = (function () {
    return arguments;
 * }('Banana', 'Orange', 'Lemon', 'Apple', 'Mango'));
 *
 * var citrus = arrayLikeSlice(args, 1, 3);
 *
 * // args contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
 * // citrus contains ['Orange','Lemon']
 */
module.exports = function slice(arrayLike, start, end) {
  var iterable = splitIfBoxedBug(toObject(arrayLike));
  var length = toLength(iterable.length);
  var k = setRelative(toInteger(start), length);
  var relativeEnd = isUndefined(end) ? length : toInteger(end);
  var finalEnd = setRelative(relativeEnd, length);
  var val = [];
  val.length = getMax(finalEnd - k, 0);
  var next = 0;
  while (k < finalEnd) {
    if (k in iterable) {
      val[next] = iterable[k];
    }

    next += 1;
    k += 1;
  }

  return val;
};

},{"split-if-boxed-bug-x":334,"to-integer-x":337,"to-length-x":339,"to-object-x":344,"validate.io-undefined":356}],15:[function(require,module,exports){
/**
 * @file Creates an array with the results of calling a function on every element.
 * @version 2.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-map-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var ArrayCtr = cachedCtrs.Array;
var castObject = cachedCtrs.Object;
var nativeMap = typeof ArrayCtr.prototype.map === 'function' && ArrayCtr.prototype.map;

var isWorking;
if (nativeMap) {
  var attempt = require('attempt-x');
  var spy = 0;
  var res = attempt.call([1, 2], nativeMap, function (item) {
    return item;
  });

  isWorking = res.threw === false && res.value && res.value.length === 2 && res.value[0] === 1 && res.value[1] === 2;

  if (isWorking) {
    spy = '';
    res = attempt.call(castObject('ab'), nativeMap, function (item) {
      return item;
    });

    isWorking = res.threw === false && res.value && res.value.length === 2 && res.value[0] === 'a' && res.value[1] === 'b';
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call((function () {
      return arguments;
    }(1, 2)), nativeMap, function (item) {
      return item;
    });

    isWorking = res.threw === false && res.value && res.value.length === 2 && res.value[0] === 1 && res.value[1] === 2;
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call({
      0: 1,
      2: 2,
      length: 3
    }, nativeMap, function (item) {
      return item;
    });

    isWorking = res.threw === false && res.value && res.value.length === 3 && (1 in res.value) === false;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      spy = null;
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativeMap, function (item) {
        return item;
      });

      isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === div;
    }
  }

  if (isWorking) {
    var isStrict = (function () {
      // eslint-disable-next-line no-invalid-this
      return Boolean(this) === false;
    }());

    if (isStrict) {
      spy = null;
      res = attempt.call([1], nativeMap, function () {
        // eslint-disable-next-line no-invalid-this
        spy = typeof this === 'string';
      }, 'x');

      isWorking = res.threw === false && res.value && res.value.length === 1 && spy === true;
    }
  }

  if (isWorking) {
    spy = {};
    var fn = [
      'return nativeMap.call("foo", function (_, __, context) {',
      'if (Boolean(context) === false || typeof context !== "object") {',
      'spy.value = true;}});'
    ].join('');

    // eslint-disable-next-line no-new-func
    res = attempt(Function('nativeMap', 'spy', fn), nativeMap, spy);

    isWorking = res.threw === false && res.value && res.value.length === 3 && spy.value !== true;
  }
}

var $map;
if (nativeMap) {
  $map = function map(array, callBack /* , thisArg */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativeMap.apply(array, args);
  };
} else {
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x').toLength2018;
  var isUndefined = require('validate.io-undefined');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $map = function map(array, callBack /* , thisArg */) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var noThis = isUndefined(thisArg);
    var result = [];
    result.length = length;
    for (var i = 0; i < length; i += 1) {
      if (i in iterable) {
        var item = iterable[i];
        result[i] = noThis ? callBack(item, i, object) : callBack.call(thisArg, item, i, object);
      }
    }

    return result;
  };
}

/**
 * This method creates a new array with the results of calling a provided
 * function on every element in the calling array.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function that produces an element of the Array.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {array} A new array with each element being the result of the
 * callback function.
 * @example
 * var map = require('array-map-x');
 *
 * var numbers = [1, 4, 9];
 * var roots = map(numbers, Math.sqrt);
 * // roots is now [1, 2, 3]
 * // numbers is still [1, 4, 9]
 */
module.exports = $map;

},{"assert-is-function-x":16,"attempt-x":32,"cached-constructors-x":35,"split-if-boxed-bug-x":334,"to-length-x":339,"to-object-x":344,"validate.io-undefined":356}],16:[function(require,module,exports){
/**
 * @file If isFunction(callbackfn) is false, throw a TypeError exception.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-function-x
 */

'use strict';

var isFunction = require('is-function-x');
var safeToString = require('to-string-symbols-supported-x');
var isPrimitive = require('is-primitive');

/**
 * Tests `callback` to see if it is a function, throws a `TypeError` if it is
 * not. Otherwise returns the `callback`.
 *
 * @param {*} callback - The argument to be tested.
 * @throws {TypeError} Throws if `callback` is not a function.
 * @returns {*} Returns `callback` if it is function.
 * @example
 * var assertIsFunction = require('assert-is-function-x');
 * var primitive = true;
 * var mySymbol = Symbol('mySymbol');
 * var symObj = Object(mySymbol);
 * var object = {};
 * function fn () {}
 *
 * assertIsFunction(primitive);
 *    // TypeError 'true is not a function'.
 * assertIsFunction(object);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(mySymbol);
 *    // TypeError 'Symbol(mySymbol) is not a function'.
 * assertIsFunction(symObj);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(fn);
 *    // Returns fn.
 */
module.exports = function assertIsFunction(callback) {
  if (isFunction(callback) === false) {
    var msg = isPrimitive(callback) ? safeToString(callback) : '#<Object>';
    throw new TypeError(msg + ' is not a function');
  }

  return callback;
};

},{"is-function-x":110,"is-primitive":126,"to-string-symbols-supported-x":347}],17:[function(require,module,exports){
/**
 * @file Reduce an array (from left to right) to a single value.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-reduce-x
 */

'use strict';

var attempt = require('attempt-x');
var nativeReduce = typeof Array.prototype.reduce === 'function' && Array.prototype.reduce;

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
var isWorking;
if (nativeReduce) {
  isWorking = attempt.call([], nativeReduce, function (acc) {
    return acc;
  }).threw;

  var res;
  if (isWorking) {
    res = attempt.call(Object('abc'), nativeReduce, function (acc, c) {
      return acc + c;
    }, 'x');

    isWorking = res.threw === false && res.value === 'xabc';
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }(1, 2, 3)), nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 1);

    isWorking = res.threw === false && res.value === 7;
  }

  if (isWorking) {
    res = attempt.call({
      0: 1,
      1: 2,
      3: 3,
      4: 4,
      length: 4
    }, nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 2);

    isWorking = res.threw === false && res.value === 8;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativeReduce, function (acc, node) {
        acc[acc.length] = node;
        return acc;
      }, []);

      isWorking = res.threw === false && res.value.length === 1 && res.value[0] === div;
    }
  }

  if (isWorking) {
    // eslint-disable-next-line max-params
    res = attempt.call('ab', nativeReduce, function (_, __, ___, list) {
      return list;
    });

    isWorking = res.threw === false && typeof res.value === 'object';
  }
}

var $reduce;
if (nativeReduce && isWorking) {
  $reduce = function reduce(array, callBack /* , initialValue */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativeReduce.apply(array, args);
  };
} else {
  // Check failure of by-index access of string characters (IE < 9)
  // and failure of `0 in boxedString` (Rhino)
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $reduce = function reduce(array, callBack /* , initialValue*/) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var argsLength = arguments.length;
    // no value to return if no initial value and an empty array
    if (length === 0 && argsLength < 3) {
      throw new TypeError('reduce of empty array with no initial value');
    }

    var i = 0;
    var result;
    if (argsLength > 2) {
      result = arguments[2];
    } else {
      // eslint-disable-next-line no-constant-condition
      do {
        if (i in iterable) {
          result = iterable[i];
          i += 1;
          // eslint-disable-next-line no-restricted-syntax
          break;
        }

        // if array contains no values, no initial value to return
        i += 1;
        if (i >= length) {
          throw new TypeError('reduce of empty array with no initial value');
        }
      } while (true);
    }

    while (i < length) {
      if (i in iterable) {
        result = callBack(result, iterable[i], i, object);
      }

      i += 1;
    }

    return result;
  };
}

/**
 * This method applies a function against an accumulator and each element in the
 * array (from left to right) to reduce it to a single value.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to execute for each element.
 * @param {*} [initialValue] - Value to use as the first argument to the first
 *  call of the callback. If no initial value is supplied, the first element in
 *  the array will be used. Calling reduce on an empty array without an initial
 *  value is an error.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @throws {TypeError} If called on an empty array without an initial value.
 * @returns {*} The value that results from the reduction.
 * @example
 * var reduce = require('array-reduce-x');
 *
 * var sum = reduce([0, 1, 2, 3], function (a, b) {
 *   return a + b;
 * }, 0);
 * // sum is 6
 */
module.exports = $reduce;

},{"assert-is-function-x":18,"attempt-x":32,"split-if-boxed-bug-x":334,"to-length-x":22,"to-object-x":344}],18:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":110,"is-primitive":126,"to-string-symbols-supported-x":347}],19:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Math.sign.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-math.sign|20.2.2.29 Math.sign(x)}
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-sign-x
 */

'use strict';

var toNumber = require('to-number-x');
var numberIsNaN = require('is-nan-x');

/**
 * This method returns the sign of a number, indicating whether the number is positive,
 * negative or zero.
 *
 * @param {*} x - A number.
 * @returns {number} A number representing the sign of the given argument. If the argument
 * is a positive number, negative number, positive zero or negative zero, the function will
 * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
 * @example
 * var mathSign = require('math-sign-x');
 *
 * mathSign(3);     //  1
 * mathSign(-3);    // -1
 * mathSign('-3');  // -1
 * mathSign(0);     //  0
 * mathSign(-0);    // -0
 * mathSign(NaN);   // NaN
 * mathSign('foo'); // NaN
 * mathSign();      // NaN
 */
module.exports = function sign(x) {
  var n = toNumber(x);
  if (n === 0 || numberIsNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

},{"is-nan-x":116,"to-number-x":23}],20:[function(require,module,exports){
/**
 * @file Parses a string argument and returns an integer of the specified radix.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module parse-int-x
 */

'use strict';

var nativeParseInt = parseInt;
var ws = require('white-space-x').string;
var toStr = require('to-string-x');

var $parseInt;
if (nativeParseInt(ws + '08') === 8 && nativeParseInt(ws + '0x16') === 22) {
  $parseInt = function parseInteger(string, radix) {
    return nativeParseInt(toStr(string), radix);
  };
} else {
  var trim = require('trim-x');
  var castNumber = require('cached-constructors-x').Number;
  var hexRegex = /^[-+]?0[xX]/;
  var test = hexRegex.test;

  $parseInt = function parseInteger(string, radix) {
    var str = trim(toStr(string));

    return nativeParseInt(str, castNumber(radix) || (test.call(hexRegex, str) ? 16 : 10));
  };
}

/**
 * This method parses a string argument and returns an integer of the specified
 * radix (the base in mathematical numeral systems).
 *
 * @param {string} string - The value to parse. If the string argument is not a
 *  string, then it is converted to a string (using the ToString abstract
 *  operation). Leading whitespace in the string argument is ignored.
 * @param {number} radix - An integer between 2 and 36 that represents the radix
 *  (the base in mathematical numeral systems) of the above mentioned string.
 *  Specify 10 for the decimal numeral system commonly used by humans. Always
 *  specify this parameter to eliminate reader confusion and to guarantee
 *  predictable behavior. Different implementations produce different results
 *  when a radix is not specified, usually defaulting the value to 10.
 * @throws {TypeError} If target is a Symbol or is not coercible.
 * @returns {number} An integer number parsed from the given string. If the first
 *  character cannot be converted to a number, NaN is returned.
 * @example
 * var $parseInt = require('parse-int-x');
 *
 * // The following examples all return 15
 * $parseInt(' 0xF', 16);
 * $parseInt(' F', 16);
 * $parseInt('17', 8);
 * $parseInt(021, 8);
 * $parseInt('015', 10);   // $parseInt(015, 10); will return 15
 * $parseInt(15.99, 10);
 * $parseInt('15,123', 10);
 * $parseInt('FXX123', 16);
 * $parseInt('1111', 2);
 * $parseInt('15 * 3', 10);
 * $parseInt('15e2', 10);
 * $parseInt('15px', 10);
 * $parseInt('12', 13);
 *
 * //The following examples all return NaN:
 * $parseInt('Hello', 8); // Not a number at all
 * $parseInt('546', 2);   // Digits are not valid for binary representations
 */
module.exports = $parseInt;

},{"cached-constructors-x":35,"to-string-x":349,"trim-x":353,"white-space-x":357}],21:[function(require,module,exports){
/**
 * @file ToInteger converts 'argument' to an integral numeric value.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger|7.1.4 ToInteger ( argument )}
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-integer-x
 */

'use strict';

var toNumber = require('to-number-x');
var numberIsNaN = require('is-nan-x');
var numberIsFinite = require('is-finite-x');
var mathSign = require('math-sign-x');

/**
 * Converts `value` to an integer.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 *
 * @example
 * var toInteger = require('to-integer-x');
 * toInteger(3); // 3
 * toInteger(Number.MIN_VALUE); // 0
 * toInteger(Infinity); // 1.7976931348623157e+308
 * toInteger('3'); // 3
 */
module.exports = function toInteger(value) {
  var number = toNumber(value);
  if (numberIsNaN(number)) {
    return 0;
  }

  if (number === 0 || numberIsFinite(number) === false) {
    return number;
  }

  return mathSign(number) * Math.floor(Math.abs(number));
};

},{"is-finite-x":109,"is-nan-x":116,"math-sign-x":19,"to-number-x":23}],22:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToLength.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tolength|7.1.15 ToLength ( argument )}
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-length-x
 */

'use strict';

var toInteger = require('to-integer-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * @param {*} value - The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 * var toLength = require('to-length-x');
 * toLength(3); // 3
 * toLength(Number.MIN_VALUE); // 0
 * toLength(Infinity); // Number.MAX_SAFE_INTEGER
 * toLength('3'); // 3
 */
module.exports = function toLength(value) {
  var len = toInteger(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

},{"max-safe-integer":300,"to-integer-x":21}],23:[function(require,module,exports){
/**
 * @file Converts argument to a value of type Number.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-number-x
 */

'use strict';

var constructors = require('cached-constructors-x');
var castNumber = require('cached-constructors-x').Number;
var Rx = constructors.RegExp;
var toPrimitive = require('to-primitive-x');
var trim = require('trim-x');
var $parseInt = require('parse-int-x');
var pStrSlice = ''.slice;
var NAN = require('nan-x');

var binaryRegex = /^0b[01]+$/i;
// Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
var test = binaryRegex.test;
var isBinary = function _isBinary(value) {
  return test.call(binaryRegex, value);
};

var octalRegex = /^0o[0-7]+$/i;
var isOctal = function _isOctal(value) {
  return test.call(octalRegex, value);
};

var nonWSregex = new Rx('[\u0085\u200b\ufffe]', 'g');
var hasNonWS = function _hasNonWS(value) {
  return test.call(nonWSregex, value);
};

var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = function _isInvalidHexLiteral(value) {
  return test.call(invalidHexLiteral, value);
};

/**
 * This method converts argument to a value of type Number.

 * @param {*} argument - The argument to convert to a number.
 * @throws {TypeError} - If argument is a Symbol or not coercible.
 * @returns {*} The argument converted to a number.
 * @example
 * var toNumber = require('to-number-x');
 *
 * toNumber('1'); // 1
 * toNumber(null); // 0
 * toNumber(true); // 1
 * toNumber('0o10'); // 8
 * toNumber('0b10'); // 2
 * toNumber('0xF'); // 16
 *
 * toNumber(' 1 '); // 1
 *
 * toNumber(Symbol('')) // TypeError
 * toNumber(Object.create(null)) // TypeError
 */
module.exports = function toNumber(argument) {
  var value = toPrimitive(argument, Number);
  if (typeof value === 'symbol') {
    throw new TypeError('Cannot convert a Symbol value to a number');
  }

  if (typeof value === 'string') {
    if (isBinary(value)) {
      return toNumber($parseInt(pStrSlice.call(value, 2), 2));
    }

    if (isOctal(value)) {
      return toNumber($parseInt(pStrSlice.call(value, 2), 8));
    }

    if (hasNonWS(value) || isInvalidHexLiteral(value)) {
      return NAN;
    }

    var trimmed = trim(value);
    if (trimmed !== value) {
      return toNumber(trimmed);
    }
  }

  return castNumber(value);
};

},{"cached-constructors-x":35,"nan-x":307,"parse-int-x":20,"to-primitive-x":345,"trim-x":353}],24:[function(require,module,exports){
/**
 * @file Cross-browser array slicer.
 * @version 3.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-slice-x
 */

'use strict';

var toObject = require('to-object-x');
var isArguments = require('is-arguments');
var isArray = require('is-array-x');
var arrayLikeSlice = require('array-like-slice-x');
var nativeSlice = require('cached-constructors-x').Array.prototype.slice;
var isString;
var failArr;
var failDOM;
if (nativeSlice) {
  var attempt = require('attempt-x');
  var res = attempt.call([
    1,
    2,
    3
  ], nativeSlice, 1, 2);

  failArr = res.threw || isArray(res.value) === false || res.value.length !== 1 || res.value[0] !== 2;
  if (failArr === false) {
    res = attempt.call('abc', nativeSlice, 1, 2);
    isString = (res.threw || res.value.length !== 1 || res.value[0] !== 'b') && require('is-string');
    var doc = typeof document !== 'undefined' && document;
    failDOM = doc && attempt.call(doc.documentElement, nativeSlice).threw;
  }
} else {
  failArr = true;
}

/**
 * The slice() method returns a shallow copy of a portion of an array into a new
 * array object selected from begin to end (end not included). The original
 * array will not be modified.
 *
 * @param {Array|Object} array - The array to slice.
 * @param {number} [start] - Zero-based index at which to begin extraction.
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(-2) extracts the last two elements in the sequence.
 *  If begin is undefined, slice begins from index 0.
 * @param {number} [end] - Zero-based index before which to end extraction.
 *  Slice extracts up to but not including end. For example, slice(1,4)
 *  extracts the second element through the fourth element (elements indexed
 *  1, 2, and 3).
 *  A negative index can be used, indicating an offset from the end of the
 *  sequence. slice(2,-1) extracts the third element through the second-to-last
 *  element in the sequence.
 *  If end is omitted, slice extracts through the end of the
 *  sequence (arr.length).
 *  If end is greater than the length of the sequence, slice extracts through
 *  the end of the sequence (arr.length).
 * @returns {Array} A new array containing the extracted elements.
 * @example
 * var slice = require('array-slice-x');
 * var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
 * var citrus = slice(fruits, 1, 3);
 *
 * // fruits contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
 * // citrus contains ['Orange','Lemon']
 */
module.exports = function slice(array, start, end) {
  var object = toObject(array);
  if (failArr || (failDOM && isArray(object) === false) || (isString && isString(object)) || isArguments(object)) {
    return arrayLikeSlice(object, start, end);
  }

  return nativeSlice.apply(object, arrayLikeSlice(arguments, 1));
};

},{"array-like-slice-x":14,"attempt-x":32,"cached-constructors-x":35,"is-arguments":98,"is-array-x":101,"is-string":134,"to-object-x":344}],25:[function(require,module,exports){
/**
 * @file Tests whether some element passes the provided function.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-some-x
 */

'use strict';

var toObject = require('to-object-x');
var assertIsFunction = require('assert-is-function-x');

var tests = {
  // Check node 0.6.21 bug where third parameter is not boxed
  properlyBoxesNonStrict: true,
  properlyBoxesStrict: true
};

var nativeSome = Array.prototype.some;
if (nativeSome) {
  try {
    nativeSome.call([1], function () {
      // eslint-disable-next-line no-invalid-this
      tests.properlyBoxesStrict = typeof this === 'string';
    }, 'x');

    var fn = [
      'return nativeSome.call("foo", function (_, __, context) {',
      'if (Boolean(context) === false || typeof context !== "object") {',
      'tests.properlyBoxesNonStrict = false;}});'
    ].join('');

    // eslint-disable-next-line no-new-func
    Function('nativeSome', 'tests', fn)(nativeSome, tests);
  } catch (e) {
    nativeSome = null;
  }
}

var $some;
if (nativeSome && tests.properlyBoxesNonStrict && tests.properlyBoxesStrict) {
  $some = function some(array, callBack /* , thisArg */) {
    var object = toObject(array);
    var args = [assertIsFunction(callBack)];
    if (arguments.length > 2) {
      args.push(arguments[2]);
    }

    return nativeSome.apply(object, args);
  };
} else {
  // ES5 15.4.4.17
  // http://es5.github.com/#x15.4.4.17
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
  var isString = require('is-string');
  var toLength = require('to-length-x');
  var isUndefined = require('validate.io-undefined');
  var splitString = require('has-boxed-string-x') === false;
  $some = function some(array, callBack /* , thisArg */) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitString && isString(object) ? object.split('') : object;
    var length = toLength(iterable.length);
    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    for (var i = 0; i < length; i += 1) {
      if (i in iterable) {
        var result;
        if (isUndefined(thisArg)) {
          result = callBack(iterable[i], i, object);
        } else {
          result = callBack.call(thisArg, iterable[i], i, object);
        }

        if (result) {
          return true;
        }
      }
    }

    return false;
  };
}

/**
 * This method tests whether some element in the array passes the test
 * implemented by the provided function.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to test for each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {boolean} `true` if the callback function returns a truthy value for
 *  any array element; otherwise, `false`.
 * @example
 * var some = require('array-some-x');
 *
 * function isBiggerThan10(element, index, array) {
 *   return element > 10;
 * }
 *
 * some([2, 5, 8, 1, 4], isBiggerThan10);  // false
 * some([12, 5, 8, 1, 4], isBiggerThan10); // true
 */
module.exports = $some;

},{"assert-is-function-x":30,"has-boxed-string-x":69,"is-string":134,"to-length-x":29,"to-object-x":344,"validate.io-undefined":356}],26:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"is-nan":118,"max-safe-integer":300}],27:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11,"is-nan":118}],28:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12,"is-finite-x":26,"is-nan":118,"math-sign-x":27}],29:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"max-safe-integer":300,"to-integer-x":28}],30:[function(require,module,exports){
/**
 * @file If isFunction(callbackfn) is false, throw a TypeError exception.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-function-x
 */

'use strict';

var isFunction = require('is-function-x');
var safeToString = require('safe-to-string-x');
var isPrimitive = require('is-primitive');

/**
 * Tests `callback` to see if it is a function, throws a `TypeError` if it is
 * not. Otherwise returns the `callback`.
 *
 * @param {*} callback - The argument to be tested.
 * @throws {TypeError} Throws if `callback` is not a function.
 * @returns {*} Returns `callback` if it is function.
 * @example
 * var assertIsFunction = require('assert-is-function-x');
 * var primitive = true;
 * var mySymbol = Symbol('mySymbol');
 * var symObj = Object(mySymbol);
 * var object = {};
 * function fn () {}
 *
 * assertIsFunction(primitive);
 *    // TypeError 'true is not a function'.
 * assertIsFunction(object);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(mySymbol);
 *    // TypeError 'Symbol(mySymbol) is not a function'.
 * assertIsFunction(symObj);
 *    // TypeError '#<Object> is not a function'.
 * assertIsFunction(fn);
 *    // Returns fn.
 */
module.exports = function assertIsFunction(callback) {
  if (isFunction(callback) === false) {
    var msg = isPrimitive(callback) ? safeToString(callback) : '#<Object>';
    throw new TypeError(msg + ' is not a function');
  }
  return callback;
};

},{"is-function-x":110,"is-primitive":126,"safe-to-string-x":331}],31:[function(require,module,exports){
/**
 * @file If IsObject(value) is false, throw a TypeError exception.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-object-x
 */

'use strict';

var safeToString = require('safe-to-string-x');
var isPrimitive = require('is-primitive');

/**
   * Tests `value` to see if it is an object, throws a `TypeError` if it is
   * not. Otherwise returns the `value`.
   *
   * @param {*} value - The argument to be tested.
   * @throws {TypeError} Throws if `value` is not an object.
   * @returns {*} Returns `value` if it is an object.
   * @example
   * var assertIsObject = require('assert-is-object-x');
   * var primitive = true;
   * var mySymbol = Symbol('mySymbol');
   * var symObj = Object(mySymbol);
   * var object = {};
   * function fn () {}
   *
   * assertIsObject(primitive); // TypeError 'true is not an object'
   * assertIsObject(mySymbol); // TypeError 'Symbol(mySymbol) is not an object'
   * assertIsObject(symObj); // Returns symObj.
   * assertIsObject(object); // Returns object.
   * assertIsObject(fn); // Returns fn.
   */
module.exports = function assertIsObject(value) {
  if (isPrimitive(value)) {
    throw new TypeError(safeToString(value) + ' is not an object');
  }
  return value;
};

},{"is-primitive":126,"safe-to-string-x":331}],32:[function(require,module,exports){
/**
 * @file Invokes function, returning an object of the results.
 * @version 1.1.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module attempt-x
 */

'use strict';

var getArgs = function _getArgs(args) {
  var length = args.length >>> 0;
  var array = [];
  var argLength = length - 1;
  if (argLength < 1) {
    return array;
  }

  array.length = argLength;
  for (var index = 1; index < length; index += 1) {
    array[index - 1] = args[index];
  }

  return array;
};

/**
 * This method attempts to invoke the function, returning either the result or
 * the caught error object. Any additional arguments are provided to the
 * function when it's invoked.
 *
 * @param {Function} fn - The function to attempt.
 * @param {...*} [args] - The arguments to invoke the function with.
 * @returns {Object} Returns an object of the result.
 * @example
 * var attempt = require('attempt-x');
 *
 * function thrower() {
 *   throw new Error('Threw');
 * }
 *
 * attempt(thrower, 1, 2);
 * // {
 * //   threw: true,
 * //   value: // Error('Threw') object
 * // }
 *
 * function sumArgs(a, b) {
 *   return a + b;
 * }
 *
 * attempt(sumArgs, 1, 2);
 * // {
 * //   threw: false,
 * //   value: 3
 * // }
 *
 * var thisArg = [];
 * function pusher(a, b) {
 *   return this.push(a, b);
 * }
 *
 * attempt.call(thisArg, pusher, 1, 2);
 * // {
 * //   threw: false,
 * //   value: 2
 * // }
 * // thisArg => [1, 2];
 */
module.exports = function attempt(fn) {
  try {
    return {
      threw: false,
      value: fn.apply(this, getArgs(arguments))
    };
  } catch (e) {
    return {
      threw: true,
      value: e
    };
  }
};

},{}],33:[function(require,module,exports){
/**
* @file A big counter.
* @version 2.0.1
* @author Xotic750 <Xotic750@gmail.com>
* @copyright  Xotic750
* @license {@link <https://opensource.org/licenses/MIT> MIT}
* @module big-counter-x
*/

'use strict';

var defineProperties = require('object-define-properties-x');

/**
 * Serialise the counter´s current value.
 *
 * @private
 * @this BigCounter
 * @return {string} A string representation of an integer.
 */
var counterToString = function ToString() {
  return this.count.slice().reverse().join('');
};

/**
 * The BigCounter class.
 *
 * @private
 * @class
 */
var BigC = function BigCounter() {
  if (Boolean(this) === false || (this instanceof BigC) === false) {
    return new BigC();
  }

  defineProperties(this, {
    count: {
      value: [0]
    }
  });
};

defineProperties(BigC.prototype, {
  /**
   * Gets the counter´s current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  get: {
    value: counterToString
  },
  /**
   * Increments the counter´s value by `1`.
   *
   * @function
   * @returns {Object} The counter object.
   */
  next: {
    value: function next() {
      var clone = this.count.slice();
      this.count.length = 0;
      var length = clone.length;
      var howMany = Math.max(length, 1);
      var carry = 0;
      var index = 0;
      while (index < howMany || carry) {
        var zi = carry + (index < length ? clone[index] : 0) + (index === 0 ? 1 : 0);
        this.count.push(zi % 10);
        carry = Math.floor(zi / 10);
        index += 1;
      }

      return this;
    }
  },
  /**
   * Resets the counter back to `0`.
   *
   * @function
   * @returns {Object} The counter object.
   */
  reset: {
    value: function reset() {
      this.count.length = 0;
      this.count.push(0);
      return this;
    }
  },
  /**
   * Gets the counter´s current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  toJSON: {
    value: counterToString
  },
  /**
   * Gets the counter´s current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  toString: {
    value: counterToString
  },
  /**
   * Gets the counter´s current value.
   *
   * @function
   * @returns {string} A string representation of an integer.
   */
  valueOf: {
    value: counterToString
  }
});

/**
 * Incremental integer counter. Counts from `0` to very big intergers.
 * Javascript´s number type allows you to count in integer steps
 * from `0` to `9007199254740991`. As of ES5, Strings can contain
 * approximately 65000 characters and ES6 is supposed to handle
 * the `MAX_SAFE_INTEGER` (though I don´t believe any environments supports
 * this). This counter represents integer values as strings and can therefore
 * count in integer steps from `0` to the maximum string length (that´s some
 * 65000 digits). In the lower range, upto `9007199254740991`, the strings can
 * be converted to safe Javascript integers `Number(value)` or `+value`. This
 * counter is great for any applications that need a really big count
 * represented as a string, (an ID string).
 *
 * @class
 * @example
 * var BigCounter = require('big-counter-x');
 * var counter = new BigCounter();
 *
 * counter.get(); // '0'
 * counter.next(); // counter object
 * counter.get(); // '1'
 *
 * // Methods are chainable.
 * counter.next().next(); // counter object
 * counter.get(); // '3'
 *
 * counter.reset(); // counter object
 * counter.get(); // '0'
 * counter.toString(); // '0'
 * counter.valueOf(); // '0'
 * counter.toJSON(); // '0'
 *
 * // Values upto `9007199254740991` convert to numbers.
 * Number(counter); // 0
 * +counter; // 0
 */
module.exports = BigC;

},{"object-define-properties-x":317}],34:[function(require,module,exports){
'use strict';

var boolean = function boolean(value) {
  if (typeof value === 'string') {
    return (/^(true|t|yes|y|1)$/i.test(value.trim())
    );
  }

  if (typeof value === 'number') {
    return value !== 0;
  }

  if (typeof value === 'boolean') {
    return value;
  }

  return false;
};

module.exports = boolean;
},{}],35:[function(require,module,exports){
/**
 * @file Constructors cached from literals.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module cached-constructors-x
 */

'use strict';

/**
 * Constructors cached from literals.
 *
 * @type Object
 * @example
 * var constructors = require('cached-constructors-x');
 */
module.exports = {
  Array: [].constructor,
  Boolean: true.constructor,
  Function: function () {}.constructor,
  Number: (0).constructor,
  Object: {}.constructor,
  RegExp: (/(?:)/).constructor,
  String: ''.constructor
};

},{}],36:[function(require,module,exports){
/**
 * @file Calculates a fromIndex of a given value for an array.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module calculate-from-index-x
 */

'use strict';

var toObject = require('to-object-x');
var toLength = require('to-length-x');
var toInteger = require('to-integer-x');
var isArrayLike = require('is-array-like-x');

var $calcFromIndex = function calcFromIndex(array, fromIndex) {
  var object = toObject(array);
  if (isArrayLike(object) === false) {
    return 0;
  }

  var length = toLength(object.length);
  var index = toInteger(fromIndex);
  return index >= 0 ? index : Math.max(0, length + index);
};

/**
 * This method calculates a fromIndex of a given value for an array.
 *
 * @param {array} array The array on which to calculate the starting index.
 * @throws {TypeError} If array is null or undefined.
 * @param {number} fromIndex The position in this array at which to begin. A
 *  negative value gives the index of array.length + fromIndex by asc.
 * @return {number} The calculated fromIndex. Default is 0.
 * @example
 * var calcFromIndex = require('calculate-from-index-x');
 *
 * calcFromIndex([1, 2, 3], 1); // 1
 * calcFromIndex([1, 2, 3], Infinity); // Infinity
 * calcFromIndex([1, 2, 3], -Infinity); // 0
 * calcFromIndex([1, 2, 3], -1); // 2
 */
module.exports = $calcFromIndex;

},{"is-array-like-x":100,"to-integer-x":39,"to-length-x":40,"to-object-x":344}],37:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"is-nan":118,"max-safe-integer":300}],38:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11,"is-nan":118}],39:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12,"is-finite-x":37,"is-nan":118,"math-sign-x":38}],40:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"max-safe-integer":300,"to-integer-x":39}],41:[function(require,module,exports){
/**
 * @file ES6 collections fallback library: Map and Set.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module collections-x
 */

'use strict';

var hasOwn = require('has-own-property-x');
var isFunction = require('is-function-x');
var defineProperty = require('object-define-property-x');
var defineProperties = require('object-define-properties-x');
var isString = require('is-string');
var isArrayLike = require('is-array-like-x');
var isPrimitive = require('is-primitive');
var isSurrogatePair = require('is-surrogate-pair-x');
var indexOf = require('index-of-x');
var assertIsFunction = require('assert-is-function-x');
var assertIsObject = require('assert-is-object-x');
var IdGenerator = require('big-counter-x');
var isNil = require('is-nil-x');
var isMap = require('is-map-x');
var isSet = require('is-set-x');
var isObjectLike = require('is-object-like-x');
var isArray = require('is-array-x');
var isBoolean = require('is-boolean-object');
var isUndefined = require('validate.io-undefined');
var some = require('array-some-x');
var getPrototypeOf = require('get-prototype-of-x');
var hasSymbolSupport = require('has-symbol-support-x');
var hasRealSymbolIterator = hasSymbolSupport && typeof Symbol.iterator === 'symbol';
var hasFakeSymbolIterator = typeof Symbol === 'object' && typeof Symbol.iterator === 'string';
var symIt;

if (hasRealSymbolIterator || hasFakeSymbolIterator) {
  symIt = Symbol.iterator;
} else if (isFunction(Array.prototype['_es6-shim iterator_'])) {
  symIt = '_es6-shim iterator_';
} else {
  symIt = '@@iterator';
}

var isNumberType = function _isNumberType(value) {
  return typeof value === 'number';
};

/**
 * Detect an interator function.
 *
 * @private
 * @param {*} iterable - Value to detect iterator function.
 * @returns {Symbol|string|undefined} The iterator property identifier.
 */
var getSymbolIterator = function _getSymbolIterator(iterable) {
  if (isNil(iterable) === false) {
    if ((hasRealSymbolIterator || hasFakeSymbolIterator) && iterable[symIt]) {
      return symIt;
    }

    if (iterable['_es6-shim iterator_']) {
      return '_es6-shim iterator_';
    }

    if (iterable['@@iterator']) {
      return '@@iterator';
    }
  }

  return void 0;
};

/**
 * If an iterable object is passed, all of its elements will be added to the
 * new Map/Set, null is treated as undefined.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {*} iterable - Value to parsed.
 */
// eslint-disable-next-line complexity
var parseIterable = function _parseIterable(kind, context, iterable) {
  var symbolIterator = getSymbolIterator(iterable);
  if (kind === 'map') {
    defineProperty(context, '[[value]]', {
      value: []
    });
  }

  defineProperties(context, {
    '[[changed]]': {
      value: false
    },
    '[[id]]': {
      value: new IdGenerator()
    },
    '[[key]]': {
      value: []
    },
    '[[order]]': {
      value: []
    }
  });

  var next;
  var key;
  var indexof;
  if (iterable && isFunction(iterable[symbolIterator])) {
    var iterator = iterable[symbolIterator]();
    next = iterator.next();
    if (kind === 'map') {
      if (isArrayLike(next.value) === false || next.value.length < 2) {
        throw new TypeError(
          'Iterator value ' + isArrayLike(next.value) + ' is not an entry object'
        );
      }
    }

    while (next.done === false) {
      key = kind === 'map' ? next.value[0] : next.value;
      indexof = indexOf(
        assertIsObject(context)['[[key]]'],
        key,
        'SameValueZero'
      );

      if (indexof < 0) {
        if (kind === 'map') {
          context['[[value]]'].push(next.value[1]);
        }

        context['[[key]]'].push(key);
        context['[[order]]'].push(context['[[id]]'].get());
        context['[[id]]'].next();
      } else if (kind === 'map') {
        context['[[value]]'][indexof] = next.value[1];
      }

      next = iterator.next();
    }
  }

  if (isString(iterable)) {
    if (kind === 'map') {
      throw new TypeError(
        'Iterator value ' + iterable.charAt(0) + ' is not an entry object'
      );
    }

    next = 0;
    while (next < iterable.length) {
      var char1 = iterable.charAt(next);
      var char2 = iterable.charAt(next + 1);
      if (isSurrogatePair(char1, char2)) {
        key = char1 + char2;
        next += 1;
      } else {
        key = char1;
      }

      indexof = indexOf(
        assertIsObject(context)['[[key]]'],
        key,
        'SameValueZero'
      );

      if (indexof < 0) {
        context['[[key]]'].push(key);
        context['[[order]]'].push(context['[[id]]'].get());
        context['[[id]]'].next();
      }

      next += 1;
    }
  } else if (isArrayLike(iterable)) {
    next = 0;
    while (next < iterable.length) {
      if (kind === 'map') {
        if (isPrimitive(iterable[next])) {
          throw new TypeError(
            'Iterator value ' + isArrayLike(next.value) + ' is not an entry object'
          );
        }

        key = iterable[next][0];
      } else {
        key = iterable[next];
      }

      key = kind === 'map' ? iterable[next][0] : iterable[next];
      indexof = indexOf(
        assertIsObject(context)['[[key]]'],
        key,
        'SameValueZero'
      );

      if (indexof < 0) {
        if (kind === 'map') {
          context['[[value]]'].push(iterable[next][1]);
        }

        context['[[key]]'].push(key);
        context['[[order]]'].push(context['[[id]]'].get());
        context['[[id]]'].next();
      } else if (kind === 'map') {
        context['[[value]]'][indexof] = iterable[next][1];
      }

      next += 1;
    }
  }

  defineProperty(context, 'size', {
    value: context['[[key]]'].length,
    writable: true
  });
};

/**
 * The base forEach method executes a provided function once per each value
 * in the Map/Set object, in insertion order.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {Function} callback - Function to execute for each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @returns {Object} The Map/Set object.
 */
// eslint-disable-next-line max-params
var baseForEach = function _baseForEach(kind, context, callback, thisArg) {
  assertIsObject(context);
  assertIsFunction(callback);
  var pointers = {
    index: 0,
    order: context['[[order]]'][0]
  };

  context['[[change]]'] = false;
  var length = context['[[key]]'].length;
  while (pointers.index < length) {
    if (hasOwn(context['[[key]]'], pointers.index)) {
      var key = context['[[key]]'][pointers.index];
      var value = kind === 'map' ? context['[[value]]'][pointers.index] : key;
      callback.call(thisArg, value, key, context);
    }

    if (context['[[change]]']) {
      length = context['[[key]]'].length;
      some(context['[[order]]'], function _some1(id, count) {
        pointers.index = count;
        return id > pointers.order;
      });

      context['[[change]]'] = false;
    } else {
      pointers.index += 1;
    }

    pointers.order = context['[[order]]'][pointers.index];
  }

  return context;
};

/**
 * The base has method returns a boolean indicating whether an element with
 * the specified key/value exists in a Map/Set object or not.
 *
 * @private
 * @param {*} key - The key/value to test for presence in the Map/Set object.
 * @returns {boolean} Returns true if an element with the specified key/value
 *  exists in the Map/Set object; otherwise false.
 */
var baseHas = function has(key) {
  // eslint-disable-next-line no-invalid-this
  return indexOf(assertIsObject(this)['[[key]]'], key, 'SameValueZero') > -1;
};

/**
 * The base clear method removes all elements from a Map/Set object.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @returns {Object} The Map/Set object.
 */
var baseClear = function _baseClear(kind, context) {
  assertIsObject(context);
  context['[[id]]'].reset();
  context['[[change]]'] = true;
  context.size = 0;
  context['[[order]]'].length = 0;
  context['[[key]]'].length = 0;
  if (kind === 'map') {
    context['[[value]]'].length = 0;
  }

  return context;
};

/**
 * The base delete method removes the specified element from a Map/Set object.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {*} key - The key/value of the element to remove from Map/Set object.
 * @returns {Object} The Map/Set object.
 */
var baseDelete = function _baseDelete(kind, context, key) {
  var indexof = indexOf(
    assertIsObject(context)['[[key]]'],
    key,
    'SameValueZero'
  );

  var result = false;
  if (indexof > -1) {
    if (kind === 'map') {
      context['[[value]]'].splice(indexof, 1);
    }

    context['[[key]]'].splice(indexof, 1);
    context['[[order]]'].splice(indexof, 1);
    context['[[change]]'] = true;
    context.size = context['[[key]]'].length;
    result = true;
  }

  return result;
};

/**
 * The base set and add method.
 *
 * @private
 * @param {string} kind - Either 'map' or 'set'.
 * @param {Object} context - The Map/Set object.
 * @param {*} key - The key or value of the element to add/set on the object.
 * @param {*} value - The value of the element to add to the Map object.
 * @returns {Object} The Map/Set object.
 */
// eslint-disable-next-line max-params
var baseAddSet = function _baseAddSet(kind, context, key, value) {
  var index = indexOf(
    assertIsObject(context)['[[key]]'],
    key,
    'SameValueZero'
  );

  if (index > -1) {
    if (kind === 'map') {
      context['[[value]]'][index] = value;
    }
  } else {
    if (kind === 'map') {
      context['[[value]]'].push(value);
    }

    context['[[key]]'].push(key);
    context['[[order]]'].push(context['[[id]]'].get());
    context['[[id]]'].next();
    context['[[change]]'] = true;
    context.size = context['[[key]]'].length;
  }

  return context;
};

/**
 * An object is an iterator when it knows how to access items from a
 * collection one at a time, while keeping track of its current position
 * within that sequence. In JavaScript an iterator is an object that provides
 * a next() method which returns the next item in the sequence. This method
 * returns an object with two properties: done and value. Once created,
 * an iterator object can be used explicitly by repeatedly calling next().
 *
 * @private
 * @class
 * @param {Object} context - The Set object.
 * @param {string} iteratorKind - Values are `value`, `key` or `key+value`.
 */
var SetIt = function SetIterator(context, iteratorKind) {
  defineProperties(this, {
    '[[IteratorHasMore]]': {
      value: true,
      writable: true
    },
    '[[Set]]': {
      value: assertIsObject(context)
    },
    '[[SetIterationKind]]': {
      value: iteratorKind || 'value'
    },
    '[[SetNextIndex]]': {
      value: 0,
      writable: true
    }
  });
};

/**
 * Once initialized, the next() method can be called to access key-value
 * pairs from the object in turn.
 *
 * @private
 * @function next
 * @returns {Object} Returns an object with two properties: done and value.
 */
defineProperty(SetIt.prototype, 'next', {
  value: function next() {
    var context = assertIsObject(this['[[Set]]']);
    var index = this['[[SetNextIndex]]'];
    var iteratorKind = this['[[SetIterationKind]]'];
    var more = this['[[IteratorHasMore]]'];
    var object;
    if (index < context['[[key]]'].length && more) {
      object = { done: false };
      if (iteratorKind === 'key+value') {
        object.value = [context['[[key]]'][index], context['[[key]]'][index]];
      } else {
        object.value = context['[[key]]'][index];
      }

      this['[[SetNextIndex]]'] += 1;
    } else {
      this['[[IteratorHasMore]]'] = false;
      object = {
        done: true,
        value: void 0
      };
    }

    return object;
  }
});

/**
 * The @@iterator property is the same Iterator object.
 *
 * @private
 * @function symIt
 * @memberof SetIterator.prototype
 * @returns {Object} This Iterator object.
 */
defineProperty(SetIt.prototype, symIt, {
  value: function iterator() {
    return this;
  }
});

/**
 * This method returns a new Iterator object that contains the
 * values for each element in the Set object in insertion order.
 *
 * @private
 * @this Set
 * @returns {Object} A new Iterator object.
 */
var setValuesIterator = function values() {
  return new SetIt(this);
};

/**
 * The Set object lets you store unique values of any type, whether primitive
 * values or object references.
 *
 * @class Set
 * @private
 * @param {*} [iterable] - If an iterable object is passed, all of its elements
 * will be added to the new Set. null is treated as undefined.
 * @example
 * var mySet = new Set();
 *
 * mySet.add(1);
 * mySet.add(5);
 * mySet.add("some text");
 * var o = {a: 1, b: 2};
 * mySet.add(o);
 *
 * mySet.has(1); // true
 * mySet.has(3); // false, 3 has not been added to the set
 * mySet.has(5);              // true
 * mySet.has(Math.sqrt(25));  // true
 * mySet.has("Some Text".toLowerCase()); // true
 * mySet.has(o); // true
 *
 * mySet.size; // 4
 *
 * mySet.delete(5); // removes 5 from the set
 * mySet.has(5);    // false, 5 has been removed
 *
 * mySet.size; // 3, we just removed one value
 *
 * // Relation with Array objects
 *
 * var myArray = ["value1", "value2", "value3"];
 *
 * // Use the regular Set constructor to transform an Array into a Set
 * var mySet = new Set(myArray);
 *
 * mySet.has("value1"); // returns true
 *
 * // Use the spread operator to transform a set into an Array.
 * console.log(uneval([...mySet])); // Will show you exactly the same Array
 *                                  // as myArray
 */
var SetObject = function Set() {
  if (Boolean(this) === false || (this instanceof SetObject) === false) {
    throw new TypeError('Constructor Set requires \'new\'');
  }

  parseIterable('set', this, arguments.length ? arguments[0] : void 0);
};

defineProperties(SetObject.prototype, /** @lends module:collections-x.Set.prototype */ {
  /**
   * The add() method appends a new element with a specified value to the end
   * of a Set object.
   *
   * @param {*} value - Required. The value of the element to add to the Set
   *  object.
   * @returns {Object} The Set object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   *
   * mySet.add(1);
   * mySet.add(5).add("some text"); // chainable
   *
   * console.log(mySet);
   * // Set [1, 5, "some text"]
   */
  add: {
    value: function add(value) {
      return baseAddSet('set', this, value);
    }
  },
  /**
   * The clear() method removes all elements from a Set object.
   *
   * @returns {Object} The Set object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add(1);
   * mySet.add("foo");
   *
   * mySet.size;       // 2
   * mySet.has("foo"); // true
   *
   * mySet.clear();
   *
   * mySet.size;       // 0
   * mySet.has("bar")  // false
   */
  clear: {
    value: function clear() {
      return baseClear('set', this);
    }
  },
  /**
   * The delete() method removes the specified element from a Set object.
   *
   * @param {*} value - The value of the element to remove from the Set object.
   * @returns {boolean} Returns true if an element in the Set object has been
   *  removed successfully; otherwise false.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foo");
   *
   * mySet.delete("bar"); // Returns false. No "bar" element found
   *                      //to be deleted.
   * mySet.delete("foo"); // Returns true.  Successfully removed.
   *
   * mySet.has("foo");    // Returns false. The "foo" element is no
   *                      //longer present.
   */
  'delete': {
    value: function de1ete(value) {
      return baseDelete('set', this, value);
    }
  },
  /**
   * The entries() method returns a new Iterator object that contains an
   * array of [value, value] for each element in the Set object, in
   * insertion order. For Set objects there is no key like in Map objects.
   * However, to keep the API similar to the Map object, each entry has the
   * same value for its key and value here, so that an array [value, value]
   * is returned.
   *
   * @function
   * @returns {Object} A new Iterator object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foobar");
   * mySet.add(1);
   * mySet.add("baz");
   *
   * var setIter = mySet.entries();
   *
   * console.log(setIter.next().value); // ["foobar", "foobar"]
   * console.log(setIter.next().value); // [1, 1]
   * console.log(setIter.next().value); // ["baz", "baz"]
   */
  entries: {
    value: function entries() {
      return new SetIt(this, 'key+value');
    }
  },
  /**
   * The forEach() method executes a provided function once per each value
   * in the Set object, in insertion order.
   *
   * @param {Function} callback - Function to execute for each element.
   * @param {*} [thisArg] - Value to use as this when executing callback.
   * @returns {Object} The Set object.
   * @example
   * function logSetElements(value1, value2, set) {
   *     console.log("s[" + value1 + "] = " + value2);
   * }
   *
   * new Set(["foo", "bar", undefined]).forEach(logSetElements);
   *
   * // logs:
   * // "s[foo] = foo"
   * // "s[bar] = bar"
   * // "s[undefined] = undefined"
   */
  forEach: {
    value: function forEach(callback, thisArg) {
      return baseForEach('set', this, callback, thisArg);
    }
  },
  /**
   * The has() method returns a boolean indicating whether an element with the
   * specified value exists in a Set object or not.
   *
   * @function
   * @param {*} value - The value to test for presence in the Set object.
   * @returns {boolean} Returns true if an element with the specified value
   *  exists in the Set object; otherwise false.
   * @example
   * var Set = require('collections-x').Set;
   * var mySet = new Set();
   * mySet.add("foo");
   *
   * mySet.has("foo");  // returns true
   * mySet.has("bar");  // returns false
   */
  has: {
    value: baseHas
  },
  /**
   * The keys() method is an alias for the `values` method (for similarity
   * with Map objects); it behaves exactly the same and returns values of
   * Set elements.
   *
   * @function
   * @returns {Object} A new Iterator object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foo");
   * mySet.add("bar");
   * mySet.add("baz");
   *
   * var setIter = mySet.keys();
   *
   * console.log(setIter.next().value); // "foo"
   * console.log(setIter.next().value); // "bar"
   * console.log(setIter.next().value); // "baz"
   */
  keys: {
    value: setValuesIterator
  },
  /**
   * The value of size is an integer representing how many entries the Set
   * object has.
   *
   * @name size
   * @memberof module:collections-x.Set
   * @instance
   * @type {number}
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add(1);
   * mySet.add(5);
   * mySet.add("some text");
   *
   * mySet.size; // 3
   */
  size: {
    value: 0,
    writable: true
  },
  /**
   * The values() method returns a new Iterator object that contains the
   * values for each element in the Set object in insertion order.
   *
   * @function
   * @returns {Object} A new Iterator object.
   * @example
   * var Set = require('collections-x').Set
   * var mySet = new Set();
   * mySet.add("foo");
   * mySet.add("bar");
   * mySet.add("baz");
   *
   * var setIter = mySet.values();
   *
   * console.log(setIter.next().value); // "foo"
   * console.log(setIter.next().value); // "bar"
   * console.log(setIter.next().value); // "baz"
   */
  values: {
    value: setValuesIterator
  }
});

/**
 * The initial value of the @@iterator property is the same function object
 * as the initial value of the values property.
 *
 * @function symIt
 * @memberof module:collections-x.Set.prototype
 * @returns {Object} A new Iterator object.
 * @example
 * var Set = require('collections-x').Set,
 * var symIt = var Set = require('collections-x').symIt;
 * var mySet = new Set();
 * mySet.add("0");
 * mySet.add(1);
 * mySet.add({});
 *
 * var setIter = mySet[symIt]();
 *
 * console.log(setIter.next().value); // "0"
 * console.log(setIter.next().value); // 1
 * console.log(setIter.next().value); // Object
 */
defineProperty(SetObject.prototype, symIt, {
  value: setValuesIterator
});

/**
 * An object is an iterator when it knows how to access items from a
 * collection one at a time, while keeping track of its current position
 * within that sequence. In JavaScript an iterator is an object that provides
 * a next() method which returns the next item in the sequence. This method
 * returns an object with two properties: done and value. Once created,
 * an iterator object can be used explicitly by repeatedly calling next().
 *
 * @private
 * @class
 * @param {Object} context - The Map object.
 * @param {string} iteratorKind - Values are `value`, `key` or `key+value`.
 */
var MapIt = function MapIterator(context, iteratorKind) {
  defineProperties(this, {
    '[[IteratorHasMore]]': {
      value: true,
      writable: true
    },
    '[[Map]]': {
      value: assertIsObject(context)
    },
    '[[MapIterationKind]]': {
      value: iteratorKind
    },
    '[[MapNextIndex]]': {
      value: 0,
      writable: true
    }
  });
};

/**
 * Once initialized, the next() method can be called to access key-value
 * pairs from the object in turn.
 *
 * @private
 * @function next
 * @returns {Object} Returns an object with two properties: done and value.
 */
defineProperty(MapIt.prototype, 'next', {
  value: function next() {
    var context = assertIsObject(this['[[Map]]']);
    var index = this['[[MapNextIndex]]'];
    var iteratorKind = this['[[MapIterationKind]]'];
    var more = this['[[IteratorHasMore]]'];
    var object;
    assertIsObject(context);
    if (index < context['[[key]]'].length && more) {
      object = { done: false };
      if (iteratorKind === 'key+value') {
        object.value = [context['[[key]]'][index], context['[[value]]'][index]];
      } else {
        object.value = context['[[' + iteratorKind + ']]'][index];
      }

      this['[[MapNextIndex]]'] += 1;
    } else {
      this['[[IteratorHasMore]]'] = false;
      object = {
        done: true,
        value: void 0
      };
    }

    return object;
  }
});

/**
 * The @@iterator property is the same Iterator object.
 *
 * @private
 * @function symIt
 * @memberof MapIterator.prototype
 * @returns {Object} This Iterator object.
 */
defineProperty(MapIt.prototype, symIt, {
  value: function iterator() {
    return this;
  }
});

/**
 * The Map object is a simple key/value map. Any value (both objects and
 * primitive values) may be used as either a key or a value.
 *
 * @class Map
 * @private
 * @param {*} [iterable] - Iterable is an Array or other iterable object whose
 *  elements are key-value pairs (2-element Arrays). Each key-value pair is
 *  added to the new Map. null is treated as undefined.
 * @example
 * var Map = require('collections-x').Map;
 * var myMap = new Map();
 *
 * var keyString = "a string",
 *     keyObj = {},
 *     keyFunc = function () {};
 *
 * // setting the values
 * myMap.set(keyString, "value associated with 'a string'");
 * myMap.set(keyObj, "value associated with keyObj");
 * myMap.set(keyFunc, "value associated with keyFunc");
 *
 * myMap.size; // 3
 *
 * // getting the values
 * myMap.get(keyString);    // "value associated with 'a string'"
 * myMap.get(keyObj);       // "value associated with keyObj"
 * myMap.get(keyFunc);      // "value associated with keyFunc"
 *
 * myMap.get("a string");   // "value associated with 'a string'"
 *                          // because keyString === 'a string'
 * myMap.get({});           // undefined, because keyObj !== {}
 * myMap.get(function() {}) // undefined, because keyFunc !== function () {}
 *
 * // Using NaN as Map keys
 * var myMap = new Map();
 * myMap.set(NaN, "not a number");
 *
 * myMap.get(NaN); // "not a number"
 *
 * var otherNaN = Number("foo");
 * myMap.get(otherNaN); // "not a number"
 *
 * // Relation with Array objects
 * var kvArray = [["key1", "value1"], ["key2", "value2"]];
 *
 * // Use the regular Map constructor to transform a
 * // 2D key-value Array into a map
 * var myMap = new Map(kvArray);
 *
 * myMap.get("key1"); // returns "value1"
 */
var MapObject = function Map() {
  if (Boolean(this) === false || (this instanceof MapObject) === false) {
    throw new TypeError('Constructor Map requires \'new\'');
  }

  parseIterable('map', this, arguments.length ? arguments[0] : void 0);
};

defineProperties(MapObject.prototype, /** @lends module:collections-x.Map.prototype */ {
  /**
   * The clear() method removes all elements from a Map object.
   *
   * @returns {Object} The Map object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "baz");
   * myMap.set(1, "foo");
   *
   * myMap.size;       // 2
   * myMap.has("bar"); // true
   *
   * myMap.clear();
   *
   * myMap.size;       // 0
   * myMap.has("bar")  // false
   */
  clear: {
    value: function clear() {
      return baseClear('map', this);
    }
  },
  /**
   * The delete() method removes the specified element from a Map object.
   *
   * @param {*} key - The key of the element to remove from the Map object.
   * @returns {boolean} Returns true if an element in the Map object has been
   *  removed successfully.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "foo");
   *
   * myMap.delete("bar"); // Returns true. Successfully removed.
   * myMap.has("bar");    // Returns false.
   *                      // The "bar" element is no longer present.
   */
  'delete': {
    value: function de1ete(key) {
      return baseDelete('map', this, key);
    }
  },
  /**
   * The entries() method returns a new Iterator object that contains the
   * [key, value] pairs for each element in the Map object in insertion order.
   *
   * @returns {Object} A new Iterator object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("0", "foo");
   * myMap.set(1, "bar");
   * myMap.set({}, "baz");
   *
   * var mapIter = myMap.entries();
   *
   * console.log(mapIter.next().value); // ["0", "foo"]
   * console.log(mapIter.next().value); // [1, "bar"]
   * console.log(mapIter.next().value); // [Object, "baz"]
   */
  entries: {
    value: function entries() {
      return new MapIt(this, 'key+value');
    }
  },
  /**
   * The forEach() method executes a provided function once per each
   * key/value pair in the Map object, in insertion order.
   *
   * @param {Function} callback - Function to execute for each element..
   * @param {*} [thisArg] - Value to use as this when executing callback.
   * @returns {Object} The Map object.
   * @example
   * var Map = require('collections-x').Map;
   * function logElements(value, key, map) {
   *      console.log("m[" + key + "] = " + value);
   * }
   * var myMap = new Map([["foo", 3], ["bar", {}], ["baz", undefined]]);
   * myMap.forEach(logElements);
   * // logs:
   * // "m[foo] = 3"
   * // "m[bar] = [object Object]"
   * // "m[baz] = undefined"
   */
  forEach: {
    value: function forEach(callback, thisArg) {
      return baseForEach('map', this, callback, thisArg);
    }
  },
  /**
   * The get() method returns a specified element from a Map object.
   *
   * @param {*} key - The key of the element to return from the Map object.
   * @returns {*} Returns the element associated with the specified key or
   *  undefined if the key can't be found in the Map object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "foo");
   *
   * myMap.get("bar");  // Returns "foo".
   * myMap.get("baz");  // Returns undefined.
   */
  get: {
    value: function get(key) {
      var index = indexOf(
        assertIsObject(this)['[[key]]'],
        key,
        'SameValueZero'
      );

      return index > -1 ? this['[[value]]'][index] : void 0;
    }
  },
  /**
   * The has() method returns a boolean indicating whether an element with
   * the specified key exists or not.
   *
   * @function
   * @param {*} key - The key of the element to test for presence in the
   *  Map object.
   * @returns {boolean} Returns true if an element with the specified key
   *  exists in the Map object; otherwise false.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("bar", "foo");
   *
   * myMap.has("bar");  // returns true
   * myMap.has("baz");  // returns false
   */
  has: {
    value: baseHas
  },
  /**
   * The keys() method returns a new Iterator object that contains the keys
   * for each element in the Map object in insertion order.
   *
   * @returns {Object} A new Iterator object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("0", "foo");
   * myMap.set(1, "bar");
   * myMap.set({}, "baz");
   *
   * var mapIter = myMap.keys();
   *
   * console.log(mapIter.next().value); // "0"
   * console.log(mapIter.next().value); // 1
   * console.log(mapIter.next().value); // Object
   */
  keys: {
    value: function keys() {
      return new MapIt(this, 'key');
    }
  },
  /**
   * The set() method adds a new element with a specified key and value to
   * a Map object.
   *
   * @param {*} key - The key of the element to add to the Map object.
   * @param {*} value - The value of the element to add to the Map object.
   * @returns {Object} The Map object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   *
   * // Add new elements to the map
   * myMap.set("bar", "foo");
   * myMap.set(1, "foobar");
   *
   * // Update an element in the map
   * myMap.set("bar", "fuuu");
   */
  set: {
    value: function set(key, value) {
      return baseAddSet('map', this, key, value);
    }
  },
  /**
   * The value of size is an integer representing how many entries the Map
   * object has.
   *
   * @name size
   * @memberof module:collections-x.Map
   * @instance
   * @type {number}
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set(1, true);
   * myMap.set(5, false);
   * myMap.set("some text", 1);
   *
   * myMap.size; // 3
   */
  size: {
    value: 0,
    writable: true
  },
  /**
   * The values() method returns a new Iterator object that contains the
   * values for each element in the Map object in insertion order.
   *
   * @returns {Object} A new Iterator object.
   * @example
   * var Map = require('collections-x').Map;
   * var myMap = new Map();
   * myMap.set("0", "foo");
   * myMap.set(1, "bar");
   * myMap.set({}, "baz");
   *
   * var mapIter = myMap.values();
   *
   * console.log(mapIter.next().value); // "foo"
   * console.log(mapIter.next().value); // "bar"
   * console.log(mapIter.next().value); // "baz"
   */
  values: {
    value: function values() {
      return new MapIt(this, 'value');
    }
  }
});

/**
 * The initial value of the @@iterator property is the same function object
 * as the initial value of the entries property.
 *
 * @function symIt
 * @memberof module:collections-x.Map.prototype
 * @returns {Object} A new Iterator object.
 * @example
 * var Map = require('collections-x').Map;
 * var symIt = require('collections-x').symIt;
 * var myMap = new Map();
 * myMap.set("0", "foo");
 * myMap.set(1, "bar");
 * myMap.set({}, "baz");
 *
 * var mapIter = myMap[symIt]();
 *
 * console.log(mapIter.next().value); // ["0", "foo"]
 * console.log(mapIter.next().value); // [1, "bar"]
 * console.log(mapIter.next().value); // [Object, "baz"]
 */
defineProperty(MapObject.prototype, symIt, {
  value: MapObject.prototype.entries
});

/*
 * Determine whether to use shim or native.
 */

var ExportMap = MapObject;
try {
  ExportMap = new Map() ? Map : MapObject;
} catch (ignore) {}

var ExportSet = SetObject;
try {
  ExportSet = new Set() ? Set : SetObject;
} catch (ignore) {}

var testMap;

if (ExportMap !== MapObject) {
  testMap = new ExportMap();
  if (isNumberType(testMap.size) === false || testMap.size !== 0) {
    ExportMap = MapObject;
  } else {
    var propsMap = [
      'has',
      'set',
      'clear',
      'delete',
      'forEach',
      'values',
      'entries',
      'keys',
      symIt
    ];

    var failedMap = some(propsMap, function (method) {
      return isFunction(testMap[method]) === false;
    });

    if (failedMap) {
      ExportMap = MapObject;
    }
  }
}

if (ExportMap !== MapObject) {
  // Safari 8, for example, doesn't accept an iterable.
  var mapAcceptsArguments = false;
  try {
    mapAcceptsArguments = new ExportMap([[1, 2]]).get(1) === 2;
  } catch (ignore) {}

  if (mapAcceptsArguments === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  testMap = new ExportMap();
  var mapSupportsChaining = testMap.set(1, 2) === testMap;
  if (mapSupportsChaining === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4
  testMap = new ExportMap([
    [1, 0],
    [2, 0],
    [3, 0],
    [4, 0]
  ]);
  testMap.set(-0, testMap);
  var gets = testMap.get(0) === testMap && testMap.get(-0) === testMap;
  var mapUsesSameValueZero = gets && testMap.has(0) && testMap.has(-0);

  if (mapUsesSameValueZero === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  if (Object.setPrototypeOf) {
    var MyMap = function (arg) {
      testMap = new ExportMap(arg);
      Object.setPrototypeOf(testMap, MyMap.prototype);
      return testMap;
    };
    Object.setPrototypeOf(MyMap, ExportMap);
    MyMap.prototype = Object.create(ExportMap.prototype, { constructor: { value: MyMap } });

    var mapSupportsSubclassing = false;
    try {
      testMap = new MyMap([]);
      // Firefox 32 is ok with the instantiating the subclass but will
      // throw when the map is used.
      testMap.set(42, 42);
      mapSupportsSubclassing = testMap instanceof MyMap;
    } catch (ignore) {}

    if (mapSupportsSubclassing === false) {
      ExportMap = MapObject;
    }
  }
}

if (ExportMap !== MapObject) {
  var mapRequiresNew;
  try {
    // eslint-disable-next-line new-cap
    mapRequiresNew = (ExportMap() instanceof ExportMap) === false;
  } catch (e) {
    mapRequiresNew = e instanceof TypeError;
  }

  if (mapRequiresNew === false) {
    ExportMap = MapObject;
  }
}

if (ExportMap !== MapObject) {
  testMap = new ExportMap();
  // eslint-disable-next-line id-length
  var mapIterationThrowsStopIterator;
  try {
    mapIterationThrowsStopIterator = testMap.keys().next().done === false;
  } catch (ignore) {
    mapIterationThrowsStopIterator = true;
  }

  if (mapIterationThrowsStopIterator) {
    ExportMap = MapObject;
  }
}

// Safari 8
if (ExportMap !== MapObject && isFunction(new ExportMap().keys().next) === false) {
  ExportMap = MapObject;
}

if (hasRealSymbolIterator && ExportMap !== MapObject) {
  var testMapProto = getPrototypeOf(new ExportMap().keys());
  var hasBuggyMapIterator = true;
  if (testMapProto) {
    hasBuggyMapIterator = isFunction(testMapProto[symIt]) === false;
  }

  if (hasBuggyMapIterator) {
    ExportMap = MapObject;
  }
}

var testSet;

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  if (isNumberType(testSet.size) === false || testSet.size !== 0) {
    ExportMap = MapObject;
  } else {
    var propsSet = [
      'has',
      'add',
      'clear',
      'delete',
      'forEach',
      'values',
      'entries',
      'keys',
      symIt
    ];

    var failedSet = some(propsSet, function (method) {
      return isFunction(testSet[method]) === false;
    });

    if (failedSet) {
      ExportSet = SetObject;
    }
  }
}

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  testSet['delete'](0);
  testSet.add(-0);
  var setUsesSameValueZero = testSet.has(0) && testSet.has(-0);
  if (setUsesSameValueZero === false) {
    ExportSet = SetObject;
  }
}

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  var setSupportsChaining = testSet.add(1) === testSet;
  if (setSupportsChaining === false) {
    ExportSet = SetObject;
  }
}

if (ExportSet !== SetObject) {
  if (Object.setPrototypeOf) {
    var MySet = function (arg) {
      testSet = new ExportSet(arg);
      Object.setPrototypeOf(testSet, MySet.prototype);
      return testSet;
    };
    Object.setPrototypeOf(MySet, ExportSet);
    MySet.prototype = Object.create(ExportSet.prototype, { constructor: { value: MySet } });

    var setSupportsSubclassing = false;
    try {
      testSet = new MySet([]);
      testSet.add(42, 42);
      setSupportsSubclassing = testSet instanceof MySet;
    } catch (ignore) {}

    if (setSupportsSubclassing === false) {
      ExportSet = SetObject;
    }
  }
}

if (ExportSet !== SetObject) {
  var setRequiresNew;
  try {
    // eslint-disable-next-line new-cap
    setRequiresNew = (ExportSet() instanceof ExportSet) === false;
  } catch (e) {
    setRequiresNew = e instanceof TypeError;
  }

  if (setRequiresNew === false) {
    ExportSet = SetObject;
  }
}

if (ExportSet !== SetObject) {
  testSet = new ExportSet();
  // eslint-disable-next-line id-length
  var setIterationThrowsStopIterator;
  try {
    setIterationThrowsStopIterator = testSet.keys().next().done === false;
  } catch (ignore) {
    setIterationThrowsStopIterator = true;
  }

  if (setIterationThrowsStopIterator) {
    ExportSet = SetObject;
  }
}

// Safari 8
if (ExportSet !== SetObject && isFunction(new ExportSet().keys().next) === false) {
  ExportSet = SetObject;
}

if (hasRealSymbolIterator && ExportSet !== SetObject) {
  var testSetProto = getPrototypeOf(new ExportSet().keys());
  var hasBuggySetIterator = true;
  if (testSetProto) {
    hasBuggySetIterator = isFunction(testSetProto[symIt]) === false;
  }

  if (hasBuggySetIterator) {
    ExportSet = SetObject;
  }
}

var hasCommon = function _hasCommon(object) {
  return isObjectLike(object) && isFunction(object[symIt]) && isBoolean(object['[[changed]]']) && isObjectLike(object['[[id]]']) && isArray(object['[[key]]']) && isArray(object['[[order]]']) && isNumberType(object.size);
};

var $isMap;
if (ExportMap === MapObject) {
  $isMap = function _isMap(object) {
    if (isMap(object)) {
      return true;
    }

    return hasCommon(object) && isArray(object['[[value]]']);
  };
} else {
  $isMap = isMap;
}

var $isSet;
if (ExportSet === SetObject) {
  $isSet = function _isSet(object) {
    if (isSet(object)) {
      return true;
    }

    return hasCommon(object) && isUndefined(object['[[value]]']);
  };
} else {
  $isSet = isSet;
}

/*
 * Exports.
 */

module.exports = {
  /**
   * Determine if an `object` is a `Map`.
   *
   * @param {*} object - The object to test.
   * @returns {boolean} `true` if the `object` is a `Map`,
   *  else `false`.
   * @example
   * var isMap = require('collections-x').isMap;
   * var m = new Map();
   *
   * isMap([]); // false
   * isMap(true); // false
   * isMap(m); // true
   */
  isMap: $isMap,
  /**
   * Determine if an `object` is a `Set`.
   *
   * @param {*} object - The object to test.
   * @returns {boolean} `true` if the `object` is a `Set`,
   *  else `false`.
   * @example
   * var isSet = require('collections-x');
   * var s = new Set();
   *
   * isSet([]); // false
   * isSet(true); // false
   * isSet(s); // true
   */
  isSet: $isSet,
  /** @borrows Map as Map */
  Map: ExportMap,
  /** @borrows Set as Set */
  Set: ExportSet,
  /**
   * The iterator identifier that is in use.
   *
   * type {Symbol|string}
   */
  symIt: symIt
};

},{"array-some-x":25,"assert-is-function-x":30,"assert-is-object-x":31,"big-counter-x":33,"get-prototype-of-x":68,"has-own-property-x":42,"has-symbol-support-x":72,"index-of-x":77,"is-array-like-x":100,"is-array-x":101,"is-boolean-object":103,"is-function-x":110,"is-map-x":115,"is-nil-x":122,"is-object-like-x":124,"is-primitive":126,"is-set-x":133,"is-string":134,"is-surrogate-pair-x":135,"object-define-properties-x":317,"object-define-property-x":318,"validate.io-undefined":356}],42:[function(require,module,exports){
/**
 * @file Used to determine whether an object has an own property with the specified property key.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-hasownproperty|7.3.11 HasOwnProperty (O, P)}
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-own-property-x
 */

'use strict';

var toObject = require('to-object-x');
var toPrimitive = require('es-to-primitive/es6');
var safeToString = require('safe-to-string-x');
var isSymbol = require('is-symbol');
var hop = Object.prototype.hasOwnProperty;

/**
 * The `hasOwnProperty` method returns a boolean indicating whether
 * the `object` has the specified `property`. Does not attempt to fix known
 * issues in older browsers, but does ES6ify the method.
 *
 * @param {!Object} object - The object to test.
 * @param {string|Symbol} property - The name or Symbol of the property to test.
 * @returns {boolean} `true` if the property is set on `object`, else `false`.
 * @example
 * var hasOwnProperty = require('has-own-property-x');
 * var o = {
 *   foo: 'bar'
 * };
 *
 *
 * hasOwnProperty(o, 'bar'); // false
 * hasOwnProperty(o, 'foo'); // true
 * hasOwnProperty(undefined, 'foo');
 *                   // TypeError: Cannot convert undefined or null to object
 */
module.exports = function hasOwnProperty(object, property) {
  var prop = isSymbol(property) ? property : safeToString(toPrimitive(property, String));

  return hop.call(toObject(object), prop);
};

},{"es-to-primitive/es6":50,"is-symbol":136,"safe-to-string-x":331,"to-object-x":344}],43:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],44:[function(require,module,exports){
// Console-polyfill. MIT license.
// https://github.com/paulmillr/console-polyfill
// Make it safe to do console.log() always.
(function(global) {
  'use strict';
  if (!global.console) {
    global.console = {};
  }
  var con = global.console;
  var prop, method;
  var dummy = function() {};
  var properties = ['memory'];
  var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +
     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
     'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
  while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
  while (method = methods.pop()) if (!con[method]) con[method] = dummy;
  // Using `this` for web workers & supports Browserify / Webpack.
})(typeof window === 'undefined' ? this : window);

},{}],45:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

var fingerprint = require('./lib/fingerprint.js');
var pad = require('./lib/pad.js');

var c = 0,
  blockSize = 4,
  base = 36,
  discreteValues = Math.pow(base, blockSize);

function randomBlock () {
  return pad((Math.random() *
    discreteValues << 0)
    .toString(base), blockSize);
}

function safeCounter () {
  c = c < discreteValues ? c : 0;
  c++; // this is not subliminal
  return c - 1;
}

function cuid () {
  // Starting with a lowercase letter makes
  // it HTML element ID friendly.
  var letter = 'c', // hard-coded allows for sequential access

    // timestamp
    // warning: this exposes the exact date and time
    // that the uid was created.
    timestamp = (new Date().getTime()).toString(base),

    // Prevent same-machine collisions.
    counter = pad(safeCounter().toString(base), blockSize),

    // A few chars to generate distinct ids for different
    // clients (so different computers are far less
    // likely to generate the same id)
    print = fingerprint(),

    // Grab some more chars from Math.random()
    random = randomBlock() + randomBlock();

  return letter + timestamp + counter + print + random;
}

cuid.slug = function slug () {
  var date = new Date().getTime().toString(36),
    counter = safeCounter().toString(36).slice(-4),
    print = fingerprint().slice(0, 1) +
      fingerprint().slice(-1),
    random = randomBlock().slice(-2);

  return date.slice(-2) +
    counter + print + random;
};

cuid.isCuid = function isCuid (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  if (stringToCheck.startsWith('c')) return true;
  return false;
};

cuid.isSlug = function isSlug (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  var stringLength = stringToCheck.length;
  if (stringLength >= 7 && stringLength <= 10) return true;
  return false;
};

cuid.fingerprint = fingerprint;

module.exports = cuid;

},{"./lib/fingerprint.js":46,"./lib/pad.js":47}],46:[function(require,module,exports){
var pad = require('./pad.js');

var env = typeof window === 'object' ? window : self;
var globalCount = Object.keys(env).length;
var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
var clientId = pad((mimeTypesLength +
  navigator.userAgent.length).toString(36) +
  globalCount.toString(36), 4);

module.exports = function fingerprint () {
  return clientId;
};

},{"./pad.js":47}],47:[function(require,module,exports){
module.exports = function pad (num, size) {
  var s = '000000000' + num;
  return s.substr(s.length - size);
};

},{}],48:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"object-keys":321}],49:[function(require,module,exports){
'use strict';

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');
var isCallable = require('is-callable');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"./helpers/isPrimitive":51,"is-callable":104,"is-date-object":106,"is-symbol":136}],50:[function(require,module,exports){
'use strict';

module.exports = require('./es2015');

},{"./es2015":49}],51:[function(require,module,exports){
module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],52:[function(require,module,exports){
module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var arr = []

// Regular stringify
function stringify (obj, replacer, spacer) {
  decirc(obj, '', [], undefined)
  var res = JSON.stringify(obj, replacer, spacer)
  while (arr.length !== 0) {
    var part = arr.pop()
    part[0][part[1]] = part[2]
  }
  return res
}
function decirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]'
        arr.push([parent, k, val])
        return
      }
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, stack, val)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, stack, val)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer) {
  var tmp = deterministicDecirc(obj, '', [], undefined) || obj
  var res = JSON.stringify(tmp, replacer, spacer)
  while (arr.length !== 0) {
    var part = arr.pop()
    part[0][part[1]] = part[2]
  }
  return res
}

function deterministicDecirc (val, k, stack, parent) {
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]'
        arr.push([parent, k, val])
        return
      }
    }
    if (typeof val.toJSON === 'function') {
      return
    }
    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, stack, val)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, stack, val)
        tmp[key] = val[key]
      }
      if (parent !== undefined) {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

},{}],53:[function(require,module,exports){
/**
 * @file This method returns the index of the first element in the array that satisfies the provided testing function.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module find-index-x
 */

'use strict';

var pFindIndex = Array.prototype.findIndex;

// eslint-disable-next-line no-sparse-arrays
var implemented = pFindIndex && ([, 1].findIndex(function (item, idx) {
  return idx === 0;
}) === 0);

var findIdx;
if (implemented) {
  findIdx = function findIndex(array, callback) {
    var args = [callback];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return pFindIndex.apply(array, args);
  };
} else {
  var toLength = require('to-length-x');
  var toObject = require('to-object-x');
  var isString = require('is-string');
  var assertIsFunction = require('assert-is-function-x');
  var splitString = require('has-boxed-string-x') === false;

  findIdx = function findIndex(array, callback) {
    var object = toObject(array);
    assertIsFunction(callback);
    var iterable = splitString && isString(object) ? object.split('') : object;
    var length = toLength(iterable.length);
    if (length < 1) {
      return -1;
    }

    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var index = 0;
    while (index < length) {
      if (callback.call(thisArg, iterable[index], index, object)) {
        return index;
      }

      index += 1;
    }

    return -1;
  };
}

/**
 * Like `findIndex`, this method returns an index in the array, if an element
 * in the array satisfies the provided testing function. Otherwise -1 is returned.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If array is `null` or `undefined`-
 * @param {Function} callback - Function to execute on each value in the array,
 *  taking three arguments: `element`, `index` and `array`.
 * @throws {TypeError} If `callback` is not a function.
 * @param {*} [thisArg] - Object to use as `this` when executing `callback`.
 * @returns {number} Returns index of positively tested element, otherwise -1.
 * @example
 * var findIndex = require('find-index-x');
 *
 * function isPrime(element, index, array) {
 *   var start = 2;
 *   while (start <= Math.sqrt(element)) {
 *     if (element % start++ < 1) {
 *       return false;
 *     }
 *   }
 *   return element > 1;
 * }
 *
 * console.log(findIndex([4, 6, 8, 12, 14], isPrime)); // -1, not found
 * console.log(findIndex([4, 6, 7, 12, 13], isPrime)); // 2
 */
module.exports = findIdx;

},{"assert-is-function-x":30,"has-boxed-string-x":69,"is-string":134,"to-length-x":57,"to-object-x":344}],54:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10,"is-nan":118,"max-safe-integer":300}],55:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11,"is-nan":118}],56:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12,"is-finite-x":54,"is-nan":118,"math-sign-x":55}],57:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13,"max-safe-integer":300,"to-integer-x":56}],58:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],59:[function(require,module,exports){
// these are known as "placeholder tokens", see this link for more info:
// <https://nodejs.org/api/util.html#util_util_format_format_args>
//
// since they aren't exposed (or don't seem to be) by node (at least not yet)
// we just define an array that contains them for now
// <https://github.com/nodejs/node/issues/17601>
// <https://github.com/nodejs/node/blob/7af1ad0ec15546761233c2e90008316551db2bbd/doc/api/util.md#utilformatformat-args>
module.exports = ['%s', '%d', '%i', '%f', '%j', '%o', '%O', '%%'];

},{}],60:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],61:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":60}],62:[function(require,module,exports){
/**
 * @file Get the name of the function.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-function-name-x
 */

'use strict';

var isFunction = require('is-function-x');
var functionCtr = function () {}.constructor;

var getName;
var t = function test1() {};
if (t.name === 'test1') {
  var createsAnonymous = functionCtr().name === 'anonymous';
  getName = function _getName(fn) {
    return createsAnonymous && fn.name === 'anonymous' ? '' : fn.name;
  };
} else {
  var replaceComments = require('replace-comments-x');
  var fToString = functionCtr.prototype.toString;
  var normalise = require('normalize-space-x').normalizeSpace2018;
  var reName = /^(?:async )?(?:function|class) ?(?:\* )?([\w$]+)/i;
  var stringMatch = require('cached-constructors-x').String.prototype.match;
  getName = function _getName(fn) {
    var match;
    try {
      match = stringMatch.call(normalise(replaceComments(fToString.call(fn), ' ')), reName);
      if (match) {
        var name = match[1];
        return name === 'anonymous' ? '' : name;
      }
    } catch (ignore) {}

    return '';
  };
}

/**
 * This method returns the name of the function, or `undefined` if not
 * a function.
 *
 * @param {Function} fn - The function to get the name of.
 * @returns {undefined|string} The name of the function,  or `undefined` if
 *  not a function.
 * @example
 * var getFunctionName = require('get-function-name-x');
 *
 * getFunctionName(); // undefined
 * getFunctionName(Number.MIN_VALUE); // undefined
 * getFunctionName('abc'); // undefined
 * getFunctionName(true); // undefined
 * getFunctionName({ name: 'abc' }); // undefined
 * getFunctionName(function () {}); // ''
 * getFunctionName(new Function ()); // ''
 * getFunctionName(function test1() {}); // 'test1'
 * getFunctionName(function* test2() {}); // 'test2'
 * getFunctionName(class Test {}); // 'Test'
 */
module.exports = function getFunctionName(fn) {
  return isFunction(fn, true) ? getName(fn) : void 0;
};

},{"cached-constructors-x":35,"is-function-x":110,"normalize-space-x":308,"replace-comments-x":328}],63:[function(require,module,exports){
/**
 * @file Like Object.getOwnPropertySymbols but gets only enumerable properties.
 * @version 1.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-enumerable-property-symbols-x
 */

'use strict';

var toObject = require('to-object-x');
var filter = require('array-filter-x');
var getOPS = require('get-own-property-symbols-x');
var propertyIsEnumerable = require('property-is-enumerable-x');

/**
 * This method returns only the enumerable own property symbols of an object.
 *
 * @param {Object} target - The target.
 * @throws {typeError} - If target is null or undefined.
 * @returns {Array} The enumerable own property symbols.
 * @example
 * var getOwnEnumerablePropertySymbols = require('get-own-enumerable-property-symbols-x');
 *
 * var obj = { bar: 1, foo: 2 };
 *
 * var symbol1 = Symbol('first');
 * Object.defineProperty(obj, symbo1l, {
 *   enumerable: false,
 *   value: 'first'
 * });
 *
 * var symbol2 = Symbol('second');
 * Object.defineProperty(obj, symbol2, {
 *   enumerable: true,
 *   value: 'second'
 * });
 *
 * getOwnEnumerablePropertySymbols(obj); // [symbol2]
 */
// eslint-disable-next-line id-length
module.exports = function getOwnEnumerablePropertySymbols(target) {
  var object = toObject(target);
  return filter(getOPS(object), function (symbol) {
    return propertyIsEnumerable(object, symbol);
  });
};

},{"array-filter-x":64,"get-own-property-symbols-x":67,"property-is-enumerable-x":326,"to-object-x":344}],64:[function(require,module,exports){
/**
 * @file Creates an array with all elements that pass the test by the provided function.
 * @version 2.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-filter-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var ArrayCtr = cachedCtrs.Array;
var castObject = cachedCtrs.Object;
var nativFilter = typeof ArrayCtr.prototype.filter === 'function' && ArrayCtr.prototype.filter;

var isWorking;
if (nativFilter) {
  var attempt = require('attempt-x');
  var spy = 0;
  var res = attempt.call([1, 2], nativFilter, function (item) {
    spy += item;
    return false;
  });

  isWorking = res.threw === false && res.value && res.value.length === 0 && spy === 3;

  if (isWorking) {
    spy = '';
    res = attempt.call(castObject('abc'), nativFilter, function (item, index) {
      spy += item;
      return index === 1;
    });

    isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === 'b' && spy === 'abc';
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call((function () {
      return arguments;
    }(1, 2, 3)), nativFilter, function (item, index) {
      spy += item;
      return index === 2;
    });

    isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === 3 && spy === 6;
  }

  if (isWorking) {
    spy = 0;
    res = attempt.call({
      0: 1,
      1: 2,
      3: 3,
      4: 4,
      length: 4
    }, nativFilter, function (item) {
      spy += item;
      return false;
    });

    isWorking = res.threw === false && res.value && res.value.length === 0 && spy === 6;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      spy = null;
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativFilter, function (item) {
        spy = item;
        return item;
      });

      isWorking = res.threw === false && res.value && res.value.length === 1 && res.value[0] === div && spy === div;
    }
  }

  if (isWorking) {
    var isStrict = (function () {
      // eslint-disable-next-line no-invalid-this
      return Boolean(this) === false;
    }());

    if (isStrict) {
      spy = null;
      res = attempt.call([1], nativFilter, function () {
        // eslint-disable-next-line no-invalid-this
        spy = typeof this === 'string';
      }, 'x');

      isWorking = res.threw === false && res.value && res.value.length === 0 && spy === true;
    }
  }

  if (isWorking) {
    spy = {};
    var fn = [
      'return nativFilter.call("foo", function (_, __, context) {',
      'if (Boolean(context) === false || typeof context !== "object") {',
      'spy.value = true;}});'
    ].join('');

    // eslint-disable-next-line no-new-func
    res = attempt(Function('nativFilter', 'spy', fn), nativFilter, spy);

    isWorking = res.threw === false && res.value && res.value.length === 0 && spy.value !== true;
  }
}

var $filter;
if (nativFilter) {
  $filter = function filter(array, callBack /* , thisArg */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativFilter.apply(array, args);
  };
} else {
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x').toLength2018;
  var isUndefined = require('validate.io-undefined');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $filter = function filter(array, callBack /* , thisArg */) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var noThis = isUndefined(thisArg);
    var result = [];
    for (var i = 0; i < length; i += 1) {
      if (i in iterable) {
        var item = iterable[i];
        if (noThis ? callBack(item, i, object) : callBack.call(thisArg, item, i, object)) {
          result[result.length] = item;
        }
      }
    }

    return result;
  };
}

/**
 * This method creates a new array with all elements that pass the test
 * implemented by the provided function.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function is a predicate, to test each element.
 * @param {*} [thisArg] - Value to use as this when executing callback.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @returns {array} A new array with the elements that pass the test.
 * @example
 * var filter = require('array-filter-x');
 *
 * function isBigEnough(value) {
 *   return value >= 10;
 * }
 *
 * var filtered = filter([12, 5, 8, 130, 44], isBigEnough);
 * // filtered is [12, 130, 44]
 */
module.exports = $filter;

},{"assert-is-function-x":65,"attempt-x":32,"cached-constructors-x":35,"split-if-boxed-bug-x":334,"to-length-x":339,"to-object-x":344,"validate.io-undefined":356}],65:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":110,"is-primitive":126,"to-string-symbols-supported-x":347}],66:[function(require,module,exports){
/**
 * @file Creates an array of all properties (enumerable or not) found directly upon a given object.
 * @version 1.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-property-names-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeGOPN = Object.getOwnPropertyNames;

var $gopn;
if (typeof nativeGOPN === 'function') {
  // eslint-disable-next-line id-length
  var objectGOPNAcceptsPrimitives;
  try {
    nativeGOPN('foo');
    objectGOPNAcceptsPrimitives = true;
  } catch (ignore) {}

  if (objectGOPNAcceptsPrimitives) {
    $gopn = nativeGOPN;
  } else {
    var toStringTag = require('to-string-tag-x');
    var concat = Array.prototype.concat;
    var cachedWindowNames = typeof window === 'object' ? nativeGOPN(window) : [];

    $gopn = function getOwnPropertyNames(obj) {
      var val = toObject(obj);
      if (toStringTag(val) === '[object Window]') {
        try {
          return nativeGOPN(val);
        } catch (ignore) {
          // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
          return concat.call([], cachedWindowNames);
        }
      }

      return nativeGOPN(val);
    };
  }
} else {
  var objectKeys = require('object-keys-x');
  $gopn = function getOwnPropertyNames(obj) {
    return objectKeys(obj);
  };
}

/**
 * This method creates an array of all properties (enumerable or not) found
 * directly upon a given object.
 *
 * @param {object} obj - The object whose enumerable and non-enumerable own
 *  properties are to be returned.
 * @throws {TypeError} If target is null or undefined.
 * @returns {array} An array of strings that correspond to the properties found
 *  directly upon the given object.
 * @example
 * var getOwnPropertyName = require('get-own-property-name-x');
 *
 * getOwnPropertyNames('foo'); // ["0", "1", "2", "length"]
 */
module.exports = $gopn;

},{"object-keys-x":320,"to-object-x":344,"to-string-tag-x":348}],67:[function(require,module,exports){
/**
 * @file Creates an array of all symbol properties found directly upon a given object.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-property-symbols-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeGOPS = Object.getOwnPropertySymbols;
var isWorking;
if (require('has-symbol-support-x') && nativeGOPS && typeof nativeGOPS === 'function') {
  var symbol = Symbol('');
  var testObj = { a: 1 };
  testObj[symbol] = 2;
  var r = require('attempt-x')(nativeGOPS, testObj);
  isWorking = r.threw === false && r.value && r.value.length === 1 && r.value[0] === symbol;
}

/**
 * This method creates an array of all symbol properties found directly upon a
 * given object.
 *
 * @param {object} obj - The object whose symbol properties are to be returned.
 * @throws {TypeError} If target is null or undefined.
 * @returns {array} An array of all symbol properties found directly upon the
 *  given object.
 * @example
 * var getOwnPropertySymbols = require('get-own-property-isWorking-x');
 *
 * var symbol = Symbol('');
 * var testObj = { a: 1 };
 * testObj[symbol] = 2;
 * getOwnPropertySymbols(testObj); // [symbol]
 */
module.exports = function getOwnPropertySymbols(obj) {
  var object = toObject(obj);
  return isWorking ? nativeGOPS(object) : [];
};

},{"attempt-x":32,"has-symbol-support-x":72,"to-object-x":344}],68:[function(require,module,exports){
/**
 * @file Sham for Object.getPrototypeOf
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-prototype-of-x
 */

'use strict';

var isFunction = require('is-function-x');
var isNull = require('lodash.isnull');
var toObject = require('to-object-x');
var gpo = require('cached-constructors-x').Object.getPrototypeOf;

if (gpo) {
  try {
    gpo = gpo(Object) === Object.prototype && gpo;
  } catch (ignore) {
    gpo = null;
  }
}

if (gpo) {
  try {
    gpo(1);
  } catch (ignore) {
    var $getPrototypeOf = gpo;
    gpo = function getPrototypeOf(obj) {
      return $getPrototypeOf(toObject(obj));
    };
  }
} else {
  gpo = function getPrototypeOf(obj) {
    var object = toObject(obj);
    // eslint-disable-next-line no-proto
    var proto = object.__proto__;
    if (proto || isNull(proto)) {
      return proto;
    }

    if (isFunction(object.constructor)) {
      return object.constructor.prototype;
    }

    if (object instanceof Object) {
      return Object.prototype;
    }

    return null;
  };
}

/**
 * This method returns the prototype (i.e. the value of the internal [[Prototype]] property)
 * of the specified object.
 *
 * @param {*} obj - The object whose prototype is to be returned.
 * @returns {Object} The prototype of the given object. If there are no inherited properties, null is returned.
 * @example
 * var getPrototypeOf = require('get-prototype-of-x');
 * getPrototypeOf('foo'); // String.prototype
 */
module.exports = gpo;

},{"cached-constructors-x":35,"is-function-x":110,"lodash.isnull":139,"to-object-x":344}],69:[function(require,module,exports){
/**
 * @file Check support of by-index access of string characters.
 * @version 1.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-boxed-string-x
 */

'use strict';

var boxedString = require('cached-constructors-x').Object('a');

/**
 * Check failure of by-index access of string characters (IE < 9)
 * and failure of `0 in boxedString` (Rhino).
 *
 * `true` if no failure; otherwise `false`.
 *
 * @type boolean
 */
module.exports = boxedString[0] === 'a' && (0 in boxedString);

},{"cached-constructors-x":35}],70:[function(require,module,exports){
/**
 * @file Used to determine whether an object has an own property with the specified property key.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-hasownproperty|7.3.11 HasOwnProperty (O, P)}
 * @version 3.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-own-property-x
 */

'use strict';

var toObject = require('to-object-x');
var toPropertyKey = require('to-property-key-x');
var hop = require('cached-constructors-x').Object.prototype.hasOwnProperty;

/**
 * The `hasOwnProperty` method returns a boolean indicating whether
 * the `object` has the specified `property`. Does not attempt to fix known
 * issues in older browsers, but does ES6ify the method.
 *
 * @param {!Object} object - The object to test.
 * @throws {TypeError} If object is null or undefined.
 * @param {string|Symbol} property - The name or Symbol of the property to test.
 * @returns {boolean} `true` if the property is set on `object`, else `false`.
 * @example
 * var hasOwnProperty = require('has-own-property-x');
 * var o = {
 *   foo: 'bar'
 * };
 *
 *
 * hasOwnProperty(o, 'bar'); // false
 * hasOwnProperty(o, 'foo'); // true
 * hasOwnProperty(undefined, 'foo');
 *                   // TypeError: Cannot convert undefined or null to object
 */
module.exports = function hasOwnProperty(object, property) {
  return hop.call(toObject(object), toPropertyKey(property));
};

},{"cached-constructors-x":35,"to-object-x":344,"to-property-key-x":346}],71:[function(require,module,exports){
/**
 * @file Tests if ES6 Reflect is supported.
 * @version 1.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-reflect-support-x
 */

'use strict';

/**
 * Indicates if `Reflect`exists.
 * `true`, if it exists and creates the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = typeof Reflect === 'object' && Reflect !== null;

},{}],72:[function(require,module,exports){
/**
 * @file Tests if ES6 Symbol is supported.
 * @version 1.4.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-symbol-support-x
 */

'use strict';

/**
 * Indicates if `Symbol`exists and creates the correct type.
 * `true`, if it exists and creates the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = typeof Symbol === 'function' && typeof Symbol('') === 'symbol';

},{}],73:[function(require,module,exports){
(function (global){
'use strict';

var origSymbol = global.Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./shams":74}],74:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 17], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],75:[function(require,module,exports){
/**
 * @file Tests if ES6 @@toStringTag is supported.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-@@tostringtag|26.3.1 @@toStringTag}
 * @version 1.4.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-to-string-tag-x
 */

'use strict';

/**
 * Indicates if `Symbol.toStringTag`exists and is the correct type.
 * `true`, if it exists and is the correct type, otherwise `false`.
 *
 * @type boolean
 */
module.exports = require('has-symbol-support-x') && typeof Symbol.toStringTag === 'symbol';

},{"has-symbol-support-x":72}],76:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":61}],77:[function(require,module,exports){
/**
 * @file An extended ES6 indexOf.
 * @version 2.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module index-of-x
 */

'use strict';

var numberIsNaN = require('is-nan-x');
var isString = require('is-string');
var isFalsey = require('is-falsey-x');
var toObject = require('to-object-x');
var toLength = require('to-length-x');
var sameValueZero = require('same-value-zero-x');
var sameValue = require('same-value-x');
var findIndex = require('find-index-x');
var calcFromIndex = require('calculate-from-index-x');
var splitIfBoxedBug = require('split-if-boxed-bug-x');
var pIndexOf = typeof Array.prototype.indexOf === 'function' && Array.prototype.indexOf;

var isWorking;
if (pIndexOf) {
  var attempt = require('attempt-x');
  var res = attempt.call([0, 1], pIndexOf, 1, 2);
  isWorking = res.threw === false && res.value === -1;

  if (isWorking) {
    res = attempt.call([0, 1], pIndexOf, 1);
    isWorking = res.threw === false && res.value === 1;
  }

  if (isWorking) {
    res = attempt.call([0, -0], pIndexOf, -0);
    isWorking = res.threw === false && res.value === 0;
  }

  if (isWorking) {
    var testArr = [];
    testArr.length = 2;
    testArr[1] = void 0;
    res = attempt.call(testArr, pIndexOf, void 0);
    isWorking = res.threw === false && res.value === 1;
  }

  if (isWorking) {
    res = attempt.call('abc', pIndexOf, 'c');
    isWorking = res.threw === false && res.value === 2;
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }('a', 'b', 'c')), pIndexOf, 'c');
    isWorking = res.threw === false && res.value === 2;
  }
}

if (isWorking !== true) {
  pIndexOf = function indexOf(searchElement) {
    // eslint-disable-next-line no-invalid-this
    var length = toLength(this.length);
    if (length < 1) {
      return -1;
    }

    var i = arguments[1];
    while (i < length) {
      // eslint-disable-next-line no-invalid-this
      if (i in this && this[i] === searchElement) {
        return i;
      }

      i += 1;
    }

    return -1;
  };
}

/**
 * This method returns an index in the array, if an element in the array
 * satisfies the provided testing function. Otherwise -1 is returned.
 *
 * @private
 * @param {Array} array - The array to search.
 * @param {*} searchElement - Element to locate in the array.
 * @param {number} fromIndex - The index to start the search at.
 * @param {Function} extendFn - The comparison function to use.
 * @returns {number} Returns index of found element, otherwise -1.
 */
// eslint-disable-next-line max-params
var findIdxFrom = function findIndexFrom(array, searchElement, fromIndex, extendFn) {
  var fIdx = fromIndex;
  var length = toLength(array.length);
  while (fIdx < length) {
    if (fIdx in array && extendFn(array[fIdx], searchElement)) {
      return fIdx;
    }

    fIdx += 1;
  }

  return -1;
};

/**
 * This method returns the first index at which a given element can be found
 * in the array, or -1 if it is not present.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If `array` is `null` or `undefined`.
 * @param {*} searchElement - Element to locate in the `array`.
 * @param {number} [fromIndex] - The index to start the search at. If the
 *  index is greater than or equal to the array's length, -1 is returned,
 *  which means the array will not be searched. If the provided index value is
 *  a negative number, it is taken as the offset from the end of the array.
 *  Note: if the provided index is negative, the array is still searched from
 *  front to back. If the calculated index is less than 0, then the whole
 *  array will be searched. Default: 0 (entire array is searched).
 * @param {string} [extend] - Extension type: `SameValue` or `SameValueZero`.
 * @returns {number} Returns index of found element, otherwise -1.
 * @example
 * var indexOf = require('index-of-x');
 * var subject = [2, 3, undefined, true, 'hej', null, 2, false, 0, -0, NaN];
 *
 * // Standard mode, operates just like `Array.prototype.indexOf`.
 * indexOf(subject, null); // 5
 * indexOf(testSubject, '2'); // -1
 * indexOf(testSubject, NaN); // -1
 * indexOf(testSubject, -0); // 8
 * indexOf(testSubject, 2, 2); //6
 *
 * // `SameValueZero` mode extends `indexOf` to match `NaN`.
 * indexOf(subject, null, 'SameValueZero'); // 5
 * indexOf(testSubject, '2', 'SameValueZero'); // -1
 * indexOf(testSubject, NaN, 'SameValueZero'); // 10
 * indexOf(testSubject, -0, 'SameValueZero'); // 8
 * indexOf(testSubject, 2, 2, 'SameValueZero'); //6
 *
 * // `SameValue` mode extends `indexOf` to match `NaN` and signed `0`.
 * indexOf(subject, null, 'SameValue'); // 5
 * indexOf(testSubject, '2', 'SameValue'); // -1
 * indexOf(testSubject, NaN, 'SameValue'); // 10
 * indexOf(testSubject, -0, 'SameValue'); // 9
 * indexOf(testSubject, 2, 2, 'SameValue'); //6
 */
module.exports = function indexOf(array, searchElement) {
  var object = toObject(array);
  var iterable = splitIfBoxedBug(object);
  var length = toLength(iterable.length);
  if (length < 1) {
    return -1;
  }

  var argLength = arguments.length;
  var extend = argLength > 2 && argLength > 3 ? arguments[3] : arguments[2];
  var extendFn;
  if (isString(extend)) {
    extend = extend.toLowerCase();
    if (extend === 'samevalue') {
      extendFn = sameValue;
    } else if (extend === 'samevaluezero') {
      extendFn = sameValueZero;
    }
  }

  var fromIndex = 0;
  if (extendFn && (searchElement === 0 || numberIsNaN(searchElement))) {
    if (argLength > 3) {
      fromIndex = calcFromIndex(iterable, arguments[2]);
      if (fromIndex >= length) {
        return -1;
      }

      if (fromIndex < 0) {
        fromIndex = 0;
      }
    }

    if (fromIndex > 0) {
      return findIdxFrom(iterable, searchElement, fromIndex, extendFn);
    }

    return findIndex(iterable, function (element, index) {
      return index in iterable && extendFn(searchElement, element);
    });
  }

  if (argLength > 3 || (argLength > 2 && isFalsey(extendFn))) {
    fromIndex = calcFromIndex(iterable, arguments[2]);
    if (fromIndex >= length) {
      return -1;
    }

    if (fromIndex < 0) {
      fromIndex = 0;
    }
  }

  return pIndexOf.call(iterable, searchElement, fromIndex);
};

},{"attempt-x":32,"calculate-from-index-x":79,"find-index-x":86,"is-falsey-x":108,"is-nan-x":116,"is-string":134,"same-value-x":332,"same-value-zero-x":333,"split-if-boxed-bug-x":334,"to-length-x":90,"to-object-x":344}],78:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":110,"is-primitive":126,"to-string-symbols-supported-x":347}],79:[function(require,module,exports){
/**
 * @file Calculates a fromIndex of a given value for an array.
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module calculate-from-index-x
 */

'use strict';

var toObject = require('to-object-x');
var toLength = require('to-length-x').toLength2018;
var toInteger = require('to-integer-x').toInteger2018;
var isArrayLike = require('is-array-like-x');

var getMax = function _getMax(a, b) {
  return a >= b ? a : b;
};

/**
 * This method calculates a fromIndex of a given value for an array.
 *
 * @param {array} array * The array on which to calculate the starting index.
 * @throws {TypeError} If array is null or undefined.
 * @param {number} fromIndex * The position in this array at which to begin. A
 *  negative value gives the index of array.length + fromIndex by asc.
 * @returns {number} The calculated fromIndex. Default is 0.
 * @example
 * var calcFromIndex = require('calculate-from-index-x');
 *
 * calcFromIndex([1, 2, 3], 1); // 1
 * calcFromIndex([1, 2, 3], Infinity); // Infinity
 * calcFromIndex([1, 2, 3], -Infinity); // 0
 * calcFromIndex([1, 2, 3], -1); // 2
 */
module.exports = function calcFromIndex(array, fromIndex) {
  var object = toObject(array);
  if (isArrayLike(object) === false) {
    return 0;
  }

  var index = toInteger(fromIndex);

  return index >= 0 ? index : getMax(0, toLength(object.length) + index);
};

},{"is-array-like-x":100,"to-integer-x":82,"to-length-x":83,"to-object-x":344}],80:[function(require,module,exports){
/**
 * @file Shim for Math.sign.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-math.sign|20.2.2.29 Math.sign(x)}
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-sign-x
 */

'use strict';

var libToNumber = require('to-number-x');
var toNumber2016 = libToNumber.toNumber2016;
var toNumber2018 = libToNumber.toNumber2018;
var numberIsNaN = require('is-nan-x');

var $sign2016 = function sign2016(x) {
  var n = toNumber2016(x);
  if (n === 0 || numberIsNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

var $sign2018 = function sign2018(x) {
  var n = toNumber2018(x);
  if (n === 0 || numberIsNaN(n)) {
    return n;
  }

  return n > 0 ? 1 : -1;
};

module.exports = {
  /**
   * Reference to sign2018.
   */
  sign: $sign2018,

  /**
   * This method returns the sign of a number, indicating whether the number is positive,
   * negative or zero. (ES2016)
   *
   * @param {*} x - A number.
   * @returns {number} A number representing the sign of the given argument. If the argument
   * is a positive number, negative number, positive zero or negative zero, the function will
   * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
   * @example
   * var mathSign = require('math-sign-x').sign2016;
   *
   * mathSign(3);     //  1
   * mathSign(-3);    // -1
   * mathSign('-3');  // -1
   * mathSign(0);     //  0
   * mathSign(-0);    // -0
   * mathSign(NaN);   // NaN
   * mathSign('foo'); // NaN
   * mathSign();      // NaN
   */
  sign2016: $sign2016,

  /**
   * This method returns the sign of a number, indicating whether the number is positive,
   * negative or zero. (ES2018)
   *
   * @param {*} x - A number.
   * @returns {number} A number representing the sign of the given argument. If the argument
   * is a positive number, negative number, positive zero or negative zero, the function will
   * return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned.
   * @example
   * var mathSign = require('math-sign-x').sign2018;
   *
   * mathSign(3);     //  1
   * mathSign(-3);    // -1
   * mathSign('-3');  // -1
   * mathSign(0);     //  0
   * mathSign(-0);    // -0
   * mathSign(NaN);   // NaN
   * mathSign('foo'); // NaN
   * mathSign();      // NaN
   */
  sign2018: $sign2018
};

},{"is-nan-x":116,"to-number-x":84}],81:[function(require,module,exports){
/**
 * @file Parses a string argument and returns an integer of the specified radix.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module parse-int-x
 */

'use strict';

var nativeParseInt = parseInt;
var NAN = require('nan-x');
var toStr = require('to-string-x');
var trimLeft2016 = require('trim-left-x').trimLeft2016;
var trimLeft2018 = require('trim-left-x').trimLeft2018;
var chachedCtrs = require('cached-constructors-x');
var castNumber = chachedCtrs.Number;
var charAt = chachedCtrs.String.prototype.charAt;
var hexRegex = /^[-+]?0[xX]/;
var test = hexRegex.test;

var $parseInt2016 = function parseInt2016(string, radix) {
  var str = trimLeft2016(toStr(string));

  return nativeParseInt(str, castNumber(radix) || (test.call(hexRegex, str) ? 16 : 10));
};

var $parseInt2018 = function parseInt2018(string, radix) {
  var str = trimLeft2018(toStr(string));
  if (charAt.call(str, 0) === '\u180E') {
    return NAN;
  }

  return nativeParseInt(str, castNumber(radix) || (test.call(hexRegex, str) ? 16 : 10));
};

module.exports = {
  /**
   * Reference to parseInt2018.
   */
  parseInt: $parseInt2018,

  /**
   * This method parses a string argument and returns an integer of the specified
   * radix (the base in mathematical numeral systems). (ES2016)
   *
   * @param {string} string - The value to parse. If the string argument is not a
   *  string, then it is converted to a string (using the ToString abstract
   *  operation). Leading whitespace in the string argument is ignored.
   * @param {number} radix - An integer between 2 and 36 that represents the radix
   *  (the base in mathematical numeral systems) of the above mentioned string.
   *  Specify 10 for the decimal numeral system commonly used by humans. Always
   *  specify this parameter to eliminate reader confusion and to guarantee
   *  predictable behavior. Different implementations produce different results
   *  when a radix is not specified, usually defaulting the value to 10.
   * @throws {TypeError} If target is a Symbol or is not coercible.
   * @returns {number} An integer number parsed from the given string. If the first
   *  character cannot be converted to a number, NaN is returned.
   * @example
   * var $parseInt = require('parse-int-x').parseInt2016;
   *
   * // The following examples all return 15
   * $parseInt(' 0xF', 16);
   * $parseInt(' F', 16);
   * $parseInt('17', 8);
   * $parseInt(021, 8);
   * $parseInt('015', 10);   // $parseInt(015, 10); will return 15
   * $parseInt(15.99, 10);
   * $parseInt('15,123', 10);
   * $parseInt('FXX123', 16);
   * $parseInt('1111', 2);
   * $parseInt('15 * 3', 10);
   * $parseInt('15e2', 10);
   * $parseInt('15px', 10);
   * $parseInt('12', 13);
   *
   * //The following examples all return NaN:
   * $parseInt('Hello', 8); // Not a number at all
   * $parseInt('546', 2);   // Digits are not valid for binary representations
   */
  parseInt2016: $parseInt2016,

  /**
   * This method parses a string argument and returns an integer of the specified
   * radix (the base in mathematical numeral systems). (ES2018)
   *
   * @param {string} string - The value to parse. If the string argument is not a
   *  string, then it is converted to a string (using the ToString abstract
   *  operation). Leading whitespace in the string argument is ignored.
   * @param {number} radix - An integer between 2 and 36 that represents the radix
   *  (the base in mathematical numeral systems) of the above mentioned string.
   *  Specify 10 for the decimal numeral system commonly used by humans. Always
   *  specify this parameter to eliminate reader confusion and to guarantee
   *  predictable behavior. Different implementations produce different results
   *  when a radix is not specified, usually defaulting the value to 10.
   * @throws {TypeError} If target is a Symbol or is not coercible.
   * @returns {number} An integer number parsed from the given string. If the first
   *  character cannot be converted to a number, NaN is returned.
   * @example
   * var $parseInt = require('parse-int-x').parseInt2018;
   *
   * // The following examples all return 15
   * $parseInt(' 0xF', 16);
   * $parseInt(' F', 16);
   * $parseInt('17', 8);
   * $parseInt(021, 8);
   * $parseInt('015', 10);   // $parseInt(015, 10); will return 15
   * $parseInt(15.99, 10);
   * $parseInt('15,123', 10);
   * $parseInt('FXX123', 16);
   * $parseInt('1111', 2);
   * $parseInt('15 * 3', 10);
   * $parseInt('15e2', 10);
   * $parseInt('15px', 10);
   * $parseInt('12', 13);
   *
   * //The following examples all return NaN:
   * $parseInt('Hello', 8); // Not a number at all
   * $parseInt('546', 2);   // Digits are not valid for binary representations
   */
  parseInt2018: $parseInt2018
};

},{"cached-constructors-x":35,"nan-x":307,"to-string-x":349,"trim-left-x":350}],82:[function(require,module,exports){
/**
 * @file ToInteger converts 'argument' to an integral numeric value.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger|7.1.4 ToInteger ( argument )}
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-integer-x
 */

'use strict';

var libToNumber = require('to-number-x');
var toNumber2016 = libToNumber.toNumber2016;
var toNumber2018 = libToNumber.toNumber2018;
var numberIsNaN = require('is-nan-x');
var numberIsFinite = require('is-finite-x');
var libMathSign = require('math-sign-x');
var mathSign2016 = libMathSign.sign2016;
var mathSign2018 = libMathSign.sign2018;
var mathFloor = Math.floor;
var mathAbs = Math.abs;

var $toInteger2016 = function toInteger2016(value) {
  var number = toNumber2016(value);
  if (numberIsNaN(number)) {
    return 0;
  }

  if (number === 0 || numberIsFinite(number) === false) {
    return number;
  }

  return mathSign2016(number) * mathFloor(mathAbs(number));
};

var $toInteger2018 = function toInteger2018(value) {
  var number = toNumber2018(value);
  if (numberIsNaN(number)) {
    return 0;
  }

  if (number === 0 || numberIsFinite(number) === false) {
    return number;
  }

  return mathSign2018(number) * mathFloor(mathAbs(number));
};

module.exports = {
  /**
   * Reference to toInteger2018.
   */
  toInteger: $toInteger2018,

  /**
   * Converts `value` to an integer. (ES2016)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   *
   * @example
   * var toInteger = require('to-integer-x').toInteger2016;
   * toInteger(3); // 3
   * toInteger(Number.MIN_VALUE); // 0
   * toInteger(Infinity); // 1.7976931348623157e+308
   * toInteger('3'); // 3
   */
  toInteger2016: $toInteger2016,

  /**
   * Converts `value` to an integer. (ES2018)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   *
   * @example
   * var toInteger = require('to-integer-x').toInteger2018;
   * toInteger(3); // 3
   * toInteger(Number.MIN_VALUE); // 0
   * toInteger(Infinity); // 1.7976931348623157e+308
   * toInteger('3'); // 3
   */
  toInteger2018: $toInteger2018
};

},{"is-finite-x":109,"is-nan-x":116,"math-sign-x":80,"to-number-x":84}],83:[function(require,module,exports){
/**
 * @file Shim for ToLength.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tolength|7.1.15 ToLength ( argument )}
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-length-x
 */

'use strict';

var libToInteger = require('to-integer-x');
var toInteger2016 = libToInteger.toInteger2016;
var toInteger2018 = libToInteger.toInteger2018;
var MAX_SAFE_INTEGER = require('max-safe-integer');

var $toLength2016 = function toLength2016(value) {
  var len = toInteger2016(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

var $toLength2018 = function toLength2018(value) {
  var len = toInteger2018(value);
  // includes converting -0 to +0
  if (len <= 0) {
    return 0;
  }

  if (len > MAX_SAFE_INTEGER) {
    return MAX_SAFE_INTEGER;
  }

  return len;
};

module.exports = {
  /**
   * Reference to toLength2018.
   */
  toLength: $toLength2018,

  /**
   * Converts `value` to an integer suitable for use as the length of an
   * array-like object. (ES2016)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   * var toLength = require('to-length-x').toLength2016;
   * toLength(3); // 3
   * toLength(Number.MIN_VALUE); // 0
   * toLength(Infinity); // Number.MAX_SAFE_INTEGER
   * toLength('3'); // 3
   */
  toLength2016: $toLength2016,

  /**
   * Converts `value` to an integer suitable for use as the length of an
   * array-like object. (ES2018)
   *
   * @param {*} value - The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   * var toLength = require('to-length-x').toLength2018;
   * toLength(3); // 3
   * toLength(Number.MIN_VALUE); // 0
   * toLength(Infinity); // Number.MAX_SAFE_INTEGER
   * toLength('3'); // 3
   */
  toLength2018: $toLength2018
};

},{"max-safe-integer":300,"to-integer-x":82}],84:[function(require,module,exports){
/**
 * @file Converts argument to a value of type Number.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-number-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var castNumber = cachedCtrs.Number;
var Rx = cachedCtrs.RegExp;
var toPrimitive = require('to-primitive-x');
var libTrim = require('trim-x');
var trim2016 = libTrim.trim2016;
var trim2018 = libTrim.trim2018;
var libParseInt = require('parse-int-x');
var $parseInt2016 = libParseInt.parseInt2016;
var $parseInt2018 = libParseInt.parseInt2018;
var pStrSlice = cachedCtrs.String.prototype.slice;
var NAN = require('nan-x');

var binaryRegex = /^0b[01]+$/i;
// Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is
// an own property of regexes. wtf.
var test = binaryRegex.test;
var isBinary = function _isBinary(value) {
  return test.call(binaryRegex, value);
};

var octalRegex = /^0o[0-7]+$/i;
var isOctal = function _isOctal(value) {
  return test.call(octalRegex, value);
};

var nonWSregex2016 = new Rx('[\u0085\u200b\ufffe]', 'g');
var hasNonWS2016 = function _hasNonWS(value) {
  return test.call(nonWSregex2016, value);
};

var nonWSregex2018 = new Rx('[\u0085\u180e\u200b\ufffe]', 'g');
var hasNonWS2018 = function _hasNonWS(value) {
  return test.call(nonWSregex2018, value);
};

var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = function _isInvalidHexLiteral(value) {
  return test.call(invalidHexLiteral, value);
};

var $toNumber2016 = function toNumber2016(argument) {
  var value = toPrimitive(argument, Number);
  if (typeof value === 'symbol') {
    throw new TypeError('Cannot convert a Symbol value to a number');
  }

  if (typeof value === 'string') {
    if (isBinary(value)) {
      return toNumber2016($parseInt2016(pStrSlice.call(value, 2), 2));
    }

    if (isOctal(value)) {
      return toNumber2016($parseInt2016(pStrSlice.call(value, 2), 8));
    }

    if (hasNonWS2016(value) || isInvalidHexLiteral(value)) {
      return NAN;
    }

    var trimmed = trim2016(value);
    if (trimmed !== value) {
      return toNumber2016(trimmed);
    }
  }

  return castNumber(value);
};

var $toNumber2018 = function toNumber2018(argument) {
  var value = toPrimitive(argument, Number);
  if (typeof value === 'symbol') {
    throw new TypeError('Cannot convert a Symbol value to a number');
  }

  if (typeof value === 'string') {
    if (isBinary(value)) {
      return toNumber2018($parseInt2018(pStrSlice.call(value, 2), 2));
    }

    if (isOctal(value)) {
      return toNumber2018($parseInt2018(pStrSlice.call(value, 2), 8));
    }

    if (hasNonWS2018(value) || isInvalidHexLiteral(value)) {
      return NAN;
    }

    var trimmed = trim2018(value);
    if (trimmed !== value) {
      return toNumber2018(trimmed);
    }
  }

  return castNumber(value);
};

module.exports = {
  /**
   * reference to toNumber2018.
   */
  toNumber: $toNumber2018,

  /**
   * This method converts argument to a value of type Number. (ES2016)

   * @param {*} argument - The argument to convert to a number.
   * @throws {TypeError} - If argument is a Symbol or not coercible.
   * @returns {*} The argument converted to a number.
   * @example
   * var toNumber = require('to-number-x').toNumber2016;
   *
   * toNumber('1'); // 1
   * toNumber(null); // 0
   * toNumber(true); // 1
   * toNumber('0o10'); // 8
   * toNumber('0b10'); // 2
   * toNumber('0xF'); // 16
   *
   * toNumber(' 1 '); // 1
   *
   * toNumber(Symbol('')) // TypeError
   * toNumber(Object.create(null)) // TypeError
   */
  toNumber2016: $toNumber2016,

  /**
   * This method converts argument to a value of type Number. (ES2018)

   * @param {*} argument - The argument to convert to a number.
   * @throws {TypeError} - If argument is a Symbol or not coercible.
   * @returns {*} The argument converted to a number.
   * @example
   * var toNumber = require('to-number-x').toNumber2018;
   *
   * toNumber('1'); // 1
   * toNumber(null); // 0
   * toNumber(true); // 1
   * toNumber('0o10'); // 8
   * toNumber('0b10'); // 2
   * toNumber('0xF'); // 16
   *
   * toNumber(' 1 '); // 1
   *
   * toNumber(Symbol('')) // TypeError
   * toNumber(Object.create(null)) // TypeError
   */
  toNumber2018: $toNumber2018
};

},{"cached-constructors-x":35,"nan-x":307,"parse-int-x":81,"to-primitive-x":345,"trim-x":85}],85:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left and right end of a string.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-x
 */

'use strict';

var libTrimLeft = require('trim-left-x');
var trimLeft2016 = libTrimLeft.trimLeft2016;
var trimLeft2018 = libTrimLeft.trimLeft2018;
var libTrimRight = require('trim-right-x');
var trimRight2016 = libTrimRight.trimRight2016;
var trimRight2018 = libTrimRight.trimRight2016;

var $trim2016 = function trim2016(string) {
  return trimLeft2016(trimRight2016(string));
};

var $trim2018 = function trim2018(string) {
  return trimLeft2018(trimRight2018(string));
};

module.exports = {
  /**
   * A reference to trim2018.
   */
  trim: $trim2018,

  /**
   * This method removes whitespace from the left and right end of a string.
   * (ES2016)
   * @param {string} string - The string to trim the whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The trimmed string.
   * @example
   * var trim = require('trim-x');
   *
   * trim(' \t\na \t\n') === 'a'; // true
   */
  trim2016: $trim2016,

  /**
   * This method removes whitespace from the left and right end of a string.
   * (ES2018)
   *
   * @param {string} string - The string to trim the whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The trimmed string.
   * @example
   * var trim = require('trim-x');
   *
   * trim(' \t\na \t\n') === 'a'; // true
   */
  trim2018: $trim2018
};

},{"trim-left-x":350,"trim-right-x":92}],86:[function(require,module,exports){
/**
 * @file This method returns the index of the first element in the array that satisfies the provided testing function.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module find-index-x
 */

'use strict';

var pFindIndex = typeof Array.prototype.findIndex === 'function' && Array.prototype.findIndex;

var isWorking;
if (pFindIndex) {
  var attempt = require('attempt-x');
  var testArr = [];
  testArr.length = 2;
  testArr[1] = 1;
  var res = attempt.call(testArr, pFindIndex, function (item, idx) {
    return idx === 0;
  });

  isWorking = res.threw === false && res.value === 0;

  if (isWorking) {
    res = attempt.call(1, pFindIndex, function (item, idx) {
      return idx === 0;
    });

    isWorking = res.threw === false && res.value === -1;
  }

  if (isWorking) {
    isWorking = attempt.call([], pFindIndex).threw;
  }

  if (isWorking) {
    res = attempt.call('abc', pFindIndex, function (item) {
      return item === 'c';
    });

    isWorking = res.threw === false && res.value === 2;
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }('a', 'b', 'c')), pFindIndex, function (item) {
      return item === 'c';
    });

    isWorking = res.threw === false && res.value === 2;
  }
}

var findIdx;
if (isWorking) {
  findIdx = function findIndex(array, callback) {
    var args = [callback];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return pFindIndex.apply(array, args);
  };
} else {
  var toLength = require('to-length-x');
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');
  var splitIfBoxedBug = require('split-if-boxed-bug-x');

  findIdx = function findIndex(array, callback) {
    var object = toObject(array);
    assertIsFunction(callback);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    if (length < 1) {
      return -1;
    }

    var thisArg;
    if (arguments.length > 2) {
      thisArg = arguments[2];
    }

    var index = 0;
    while (index < length) {
      if (callback.call(thisArg, iterable[index], index, object)) {
        return index;
      }

      index += 1;
    }

    return -1;
  };
}

/**
 * Like `findIndex`, this method returns an index in the array, if an element
 * in the array satisfies the provided testing function. Otherwise -1 is returned.
 *
 * @param {Array} array - The array to search.
 * @throws {TypeError} If array is `null` or `undefined`-
 * @param {Function} callback - Function to execute on each value in the array,
 *  taking three arguments: `element`, `index` and `array`.
 * @throws {TypeError} If `callback` is not a function.
 * @param {*} [thisArg] - Object to use as `this` when executing `callback`.
 * @returns {number} Returns index of positively tested element, otherwise -1.
 * @example
 * var findIndex = require('find-index-x');
 *
 * function isPrime(element, index, array) {
 *   var start = 2;
 *   while (start <= Math.sqrt(element)) {
 *     if (element % start++ < 1) {
 *       return false;
 *     }
 *   }
 *   return element > 1;
 * }
 *
 * console.log(findIndex([4, 6, 8, 12, 14], isPrime)); // -1, not found
 * console.log(findIndex([4, 6, 7, 12, 13], isPrime)); // 2
 */
module.exports = findIdx;

},{"assert-is-function-x":78,"attempt-x":32,"split-if-boxed-bug-x":334,"to-length-x":90,"to-object-x":344}],87:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19,"is-nan-x":116,"to-number-x":91}],88:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"cached-constructors-x":35,"dup":20,"to-string-x":349,"trim-x":353,"white-space-x":357}],89:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21,"is-finite-x":109,"is-nan-x":116,"math-sign-x":87,"to-number-x":91}],90:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22,"max-safe-integer":300,"to-integer-x":89}],91:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"cached-constructors-x":35,"dup":23,"nan-x":307,"parse-int-x":88,"to-primitive-x":345,"trim-x":353}],92:[function(require,module,exports){
/**
 * @file This method removes whitespace from the right end of a string.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-right-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reRight2016 = new Rx('[' + require('white-space-x').string2016 + ']+$');
var reRight2018 = new Rx('[' + require('white-space-x').string2018 + ']+$');
var replace = ''.replace;

var $trimRight2016 = function trimRight2016(string) {
  return replace.call(requireCoercibleToString(string), reRight2016, '');
};

var $trimRight2018 = function trimRight2018(string) {
  return replace.call(requireCoercibleToString(string), reRight2018, '');
};

module.exports = {
  /**
   * A reference to trimRight2018.
   */
  trimRight: $trimRight2018,

  /**
   * This method removes whitespace from the right end of a string. (ES2016)
   *
   * @param {string} string - The string to trim the right end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The right trimmed string.
   * @example
   * var trimRight = require('trim-right-x');
   *
   * trimRight(' \t\na \t\n') === ' \t\na'; // true
   */
  trimRight2016: $trimRight2016,

  /**
   * This method removes whitespace from the right end of a string. (ES2018)
   *
   * @param {string} string - The string to trim the right end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The right trimmed string.
   * @example
   * var trimRight = require('trim-right-x');
   *
   * trimRight(' \t\na \t\n') === ' \t\na'; // true
   */
  trimRight2018: $trimRight2018
};

},{"cached-constructors-x":35,"require-coercible-to-string-x":329,"white-space-x":93}],93:[function(require,module,exports){
/**
 * @file List of ECMAScript white space characters.
 * @version 3.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module white-space-x
 */

'use strict';

/**
 * A record of a white space character.
 *
 * @typedef {Object} CharRecord
 * @property {number} code - The character code.
 * @property {string} description - A description of the character.
 * @property {boolean} es5 - Whether the spec lists this as a white space.
 * @property {boolean} es2015 - Whether the spec lists this as a white space.
 * @property {boolean} es2016 - Whether the spec lists this as a white space.
 * @property {boolean} es2017 - Whether the spec lists this as a white space.
 * @property {boolean} es2018 - Whether the spec lists this as a white space.
 * @property {string} string - The character string.
 */

/**
 * An array of the whitespace char codes, string, descriptions and language
 * presence in the specifications.
 *
 * @private
 * @type Array.<CharRecord>
 */
var list = [
  {
    code: 0x0009,
    description: 'Tab',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u0009'
  },
  {
    code: 0x000a,
    description: 'Line Feed',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000a'
  },
  {
    code: 0x000b,
    description: 'Vertical Tab',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000b'
  },
  {
    code: 0x000c,
    description: 'Form Feed',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000c'
  },
  {
    code: 0x000d,
    description: 'Carriage Return',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u000d'
  },
  {
    code: 0x0020,
    description: 'Space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u0020'
  },
  /*
  {
    code: 0x0085,
    description: 'Next line',
    es5: false,
    es2015: false,
    es2016: false,
    es2017: false,
    es2018: false,
    string: '\u0085'
  }
  */
  {
    code: 0x00a0,
    description: 'No-break space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u00a0'
  },
  {
    code: 0x1680,
    description: 'Ogham space mark',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u1680'
  },
  {
    code: 0x180e,
    description: 'Mongolian vowel separator',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: false,
    es2018: false,
    string: '\u180e'
  },
  {
    code: 0x2000,
    description: 'En quad',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2000'
  },
  {
    code: 0x2001,
    description: 'Em quad',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2001'
  },
  {
    code: 0x2002,
    description: 'En space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2002'
  },
  {
    code: 0x2003,
    description: 'Em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2003'
  },
  {
    code: 0x2004,
    description: 'Three-per-em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2004'
  },
  {
    code: 0x2005,
    description: 'Four-per-em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2005'
  },
  {
    code: 0x2006,
    description: 'Six-per-em space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2006'
  },
  {
    code: 0x2007,
    description: 'Figure space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2007'
  },
  {
    code: 0x2008,
    description: 'Punctuation space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2008'
  },
  {
    code: 0x2009,
    description: 'Thin space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2009'
  },
  {
    code: 0x200a,
    description: 'Hair space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u200a'
  },
  /*
  {
    code: 0x200b,
    description: 'Zero width space',
    es5: false,
    es2015: false,
    es2016: false,
    es2017: false,
    es2018: false,
    string: '\u200b'
  },
  */
  {
    code: 0x2028,
    description: 'Line separator',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2028'
  },
  {
    code: 0x2029,
    description: 'Paragraph separator',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u2029'
  },
  {
    code: 0x202f,
    description: 'Narrow no-break space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u202f'
  },
  {
    code: 0x205f,
    description: 'Medium mathematical space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u205f'
  },
  {
    code: 0x3000,
    description: 'Ideographic space',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\u3000'
  },
  {
    code: 0xfeff,
    description: 'Byte Order Mark',
    es5: true,
    es2015: true,
    es2016: true,
    es2017: true,
    es2018: true,
    string: '\ufeff'
  }
];

var stringES2016 = '';
var stringES2018 = '';
var length = list.length;
for (var i = 0; i < length; i += 1) {
  if (list[i].es2016) {
    stringES2016 += list[i].string;
  }

  if (list[i].es2018) {
    stringES2018 += list[i].string;
  }
}

module.exports = {
  /**
   * An array of the whitespace char codes, string, descriptions and language
   * presence in the specifications.
   *
   * @type Array.<CharRecord>
   * @example
   * var whiteSpace = require('white-space-x');
   * whiteSpaces.list.foreach(function (item) {
   *   console.log(lib.description, item.code, item.string);
   * });
   */
  list: list,
  /**
   * A string of the ES2017 to ES2018 whitespace characters.
   *
   * @type string
   */
  string: stringES2018,

  /**
   * A string of the ES5 to ES2016 whitespace characters.
   *
   * @type string
   */
  string5: stringES2016,

  /**
   * A string of the ES5 to ES2016 whitespace characters.
   *
   * @type string
   */
  string2015: stringES2016,

  /**
   * A string of the ES5 to ES2016 whitespace characters.
   *
   * @type string
   * @example
   * var whiteSpace = require('white-space-x');
   * var characters = [
   *   '\u0009',
   *   '\u000a',
   *   '\u000b',
   *   '\u000c',
   *   '\u000d',
   *   '\u0020',
   *   '\u00a0',
   *   '\u1680',
   *   '\u180e',
   *   '\u2000',
   *   '\u2001',
   *   '\u2002',
   *   '\u2003',
   *   '\u2004',
   *   '\u2005',
   *   '\u2006',
   *   '\u2007',
   *   '\u2008',
   *   '\u2009',
   *   '\u200a',
   *   '\u2028',
   *   '\u2029',
   *   '\u202f',
   *   '\u205f',
   *   '\u3000',
   *   '\ufeff'
   * ];
   * var ws = characters.join('');
   * var re1 = new RegExp('^[' + whiteSpace.string2016 + ']+$)');
   * re1.test(ws); // true
   */
  string2016: stringES2016,

  /**
   * A string of the ES2017 to ES2018 whitespace characters.
   *
   * @type string
   */
  string2017: stringES2018,

  /**
   * A string of the ES2017 to ES2018 whitespace characters.
   *
   * @type string
   * @example
   * var whiteSpace = require('white-space-x');
   * var characters = [
   *   '\u0009',
   *   '\u000a',
   *   '\u000b',
   *   '\u000c',
   *   '\u000d',
   *   '\u0020',
   *   '\u00a0',
   *   '\u1680',
   *   '\u2000',
   *   '\u2001',
   *   '\u2002',
   *   '\u2003',
   *   '\u2004',
   *   '\u2005',
   *   '\u2006',
   *   '\u2007',
   *   '\u2008',
   *   '\u2009',
   *   '\u200a',
   *   '\u2028',
   *   '\u2029',
   *   '\u202f',
   *   '\u205f',
   *   '\u3000',
   *   '\ufeff'
   * ];
   * var ws = characters.join('');
   * var re1 = new RegExp('^[' + whiteSpace.string2018 + ']+$)');
   * re1.test(ws); // true
   */
  string2018: stringES2018
};

},{}],94:[function(require,module,exports){
/**
 * @file The constant value Infinity.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module infinity-x
 */

'use strict';

/**
 * The constant value Infinity derived mathematically by 1 / 0.
 *
 * @type number
 * @example
 * var INFINITY = require('infinity-x');
 *
 * INFINITY === Infinity; // true
 * -INFINITY === -Infinity; // true
 * INFINITY === -Infinity; // false
 */
module.exports = 1 / 0;

},{}],95:[function(require,module,exports){
/**
 * @file An implementation of node's ES6 inspect module.
 * @version 1.9.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @see https://nodejs.org/api/util.html#util_util_inspect_object_options
 * @module inspect-x
 */

'use strict';

var isFunction = require('is-function-x');
var isGeneratorFunction = require('is-generator-function');
var isAsyncFunction = require('is-async-function-x');
var isRegExp = require('is-regex');
var defineProperties = require('object-define-properties-x');
var isDate = require('is-date-object');
var isArrayBuffer = require('is-array-buffer-x');
var isSet = require('is-set-x');
var isMap = require('is-map-x');
var isTypedArray = require('is-typed-array');
var isDataView = require('is-data-view-x');
var isUndefined = require('validate.io-undefined');
var isNil = require('is-nil-x');
var isNull = require('lodash.isnull');
var isError = require('is-error-x');
var isObjectLike = require('is-object-like-x');
var isPromise = require('is-promise');
var isString = require('is-string');
var isNumber = require('is-number-object');
var isBoolean = require('is-boolean-object');
var isNegZero = require('is-negative-zero');
var isSymbol = require('is-symbol');
var isPrimitive = require('is-primitive');
var getFunctionName = require('get-function-name-x');
var hasSymbolSupport = require('has-symbol-support-x');
var hasOwn = require('has-own-property-x');
var whiteSpace = require('white-space-x');
var reSingle = new RegExp('\\{[' + whiteSpace.string + ']+\\}');
var hasSet = typeof Set === 'function' && isSet(new Set());
var testSet = hasSet && new Set(['SetSentinel']);
var sForEach = hasSet && Set.prototype.forEach;
var sValues = hasSet && Set.prototype.values;
var hasMap = typeof Map === 'function' && isMap(new Map());
var testMap = hasMap && new Map([[1, 'MapSentinel']]);
var mForEach = hasMap && Map.prototype.forEach;
var mValues = hasMap && Map.prototype.values;
var pSymToStr = hasSymbolSupport && Symbol.prototype.toString;
var pSymValOf = hasSymbolSupport && Symbol.prototype.valueOf;
var indexOf = require('index-of-x');
var reduce = require('array-reduce-x');
var forEach = require('array-for-each-x');
var filter = require('array-filter-x');
var reflectOwnKeys = require('reflect-own-keys-x');
var $stringify = require('json3').stringify;
var $keys = require('object-keys-x');
var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
var $getPrototypeOf = require('get-prototype-of-x');
var $propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var $isArray = require('is-array-x');
var $includes = require('array-includes-x');
var $assign = require('object-assign-x');
var $isNaN = require('is-nan');
var pRegExpToString = RegExp.prototype.toString;
var pErrorToString = Error.prototype.toString;
var pNumberToString = Number.prototype.toString;
var pBooleanToString = Boolean.prototype.toString;
var toISOString = require('to-iso-string-x');
var collections = require('collections-x');
var defineProperty = require('object-define-property-x');
// var hasToStringTag = hasSymbolSupport && typeof Symbol.toStringTag === 'symbol';
var bpe = 'BYTES_PER_ELEMENT';
var inspect;
var fmtValue;

var customInspectSymbol = hasSymbolSupport ? Symbol('inspect.custom') : '_inspect.custom_';

var supportsClasses;
try {
  // eslint-disable-next-line no-new-func
  new Function('return class My {}')();
  supportsClasses = true;
} catch (e) {}

var supportsGetSet;
try {
  var testVar;
  var testObject = defineProperty({}, 'defaultOptions', {
    get: function _get() {
      return testVar;
    },
    set: function _set(val) {
      testVar = val;
      return testVar;
    }
  });

  testObject.defaultOptions = 'test';
  supportsGetSet = testVar === 'test' && testObject.defaultOptions === 'test';
} catch (ignore) {}

var $seal = isFunction(Object.seal) ? Object.seal : function seal(obj) {
  return obj;
};

var $getOwnPropertySymbols = isFunction(Object.getOwnPropertySymbols) && Object.getOwnPropertySymbols;
if ($getOwnPropertySymbols) {
  try {
    var gOPSymbol = hasSymbolSupport && Symbol('');
    var gOPSObj = { a: 1 };
    gOPSObj[gOPSymbol] = 2;

    var gOPSymbols = $getOwnPropertySymbols(gOPSObj);
    if (gOPSymbol) {
      if (gOPSymbols.length !== 1 || gOPSymbols[0] !== gOPSymbol) {
        throw new Error('Inavlid result');
      }
    } else if (gOPSymbols.length !== 0) {
      throw new Error('Inavlid result');
    }
  } catch (ignore) {
    $getOwnPropertySymbols = null;
  }
}

var missingError;
var errProps;
try {
  throw new Error('test');
} catch (e) {
  errProps = $keys(e);
  forEach($keys(new Error()), function _pusher(p) {
    if ($includes(errProps, p) === false) {
      errProps.push(p);
    }
  });

  var errorString = pErrorToString.call(e);
  var errorStack = e.stack;
  if (errorStack) {
    var errorRx = new RegExp('^' + errorString);
    if (errorRx.test(errorStack) === false) {
      missingError = true;
    }
  }
}

if (isDate(Date.prototype)) {
  isDate = function _isDate(value) {
    try {
      value.getTime();
      return true;
    } catch (ignore) {
      return false;
    }
  };
}

var dateProps = $keys(Date);
var shimmedDate;
if (dateProps.length && $includes(dateProps, 'now') && $includes(dateProps, 'UTC') && $includes(dateProps, 'parse')) {
  shimmedDate = $includes($keys(new Date()), 'constructor');
}

var inspectDefaultOptions = $seal({
  breakLength: 60,
  colors: false,
  customInspect: true,
  depth: 2,
  maxArrayLength: 100,
  showHidden: false,
  showProxy: false
});

var isBooleanType = function _isBooleanType(arg) {
  return typeof arg === 'boolean';
};

var isNumberType = function _isNumberType(arg) {
  return typeof arg === 'number';
};

var isStringType = function _isStringType(arg) {
  return typeof arg === 'string';
};

var isSymbolType = function _isSymbolType(arg) {
  return typeof arg === 'symbol';
};

var isMapIterator = function _isMapIterator(value) {
  if (hasMap === false || isObjectLike(value) === false) {
    return false;
  }

  try {
    return value.next.call(mValues.call(testMap)).value === 'MapSentinel';
  } catch (ignore) {}

  return false;
};

var isSetIterator = function _isSetIterator(value) {
  if (hasSet === false || isObjectLike(value) === false) {
    return false;
  }

  try {
    return value.next.call(sValues.call(testSet)).value === 'SetSentinel';
  } catch (ignore) {}

  return false;
};

var filterIndexes = function _filterIndexes(keys, length) {
  var i = keys.length - 1;
  while (i > -1) {
    var key = keys[i];
    if (key > -1 && key % 1 === 0 && key < length && isSymbolType(key) === false) {
      keys.splice(i, 1);
    }

    i -= 1;
  }
};

var pushUniq = function _pushUniq(arr, value) {
  if ($includes(arr, value) === false) {
    arr.push(value);
  }
};

var unshiftUniq = function _unshiftUniq(arr, value) {
  var index = indexOf(arr, value);
  if (index > -1) {
    arr.splice(index, 1);
  }

  arr.unshift(value);
};

var stylizeWithColor = function _stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    var colors = inspect.colors[style];
    return '\u001b[' + colors[0] + 'm' + str + '\u001b[' + colors[1] + 'm';
  }

  return str;
};

var stylizeNoColor = function _stylizeNoColor(str) {
  return str;
};

var getNameSep = function _getNameSep(obj) {
  var name = getFunctionName(obj);
  return name ? ': ' + name : name;
};

var collectionEach = function _collectionEach(collection, callback) {
  if (isMap(collection)) {
    mForEach.call(collection, callback);
  } else if (isSet(collection)) {
    sForEach.call(collection, callback);
  }
};

var getConstructorOf = function _getConstructorOf(obj) {
  var o = obj;
  var maxLoop = 100;
  while (isNil(o) === false && maxLoop > -1) {
    o = Object(o);
    var descriptor = getOwnPropertyDescriptor(o, 'constructor');
    if (descriptor && descriptor.value) {
      return descriptor.value;
    }

    o = $getPrototypeOf(o);
    maxLoop -= 1;
  }

  return null;
};

var isSub = function _isSub(value) {
  if (supportsClasses !== true || isPrimitive(value)) {
    return false;
  }

  var constructor = getConstructorOf(value);
  return isFunction(constructor) === false && isFunction(constructor, true);
};

var getSubName = function _getSubName(value, name) {
  if (isSub(value)) {
    var subName = getFunctionName(getConstructorOf(value));
    if (subName && subName !== name) {
      return subName;
    }
  }

  return name ? name : getFunctionName(getConstructorOf(value));
};

var fmtNumber = function _fmtNumber(ctx, value) {
  // Format -0 as '-0'.
  return ctx.stylize(isNegZero(value) ? '-0' : pNumberToString.call(value), 'number');
};

var fmtPrimitive = function _fmtPrimitive(ctx, value) {
  if (isNil(value)) {
    var str = String(value);
    return ctx.stylize(str, str);
  }

  if (isStringType(value)) {
    var simple = $stringify(value).replace(/^"|"$/g, '').replace(/'/g, '\\\'').replace(/\\"/g, '"');
    return ctx.stylize('\'' + simple + '\'', 'string');
  }

  if (isNumberType(value)) {
    return fmtNumber(ctx, value);
  }

  if (isBooleanType(value)) {
    return ctx.stylize(pBooleanToString.call(value), 'boolean');
  }

  // es6 symbol primitive
  if (isSymbolType(value)) {
    return ctx.stylize(pSymToStr.call(value), 'symbol');
  }

  return void 0;
};

var fmtPrimNoColor = function _fmtPrimNoColor(ctx, value) {
  var stylize = ctx.stylize;
  ctx.stylize = stylizeNoColor;
  var str = fmtPrimitive(ctx, value);
  ctx.stylize = stylize;
  return str;
};

var recurse = function _recurse(depth) {
  return isNull(depth) ? null : depth - 1;
};

/*
var isCollection = function (value) {
  return isSet(value) || isMap(value);
};
*/

var isDigits = function _isDigits(key) {
  return (/^\d+$/).test(key);
};

// eslint-disable-next-line max-params
var fmtProp = function _fmtProp(ctx, value, depth, visibleKeys, key, arr) {
  var desc = getOwnPropertyDescriptor(value, key) || { value: value[key] };

  /*
  // this is a fix for broken FireFox, should not be needed with es6-shim
  if (key === 'size' && isCollection(value) && isFunction(value.size)) {
    desc.value = value.size();
  }
  */

  var name;
  if ($includes(visibleKeys, key) === false) {
    if (key === bpe && Boolean(value[bpe]) === false && isTypedArray(value)) {
      var constructor = getConstructorOf(value);
      if (constructor) {
        desc.value = constructor[bpe];
      }
    } else if (isSymbolType(key)) {
      name = '[' + ctx.stylize(pSymToStr.call(key), 'symbol') + ']';
    } else {
      name = '[' + key + ']';
    }
  }

  var str;
  if (desc.get) {
    str = ctx.stylize(desc.set ? '[Getter/Setter]' : '[Getter]', 'special');
  } else if (desc.set) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = fmtValue(ctx, desc.value, recurse(depth));
    if (str.indexOf('\n') > -1) {
      var rx = arr ? /\n/g : /(^|\n)/g;
      var rStr = arr ? '\n  ' : '\n   ';
      str = str.replace(rx, rStr);
    }
  }

  if (isUndefined(name)) {
    if (arr && isDigits(key)) {
      return str;
    }

    name = $stringify(key);
    if (/^"[\w$]+"$/.test(name)) {
      name = ctx.stylize(name.slice(1, -1), 'name');
    } else {
      name = name.replace(/'/g, '\\\'').replace(/\\"/g, '"').replace(/(^"|"$)/g, '\'').replace(/\\\\/g, '\\');
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
};

// eslint-disable-next-line max-params
var fmtObject = function _fmtObject(ctx, value, depth, visibleKeys, keys) {
  var out = [];
  forEach(keys, function _pusherFmObject(key) {
    out.push(fmtProp(ctx, value, depth, visibleKeys, key, false));
  });

  return out;
};

// eslint-disable-next-line max-params
var fmtArray = function _fmtArray(ctx, value, depth, visibleKeys, keys) {
  var output = [];
  var visibleLength = 0;
  var index = 0;
  while (index < value.length && visibleLength < ctx.maxArrayLength) {
    var emptyItems = 0;
    while (index < value.length && hasOwn(value, pNumberToString.call(index)) === false) {
      emptyItems += 1;
      index += 1;
    }

    if (emptyItems > 0) {
      var ending = emptyItems > 1 ? 's' : '';
      var message = '<' + emptyItems + ' empty item' + ending + '>';
      output.push(ctx.stylize(message, 'undefined'));
    } else {
      output.push(fmtProp(ctx, value, depth, visibleKeys, pNumberToString.call(index), true));
      index += 1;
    }

    visibleLength += 1;
  }

  var remaining = value.length - index;
  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }

  forEach(keys, function _pusherFmtArray(key) {
    if (isSymbolType(key) || isDigits(key) === false) {
      output.push(fmtProp(ctx, value, depth, visibleKeys, key, true));
    }
  });

  return output;
};

// eslint-disable-next-line max-params
var fmtTypedArray = function _fmtTypedArray(ctx, value, depth, visibleKeys, keys) {
  var maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  var remaining = value.length - maxLength;
  var output = new Array(maxLength);
  for (var i = 0; i < maxLength; i += 1) {
    output[i] = fmtNumber(ctx, value[i]);
  }

  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }

  forEach(keys, function _pusherFmtTypedArray(key) {
    if (isSymbolType(key) || isDigits(key) === false) {
      output.push(fmtProp(ctx, value, depth, visibleKeys, key, true));
    }
  });

  return output;
};

// eslint-disable-next-line max-params
var fmtSet = function _fmtSet(ctx, value, depth, visibleKeys, keys) {
  var out = [];
  collectionEach(value, function _pusherFmtSet1(v) {
    out.push(fmtValue(ctx, v, recurse(depth)));
  });

  forEach(keys, function _pusherFmtSet2(key) {
    out.push(fmtProp(ctx, value, depth, visibleKeys, key, false));
  });

  return out;
};

// eslint-disable-next-line max-params
var fmtMap = function (ctx, value, depth, visibleKeys, keys) {
  var out = [];
  collectionEach(value, function (v, k) {
    var r = recurse(depth);
    out.push(fmtValue(ctx, k, r) + ' => ' + fmtValue(ctx, v, r));
  });

  forEach(keys, function (key) {
    out.push(fmtProp(ctx, value, depth, visibleKeys, key, false));
  });

  return out;
};

var reduceToSingleString = function _reduceToSingleString(out, base, braces) {
  var length = reduce(out, function _reducer(prev, cur) {
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  var result;
  if (length > 60) {
    // If the opening "brace" is too large, like in the case of "Set {",
    // we need to force the first item to be on the next line or the
    // items will not line up correctly.
    var layoutBase = base === '' && braces[0].length === 1 ? '' : base + '\n ';
    result = braces[0] + layoutBase + ' ' + out.join(',\n  ') + ' ' + braces[1];
  } else {
    result = braces[0] + base + ' ' + out.join(', ') + ' ' + braces[1];
  }

  return result.replace(reSingle, '{}');
};

var fmtDate = function _fmtDate(value) {
  return $isNaN(value.getTime()) ? 'Invalid Date' : toISOString(value);
};

var fmtError = function _fmtError(value) {
  var stack = value.stack;
  if (stack) {
    if (supportsClasses) {
      var subName = getSubName(value);
      if (subName && stack.startsWith(subName) === false) {
        var msg = value.message;
        return stack.replace(pErrorToString.call(value), subName + (msg ? ': ' + msg : ''));
      }
    } else if (missingError) {
      return pErrorToString.call(value) + '\n' + stack;
    }
  }

  return stack || '[' + pErrorToString.call(value) + ']';
};

var filterDateKeys = function _filterDateKeys(key) {
  return key !== 'constructor';
};

var filterErrorKeys = function _filterErrorKeys(key) {
  return $includes(errProps, key) === false;
};

var getVisibleKeys = function _getVisibleKeys(value) {
  var keys = $keys(value);
  if (keys.length > 0) {
    if (shimmedDate && isDate(value)) {
      return filter(keys, filterDateKeys);
    }

    if (errProps.length > 0 && isError(value)) {
      return filter(keys, filterErrorKeys);
    }
  }

  return keys;
};

var getEnumSymbols = function _getEnumSymbols(value) {
  if ($getOwnPropertySymbols) {
    return filter($getOwnPropertySymbols(value), function _filterEnumSymbolKeys(key) {
      return $propertyIsEnumerable.call(value, key);
    });
  }

  return [];
};

// eslint-disable-next-line complexity
fmtValue = function _fmtValue(ctx, value, depth) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value) {
    var maybeCustomInspect = value[customInspectSymbol] || value.inspect;
    if (isFunction(maybeCustomInspect)) {
      // Filter out the util module, its inspect function is special
      if (maybeCustomInspect !== inspect) {
        var constructor = getConstructorOf(value);
        // Also filter out any prototype objects using the circular check.
        var isCircular = constructor && constructor.prototype === value;
        if (isCircular === false) {
          var ret = maybeCustomInspect.call(value, depth, ctx);
          // If the custom inspection method returned `this`, don't go into
          // infinite recursion.
          // eslint-disable-next-line max-depth
          if (ret !== value) {
            return isStringType(ret) ? ret : fmtValue(ctx, ret, depth);
          }
        }
      }
    }
  }

  // Primitive types cannot have properties
  var primitive = fmtPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var visibleKeys = getVisibleKeys(value);
  var keys;
  if (ctx.showHidden) {
    keys = reflectOwnKeys(value);
    if (isError(value)) {
      if ($includes(visibleKeys, 'message') === false && $includes(keys, 'message') === false) {
        unshiftUniq(keys, 'message');
      }

      /*
      if (includes(visibleKeys, 'name') === false && includes(keys, 'name') === false) {
        unshiftUniq(keys, 'name');
      }
      */
    }
  } else {
    keys = visibleKeys.concat(getEnumSymbols(value));
  }

  if (isString(value)) {
    // for boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisey up the out and are redundant
    filterIndexes(keys, value.length);
    filterIndexes(visibleKeys, value.length);
  } else if (isArrayBuffer(value)) {
    filterIndexes(keys, value.byteLength);
    filterIndexes(visibleKeys, value.byteLength);
  }

  var name;
  var formatted;
  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    // This could be a boxed primitive (new String(), etc.)
    if (isString(value)) {
      return ctx.stylize(
        '[' + getSubName(value, 'String') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']',
        'string'
      );
    }

    if (isNumber(value)) {
      return ctx.stylize(
        '[' + getSubName(value, 'Number') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']',
        'number'
      );
    }

    if (isBoolean(value)) {
      return ctx.stylize(
        '[' + getSubName(value, 'Boolean') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']',
        'boolean'
      );
    }

    if (isSymbol(value)) {
      return ctx.stylize(
        '[Symbol: ' + fmtPrimNoColor(ctx, pSymValOf.call(value)) + ']',
        'symbol'
      );
    }

    if (isAsyncFunction(value)) {
      return ctx.stylize('[AsyncFunction' + getNameSep(value) + ']', 'special');
    }

    if (isGeneratorFunction(value)) {
      return ctx.stylize('[GeneratorFunction' + getNameSep(value) + ']', 'special');
    }

    if (isFunction(value)) {
      return ctx.stylize('[' + getSubName(value, 'Function') + getNameSep(value) + ']', 'special');
    }

    if (supportsClasses && isFunction(value, true)) {
      return ctx.stylize('[Class' + getNameSep(value) + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(pRegExpToString.call(value), 'regexp');
    }

    if (isDate(value)) {
      name = getSubName(value);
      formatted = ctx.stylize(fmtDate(value), 'date');
      if (name === 'Date') {
        return formatted;
      }

      return ctx.stylize('[' + name + ': ' + formatted + ']', 'date');
    }

    if (isError(value)) {
      return fmtError(value);
    }

    // Fast path for ArrayBuffer. Can't do the same for DataView because it
    // has a non-primitive buffer property that we need to recurse for.
    if (isArrayBuffer(value)) {
      return getSubName(value, 'ArrayBuffer') + ' { byteLength: ' + fmtNumber(ctx, value.byteLength) + ' }';
    }

    if (isMapIterator(value)) {
      return getSubName(value, 'MapIterator') + ' {}';
    }

    if (isSetIterator(value)) {
      return getSubName(value, 'SetIterator') + ' {}';
    }

    if (isPromise(value)) {
      return getSubName(value, 'Promise') + ' {}';
    }
  }

  var base = '';
  var empty = false;
  var braces = ['{', '}'];
  var fmtter = fmtObject;
  // We can't compare constructors for various objects using a comparison
  // like `constructor === Array` because the object could have come from a
  // different context and thus the constructor won't match. Instead we check
  // the constructor names (including those up the prototype chain where
  // needed) to determine object types.
  if (isString(value)) {
    // Make boxed primitive Strings look like such
    base = '[' + getSubName(value, 'String') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']';
  } else if (isNumber(value)) {
    // Make boxed primitive Numbers look like such
    base = '[' + getSubName(value, 'Number') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']';
  } else if (isBoolean(value)) {
    // Make boxed primitive Booleans look like such
    base = '[' + getSubName(value, 'Boolean') + ': ' + fmtPrimNoColor(ctx, value.valueOf()) + ']';
  } else if (isFunction(value)) {
    // Make functions say that they are functions
    base = '[' + getSubName(value, 'Function') + getNameSep(value) + ']';
  } else if (supportsClasses && isFunction(value, true)) {
    // Make functions say that they are functions
    base = '[Class' + getNameSep(value) + ']';
  } else if (isRegExp(value)) {
    // Make RegExps say that they are RegExps
    // name = getSubName(value, 'RegExp');
    base = pRegExpToString.call(value);
  } else if (isDate(value)) {
    // Make dates with properties first say the date
    name = getSubName(value);
    formatted = fmtDate(value);
    if (name === 'Date') {
      base = formatted;
    } else {
      base = '[' + name + ': ' + formatted + ']';
    }
  } else if (isError(value)) {
    name = getSubName(value);
    // Make error with message first say the error
    base = fmtError(value);
  } else if ($isArray(value)) {
    name = getSubName(value);
    // Unset the constructor to prevent "Array [...]" for ordinary arrays.
    name = name === 'Array' ? '' : name;
    braces = ['[', ']'];
    if (ctx.showHidden) {
      unshiftUniq(keys, 'length');
    }

    empty = value.length === 0;
    fmtter = fmtArray;
  } else if (isSet(value)) {
    name = getSubName(value, 'Set');
    fmtter = fmtSet;
    // With `showHidden`, `length` will display as a hidden property for
    // arrays. For consistency's sake, do the same for `size`, even though
    // this property isn't selected by Object.getOwnPropertyNames().
    if (ctx.showHidden) {
      unshiftUniq(keys, 'size');
    }

    empty = value.size === 0;
  } else if (isMap(value)) {
    name = getSubName(value, 'Map');
    fmtter = fmtMap;
    // With `showHidden`, `length` will display as a hidden property for
    // arrays. For consistency's sake, do the same for `size`, even though
    // this property isn't selected by Object.getOwnPropertyNames().
    if (ctx.showHidden) {
      unshiftUniq(keys, 'size');
    }

    empty = value.size === 0;
  } else if (isArrayBuffer(value)) {
    name = getSubName(value, 'ArrayBuffer');
    unshiftUniq(keys, 'byteLength');
    pushUniq(visibleKeys, 'byteLength');
  } else if (isDataView(value)) {
    name = getSubName(value, 'DataView');
    unshiftUniq(keys, 'buffer');
    unshiftUniq(keys, 'byteOffset');
    unshiftUniq(keys, 'byteLength');
    pushUniq(visibleKeys, 'byteLength');
    pushUniq(visibleKeys, 'byteOffset');
    pushUniq(visibleKeys, 'buffer');
  } else if (isTypedArray(value)) {
    name = getSubName(value);
    braces = ['[', ']'];
    fmtter = fmtTypedArray;
    if (ctx.showHidden) {
      unshiftUniq(keys, 'buffer');
      unshiftUniq(keys, 'byteOffset');
      unshiftUniq(keys, 'byteLength');
      unshiftUniq(keys, 'length');
      unshiftUniq(keys, bpe);
    }
  } else if (isPromise(value)) {
    name = getSubName(value, 'Promise');
  } else if (isMapIterator(value)) {
    name = getSubName(value, 'MapIterator');
    empty = true;
  } else if (isSetIterator(value)) {
    name = getSubName(value, 'SetIterator');
    empty = true;
  } else {
    name = getSubName(value);
    // Unset the constructor to prevent "Object {...}" for ordinary objects.
    name = name === 'Object' ? '' : name;
    empty = true; // No other data than keys.
  }

  if (base) {
    base = ' ' + base;
  } else if (name) {
    // Add constructor name if available
    braces[0] = name + ' ' + braces[0];
  }

  empty = empty === true && keys.length === 0;
  if (empty) {
    return braces[0] + base + braces[1];
  }

  if (depth < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(pRegExpToString.call(value), 'regexp');
    } else if ($isArray(value)) {
      return ctx.stylize('[Array]', 'special');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  if (ctx.seen.has(value)) {
    return ctx.stylize('[Circular]', 'special');
  }

  ctx.seen.add(value);
  var out = fmtter(ctx, value, depth, visibleKeys, keys);
  ctx.seen['delete'](value);
  return reduceToSingleString(out, base, braces);
};

inspect = function _inspect(obj, opts) {
  // default options
  var ctx = {
    seen: new collections.Set(),
    stylize: stylizeNoColor
  };

  // legacy...
  if (arguments.length >= 3 && isUndefined(arguments[2]) === false) {
    ctx.depth = arguments[2];
  }

  if (arguments.length >= 4 && isUndefined(arguments[3]) === false) {
    ctx.colors = arguments[3];
  }

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  }

  // Set default and user-specified options
  if (supportsGetSet) {
    ctx = $assign({}, inspect.defaultOptions, ctx, opts);
  } else {
    ctx = $assign({}, inspectDefaultOptions, inspect.defaultOptions, ctx, opts);
  }

  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }

  if (isNull(ctx.maxArrayLength)) {
    ctx.maxArrayLength = Infinity;
  }

  return fmtValue(ctx, obj, ctx.depth);
};

if (supportsGetSet) {
  defineProperty(inspect, 'defaultOptions', {
    get: function _get() {
      return inspectDefaultOptions;
    },
    set: function _set(options) {
      if (isObjectLike(options) === false) {
        throw new TypeError('"options" must be an object');
      }

      return $assign(inspectDefaultOptions, options);
    }
  });
} else {
  defineProperties(inspect, {
    defaultOptions: {
      value: $assign({}, inspectDefaultOptions),
      writable: true
    }
  });
}

defineProperties(inspect, {
  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  colors: {
    value: {
      black: [30, 39],
      blue: [34, 39],
      bold: [1, 22],
      cyan: [36, 39],
      green: [32, 39],
      grey: [90, 39],
      inverse: [7, 27],
      italic: [3, 23],
      magenta: [35, 39],
      red: [31, 39],
      underline: [4, 24],
      white: [37, 39],
      yellow: [33, 39]
    }
  },
  custom: {
    value: customInspectSymbol
  },
  // Don't use 'blue' not visible on cmd.exe
  styles: {
    value: {
      'boolean': 'yellow',
      date: 'magenta',
      // name: intentionally not styling
      'null': 'bold',
      number: 'yellow',
      regexp: 'red',
      special: 'cyan',
      string: 'green',
      symbol: 'green',
      undefined: 'grey'
    }
  }
});

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 * Values may supply their own custom `inspect(depth, opts)` functions,
 * when called they receive the current depth in the recursive inspection,
 * as well as the options object passed to `inspect`.
 *
 * @param {Object} obj - The object to print out.
 * @param {Object} [opts] - Options object that alters the out.
 * @returns {string} The string representation.
 * @example
 * var inspect = require('inspect-x');
 *
 * console.log(inspect(inspect, { showHidden: true, depth: null }));
 * //{ [Function: inspect]
 * //  [length]: 2,
 * //  [name]: 'inspect',
 * //  [prototype]: inspect { [constructor]: [Circular] },
 * //  [colors]:
 * //   { [bold]: [ 1, 22, [length]: 2 ],
 * //     [italic]: [ 3, 23, [length]: 2 ],
 * //     [underline]: [ 4, 24, [length]: 2 ],
 * //     [inverse]: [ 7, 27, [length]: 2 ],
 * //     [white]: [ 37, 39, [length]: 2 ],
 * //     [grey]: [ 90, 39, [length]: 2 ],
 * //     [black]: [ 30, 39, [length]: 2 ],
 * //     [blue]: [ 34, 39, [length]: 2 ],
 * //     [cyan]: [ 36, 39, [length]: 2 ],
 * //     [green]: [ 32, 39, [length]: 2 ],
 * //     [magenta]: [ 35, 39, [length]: 2 ],
 * //     [red]: [ 31, 39, [length]: 2 ],
 * //     [yellow]: [ 33, 39, [length]: 2 ] },
 * //  [styles]:
 * //   { [special]: 'cyan',
 * //     [number]: 'yellow',
 * //     [boolean]: 'yellow',
 * //     [undefined]: 'grey',
 * //     [null]: 'bold',
 * //     [string]: 'green',
 * //     [symbol]: 'green',
 * //     [date]: 'magenta',
 * //     [regexp]: 'red' } }
 */
module.exports = inspect;

},{"array-filter-x":7,"array-for-each-x":8,"array-includes-x":9,"array-reduce-x":17,"collections-x":41,"get-function-name-x":62,"get-prototype-of-x":68,"has-own-property-x":96,"has-symbol-support-x":72,"index-of-x":77,"is-array-buffer-x":99,"is-array-x":101,"is-async-function-x":102,"is-boolean-object":103,"is-data-view-x":105,"is-date-object":106,"is-error-x":107,"is-function-x":110,"is-generator-function":111,"is-map-x":115,"is-nan":118,"is-negative-zero":121,"is-nil-x":122,"is-number-object":123,"is-object-like-x":124,"is-primitive":126,"is-promise":127,"is-regex":128,"is-set-x":133,"is-string":134,"is-symbol":136,"is-typed-array":137,"json3":138,"lodash.isnull":139,"object-assign-x":312,"object-define-properties-x":317,"object-define-property-x":318,"object-get-own-property-descriptor-x":97,"object-keys-x":320,"reflect-own-keys-x":327,"to-iso-string-x":338,"validate.io-undefined":356,"white-space-x":357}],96:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42,"es-to-primitive/es6":50,"is-symbol":136,"safe-to-string-x":331,"to-object-x":344}],97:[function(require,module,exports){
/**
 * @file Sham for ES6 Object.getOwnPropertyDescriptor
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-get-own-property-descriptor-x
 */

'use strict';

var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getOPDFallback;

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3

var doesGOPDWork = function (object) {
  try {
    object.sentinel = 0;
    return $getOwnPropertyDescriptor(object, 'sentinel').value === 0;
  } catch (ignore) {
    return false;
  }
};

// check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
if ($getOwnPropertyDescriptor) {
  var getOPDWorksOnObject = doesGOPDWork({});
  var getOPDWorksOnDom = typeof document === 'undefined' || doesGOPDWork(document.createElement('div'));
  if (getOPDWorksOnDom === false || getOPDWorksOnObject === false) {
    getOPDFallback = $getOwnPropertyDescriptor;
  }
}

var toObject;
if ($getOwnPropertyDescriptor && Boolean(getOPDFallback) === false) {
  try {
    $getOwnPropertyDescriptor(42, 'name');
  } catch (err) {
    toObject = require('to-object-x');
    $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
      return $getOwnPropertyDescriptor(toObject(object), property);
    };
  }
} else if (Boolean($getOwnPropertyDescriptor) === false || getOPDFallback) {
  toObject = require('to-object-x');
  var owns = require('has-own-property-x');
  var prototypeOfObject = Object.prototype;

  var propertyIsEnumerable = prototypeOfObject.propertyIsEnumerable;
  var isEnumerable = function (object, property) {
    return propertyIsEnumerable.call(object, property);
  };

  // If JS engine supports accessors creating shortcuts.
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
  if (supportsAccessors) {
    // eslint-disable-next-line no-underscore-dangle
    var lg = prototypeOfObject.__lookupGetter__;
    // eslint-disable-next-line no-underscore-dangle
    var ls = prototypeOfObject.__lookupSetter__;
    lookupGetter = function (object, property) {
      return lg.call(object, property);
    };

    lookupSetter = function (object, property) {
      return ls.call(object, property);
    };
  }

  $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
    var obj = toObject(object);

    // make a valiant attempt to use the real getOwnPropertyDescriptor
    // for I8's DOM elements.
    if (getOPDFallback) {
      try {
        return getOPDFallback.call(Object, obj, property);
      } catch (ignore) {
        // try the shim if the real one doesn't work
      }
    }

    var descriptor;

    // If object does not owns property return undefined immediately.
    if (owns(obj, property) === false) {
      return descriptor;
    }

    // If object has a property then it's for sure `configurable`, and
    // probably `enumerable`. Detect enumerability though.
    descriptor = {
      configurable: true,
      enumerable: isEnumerable(obj, property)
    };

    // If JS engine supports accessor properties then property may be a
    // getter or setter.
    if (supportsAccessors) {
      // Unfortunately `__lookupGetter__` will return a getter even
      // if object has own non getter property along with a same named
      // inherited getter. To avoid misbehavior we temporary remove
      // `__proto__` so that `__lookupGetter__` will return getter only
      // if it's owned by an object.
      // eslint-disable-next-line no-proto
      var prototype = obj.__proto__;
      var notPrototypeOfObject = obj !== prototypeOfObject;
      // avoid recursion problem, breaking in Opera Mini when
      // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
      // or any other Object.prototype accessor
      if (notPrototypeOfObject) {
        // eslint-disable-next-line no-proto
        object.__proto__ = prototypeOfObject;
      }

      var getter = lookupGetter(obj, property);
      var setter = lookupSetter(obj, property);

      if (notPrototypeOfObject) {
        // Once we have getter and setter we can put values back.
        // eslint-disable-next-line no-proto
        obj.__proto__ = prototype;
      }

      if (getter || setter) {
        if (getter) {
          descriptor.get = getter;
        }

        if (setter) {
          descriptor.set = setter;
        }

        // If it was accessor property we're done and return here
        // in order to avoid adding `value` to the descriptor.
        return descriptor;
      }
    }

    // If we got this far we know that object has an own property that is
    // not an accessor so we set it as a value and return descriptor.
    descriptor.value = obj[property];
    descriptor.writable = true;
    return descriptor;
  };
}

/**
 * This method returns a property descriptor for an own property (that is,
 * one directly present on an object and not in the object's prototype chain)
 * of a given object.
 *
 * @param {*} object - The object in which to look for the property.
 * @param {*} property - The name of the property whose description is to be retrieved.
 * @returns {Object} A property descriptor of the given property if it exists on the object, undefined otherwise.
 * @example
 * var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
 * var obj = { bar: 42 };
 * var d = getOwnPropertyDescriptor(o, 'bar');
 * // d is {
 * //   configurable: true,
 * //   enumerable: true,
 * //   value: 42,
 * //   writable: true
 * // }
 */
module.exports = $getOwnPropertyDescriptor;

},{"has-own-property-x":96,"to-object-x":344}],98:[function(require,module,exports){
'use strict';

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{}],99:[function(require,module,exports){
/**
 * @file Detect whether or not an object is an ArrayBuffer.
 * @version 1.7.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-array-buffer-x
 */

/* global ArrayBuffer */

'use strict';

var attempt = require('attempt-x');
var isObjectLike = require('is-object-like-x');
var hasABuf = typeof ArrayBuffer === 'function';
var bLength = false;
var toStringTag;
var aBufTag;

if (hasABuf) {
  if (require('has-to-string-tag-x')) {
    var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
    var descriptor = getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength');
    if (descriptor && typeof descriptor.get === 'function') {
      var res = attempt(function () {
        return new ArrayBuffer(4);
      });

      if (res.threw === false && isObjectLike(res.value)) {
        res = attempt.call(res.value, descriptor.get);
        bLength = res.threw === false && typeof res.value === 'number' && descriptor.get;
      }
    }
  }

  if (bLength === false) {
    toStringTag = require('to-string-tag-x');
    aBufTag = '[object ArrayBuffer]';
  }
}

/**
 * Determine if an `object` is an `ArrayBuffer`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is an `ArrayBuffer`,
 *  else false`.
 * @example
 * var isArrayBuffer = require('is-array-buffer-x');
 *
 * isArrayBuffer(new ArrayBuffer(4)); // true
 * isArrayBuffer(null); // false
 * isArrayBuffer([]); // false
 */
module.exports = function isArrayBuffer(object) {
  if (hasABuf === false || isObjectLike(object) === false) {
    return false;
  }

  if (bLength === false) {
    return toStringTag(object) === aBufTag;
  }

  var result = attempt.call(object, bLength);
  return result.threw === false && typeof result.value === 'number';
};

},{"attempt-x":32,"has-to-string-tag-x":75,"is-object-like-x":124,"object-get-own-property-descriptor-x":319,"to-string-tag-x":348}],100:[function(require,module,exports){
/**
 * @file Determine if a value is array like.
 * @version 1.8.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-array-like-x
 */

'use strict';

var isNil = require('is-nil-x');
var isFunction = require('is-function-x');
var isLength = require('is-length-x');

/**
 * Checks if value is array-like. A value is considered array-like if it's
 * not a function and has a `length` that's an integer greater than or
 * equal to 0 and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @param {*} value - The object to be tested.
 * @returns {boolean} Returns `true` if subject is array-like, else `false`.
 * @example
 * var isArrayLike = require('is-array-like-x');
 *
 * isArrayLike([1, 2, 3]); // true
 * isArrayLike(document.body.children); // true
 * isArrayLike('abc'); // true
 * isArrayLike(_.noop); // false
 */
module.exports = function isArrayLike(value) {
  return isNil(value) === false && isFunction(value, true) === false && isLength(value.length);
};

},{"is-function-x":110,"is-length-x":114,"is-nil-x":122}],101:[function(require,module,exports){
/**
 * @file Determines whether the passed value is an Array.
 * @version 1.2.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-array-x
 */

'use strict';

var nativeIsArray = typeof Array.isArray === 'function' && Array.isArray;

var testRes = nativeIsArray && require('attempt-x')(function () {
  return nativeIsArray([]) === true && nativeIsArray({ length: 0 }) === false;
});

var $isArray;
if (testRes && testRes.threw === false && testRes.value === true) {
  $isArray = nativeIsArray;
} else {
  var toStringTag = require('to-string-tag-x');
  $isArray = function isArray(obj) {
    return toStringTag(obj) === '[object Array]';
  };
}

/**
 * The isArray() function determines whether the passed value is an Array.
 *
 * @param {*} obj - The object to be checked..
 * @returns {boolean} `true` if the object is an Array; otherwise, `false`.
 * @example
 * var isArray = require('is-array-x');
 *
 * isArray([]); // true
 * isArray({}); // false
 */
module.exports = $isArray;

},{"attempt-x":32,"to-string-tag-x":348}],102:[function(require,module,exports){
/**
 * @file Determine if a function is a native aync function.
 * @see {@link https://tc39.github.io/ecma262/#sec-async-function-definitions|14.6 Async Function Definitions}
 * @version 1.7.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-async-function-x
 */

'use strict';

var toStringTag = require('to-string-tag-x');
var hasToStringTag = require('has-to-string-tag-x');
var normalise = require('normalize-space-x').normalizeSpace2018;
var isFnRegex = /^async function/;
var test = isFnRegex.test;
var replaceComments = require('replace-comments-x');
var functionCtr = function () {}.constructor;
var fToString = functionCtr.prototype.toString;
var $getPrototypeOf = require('get-prototype-of-x');
var attempt = require('attempt-x');

var testRes = attempt(function () {
  return $getPrototypeOf(functionCtr('return async function() {}')());
});

var supportsAsync = testRes.threw === false;
var asyncProto = testRes.value;

/**
 * Checks if `value` is classified as an `Async Function` object.
 *
 * @param {*} fn - The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 * @example
 * var isAsyncFunction = require('is--async-function-x');
 *
 * isAsyncFunction(); // false
 * isAsyncFunction(Number.MIN_VALUE); // false
 * isAsyncFunction('abc'); // false
 * isAsyncFunction(true); // false
 * isAsyncFunction({ name: 'abc' }); // false
 * isAsyncFunction(function () {}); // false
 * isAsyncFunction(new Function ()); // false
 * isAsyncFunction(function* test1() {}); // false
 * isAsyncFunction(function test2(a, b) {}); // false
 * isAsyncFunction(class Test {}); // false
 * isAsyncFunction((x, y) => {return this;}); // false
 * isAsyncFunction(async functin() {}); // true
 */
module.exports = function isAsyncFunction(fn) {
  if (supportsAsync === false || typeof fn !== 'function') {
    return false;
  }

  var str;
  try {
    str = normalise(replaceComments(fToString.call(fn), ' '));
  } catch (ignore) {
    return false;
  }

  if (test.call(isFnRegex, str)) {
    return true;
  }

  if (hasToStringTag === false) {
    return toStringTag(fn) === '[object AsyncFunction]';
  }

  return $getPrototypeOf(fn) === asyncProto;
};

},{"attempt-x":32,"get-prototype-of-x":68,"has-to-string-tag-x":75,"normalize-space-x":308,"replace-comments-x":328,"to-string-tag-x":348}],103:[function(require,module,exports){
'use strict';

var boolToStr = Boolean.prototype.toString;

var tryBooleanObject = function tryBooleanObject(value) {
	try {
		boolToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var boolClass = '[object Boolean]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isBoolean(value) {
	if (typeof value === 'boolean') { return true; }
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryBooleanObject(value) : toStr.call(value) === boolClass;
};

},{}],104:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (typeof value === 'function' && !value.prototype) { return true; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],105:[function(require,module,exports){
/**
 * @file Detect whether or not an object is a DataView.
 * @version 1.6.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-data-view-x
 */

/* global ArrayBuffer, DataView */

'use strict';

var attempt = require('attempt-x');
var isObjectLike = require('is-object-like-x');
var hasDView = typeof DataView === 'function';
var getByteLength = false;
var legacyCheck;

if (hasDView) {
  var res = attempt(function () {
    return new DataView(new ArrayBuffer(4));
  });

  var dataView = res.threw === false && isObjectLike(res.value) && res.value;

  if (dataView && require('has-to-string-tag-x')) {
    var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
    var descriptor = getOwnPropertyDescriptor(DataView.prototype, 'byteLength');
    if (descriptor && typeof descriptor.get === 'function') {
      res = attempt.call(dataView, descriptor.get);
      getByteLength = res.threw === false && typeof res.value === 'number' && descriptor.get;
    }
  }

  if (getByteLength === false) {
    var toStringTag = require('to-string-tag-x');
    var dViewTag = '[object DataView]';
    if (toStringTag(dataView) === dViewTag) {
      legacyCheck = function _legacyCheck(object) {
        return toStringTag(object) === dViewTag;
      };
    } else {
      var isArrayBuffer = require('is-array-buffer-x');
      legacyCheck = function _legacyCheck(object) {
        var isByteLength = typeof object.byteLength === 'number';
        var isByteOffset = typeof object.byteOffset === 'number';
        var isGetFloat32 = typeof object.getFloat32 === 'function';
        var isSetFloat64 = typeof object.setFloat64 === 'function';
        return isByteLength && isByteOffset && isGetFloat32 && isSetFloat64 && isArrayBuffer(object.buffer);
      };
    }
  }
}

/**
 * Determine if an `object` is an `DataView`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is a `DataView`, else `false`.
 * @example
 * var isDataView = require('is-data-view-x');
 * var ab = new ArrayBuffer(4);
 * var dv = new DataView(ab);
 *
 * isDataView(ab); // false
 * isDataView(true); // false
 * isDataView(dv); // true
 */
module.exports = function isDataView(object) {
  if (hasDView === false || isObjectLike(object) === false) {
    return false;
  }

  if (legacyCheck) {
    return legacyCheck(object);
  }

  var result = attempt.call(object, getByteLength);
  return result.threw === false && typeof result.value === 'number';
};

},{"attempt-x":32,"has-to-string-tag-x":75,"is-array-buffer-x":99,"is-object-like-x":124,"object-get-own-property-descriptor-x":319,"to-string-tag-x":348}],106:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],107:[function(require,module,exports){
/**
 * @file  Detect whether a value is an error.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-error-x
 */

'use strict';

var toStringTag = require('to-string-tag-x');
var isObjectLike = require('is-object-like-x');
var $getPrototypeOf = require('get-prototype-of-x');

var errorCheck = function checkIfError(value) {
  return toStringTag(value) === '[object Error]';
};

if (errorCheck(Error.prototype) === false) {
  var errorProto = Error.prototype;
  var testStringTag = errorCheck;
  errorCheck = function checkIfError(value) {
    return value === errorProto || testStringTag(value);
  };
}

/**
 * Determine whether or not a given `value` is an `Error` type.
 *
 * @param {*} value - The object to be tested.
 * @returns {boolean} Returns `true` if `value` is an `Error` type,
 *  else `false`.
 * @example
 * var isError = require('is-error-x');
 *
 * isError(); // false
 * isError(Number.MIN_VALUE); // false
 * isError('abc'); // false
 * isError(new Error()); //true
 */
module.exports = function isError(value) {
  if (isObjectLike(value) === false) {
    return false;
  }

  var object = value;
  var maxLoop = 100;
  while (object && maxLoop > -1) {
    if (errorCheck(object)) {
      return true;
    }

    object = $getPrototypeOf(object);
    maxLoop -= 1;
  }

  return false;
};

},{"get-prototype-of-x":68,"is-object-like-x":124,"to-string-tag-x":348}],108:[function(require,module,exports){
/**
 * @file Test if a given value is falsey.
 * @version 1.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-falsey-x
 */

'use strict';

var toBoolean = require('to-boolean-x');

/**
 * This method tests if a given value is falsey.
 *
 * @param {*} value - The value to test.
 * @returns {boolean} `true` if the value is falsey: otherwise `false`.
 * @example
 * var isFalsey = require('is-falsey-x');
 *
 * isFalsey(); // true
 * isFalsey(0); // true
 * isFalsey(''); // true
 * isFalsey(false); // true
 * isFalsey(null); // true
 *
 * isFalsey(true); // false
 * isFalsey([]); // false
 * isFalsey(1); // false
 * isFalsey(function () {}); // false
 */
module.exports = function isFalsey(value) {
  return toBoolean(value) === false;
};

},{"to-boolean-x":336}],109:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Number.isFinite.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-number.isfinite|20.1.2.2 Number.isFinite ( number )}
 * @version 3.0.4
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-finite-x
 */

'use strict';

var numberIsNaN = require('is-nan-x');
var INFINITY = require('infinity-x');

/**
 * This method determines whether the passed value is a finite number.
 *
 * @param {*} number - The value to be tested for finiteness.
 * @returns {boolean} A Boolean indicating whether or not the given value is a finite number.
 * @example
 * var numIsFinite = require('is-finite-x');
 *
 * numIsFinite(Infinity);  // false
 * numIsFinite(NaN);       // false
 * numIsFinite(-Infinity); // false
 *
 * numIsFinite(0);         // true
 * numIsFinite(2e64);      // true
 *
 * numIsFinite('0');       // false, would've been true with
 *                         // global isFinite('0')
 * numIsFinite(null);      // false, would've been true with
 */
module.exports = function isFinite(number) {
  return typeof number === 'number' && numberIsNaN(number) === false && number !== INFINITY && number !== -INFINITY;
};

},{"infinity-x":94,"is-nan-x":116}],110:[function(require,module,exports){
/**
 * @file Determine whether a given value is a function object.
 * @version 3.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-function-x
 */

'use strict';

var attempt = require('attempt-x');
var fToString = Function.prototype.toString;
var toBoolean = require('to-boolean-x');
var isFalsey = require('is-falsey-x');
var toStringTag = require('to-string-tag-x');
var hasToStringTag = require('has-to-string-tag-x');
var isPrimitive = require('is-primitive');
var normalise = require('normalize-space-x').normalizeSpace;
var deComment = require('replace-comments-x');
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var asyncTag = '[object AsyncFunction]';
var ctrRx = /^class /;
var test = ctrRx.test;

var hasNativeClass = attempt(function () {
  // eslint-disable-next-line no-new-func
  return Function('"use strict"; return class My {};')();
}).threw === false;

var testClassstring = function _testClassstring(value) {
  return test.call(ctrRx, normalise(deComment(fToString.call(value), ' ')));
};

var isES6ClassFn = function isES6ClassFunc(value) {
  var result = attempt(testClassstring, value);

  return result.threw === false && result.value;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @private
 * @param {*} value - The value to check.
 * @param {boolean} allowClass - Whether to filter ES6 classes.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 */
var tryFuncToString = function funcToString(value, allowClass) {
  if (hasNativeClass && allowClass === false && isES6ClassFn(value)) {
    return false;
  }

  return attempt.call(value, fToString).threw === false;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @param {*} value - The value to check.
 * @param {boolean} [allowClass=false] - Whether to filter ES6 classes.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 * else `false`.
 * @example
 * var isFunction = require('is-function-x');
 *
 * isFunction(); // false
 * isFunction(Number.MIN_VALUE); // false
 * isFunction('abc'); // false
 * isFunction(true); // false
 * isFunction({ name: 'abc' }); // false
 * isFunction(function () {}); // true
 * isFunction(new Function ()); // true
 * isFunction(function* test1() {}); // true
 * isFunction(function test2(a, b) {}); // true
 * isFunction(async function test3() {}); // true
 * isFunction(class Test {}); // false
 * isFunction(class Test {}, true); // true
 * isFunction((x, y) => {return this;}); // true
 */
module.exports = function isFunction(value) {
  if (isPrimitive(value)) {
    return false;
  }

  if (hasToStringTag) {
    return tryFuncToString(value, toBoolean(arguments[1]));
  }

  if (hasNativeClass && isFalsey(arguments[1]) && isES6ClassFn(value)) {
    return false;
  }

  var strTag = toStringTag(value);
  return strTag === funcTag || strTag === genTag || strTag === asyncTag;
};

},{"attempt-x":32,"has-to-string-tag-x":75,"is-falsey-x":108,"is-primitive":126,"normalize-space-x":308,"replace-comments-x":328,"to-boolean-x":336,"to-string-tag-x":348}],111:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var generatorFunc = getGeneratorFunc();
var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	return getProto(fn) === GeneratorFunction;
};

},{}],112:[function(require,module,exports){
/**
 * @file Determine whether the passed value is a zero based index.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-index-x
 */

'use strict';

var safeToString = require('to-string-symbols-supported-x');
var toInteger = require('to-integer-x').toInteger2018;
var toNumber = require('to-number-x').toNumber2018;
var mathClamp = require('math-clamp-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');
var reIsUint = /^(?:0|[1-9]\d*)$/;
var rxTest = reIsUint.test;

/**
 * This method determines whether the passed value is a zero based index.
 * JavaScript arrays are zero-indexed: the first element of an array is at
 * index 0, and the last element is at the index equal to the value of the
 * array's length property minus 1.
 *
 * @param {number|string} value - The value to be tested for being a zero based index.
 * @param {number} [length=MAX_SAFE_INTEGER] - The length that sets the upper bound.
 * @returns {boolean} A Boolean indicating whether or not the given value is a
 * zero based index within bounds.
 * @example
 * var isIndex = require('is-index-x');
 *
 * isIndex(0);                    // true
 * isIndex(1);                    // true
 * isIndex('10');                 // true
 *
 * isIndex(-100000);              // false
 * isIndex(Math.pow(2, 53));      // false
 * isIndex(0.1);                  // false
 * isIndex(Math.PI);              // false
 * isIndex(NaN);                  // false
 * isIndex(Infinity);             // false
 * isIndex(-Infinity);            // false
 * isIndex(true);                 // false
 * isIndex(false);                // false
 * isIndex([1]);                  // false
 * isIndex(10, 10);               // false
 */
module.exports = function isIndex(value) {
  var string = safeToString(value);
  if (rxTest.call(reIsUint, string) === false) {
    return false;
  }

  var number = toNumber(string);
  if (arguments.length > 1) {
    return number < mathClamp(toInteger(arguments[1]), MAX_SAFE_INTEGER);
  }

  return number < MAX_SAFE_INTEGER;
};

},{"math-clamp-x":298,"max-safe-integer":300,"to-integer-x":337,"to-number-x":340,"to-string-symbols-supported-x":347}],113:[function(require,module,exports){
/**
 * @file Determine whether the passed value is an integer.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-integer-x
 */

'use strict';

var numberIsFinite = require('is-finite-x');
var toInteger = require('to-integer-x').toInteger2018;

/**
 * This method determines whether the passed value is an integer.
 *
 * @param {*} value - The value to be tested for being an integer.
 * @returns {boolean} A Boolean indicating whether or not the given value is an integer.
 * @example
 * var isInteger = require('is-integer-x');
 *
 * isInteger(0);         // true
 * isInteger(1);         // true
 * isInteger(-100000);   // true
 *
 * isInteger(0.1);       // false
 * isInteger(Math.PI);   // false
 *
 * isInteger(NaN);       // false
 * isInteger(Infinity);  // false
 * isInteger(-Infinity); // false
 * isInteger('10');      // false
 * isInteger(true);      // false
 * isInteger(false);     // false
 * isInteger([1]);       // false
 */
module.exports = function isInteger(value) {
  return numberIsFinite(value) && toInteger(value) === value;
};

},{"is-finite-x":109,"to-integer-x":337}],114:[function(require,module,exports){
/**
 * @file Checks if `value` is a valid array-like length.
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-length-x
 */

'use strict';

var isSafeInteger = require('is-safe-integer-x');

/**
 * This method checks if `value` is a valid array-like length.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 * var isLength = require('is-length-x');
 *
 * isLength(3); // => true
 * isLength(Number.MIN_VALUE); // => false
 * isLength(Infinity); // => false
 * isLength('3'); // => false
 */
module.exports = function isLength(value) {
  return isSafeInteger(value) && value >= 0;
};

},{"is-safe-integer-x":132}],115:[function(require,module,exports){
/**
 * @file Detect whether or not an object is an ES6 Map.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-map-x
 */

'use strict';

var isFalsey = require('is-falsey-x');
var attempt;
var isObjectLike;
var isLength;
var getSize;

if (typeof Map === 'function') {
  var descriptor = require('object-get-own-property-descriptor-x')(Map.prototype, 'size');
  if (descriptor && typeof descriptor.get === 'function') {
    attempt = require('attempt-x');
    isObjectLike = require('is-object-like-x');
    var res = attempt(function () {
      return new Map();
    });

    if (res.threw === false && isObjectLike(res.value)) {
      isLength = require('is-length-x');
      res = attempt.call(res.value, descriptor.get);
      if (res.threw === false && isLength(res.value)) {
        getSize = descriptor.get;
      }
    }

  }
}

/**
 * Determine if an `object` is a `Map`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is a `Map`,
 *  else `false`.
 * @example
 * var isMap = require('is-map-x');
 * var m = new Map();
 *
 * isMap([]); // false
 * isMap(true); // false
 * isMap(m); // true
 */
module.exports = function isMap(object) {
  if (isFalsey(getSize) || isObjectLike(object) === false) {
    return false;
  }

  var result = attempt.call(object, getSize);
  return result.threw === false && isLength(result.value);
};

},{"attempt-x":32,"is-falsey-x":108,"is-length-x":114,"is-object-like-x":124,"object-get-own-property-descriptor-x":319}],116:[function(require,module,exports){
/**
 * @file ES6-compliant shim for Number.isNaN - the global isNaN returns false positives.
 * @version 1.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-nan-x
 */

'use strict';

/**
 * This method determines whether the passed value is NaN and its type is
 * `Number`. It is a more robust version of the original, global isNaN().
 *
 * @param {*} value - The value to be tested for NaN.
 * @returns {boolean} `true` if the given value is NaN and its type is Number;
 *  otherwise, `false`.
 * @example
 * var numberIsNaN = require('is-nan-x');
 *
 * numberIsNaN(NaN);        // true
 * numberIsNaN(Number.NaN); // true
 * numberIsNaN(0 / 0);      // true
 *
 * // e.g. these would have been true with global isNaN()
 * numberIsNaN('NaN');      // false
 * numberIsNaN(undefined);  // false
 * numberIsNaN({});         // false
 * numberIsNaN('blabla');   // false
 *
 * // These all return false
 * numberIsNaN(true);
 * numberIsNaN(null);
 * numberIsNaN(37);
 * numberIsNaN('37');
 * numberIsNaN('37.37');
 * numberIsNaN('');
 * numberIsNaN(' ');
 */
module.exports = function isNaN(value) {
  return value !== value;
};

},{}],117:[function(require,module,exports){
'use strict';

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};

},{}],118:[function(require,module,exports){
'use strict';

var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(implementation, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = implementation;

},{"./implementation":117,"./polyfill":119,"./shim":120,"define-properties":48}],119:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};

},{"./implementation":117}],120:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, { isNaN: function () { return Number.isNaN !== polyfill; } });
	return polyfill;
};

},{"./polyfill":119,"define-properties":48}],121:[function(require,module,exports){
'use strict';

module.exports = function isNegativeZero(number) {
	return number === 0 && (1 / number) === -Infinity;
};


},{}],122:[function(require,module,exports){
/**
 * @file Checks if `value` is `null` or `undefined`.
 * @version 1.4.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-nil-x
 */

'use strict';

var isUndefined = require('validate.io-undefined');
var isNull = require('lodash.isnull');

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 * var isNil = require('is-nil-x');
 *
 * isNil(null); // => true
 * isNil(void 0); // => true
 * isNil(NaN); // => false
 */
module.exports = function isNil(value) {
  return isNull(value) || isUndefined(value);
};

},{"lodash.isnull":139,"validate.io-undefined":356}],123:[function(require,module,exports){
'use strict';

var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject(value) {
	try {
		numToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var numClass = '[object Number]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isNumberObject(value) {
	if (typeof value === 'number') { return true; }
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
};

},{}],124:[function(require,module,exports){
/**
 * @file Determine if a value is object like.
 * @version 1.7.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-object-like-x
 */

'use strict';

var isFunction = require('is-function-x');
var isPrimitive = require('is-primitive');

/**
 * Checks if `value` is object-like. A value is object-like if it's not a
 * primitive and not a function.
 *
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 * var isObjectLike = require('is-object-like-x');
 *
 * isObjectLike({});
 * // => true
 *
 * isObjectLike([1, 2, 3]);
 * // => true
 *
 * isObjectLike(_.noop);
 * // => false
 *
 * isObjectLike(null);
 * // => false
 */
module.exports = function isObjectLike(value) {
  return isPrimitive(value) === false && isFunction(value, true) === false;
};

},{"is-function-x":110,"is-primitive":125}],125:[function(require,module,exports){
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isPrimitive(val) {
  if (typeof val === 'object') {
    return val === null;
  }
  return typeof val !== 'function';
};

},{}],126:[function(require,module,exports){
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

// see http://jsperf.com/testing-value-is-primitive/7
module.exports = function isPrimitive(value) {
  return value == null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],127:[function(require,module,exports){
module.exports = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

},{}],128:[function(require,module,exports){
'use strict';

var has = require('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":76}],129:[function(require,module,exports){
/**
 * @file Is this value a JS regex?
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-regexp-x
 */

'use strict';

var isObjectLike = require('is-object-like-x');

var toStringTag;
var regexClass;
var has;
var gOPD;
var regexExec;
var defineProperty;

if (require('has-to-string-tag-x')) {
  has = require('has-own-property-x');
  gOPD = require('object-get-own-property-descriptor-x');
  defineProperty = require('object-define-property-x');
  regexExec = RegExp.prototype.exec;
} else {
  toStringTag = require('to-string-tag-x');
  regexClass = '[object RegExp]';
}

var tryRegexExecCall = function tryRegexExec(value, descriptor) {
  try {
    value.lastIndex = 0;
    regexExec.call(value);
    return true;
  } catch (e) {
    return false;
  } finally {
    defineProperty(value, 'lastIndex', descriptor);
  }
};

/**
 * This method tests if a value is a regex.
 *
 * @param {*} value - The value to test.
 * @returns {boolean} `true` if value is a regex; otherwise `false`.
 * @example
 * var isRegex = require('is-regexp-x');
 *
 * isRegex(undefined); // false
 * isRegex(null); // false
 * isRegex(false); // false
 * isRegex(true); // false
 * isRegex(42); // false
 * isRegex('foo'); // false
 * isRegex(function () {}); // false
 * isRegex([]); // false
 * isRegex({})); // false
 *
 * isRegex(/a/g); // true
 * isRegex(new RegExp('a', 'g')); // true
 */
module.exports = function isRegex(value) {
  if (isObjectLike(value) === false) {
    return false;
  }

  if (toStringTag) {
    return toStringTag(value) === regexClass;
  }

  var descriptor = gOPD(value, 'lastIndex');
  var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
  if (hasLastIndexDataProperty !== true) {
    return false;
  }

  return tryRegexExecCall(value, descriptor);
};

},{"has-own-property-x":70,"has-to-string-tag-x":75,"is-object-like-x":124,"object-define-property-x":131,"object-get-own-property-descriptor-x":319,"to-string-tag-x":348}],130:[function(require,module,exports){
/**
 * @file If IsObject(value) is false, throw a TypeError exception.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module assert-is-object-x
 */

'use strict';

var safeToString = require('to-string-symbols-supported-x');
var isPrimitive = require('is-primitive');

/**
   * Tests `value` to see if it is an object, throws a `TypeError` if it is
   * not. Otherwise returns the `value`.
   *
   * @param {*} value - The argument to be tested.
   * @throws {TypeError} Throws if `value` is not an object.
   * @returns {*} Returns `value` if it is an object.
   * @example
   * var assertIsObject = require('assert-is-object-x');
   * var primitive = true;
   * var mySymbol = Symbol('mySymbol');
   * var symObj = Object(mySymbol);
   * var object = {};
   * function fn () {}
   *
   * assertIsObject(primitive); // TypeError 'true is not an object'
   * assertIsObject(mySymbol); // TypeError 'Symbol(mySymbol) is not an object'
   * assertIsObject(symObj); // Returns symObj.
   * assertIsObject(object); // Returns object.
   * assertIsObject(fn); // Returns fn.
   */
module.exports = function assertIsObject(value) {
  if (isPrimitive(value)) {
    throw new TypeError(safeToString(value) + ' is not an object');
  }

  return value;
};

},{"is-primitive":126,"to-string-symbols-supported-x":347}],131:[function(require,module,exports){
/**
 * @file Sham for Object.defineProperty
 * @version 4.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-define-property-x
 */

'use strict';

var attempt = require('attempt-x');
var isFalsey = require('is-falsey-x');
var toObject = require('to-object-x');
var toPropertyKey = require('to-property-key-x');
var has = require('has-own-property-x');
var isFunction = require('is-function-x');
var isUndefined = require('validate.io-undefined');
var assertIsObject = require('assert-is-object-x');
var nativeDefProp = typeof Object.defineProperty === 'function' && Object.defineProperty;
var definePropertyFallback;

var toPropertyDescriptor = function _toPropertyDescriptor(desc) {
  var object = toObject(desc);
  var descriptor = {};
  if (has(object, 'enumerable')) {
    descriptor.enumerable = Boolean(object.enumerable);
  }

  if (has(object, 'configurable')) {
    descriptor.configurable = Boolean(object.configurable);
  }

  if (has(object, 'value')) {
    descriptor.value = object.value;
  }

  if (has(object, 'writable')) {
    descriptor.writable = Boolean(object.writable);
  }

  if (has(object, 'get')) {
    var getter = object.get;
    if (isUndefined(getter) === false && isFunction(getter) === false) {
      throw new TypeError('getter must be a function');
    }

    descriptor.get = getter;
  }

  if (has(object, 'set')) {
    var setter = object.set;
    if (isUndefined(setter) === false && isFunction(setter) === false) {
      throw new TypeError('setter must be a function');
    }

    descriptor.set = setter;
  }

  if ((has(descriptor, 'get') || has(descriptor, 'set')) && (has(descriptor, 'value') || has(descriptor, 'writable'))) {
    throw new TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
  }

  return descriptor;
};

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var $defineProperty;
// check whether defineProperty works if it's given. Otherwise, shim partially.
if (nativeDefProp) {
  var testWorksWith = function _testWorksWith(object) {
    var testResult = attempt(nativeDefProp, object, 'sentinel', {});
    return testResult.threw === false && testResult.value === object && 'sentinel' in object;
  };

  var doc = typeof document !== 'undefined' && document;
  if (testWorksWith({}) && (isFalsey(doc) || testWorksWith(doc.createElement('div')))) {
    $defineProperty = function defineProperty(object, property, descriptor) {
      return nativeDefProp(assertIsObject(object), toPropertyKey(property), toPropertyDescriptor(descriptor));
    };
  } else {
    definePropertyFallback = nativeDefProp;
  }
}

if (isFalsey(nativeDefProp) || definePropertyFallback) {
  var prototypeOfObject = Object.prototype;

  // If JS engine supports accessors creating shortcuts.
  var defineGetter;
  var defineSetter;
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors = has(prototypeOfObject, '__defineGetter__');
  if (supportsAccessors) {
    /* eslint-disable no-underscore-dangle, no-restricted-properties */
    defineGetter = prototypeOfObject.__defineGetter__;
    defineSetter = prototypeOfObject.__defineSetter__;
    lookupGetter = prototypeOfObject.__lookupGetter__;
    lookupSetter = prototypeOfObject.__lookupSetter__;
    /* eslint-enable no-underscore-dangle, no-restricted-properties */
  }

  $defineProperty = function defineProperty(object, property, descriptor) {
    assertIsObject(object);
    var propKey = toPropertyKey(property);
    var propDesc = toPropertyDescriptor(descriptor);

    // make a valiant attempt to use the real defineProperty for IE8's DOM elements.
    if (definePropertyFallback) {
      var result = attempt.call(Object, definePropertyFallback, object, propKey, propDesc);
      if (result.threw === false) {
        return result.value;
      }
      // try the shim if the real one doesn't work
    }

    // If it's a data property.
    if (has(propDesc, 'value')) {
      // fail silently if 'writable', 'enumerable', or 'configurable' are requested but not supported
      if (supportsAccessors && (lookupGetter.call(object, propKey) || lookupSetter.call(object, propKey))) {
        // As accessors are supported only on engines implementing
        // `__proto__` we can safely override `__proto__` while defining
        // a property to make sure that we don't hit an inherited accessor.
        /* eslint-disable no-proto */
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;
        // Deleting a property anyway since getter / setter may be defined on object itself.
        delete object[propKey];
        object[propKey] = propDesc.value;
        // Setting original `__proto__` back now.
        object.__proto__ = prototype;
        /* eslint-enable no-proto */
      } else {
        object[propKey] = propDesc.value;
      }
    } else {
      if (supportsAccessors === false && (propDesc.get || propDesc.set)) {
        throw new TypeError('getters & setters can not be defined on this javascript engine');
      }

      // If we got that far then getters and setters can be defined !!
      if (propDesc.get) {
        defineGetter.call(object, propKey, propDesc.get);
      }

      if (propDesc.set) {
        defineSetter.call(object, propKey, propDesc.set);
      }
    }

    return object;
  };
}

/**
 * This method defines a new property directly on an object, or modifies an
 * existing property on an object, and returns the object.
 *
 * @param {Object} object - The object on which to define the property.
 * @param {string} property - The name of the property to be defined or modified.
 * @param {Object} descriptor - The descriptor for the property being defined or modified.
 * @returns {Object} The object that was passed to the function.
 * @example
 * var defineProperty = require('object-define-property-x');
 *
 * var o = {}; // Creates a new object
 *
 * defineProperty(o, 'a', {
 *   value: 37,
 *   writable: true
 * });
 */
module.exports = $defineProperty;

},{"assert-is-object-x":130,"attempt-x":32,"has-own-property-x":70,"is-falsey-x":108,"is-function-x":110,"to-object-x":344,"to-property-key-x":346,"validate.io-undefined":356}],132:[function(require,module,exports){
/**
 * @file Determine whether the passed value is a safe integer.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-safe-integer-x
 */

'use strict';

var isInteger = require('is-integer-x');
var MAX_SAFE_INTEGER = require('max-safe-integer');
var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;

/**
 * This method determines whether the passed value is a safe integer.
 *
 * Can be exactly represented as an IEEE-754 double precision number, and
 * whose IEEE-754 representation cannot be the result of rounding any other
 * integer to fit the IEEE-754 representation.
 *
 * @param {*} value - The value to be tested for being a safe integer.
 * @returns {boolean} A Boolean indicating whether or not the given value is a
 *  safe integer.
 * @example
 * var isSafeInteger = require('is-safe-integer-x');
 *
 * isSafeInteger(0);                    // true
 * isSafeInteger(1);                    // true
 * isSafeInteger(-100000);              // true
 *
 * isSafeInteger(Math.pow(2, 53));      // false
 * isSafeInteger(0.1);                  // false
 * isSafeInteger(Math.PI);              // false
 *
 * isSafeInteger(NaN);                  // false
 * isSafeInteger(Infinity);             // false
 * isSafeInteger(-Infinity);            // false
 * isSafeInteger('10');                 // false
 * isSafeInteger(true);                 // false
 * isSafeInteger(false);                // false
 * isSafeInteger([1]);                  // false
 */
module.exports = function isSafeInteger(value) {
  return isInteger(value) && value >= MIN_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
};

},{"is-integer-x":113,"max-safe-integer":300}],133:[function(require,module,exports){
/**
 * @file Detect whether or not an object is an ES6 SET.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-set-x
 */

'use strict';

var isFalsey = require('is-falsey-x');
var attempt;
var isObjectLike;
var isLength;
var getSize;

if (typeof Set === 'function') {
  var descriptor = require('object-get-own-property-descriptor-x')(Set.prototype, 'size');
  if (descriptor && typeof descriptor.get === 'function') {
    attempt = require('attempt-x');
    isObjectLike = require('is-object-like-x');
    var res = attempt(function () {
      return new Set();
    });

    if (res.threw === false && isObjectLike(res.value)) {
      isLength = require('is-length-x');
      res = attempt.call(res.value, descriptor.get);
      if (res.threw === false && isLength(res.value)) {
        getSize = descriptor.get;
      }
    }

  }
}

/**
 * Determine if an `object` is a `Set`.
 *
 * @param {*} object - The object to test.
 * @returns {boolean} `true` if the `object` is a `Set`,
 *  else `false`.
 * @example
 * var isSet = require('is-set-x');
 * var s = new Set();
 *
 * isSet([]); // false
 * isSet(true); // false
 * isSet(s); // true
 */
module.exports = function isSet(object) {
  if (isFalsey(getSize) || isObjectLike(object) === false) {
    return false;
  }

  var result = attempt.call(object, getSize);
  return result.threw === false && isLength(result.value);
};

},{"attempt-x":32,"is-falsey-x":108,"is-length-x":114,"is-object-like-x":124,"object-get-own-property-descriptor-x":319}],134:[function(require,module,exports){
'use strict';

var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isString(value) {
	if (typeof value === 'string') { return true; }
	if (typeof value !== 'object') { return false; }
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};

},{}],135:[function(require,module,exports){
/**
 * @file Tests if 2 characters together are a surrogate pair.
 * @version 1.4.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module is-surrogate-pair-x
 */

'use strict';

var isString = require('is-string');

/**
 * Tests if the two character arguments combined are a valid UTF-16
 * surrogate pair.
 *
 * @param {*} char1 - The first character of a suspected surrogate pair.
 * @param {*} char2 - The second character of a suspected surrogate pair.
 * @returns {boolean} Returns true if the two characters create a valid
 *  'UTF-16' surrogate pair; otherwise false.
 * @example
 * var isSurrogatePair = require('is-surrogate-pair-x');
 *
 * var test1 = 'a';
 * var test2 = '𠮟';
 *
 * isSurrogatePair(test1.charAt(0), test1.charAt(1)); // false
 * isSurrogatePair(test2.charAt(0), test2.charAt(1)); // true
 */
module.exports = function isSurrogatePair(char1, char2) {
  if (isString(char1) && char1.length === 1 && isString(char2) && char2.length === 1) {
    var code1 = char1.charCodeAt();
    if (code1 >= 0xD800 && code1 <= 0xDBFF) {
      var code2 = char2.charCodeAt();
      if (code2 >= 0xDC00 && code2 <= 0xDFFF) {
        return true;
      }
    }
  }

  return false;
};

},{"is-string":134}],136:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = require('has-symbols')();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false && value;
	};
}

},{"has-symbols":73}],137:[function(require,module,exports){
(function (global){
'use strict';

var forEach = require('foreach');

var toStr = Object.prototype.toString;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var typedArrays = {
	Float32Array: true,
	Float64Array: true,
	Int8Array: true,
	Int16Array: true,
	Int32Array: true,
	Uint8Array: true,
	Uint8ClampedArray: true,
	Uint16Array: true,
	Uint32Array: true
};

var slice = String.prototype.slice;
var toStrTags = {};
var gOPD = Object.getOwnPropertyDescriptor;
if (hasToStringTag && gOPD && Object.getPrototypeOf) {
	forEach(typedArrays, function (_, typedArray) {
		var arr = new global[typedArray]();
		if (!(Symbol.toStringTag in arr)) {
			throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
		}
		var proto = Object.getPrototypeOf(arr);
		var descriptor = gOPD(proto, Symbol.toStringTag);
		if (!descriptor) {
			var superProto = Object.getPrototypeOf(proto);
			descriptor = gOPD(superProto, Symbol.toStringTag);
		}
		toStrTags[typedArray] = descriptor.get;
	});
}

var tryTypedArrays = function tryTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) { return !!typedArrays[slice.call(toStr.call(value), 8, -1)]; }
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"foreach":58}],138:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],139:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

module.exports = isNull;

},{}],140:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":208,"./_root":249}],141:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":216,"./_hashDelete":217,"./_hashGet":218,"./_hashHas":219,"./_hashSet":220}],142:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":230,"./_listCacheDelete":231,"./_listCacheGet":232,"./_listCacheHas":233,"./_listCacheSet":234}],143:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":208,"./_root":249}],144:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":235,"./_mapCacheDelete":236,"./_mapCacheGet":237,"./_mapCacheHas":238,"./_mapCacheSet":239}],145:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":208,"./_root":249}],146:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":208,"./_root":249}],147:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":142,"./_stackClear":252,"./_stackDelete":253,"./_stackGet":254,"./_stackHas":255,"./_stackSet":256}],148:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":249}],149:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":249}],150:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":208,"./_root":249}],151:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],152:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],153:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],154:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":184,"./_isIndex":225,"./isArguments":267,"./isArray":268,"./isBuffer":270,"./isTypedArray":283}],155:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],156:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],157:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":161,"./eq":262}],158:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":262}],159:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":197,"./keys":285}],160:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":197,"./keysIn":286}],161:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":202}],162:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });

    return result;
  }

  if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });

    return result;
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":147,"./_arrayEach":152,"./_assignValue":157,"./_baseAssign":159,"./_baseAssignIn":160,"./_cloneBuffer":191,"./_copyArray":196,"./_copySymbols":198,"./_copySymbolsIn":199,"./_getAllKeys":205,"./_getAllKeysIn":206,"./_getTag":213,"./_initCloneArray":221,"./_initCloneByTag":222,"./_initCloneObject":223,"./isArray":268,"./isBuffer":270,"./isMap":275,"./isObject":277,"./isSet":280,"./keys":285}],163:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":277}],164:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],165:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":156,"./_isFlattenable":224}],166:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":189,"./_toKey":259}],167:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":156,"./isArray":268}],168:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":148,"./_getRawTag":210,"./_objectToString":245}],169:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],170:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":164,"./_baseIsNaN":173,"./_strictIndexOf":257}],171:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":168,"./isObjectLike":278}],172:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":213,"./isObjectLike":278}],173:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],174:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":228,"./_toSource":260,"./isFunction":273,"./isObject":277}],175:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":213,"./isObjectLike":278}],176:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":168,"./isLength":274,"./isObjectLike":278}],177:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":229,"./_nativeKeys":242}],178:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":229,"./_nativeKeysIn":243,"./isObject":277}],179:[function(require,module,exports){
var basePickBy = require('./_basePickBy'),
    hasIn = require('./hasIn');

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

},{"./_basePickBy":180,"./hasIn":264}],180:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSet = require('./_baseSet'),
    castPath = require('./_castPath');

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;

},{"./_baseGet":166,"./_baseSet":181,"./_castPath":189}],181:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    castPath = require('./_castPath'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;

},{"./_assignValue":157,"./_castPath":189,"./_isIndex":225,"./_toKey":259,"./isObject":277}],182:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":202,"./constant":261,"./identity":265}],183:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],184:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],185:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":148,"./_arrayMap":155,"./isArray":268,"./isSymbol":282}],186:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],187:[function(require,module,exports){
var castPath = require('./_castPath'),
    last = require('./last'),
    parent = require('./_parent'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

},{"./_castPath":189,"./_parent":248,"./_toKey":259,"./last":287}],188:[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;

},{"./_arrayMap":155}],189:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":226,"./_stringToPath":258,"./isArray":268,"./toString":296}],190:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":149}],191:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":249}],192:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":190}],193:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],194:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":148}],195:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":190}],196:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],197:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":157,"./_baseAssignValue":161}],198:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":197,"./_getSymbols":211}],199:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":197,"./_getSymbolsIn":212}],200:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":249}],201:[function(require,module,exports){
var isPlainObject = require('./isPlainObject');

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;

},{"./isPlainObject":279}],202:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":208}],203:[function(require,module,exports){
var flatten = require('./flatten'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

},{"./_overRest":247,"./_setToString":250,"./flatten":263}],204:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],205:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":167,"./_getSymbols":211,"./keys":285}],206:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":167,"./_getSymbolsIn":212,"./keysIn":286}],207:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":227}],208:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":174,"./_getValue":214}],209:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":246}],210:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":148}],211:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":153,"./stubArray":291}],212:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":156,"./_getPrototype":209,"./_getSymbols":211,"./stubArray":291}],213:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":140,"./_Map":143,"./_Promise":145,"./_Set":146,"./_WeakMap":150,"./_baseGetTag":168,"./_toSource":260}],214:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],215:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":189,"./_isIndex":225,"./_toKey":259,"./isArguments":267,"./isArray":268,"./isLength":274}],216:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":241}],217:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],218:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":241}],219:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":241}],220:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":241}],221:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],222:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":190,"./_cloneDataView":192,"./_cloneRegExp":193,"./_cloneSymbol":194,"./_cloneTypedArray":195}],223:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":163,"./_getPrototype":209,"./_isPrototype":229}],224:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":148,"./isArguments":267,"./isArray":268}],225:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],226:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":268,"./isSymbol":282}],227:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],228:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":200}],229:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],230:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],231:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":158}],232:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":158}],233:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":158}],234:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":158}],235:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":141,"./_ListCache":142,"./_Map":143}],236:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":207}],237:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":207}],238:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":207}],239:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":207}],240:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":288}],241:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":208}],242:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":246}],243:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],244:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":204}],245:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],246:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],247:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":151}],248:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSlice = require('./_baseSlice');

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

},{"./_baseGet":166,"./_baseSlice":183}],249:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":204}],250:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":182,"./_shortOut":251}],251:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],252:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":142}],253:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],254:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],255:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],256:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":142,"./_Map":143,"./_MapCache":144}],257:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],258:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":240}],259:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":282}],260:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],261:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],262:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],263:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten');

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

},{"./_baseFlatten":165}],264:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":169,"./_hasPath":215}],265:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],266:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf'),
    isArrayLike = require('./isArrayLike'),
    isString = require('./isString'),
    toInteger = require('./toInteger'),
    values = require('./values');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;

},{"./_baseIndexOf":170,"./isArrayLike":269,"./isString":281,"./toInteger":294,"./values":297}],267:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":171,"./isObjectLike":278}],268:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],269:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":273,"./isLength":274}],270:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":249,"./stubFalse":292}],271:[function(require,module,exports){
var baseKeys = require('./_baseKeys'),
    getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isPrototype = require('./_isPrototype'),
    isTypedArray = require('./isTypedArray');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

},{"./_baseKeys":177,"./_getTag":213,"./_isPrototype":229,"./isArguments":267,"./isArray":268,"./isArrayLike":269,"./isBuffer":270,"./isTypedArray":283}],272:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike'),
    isPlainObject = require('./isPlainObject');

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

module.exports = isError;

},{"./_baseGetTag":168,"./isObjectLike":278,"./isPlainObject":279}],273:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":168,"./isObject":277}],274:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],275:[function(require,module,exports){
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

},{"./_baseIsMap":172,"./_baseUnary":186,"./_nodeUtil":244}],276:[function(require,module,exports){
/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

module.exports = isNull;

},{}],277:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],278:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],279:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":168,"./_getPrototype":209,"./isObjectLike":278}],280:[function(require,module,exports){
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

},{"./_baseIsSet":175,"./_baseUnary":186,"./_nodeUtil":244}],281:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":168,"./isArray":268,"./isObjectLike":278}],282:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":168,"./isObjectLike":278}],283:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":176,"./_baseUnary":186,"./_nodeUtil":244}],284:[function(require,module,exports){
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

},{}],285:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":154,"./_baseKeys":177,"./isArrayLike":269}],286:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":154,"./_baseKeysIn":178,"./isArrayLike":269}],287:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],288:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":144}],289:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseClone = require('./_baseClone'),
    baseUnset = require('./_baseUnset'),
    castPath = require('./_castPath'),
    copyObject = require('./_copyObject'),
    customOmitClone = require('./_customOmitClone'),
    flatRest = require('./_flatRest'),
    getAllKeysIn = require('./_getAllKeysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;

},{"./_arrayMap":155,"./_baseClone":162,"./_baseUnset":187,"./_castPath":189,"./_copyObject":197,"./_customOmitClone":201,"./_flatRest":203,"./_getAllKeysIn":206}],290:[function(require,module,exports){
var basePick = require('./_basePick'),
    flatRest = require('./_flatRest');

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;

},{"./_basePick":179,"./_flatRest":203}],291:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],292:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],293:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":295}],294:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":293}],295:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":277,"./isSymbol":282}],296:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":185}],297:[function(require,module,exports){
var baseValues = require('./_baseValues'),
    keys = require('./keys');

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

},{"./_baseValues":188,"./keys":285}],298:[function(require,module,exports){
/**
 * @file Clamp a number to limits.
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module math-clamp-x
 */

'use strict';

var toNumber = require('to-number-x').toNumber2018;

/**
 * This method clamp a number to min and max limits inclusive.
 *
 * @param {number} value - The number to be clamped.
 * @param {number} [min=0] - The minimum number.
 * @param {number} max - The maximum number.
 * @throws {RangeError} If min > max.
 * @return {number} The clamped number.
 * @example
 * var mathClamp = require('math-clamp-x');
 */
module.exports = function clamp(value) {
  var number = toNumber(value);
  var argsLength = arguments.length;
  if (argsLength < 2) {
    return number;
  }

  var min = toNumber(arguments[1]);
  var max;
  if (argsLength < 3) {
    max = min;
    min = 0;
  } else {
    max = toNumber(arguments[2]);
  }

  if (min > max) {
    throw new RangeError('"min" must be less than "max"');
  }

  if (number < min) {
    return min;
  }

  if (number > max) {
    return max;
  }

  return number;
};

},{"to-number-x":340}],299:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"dup":80,"is-nan-x":116,"to-number-x":340}],300:[function(require,module,exports){
'use strict';
module.exports = 9007199254740991;

},{}],301:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "A-IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.2]"
  },
  {
    "Header Field Name": "Accept-Additions",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Charset",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.3]"
  },
  {
    "Header Field Name": "Accept-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Accept-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.4][RFC7694, Section 3]"
  },
  {
    "Header Field Name": "Accept-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.5]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Accept-Patch",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC5789]"
  },
  {
    "Header Field Name": "Accept-Post",
    "Template": "perm/accept-post",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://www.w3.org/TR/ldp/]"
  },
  {
    "Header Field Name": "Accept-Ranges",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 2.3]"
  },
  {
    "Header Field Name": "Age",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.1]"
  },
  {
    "Header Field Name": "Allow",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.1]"
  },
  {
    "Header Field Name": "ALPN",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7639, Section 2]"
  },
  {
    "Header Field Name": "Also-Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Alt-Svc",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alt-Used",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alternate-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Alternates",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Apply-To-Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "Approved",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archive",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Article-Names",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Article-Updates",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Authentication-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 4]"
  },
  {
    "Header Field Name": "Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 3]"
  },
  {
    "Header Field Name": "Authentication-Results",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7601]"
  },
  {
    "Header Field Name": "Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.2]"
  },
  {
    "Header Field Name": "Auto-Submitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3834 section 5]"
  },
  {
    "Header Field Name": "Autoforwarded",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Autosubmitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC1808][RFC2068 Section 14.11]"
  },
  {
    "Header Field Name": "Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Body",
    "Template": "",
    "Protocol": "none",
    "Status": "reserved",
    "Reference": "[RFC6068]"
  },
  {
    "Header Field Name": "C-Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cache-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.2]"
  },
  {
    "Header Field Name": "CalDAV-Timezones",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7809, Section 7.1]"
  },
  {
    "Header Field Name": "Cancel-Key",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cancel-Lock",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Close",
    "Template": "",
    "Protocol": "http",
    "Status": "reserved",
    "Reference": "[RFC7230, Section 8.1]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Connection",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.1]"
  },
  {
    "Header Field Name": "Content-Alternative",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2068][RFC2616]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC2110][RFC2557]"
  },
  {
    "Header Field Name": "Content-Description",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6266]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Duration",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.2.2]"
  },
  {
    "Header Field Name": "Content-features",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.3.2]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Length",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.4.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 4.2]"
  },
  {
    "Header Field Name": "Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Script-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Style-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Translation-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "standard",
    "Reference": "[RFC8255]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.1.5]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Conversion",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Conversion-With-Loss",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "DASL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5323]"
  },
  {
    "Header Field Name": "DAV",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "DL-Expansion-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.1.2]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Date-Received",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Default-Style",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Deferred-Delivery",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delivery-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delta-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Depth",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Derived-From",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Destination",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Differential-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Discarded-X400-IPMS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Discarded-X400-MTS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disclose-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-Options",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Distribution",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "DKIM-Signature",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6376]"
  },
  {
    "Header Field Name": "Downgraded-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Final-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Mail-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Message-Id",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Original-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Rcpt-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Early-Data",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8470]"
  },
  {
    "Header Field Name": "Encoding",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Encrypted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ETag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.3]"
  },
  {
    "Header Field Name": "Expect",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.1]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.3]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Expiry-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Followup-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Forwarded",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7239]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.1]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Generate-Delivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "GetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Hobareg",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC7486, Section 6.1.1]"
  },
  {
    "Header Field Name": "Host",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.4]"
  },
  {
    "Header Field Name": "HTTP2-Settings",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7540, Section 3.2.1]"
  },
  {
    "Header Field Name": "IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "If",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "If-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.1]"
  },
  {
    "Header Field Name": "If-Modified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.3]"
  },
  {
    "Header Field Name": "If-None-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.2]"
  },
  {
    "Header Field Name": "If-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.2]"
  },
  {
    "Header Field Name": "If-Schedule-Tag-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "If-Unmodified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.4]"
  },
  {
    "Header Field Name": "Importance",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Include-Referred-Token-Binding-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Incomplete-Copy",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Injection-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Injection-Info",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Keep-Alive",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Last-Modified",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.2]"
  },
  {
    "Header Field Name": "Latest-Delivery-Time",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Lines",
    "Template": "",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5536][RFC3977]"
  },
  {
    "Header Field Name": "Link",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8288]"
  },
  {
    "Header Field Name": "List-Archive",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Help",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Owner",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Subscribe",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe",
    "Template": "perm/list-unsubscribe",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC8058]"
  },
  {
    "Header Field Name": "Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.2]"
  },
  {
    "Header Field Name": "Lock-Token",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Max-Forwards",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.2]"
  },
  {
    "Header Field Name": "Memento-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Message-Context",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Meter",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Appendix A.1]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "MMHS-Exempted-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.1 and Appendix B.105]"
  },
  {
    "Header Field Name": "MMHS-Extended-Authorisation-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.2 and Appendix B.106]"
  },
  {
    "Header Field Name": "MMHS-Subject-Indicator-Codes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.3 and Appendix B.107]"
  },
  {
    "Header Field Name": "MMHS-Handling-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.4 and Appendix B.108]"
  },
  {
    "Header Field Name": "MMHS-Message-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.5 and Appendix B.109]"
  },
  {
    "Header Field Name": "MMHS-Codress-Message-Indicator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.6 and Appendix B.110]"
  },
  {
    "Header Field Name": "MMHS-Originator-Reference",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.7 and Appendix B.111]"
  },
  {
    "Header Field Name": "MMHS-Primary-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.8 and Appendix B.101]"
  },
  {
    "Header Field Name": "MMHS-Copy-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.9 and Appendix B.102]"
  },
  {
    "Header Field Name": "MMHS-Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.10 and Appendix B.103]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-CC",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Acp127-Message-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.14 and Appendix B.116]"
  },
  {
    "Header Field Name": "MMHS-Originator-PLAD",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.15 and Appendix B.117]"
  },
  {
    "Header Field Name": "MT-Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6758]"
  },
  {
    "Header Field Name": "Negotiate",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Newsgroups",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Host",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC2980][RFC5536]"
  },
  {
    "Header Field Name": "Obsoletes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional-WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 3]"
  },
  {
    "Header Field Name": "Ordering-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "mail",
    "Status": "informational",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Origin",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6454]"
  },
  {
    "Header Field Name": "Original-Encoded-Information-Types",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Original-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Recipient",
    "Template": "perm/original-recipient",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3798][RFC5337]"
  },
  {
    "Header Field Name": "Original-Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5537]"
  },
  {
    "Header Field Name": "Originator-Return-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Overwrite",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "P3P",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Path",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Pep-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Position",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Posting-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Pragma",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.4]"
  },
  {
    "Header Field Name": "Prefer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Preference-Applied",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Prevent-NonDelivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ProfileObject",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Query",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Request",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.3]"
  },
  {
    "Header Field Name": "Proxy-Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 4]"
  },
  {
    "Header Field Name": "Proxy-Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.4]"
  },
  {
    "Header Field Name": "Proxy-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Instruction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public-Key-Pins",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Public-Key-Pins-Report-Only",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.1]"
  },
  {
    "Header Field Name": "Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC5321]"
  },
  {
    "Header Field Name": "Received-SPF",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7208]"
  },
  {
    "Header Field Name": "Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Referer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.2]"
  },
  {
    "Header Field Name": "Relay-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Reply-By",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Require-Recipient-Valid-Since",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7293]"
  },
  {
    "Header Field Name": "Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Retry-After",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.3]"
  },
  {
    "Header Field Name": "Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Safe",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Schedule-Reply",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Schedule-Tag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Sec-Token-Binding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Extensions",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Key",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Security-Scheme",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "See-Also",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Sensitivity",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Server",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.2]"
  },
  {
    "Header Field Name": "Set-Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Set-Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "SetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SLUG",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5023]"
  },
  {
    "Header Field Name": "SoapAction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Solicitation",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC3865]"
  },
  {
    "Header Field Name": "Status-URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Strict-Transport-Security",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6797]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Summary",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2156]"
  },
  {
    "Header Field Name": "Surrogate-Capability",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Surrogate-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TCN",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TE",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.3]"
  },
  {
    "Header Field Name": "Timeout",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "TLS-Report-Domain",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "TLS-Report-Submitter",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Topic",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.4]"
  },
  {
    "Header Field Name": "Trailer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.4]"
  },
  {
    "Header Field Name": "Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.1]"
  },
  {
    "Header Field Name": "TTL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.2]"
  },
  {
    "Header Field Name": "Urgency",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.3]"
  },
  {
    "Header Field Name": "URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Upgrade",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.7]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.3]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2616]"
  },
  {
    "Header Field Name": "Variant-Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.4]"
  },
  {
    "Header Field Name": "VBR-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5518]"
  },
  {
    "Header Field Name": "Via",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.7.1]"
  },
  {
    "Header Field Name": "WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.1]"
  },
  {
    "Header Field Name": "Want-Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Warning",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.5]"
  },
  {
    "Header Field Name": "X400-Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-MTS-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Originator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Trace",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X-Content-Type-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://fetch.spec.whatwg.org/#x-content-type-options-header]"
  },
  {
    "Header Field Name": "X-Frame-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7034]"
  },
  {
    "Header Field Name": "Xref",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Access-Control",
    "Template": "prov/access-control",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Credentials",
    "Template": "prov/access-control-allow-credentials",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Headers",
    "Template": "prov/access-control-allow-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Methods",
    "Template": "prov/access-control-allow-methods",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Origin",
    "Template": "prov/access-control-allow-origin",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Max-Age",
    "Template": "prov/access-control-max-age",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Method",
    "Template": "prov/access-control-request-method",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Headers",
    "Template": "prov/access-control-request-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "AMP-Cache-Transform",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[https://github.com/ampproject/amphtml/blob/master/spec/amp-cache-transform.md]"
  },
  {
    "Header Field Name": "Apparently-To",
    "Template": "prov/apparently-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "ARC-Authentication-Results",
    "Template": "prov/arc-authentication-results",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Message-Signature",
    "Template": "prov/arc-message-signature",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Seal",
    "Template": "prov/arc-seal",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cost",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "Eesst-Version",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Errors-To",
    "Template": "prov/errors-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "Form-Sub",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-levine-mailbomb-header]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Method-Check",
    "Template": "prov/method-check",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check-Expires",
    "Template": "prov/method-check-expires",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "MMHS-Authorizing-Users",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7912]"
  },
  {
    "Header Field Name": "Non-Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Privicon",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-koenig-privicons]"
  },
  {
    "Header Field Name": "Referer-Root",
    "Template": "prov/referer-root",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Resolution-Hint",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Resolver-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SIO-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SIO-Label-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SubOK",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Subst",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Title",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Color",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Media",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Pixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Resolution",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Windowpixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "mail",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Device-Accept",
    "Template": "prov/x-device-accept",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Charset",
    "Template": "prov/x-device-accept-charset",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Encoding",
    "Template": "prov/x-device-accept-encoding",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Language",
    "Template": "prov/x-device-accept-language",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-User-Agent",
    "Template": "prov/x-device-user-agent",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Mittente",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-PGP-Sig",
    "Template": "prov/x-pgp-sig",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[ftp://ftp.isc.org/pub/pgpcontrol/FORMAT][https://ftp.isc.org/pub/pgpcontrol/FORMAT]"
  },
  {
    "Header Field Name": "X-Ricevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Riferimento-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-TipoRicevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Trasporto",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-VerificaSicurezza",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  }
]
},{}],302:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "Lines",
    "Template": "",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5536][RFC3977]"
  },
  {
    "Header Field Name": "Access-Control",
    "Template": "prov/access-control",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check",
    "Template": "prov/method-check",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check-Expires",
    "Template": "prov/method-check-expires",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Referer-Root",
    "Template": "prov/referer-root",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "mail",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  }
]
},{}],303:[function(require,module,exports){
module.exports = {
  all: require('./all.json'),
  permanent: require('./permanent.json'),
  provisional: require('./provisional.json'),
  standard: require('./standard.json'),
  deprecated: require('./deprecated.json')
};

},{"./all.json":301,"./deprecated.json":302,"./permanent.json":304,"./provisional.json":305,"./standard.json":306}],304:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "A-IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.2]"
  },
  {
    "Header Field Name": "Accept-Additions",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Charset",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.3]"
  },
  {
    "Header Field Name": "Accept-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Accept-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.4][RFC7694, Section 3]"
  },
  {
    "Header Field Name": "Accept-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.5]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Accept-Patch",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC5789]"
  },
  {
    "Header Field Name": "Accept-Post",
    "Template": "perm/accept-post",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://www.w3.org/TR/ldp/]"
  },
  {
    "Header Field Name": "Accept-Ranges",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 2.3]"
  },
  {
    "Header Field Name": "Age",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.1]"
  },
  {
    "Header Field Name": "Allow",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.1]"
  },
  {
    "Header Field Name": "ALPN",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7639, Section 2]"
  },
  {
    "Header Field Name": "Also-Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Alt-Svc",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alt-Used",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alternate-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Alternates",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Apply-To-Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "Approved",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archive",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Article-Names",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Article-Updates",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Authentication-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 4]"
  },
  {
    "Header Field Name": "Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 3]"
  },
  {
    "Header Field Name": "Authentication-Results",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7601]"
  },
  {
    "Header Field Name": "Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.2]"
  },
  {
    "Header Field Name": "Auto-Submitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3834 section 5]"
  },
  {
    "Header Field Name": "Autoforwarded",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Autosubmitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC1808][RFC2068 Section 14.11]"
  },
  {
    "Header Field Name": "Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Body",
    "Template": "",
    "Protocol": "none",
    "Status": "reserved",
    "Reference": "[RFC6068]"
  },
  {
    "Header Field Name": "C-Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "C-PEP-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cache-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.2]"
  },
  {
    "Header Field Name": "CalDAV-Timezones",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7809, Section 7.1]"
  },
  {
    "Header Field Name": "Cancel-Key",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cancel-Lock",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Close",
    "Template": "",
    "Protocol": "http",
    "Status": "reserved",
    "Reference": "[RFC7230, Section 8.1]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Connection",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.1]"
  },
  {
    "Header Field Name": "Content-Alternative",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2068][RFC2616]"
  },
  {
    "Header Field Name": "Content-Base",
    "Template": "",
    "Protocol": "MIME",
    "Status": "obsoleted",
    "Reference": "[RFC2110][RFC2557]"
  },
  {
    "Header Field Name": "Content-Description",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6266]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Duration",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.2.2]"
  },
  {
    "Header Field Name": "Content-features",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-ID",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.3.2]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Length",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.4.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-MD5",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 4.2]"
  },
  {
    "Header Field Name": "Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Script-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Style-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Translation-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "standard",
    "Reference": "[RFC8255]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.1.5]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Content-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Conversion",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Conversion-With-Loss",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "DASL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5323]"
  },
  {
    "Header Field Name": "DAV",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "DL-Expansion-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.1.2]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Date-Received",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Default-Style",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Deferred-Delivery",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delivery-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Delta-Base",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Depth",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Derived-From",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Destination",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Differential-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Discarded-X400-IPMS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Discarded-X400-MTS-Extensions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disclose-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-Options",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Distribution",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "DKIM-Signature",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6376]"
  },
  {
    "Header Field Name": "Downgraded-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Disposition-Notification-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Final-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Mail-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Message-Id",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Original-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Rcpt-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Downgraded-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5504][RFC6857]"
  },
  {
    "Header Field Name": "Early-Data",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8470]"
  },
  {
    "Header Field Name": "Encoding",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Encrypted",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ETag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.3]"
  },
  {
    "Header Field Name": "Expect",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.1]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.3]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Expiry-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Ext",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Followup-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Forwarded",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7239]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.1]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Generate-Delivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "GetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Hobareg",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC7486, Section 6.1.1]"
  },
  {
    "Header Field Name": "Host",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.4]"
  },
  {
    "Header Field Name": "HTTP2-Settings",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7540, Section 3.2.1]"
  },
  {
    "Header Field Name": "IM",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "If",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "If-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.1]"
  },
  {
    "Header Field Name": "If-Modified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.3]"
  },
  {
    "Header Field Name": "If-None-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.2]"
  },
  {
    "Header Field Name": "If-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.2]"
  },
  {
    "Header Field Name": "If-Schedule-Tag-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "If-Unmodified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.4]"
  },
  {
    "Header Field Name": "Importance",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Include-Referred-Token-Binding-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Incomplete-Copy",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Injection-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Injection-Info",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Keep-Alive",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Language",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Last-Modified",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.2]"
  },
  {
    "Header Field Name": "Latest-Delivery-Time",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Lines",
    "Template": "",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5536][RFC3977]"
  },
  {
    "Header Field Name": "Link",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8288]"
  },
  {
    "Header Field Name": "List-Archive",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Help",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Owner",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Subscribe",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe",
    "Template": "perm/list-unsubscribe",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "List-Unsubscribe-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC8058]"
  },
  {
    "Header Field Name": "Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.2]"
  },
  {
    "Header Field Name": "Lock-Token",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Man",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Max-Forwards",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.2]"
  },
  {
    "Header Field Name": "Memento-Datetime",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7089]"
  },
  {
    "Header Field Name": "Message-Context",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Meter",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Appendix A.1]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "MIME",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "MMHS-Exempted-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.1 and Appendix B.105]"
  },
  {
    "Header Field Name": "MMHS-Extended-Authorisation-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.2 and Appendix B.106]"
  },
  {
    "Header Field Name": "MMHS-Subject-Indicator-Codes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.3 and Appendix B.107]"
  },
  {
    "Header Field Name": "MMHS-Handling-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.4 and Appendix B.108]"
  },
  {
    "Header Field Name": "MMHS-Message-Instructions",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.5 and Appendix B.109]"
  },
  {
    "Header Field Name": "MMHS-Codress-Message-Indicator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.6 and Appendix B.110]"
  },
  {
    "Header Field Name": "MMHS-Originator-Reference",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.7 and Appendix B.111]"
  },
  {
    "Header Field Name": "MMHS-Primary-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.8 and Appendix B.101]"
  },
  {
    "Header Field Name": "MMHS-Copy-Precedence",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.9 and Appendix B.102]"
  },
  {
    "Header Field Name": "MMHS-Message-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.10 and Appendix B.103]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Other-Recipients-Indicator-CC",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.12 and Appendix B.113]"
  },
  {
    "Header Field Name": "MMHS-Acp127-Message-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.14 and Appendix B.116]"
  },
  {
    "Header Field Name": "MMHS-Originator-PLAD",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6477][ACP123 Appendix A1.15 and Appendix B.117]"
  },
  {
    "Header Field Name": "MT-Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6758]"
  },
  {
    "Header Field Name": "Negotiate",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Newsgroups",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "NNTP-Posting-Host",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC2980][RFC5536]"
  },
  {
    "Header Field Name": "Obsoletes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Opt",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional-WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "experimental",
    "Reference": "[RFC8053, Section 3]"
  },
  {
    "Header Field Name": "Ordering-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "mail",
    "Status": "informational",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Origin",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6454]"
  },
  {
    "Header Field Name": "Original-Encoded-Information-Types",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Original-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Recipient",
    "Template": "perm/original-recipient",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3798][RFC5337]"
  },
  {
    "Header Field Name": "Original-Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5537]"
  },
  {
    "Header Field Name": "Originator-Return-Address",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Original-Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Overwrite",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "P3P",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Path",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "PEP",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "PICS-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Pep-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Position",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Posting-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Pragma",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.4]"
  },
  {
    "Header Field Name": "Prefer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Preference-Applied",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Prevent-NonDelivery-Report",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "ProfileObject",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Query",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Protocol-Request",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.3]"
  },
  {
    "Header Field Name": "Proxy-Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 4]"
  },
  {
    "Header Field Name": "Proxy-Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.4]"
  },
  {
    "Header Field Name": "Proxy-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Proxy-Instruction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Public-Key-Pins",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Public-Key-Pins-Report-Only",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.1]"
  },
  {
    "Header Field Name": "Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC5321]"
  },
  {
    "Header Field Name": "Received-SPF",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7208]"
  },
  {
    "Header Field Name": "Redirect-Ref",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4437]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Referer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.2]"
  },
  {
    "Header Field Name": "Relay-Version",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC0850][RFC5536]"
  },
  {
    "Header Field Name": "Reply-By",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Require-Recipient-Valid-Since",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7293]"
  },
  {
    "Header Field Name": "Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "obsoleted",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Retry-After",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.3]"
  },
  {
    "Header Field Name": "Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Safe",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Schedule-Reply",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Schedule-Tag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Sec-Token-Binding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Extensions",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Key",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Security-Scheme",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "See-Also",
    "Template": "",
    "Protocol": "netnews",
    "Status": "obsoleted",
    "Reference": "[RFC1849][RFC5536]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Sensitivity",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Server",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.2]"
  },
  {
    "Header Field Name": "Set-Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "Set-Cookie2",
    "Template": "",
    "Protocol": "http",
    "Status": "obsoleted",
    "Reference": "[RFC2965][RFC6265]"
  },
  {
    "Header Field Name": "SetProfile",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SLUG",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5023]"
  },
  {
    "Header Field Name": "SoapAction",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Solicitation",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC3865]"
  },
  {
    "Header Field Name": "Status-URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Strict-Transport-Security",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6797]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Summary",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2156]"
  },
  {
    "Header Field Name": "Surrogate-Capability",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Surrogate-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TCN",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "TE",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.3]"
  },
  {
    "Header Field Name": "Timeout",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "TLS-Report-Domain",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "TLS-Report-Submitter",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Topic",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.4]"
  },
  {
    "Header Field Name": "Trailer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.4]"
  },
  {
    "Header Field Name": "Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.1]"
  },
  {
    "Header Field Name": "TTL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.2]"
  },
  {
    "Header Field Name": "Urgency",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.3]"
  },
  {
    "Header Field Name": "URI",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Upgrade",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.7]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.3]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2616]"
  },
  {
    "Header Field Name": "Variant-Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.4]"
  },
  {
    "Header Field Name": "VBR-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5518]"
  },
  {
    "Header Field Name": "Via",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.7.1]"
  },
  {
    "Header Field Name": "WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.1]"
  },
  {
    "Header Field Name": "Want-Digest",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Warning",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.5]"
  },
  {
    "Header Field Name": "X400-Content-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Return",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Content-Type",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-MTS-Identifier",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Originator",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Recipients",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X400-Trace",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC4021]"
  },
  {
    "Header Field Name": "X-Content-Type-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://fetch.spec.whatwg.org/#x-content-type-options-header]"
  },
  {
    "Header Field Name": "X-Frame-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "informational",
    "Reference": "[RFC7034]"
  },
  {
    "Header Field Name": "Xref",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  }
]
},{}],305:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "Access-Control",
    "Template": "prov/access-control",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Credentials",
    "Template": "prov/access-control-allow-credentials",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Headers",
    "Template": "prov/access-control-allow-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Methods",
    "Template": "prov/access-control-allow-methods",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Allow-Origin",
    "Template": "prov/access-control-allow-origin",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Max-Age",
    "Template": "prov/access-control-max-age",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Method",
    "Template": "prov/access-control-request-method",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Access-Control-Request-Headers",
    "Template": "prov/access-control-request-headers",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "AMP-Cache-Transform",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[https://github.com/ampproject/amphtml/blob/master/spec/amp-cache-transform.md]"
  },
  {
    "Header Field Name": "Apparently-To",
    "Template": "prov/apparently-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "ARC-Authentication-Results",
    "Template": "prov/arc-authentication-results",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Message-Signature",
    "Template": "prov/arc-message-signature",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "ARC-Seal",
    "Template": "prov/arc-seal",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-ietf-dmarc-arc-protocol]"
  },
  {
    "Header Field Name": "Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Content-Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Cost",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "EDIINT-Features",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6017]"
  },
  {
    "Header Field Name": "Eesst-Version",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7681]"
  },
  {
    "Header Field Name": "Errors-To",
    "Template": "prov/errors-to",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC2076]"
  },
  {
    "Header Field Name": "Form-Sub",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-levine-mailbomb-header]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Jabber-ID",
    "Template": "prov/jabber-id",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[RFC7259]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Method-Check",
    "Template": "prov/method-check",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Method-Check-Expires",
    "Template": "prov/method-check-expires",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "MMHS-Authorizing-Users",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7912]"
  },
  {
    "Header Field Name": "Non-Compliance",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Optional",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Privicon",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[draft-koenig-privicons]"
  },
  {
    "Header Field Name": "Referer-Root",
    "Template": "prov/referer-root",
    "Protocol": "http",
    "Status": "deprecated",
    "Reference": "[W3C Web Application Formats Working Group]"
  },
  {
    "Header Field Name": "Resolution-Hint",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Resolver-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "SIO-Label",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SIO-Label-History",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC7444]"
  },
  {
    "Header Field Name": "SubOK",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Subst",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Title",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Color",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Media",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Pixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Resolution",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "UA-Windowpixels",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Version",
    "Template": "",
    "Protocol": "http",
    "Status": "",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "mail",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Archived-At",
    "Template": "prov/x-archived-at",
    "Protocol": "netnews",
    "Status": "deprecated",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "X-Device-Accept",
    "Template": "prov/x-device-accept",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Charset",
    "Template": "prov/x-device-accept-charset",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Encoding",
    "Template": "prov/x-device-accept-encoding",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-Accept-Language",
    "Template": "prov/x-device-accept-language",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Device-User-Agent",
    "Template": "prov/x-device-user-agent",
    "Protocol": "http",
    "Status": "",
    "Reference": "[W3C Mobile Web Best Practices Working Group]"
  },
  {
    "Header Field Name": "X-Mittente",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-PGP-Sig",
    "Template": "prov/x-pgp-sig",
    "Protocol": "netnews",
    "Status": "",
    "Reference": "[ftp://ftp.isc.org/pub/pgpcontrol/FORMAT][https://ftp.isc.org/pub/pgpcontrol/FORMAT]"
  },
  {
    "Header Field Name": "X-Ricevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Riferimento-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-TipoRicevuta",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-Trasporto",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  },
  {
    "Header Field Name": "X-VerificaSicurezza",
    "Template": "",
    "Protocol": "mail",
    "Status": "",
    "Reference": "[RFC6109]"
  }
]
},{}],306:[function(require,module,exports){
module.exports=[
  {
    "Header Field Name": "Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.2]"
  },
  {
    "Header Field Name": "Accept-Charset",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.3]"
  },
  {
    "Header Field Name": "Accept-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.4][RFC7694, Section 3]"
  },
  {
    "Header Field Name": "Accept-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.3.5]"
  },
  {
    "Header Field Name": "Accept-Post",
    "Template": "perm/accept-post",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://www.w3.org/TR/ldp/]"
  },
  {
    "Header Field Name": "Accept-Ranges",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 2.3]"
  },
  {
    "Header Field Name": "Age",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.1]"
  },
  {
    "Header Field Name": "Allow",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.1]"
  },
  {
    "Header Field Name": "ALPN",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7639, Section 2]"
  },
  {
    "Header Field Name": "Alt-Svc",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Alt-Used",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7838]"
  },
  {
    "Header Field Name": "Approved",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archive",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Archived-At",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5064]"
  },
  {
    "Header Field Name": "Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 3]"
  },
  {
    "Header Field Name": "Authentication-Results",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7601]"
  },
  {
    "Header Field Name": "Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.2]"
  },
  {
    "Header Field Name": "Auto-Submitted",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3834 section 5]"
  },
  {
    "Header Field Name": "Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Cache-Control",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.2]"
  },
  {
    "Header Field Name": "CalDAV-Timezones",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7809, Section 7.1]"
  },
  {
    "Header Field Name": "Cancel-Key",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cancel-Lock",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC8315]"
  },
  {
    "Header Field Name": "Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Comments",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Connection",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.1]"
  },
  {
    "Header Field Name": "Content-Disposition",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6266]"
  },
  {
    "Header Field Name": "Content-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.2.2]"
  },
  {
    "Header Field Name": "Content-Language",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.3.2]"
  },
  {
    "Header Field Name": "Content-Length",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.2]"
  },
  {
    "Header Field Name": "Content-Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.4.2]"
  },
  {
    "Header Field Name": "Content-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 4.2]"
  },
  {
    "Header Field Name": "Content-Translation-Type",
    "Template": "",
    "Protocol": "MIME",
    "Status": "standard",
    "Reference": "[RFC8255]"
  },
  {
    "Header Field Name": "Content-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 3.1.1.5]"
  },
  {
    "Header Field Name": "Control",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "DASL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5323]"
  },
  {
    "Header Field Name": "DAV",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.1.2]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Depth",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Destination",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Distribution",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "DKIM-Signature",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6376]"
  },
  {
    "Header Field Name": "Downgraded-Final-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Message-Id",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-Original-Recipient",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Downgraded-References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6857 Section 3.1.10]"
  },
  {
    "Header Field Name": "Early-Data",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8470]"
  },
  {
    "Header Field Name": "ETag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.3]"
  },
  {
    "Header Field Name": "Expect",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.1]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.3]"
  },
  {
    "Header Field Name": "Expires",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Followup-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Forwarded",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7239]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.1]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "From",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Host",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.4]"
  },
  {
    "Header Field Name": "HTTP2-Settings",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7540, Section 3.2.1]"
  },
  {
    "Header Field Name": "If",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "If-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.1]"
  },
  {
    "Header Field Name": "If-Modified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.3]"
  },
  {
    "Header Field Name": "If-None-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.2]"
  },
  {
    "Header Field Name": "If-Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.2]"
  },
  {
    "Header Field Name": "If-Schedule-Tag-Match",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "If-Unmodified-Since",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 3.4]"
  },
  {
    "Header Field Name": "In-Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Include-Referred-Token-Binding-ID",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Injection-Date",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Injection-Info",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Keywords",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Last-Modified",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7232, Section 2.2]"
  },
  {
    "Header Field Name": "Link",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8288]"
  },
  {
    "Header Field Name": "List-Unsubscribe-Post",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC8058]"
  },
  {
    "Header Field Name": "Location",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.2]"
  },
  {
    "Header Field Name": "Lock-Token",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Max-Forwards",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.1.2]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Message-ID",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "MIME-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Appendix A.1]"
  },
  {
    "Header Field Name": "MT-Priority",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC6758]"
  },
  {
    "Header Field Name": "Newsgroups",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Ordering-Type",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Organization",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Origin",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6454]"
  },
  {
    "Header Field Name": "Original-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Original-Recipient",
    "Template": "perm/original-recipient",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC3798][RFC5337]"
  },
  {
    "Header Field Name": "Original-Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5537]"
  },
  {
    "Header Field Name": "Original-Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5703]"
  },
  {
    "Header Field Name": "Overwrite",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "Path",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Position",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4229]"
  },
  {
    "Header Field Name": "Pragma",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.4]"
  },
  {
    "Header Field Name": "Prefer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Preference-Applied",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7240]"
  },
  {
    "Header Field Name": "Proxy-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.3]"
  },
  {
    "Header Field Name": "Proxy-Authentication-Info",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7615, Section 4]"
  },
  {
    "Header Field Name": "Proxy-Authorization",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.4]"
  },
  {
    "Header Field Name": "Public-Key-Pins",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Public-Key-Pins-Report-Only",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7469]"
  },
  {
    "Header Field Name": "Range",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7233, Section 3.1]"
  },
  {
    "Header Field Name": "Received",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC5321]"
  },
  {
    "Header Field Name": "Received-SPF",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7208]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "References",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Referer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.2]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Reply-To",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Require-Recipient-Valid-Since",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC7293]"
  },
  {
    "Header Field Name": "Resent-Bcc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Cc",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Date",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-From",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-Message-ID",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Resent-Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Resent-To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Retry-After",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.3]"
  },
  {
    "Header Field Name": "Return-Path",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Schedule-Reply",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Schedule-Tag",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6638]"
  },
  {
    "Header Field Name": "Sec-Token-Binding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC-ietf-tokbind-https-18]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Accept",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Extensions",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Key",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Protocol",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sec-WebSocket-Version",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6455]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322][RFC6854]"
  },
  {
    "Header Field Name": "Sender",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Server",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.4.2]"
  },
  {
    "Header Field Name": "Set-Cookie",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6265]"
  },
  {
    "Header Field Name": "SLUG",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC5023]"
  },
  {
    "Header Field Name": "Strict-Transport-Security",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC6797]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Subject",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC5322]"
  },
  {
    "Header Field Name": "Summary",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  },
  {
    "Header Field Name": "Supersedes",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2156]"
  },
  {
    "Header Field Name": "TE",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.3]"
  },
  {
    "Header Field Name": "Timeout",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC4918]"
  },
  {
    "Header Field Name": "TLS-Report-Domain",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "TLS-Report-Submitter",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC-ietf-uta-smtp-tlsrpt-23]"
  },
  {
    "Header Field Name": "To",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5322]"
  },
  {
    "Header Field Name": "Topic",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.4]"
  },
  {
    "Header Field Name": "Trailer",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 4.4]"
  },
  {
    "Header Field Name": "Transfer-Encoding",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 3.3.1]"
  },
  {
    "Header Field Name": "TTL",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.2]"
  },
  {
    "Header Field Name": "Urgency",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC8030, Section 5.3]"
  },
  {
    "Header Field Name": "Upgrade",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 6.7]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 5.5.3]"
  },
  {
    "Header Field Name": "User-Agent",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536][RFC2616]"
  },
  {
    "Header Field Name": "Vary",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7231, Section 7.1.4]"
  },
  {
    "Header Field Name": "VBR-Info",
    "Template": "",
    "Protocol": "mail",
    "Status": "standard",
    "Reference": "[RFC5518]"
  },
  {
    "Header Field Name": "Via",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7230, Section 5.7.1]"
  },
  {
    "Header Field Name": "WWW-Authenticate",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7235, Section 4.1]"
  },
  {
    "Header Field Name": "Warning",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[RFC7234, Section 5.5]"
  },
  {
    "Header Field Name": "X-Content-Type-Options",
    "Template": "",
    "Protocol": "http",
    "Status": "standard",
    "Reference": "[https://fetch.spec.whatwg.org/#x-content-type-options-header]"
  },
  {
    "Header Field Name": "Xref",
    "Template": "",
    "Protocol": "netnews",
    "Status": "standard",
    "Reference": "[RFC5536]"
  }
]
},{}],307:[function(require,module,exports){
/**
 * @file The constant NaN derived mathematically by 0 / 0.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module nan-x
 */

'use strict';

/**
 * The constant NaN derived mathematically by 0 / 0.
 *
 * @type number
 * @example
 * var NAN = require('nan-x');
 *
 * NAN !== NAN; // true
 * NAN === NAN; // false
 */
module.exports = 0 / 0;

},{}],308:[function(require,module,exports){
/**
 * @file Trims and replaces sequences of whitespace characters by a single space.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module normalize-space-x
 */

'use strict';

var libTrim = require('trim-x');
var trim2016 = libTrim.trim2016;
var trim2018 = libTrim.trim2018;
var Rx = require('cached-constructors-x').RegExp;
var libWhiteSpace = require('white-space-x');
var reNormalize2016 = new Rx('[' + libWhiteSpace.string2016 + ']+', 'g');
var reNormalize2018 = new Rx('[' + libWhiteSpace.string2018 + ']+', 'g');
var replace = ''.replace;

var $normalizeSpace2016 = function normalizeSpace2016(string) {
  return replace.call(trim2016(string), reNormalize2016, ' ');
};

var $normalizeSpace2018 = function normalizeSpace2018(string) {
  return replace.call(trim2018(string), reNormalize2018, ' ');
};

module.exports = {
  /**
   * Reference to normalizeSpace2018.
   */
  normalizeSpace: $normalizeSpace2018,

  /**
   * This method strips leading and trailing white-space from a string,
   * replaces sequences of whitespace characters by a single space,
   * and returns the resulting string. (ES2016)
   *
   * @param {string} string - The string to be normalized.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The normalized string.
   * @example
   * var normalizeSpace = require('normalize-space-x');
   *
   * normalizeSpace(' \t\na \t\nb \t\n') === 'a b'; // true
   */
  normalizeSpace2016: $normalizeSpace2016,

  /**
   * This method strips leading and trailing white-space from a string,
   * replaces sequences of whitespace characters by a single space,
   * and returns the resulting string. (ES2018)
   *
   * @param {string} string - The string to be normalized.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The normalized string.
   * @example
   * var normalizeSpace = require('normalize-space-x');
   *
   * normalizeSpace(' \t\na \t\nb \t\n') === 'a b'; // true
   */
  normalizeSpace2018: $normalizeSpace2018
};

},{"cached-constructors-x":35,"trim-x":310,"white-space-x":311}],309:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"cached-constructors-x":35,"dup":92,"require-coercible-to-string-x":329,"white-space-x":311}],310:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"dup":85,"trim-left-x":350,"trim-right-x":309}],311:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],312:[function(require,module,exports){
/**
 * @file Used to copy the values of all enumerable own properties from one or more source objects to a target object.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-assign-x
 */

'use strict';

var attempt = require('attempt-x');
var objectKeys = require('object-keys-x');
var isFunction = require('is-function-x');
var reduce = require('array-reduce-x');
var getOwnPropertyNames = require('get-own-property-names-x');
var isObjectLike = require('is-object-like-x');
var nativeAssign = isFunction(Object.assign) && Object.assign;

var workingNativeAssign = function _nativeWorks() {
  var obj = {};
  var res = attempt(nativeAssign, obj, { 0: 1 }, { 1: 2 });
  return res.threw === false && res.value === obj && objectKeys(obj).length === 2 && obj[0] === 1 && obj[1] === 2;
};

// eslint-disable-next-line id-length
var lacksProperEnumerationOrder = function _enumOrder() {
  // https://bugs.chromium.org/p/v8/issues/detail?id=4118
  var test1 = Object('abc');
  test1[5] = 'de';
  if (getOwnPropertyNames(test1)[0] === '5') {
    return true;
  }

  var strNums = '0123456789';
  // https://bugs.chromium.org/p/v8/issues/detail?id=3056
  var test2 = reduce(strNums.split(''), function (acc, ignore, index) {
    acc['_' + String.fromCharCode(index)] = index;
    return acc;
  }, {});

  var order = reduce(getOwnPropertyNames(test2), function (acc, name) {
    return acc + test2[name];
  }, '');

  if (order !== strNums) {
    return true;
  }

  // https://bugs.chromium.org/p/v8/issues/detail?id=3056
  var letters = 'abcdefghijklmnopqrst';
  var test3 = reduce(letters.split(''), function (acc, letter) {
    acc[letter] = letter;
    return acc;
  }, {});

  var result = attempt(nativeAssign, {}, test3);
  return result.threw === false && objectKeys(result.value).join('') !== letters;
};

// eslint-disable-next-line id-length
var assignHasPendingExceptions = function _exceptions() {
  if (isFunction(Object.preventExtensions) === false) {
    return false;
  }

  // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
  // which is 72% slower than our shim, and Firefox 40's native implementation.
  var result = attempt(Object.preventExtensions, { 1: 2 });
  if (result.threw || isObjectLike(result.value) === false) {
    return false;
  }

  var thrower = result.value;
  result = attempt(nativeAssign, thrower, 'xy');
  return result.threw ? thrower[1] === 'y' : false;
};

var shouldImplement = (function () {
  if (nativeAssign === false) {
    return true;
  }

  if (workingNativeAssign() === false) {
    return true;
  }

  if (lacksProperEnumerationOrder()) {
    return true;
  }

  if (assignHasPendingExceptions()) {
    return true;
  }

  return false;
}());

var $assign;
if (shouldImplement) {
  var toObject = require('to-object-x');
  var slice = require('array-slice-x');
  var isNil = require('is-nil-x');
  var getOEPS = require('get-own-enumerable-property-symbols-x');
  var concat = Array.prototype.concat;

  // 19.1.3.1
  $assign = function assign(target) {
    return reduce(slice(arguments, 1), function _assignSources(tgt, source) {
      if (isNil(source)) {
        return tgt;
      }

      var object = Object(source);
      return reduce(concat.call(objectKeys(object), getOEPS(object)), function _assignTo(tar, key) {
        tar[key] = object[key];
        return tar;
      }, tgt);
    }, toObject(target));
  };
} else {
  $assign = nativeAssign;
}

/**
 * This method is used to copy the values of all enumerable own properties from
 * one or more source objects to a target object. It will return the target object.
 *
 * @param {*} target - The target object.
 * @param {*} [...source] - The source object(s).
 * @throws {TypeError} If target is null or undefined.
 * @returns {Object} The target object.
 * @example
 * var assign = require('object-assign-x');
 *
 * var obj = { a: 1 };
 * var copy = assign({}, obj);
 * console.log(copy); // { a: 1 }
 */
module.exports = $assign;

},{"array-reduce-x":313,"array-slice-x":24,"attempt-x":32,"get-own-enumerable-property-symbols-x":63,"get-own-property-names-x":315,"is-function-x":110,"is-nil-x":122,"is-object-like-x":124,"object-keys-x":316,"to-object-x":344}],313:[function(require,module,exports){
/**
 * @file Reduce an array (from left to right) to a single value.
 * @version 2.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module array-reduce-x
 */

'use strict';

var cachedCtrs = require('cached-constructors-x');
var ArrayCtr = cachedCtrs.Array;
var castObject = cachedCtrs.Object;
var nativeReduce = typeof ArrayCtr.prototype.reduce === 'function' && ArrayCtr.prototype.reduce;

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
var isWorking;
if (nativeReduce) {
  var attempt = require('attempt-x');
  isWorking = attempt.call([], nativeReduce, function (acc) {
    return acc;
  }).threw;

  var res;
  if (isWorking) {
    res = attempt.call(castObject('abc'), nativeReduce, function (acc, c) {
      return acc + c;
    }, 'x');

    isWorking = res.threw === false && res.value === 'xabc';
  }

  if (isWorking) {
    res = attempt.call((function () {
      return arguments;
    }(1, 2, 3)), nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 1);

    isWorking = res.threw === false && res.value === 7;
  }

  if (isWorking) {
    res = attempt.call({
      0: 1,
      1: 2,
      3: 3,
      4: 4,
      length: 4
    }, nativeReduce, function (acc, arg) {
      return acc + arg;
    }, 2);

    isWorking = res.threw === false && res.value === 8;
  }

  if (isWorking) {
    var doc = typeof document !== 'undefined' && document;
    if (doc) {
      var fragment = doc.createDocumentFragment();
      var div = doc.createElement('div');
      fragment.appendChild(div);
      res = attempt.call(fragment.childNodes, nativeReduce, function (acc, node) {
        acc[acc.length] = node;
        return acc;
      }, []);

      isWorking = res.threw === false && res.value.length === 1 && res.value[0] === div;
    }
  }

  if (isWorking) {
    // eslint-disable-next-line max-params
    res = attempt.call('ab', nativeReduce, function (_, __, ___, list) {
      return list;
    });

    isWorking = res.threw === false && typeof res.value === 'object';
  }
}

var $reduce;
if (nativeReduce && isWorking) {
  $reduce = function reduce(array, callBack /* , initialValue */) {
    var args = [callBack];
    if (arguments.length > 2) {
      args[1] = arguments[2];
    }

    return nativeReduce.apply(array, args);
  };
} else {
  // Check failure of by-index access of string characters (IE < 9)
  // and failure of `0 in boxedString` (Rhino)
  var splitIfBoxedBug = require('split-if-boxed-bug-x');
  var toLength = require('to-length-x').toLength2018;
  var toObject = require('to-object-x');
  var assertIsFunction = require('assert-is-function-x');

  $reduce = function reduce(array, callBack /* , initialValue*/) {
    var object = toObject(array);
    // If no callback function or if callback is not a callable function
    assertIsFunction(callBack);
    var iterable = splitIfBoxedBug(object);
    var length = toLength(iterable.length);
    var argsLength = arguments.length;
    // no value to return if no initial value and an empty array
    if (length === 0 && argsLength < 3) {
      throw new TypeError('reduce of empty array with no initial value');
    }

    var i = 0;
    var result;
    if (argsLength > 2) {
      result = arguments[2];
    } else {
      do {
        if (i in iterable) {
          result = iterable[i];
          i += 1;
          // eslint-disable-next-line no-restricted-syntax
          break;
        }

        // if array contains no values, no initial value to return
        i += 1;
        if (i >= length) {
          throw new TypeError('reduce of empty array with no initial value');
        }
      } while (true); // eslint-disable-line no-constant-condition
    }

    while (i < length) {
      if (i in iterable) {
        result = callBack(result, iterable[i], i, object);
      }

      i += 1;
    }

    return result;
  };
}

/**
 * This method applies a function against an accumulator and each element in the
 * array (from left to right) to reduce it to a single value.
 *
 * @param {array} array - The array to iterate over.
 * @param {Function} callBack - Function to execute for each element.
 * @param {*} [initialValue] - Value to use as the first argument to the first
 *  call of the callback. If no initial value is supplied, the first element in
 *  the array will be used. Calling reduce on an empty array without an initial
 *  value is an error.
 * @throws {TypeError} If array is null or undefined.
 * @throws {TypeError} If callBack is not a function.
 * @throws {TypeError} If called on an empty array without an initial value.
 * @returns {*} The value that results from the reduction.
 * @example
 * var reduce = require('array-reduce-x');
 *
 * var sum = reduce([0, 1, 2, 3], function (a, b) {
 *   return a + b;
 * }, 0);
 * // sum is 6
 */
module.exports = $reduce;

},{"assert-is-function-x":314,"attempt-x":32,"cached-constructors-x":35,"split-if-boxed-bug-x":334,"to-length-x":339,"to-object-x":344}],314:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16,"is-function-x":110,"is-primitive":126,"to-string-symbols-supported-x":347}],315:[function(require,module,exports){
/**
 * @file Creates an array of all properties (enumerable or not) found directly upon a given object.
 * @version 2.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module get-own-property-names-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeGOPN = typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames;

var getOPN;
if (nativeGOPN) {
  var attempt = require('attempt-x');
  var isArray = require('is-array-x');
  var isCorrectRes = function _isCorrectRes(r, length) {
    return r.threw === false && isArray(r.value) && r.value.length === length;
  };

  var either = function _either(r, a, b) {
    var x = r.value[0];
    var y = r.value[1];
    return (x === a && y === b) || (x === b && y === a);
  };

  var res = attempt(nativeGOPN, 'fo');
  if (isCorrectRes(res, 3) && either(res, '0', '1') && res.value[2] === 'length') {
    getOPN = nativeGOPN;
  } else {
    res = attempt(nativeGOPN, { a: 1, b: 2 });
    if (isCorrectRes(res, 2) && either(res, 'a', 'b')) {
      var toStringTag = require('to-string-tag-x');
      var arraySlice = require('array-slice-x');
      var win = typeof window === 'object' && window;
      var cachedWindowNames = win ? nativeGOPN(win) : [];

      getOPN = function getOwnPropertyNames(obj) {
        var val = toObject(obj);
        // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
        if (win && win !== window && toStringTag(val) === '[object Window]') {
          var result = attempt(nativeGOPN, val);
          return result.threw ? arraySlice(cachedWindowNames) : result.value;
        }

        return nativeGOPN(val);
      };
    }
  }
}

if (typeof getOPN !== 'function') {
  var objectKeys = require('object-keys-x');
  getOPN = function getOwnPropertyNames(obj) {
    return objectKeys(obj);
  };
}

/**
 * This method creates an array of all properties (enumerable or not) found
 * directly upon a given object.
 *
 * @param {object} obj - The object whose enumerable and non-enumerable own
 *  properties are to be returned.
 * @throws {TypeError} If target is null or undefined.
 * @returns {array} An array of strings that correspond to the properties found
 *  directly upon the given object.
 * @example
 * var getOwnPropertyName = require('get-own-property-name-x');
 *
 * getOwnPropertyNames('foo'); // ["0", "1", "2", "length"]
 */
module.exports = getOPN;

},{"array-slice-x":24,"attempt-x":32,"is-array-x":101,"object-keys-x":316,"to-object-x":344,"to-string-tag-x":348}],316:[function(require,module,exports){
/**
 * @file An ES6 Object.keys shim.
 * @version 2.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-keys-x
 */

'use strict';

var toObject = require('to-object-x');
var nativeKeys = typeof Object.keys === 'function' && Object.keys;

var isWorking;
var throwsWithNull;
var worksWithPrim;
var worksWithRegex;
var worksWithArgs;
var worksWithStr;
if (nativeKeys) {
  var attempt = require('attempt-x');
  var isArray = require('is-array-x');
  var isCorrectRes = function _isCorrectRes(r, length) {
    return r.threw === false && isArray(r.value) && r.value.length === length;
  };

  var either = function _either(r, a, b) {
    var x = r.value[0];
    var y = r.value[1];
    return (x === a && y === b) || (x === b && y === a);
  };

  var testObj = { a: 1, b: 2 };
  var res = attempt(nativeKeys, testObj);
  isWorking = isCorrectRes(res, 2) && either(res, 'a', 'b');

  if (isWorking) {
    testObj = Object('a');
    testObj.y = 1;
    res = attempt(nativeKeys, testObj);
    isWorking = isCorrectRes(res, 2) && either(res, '0', 'y');
  }

  if (isWorking) {
    throwsWithNull = attempt(nativeKeys, null).threw;
    worksWithPrim = isCorrectRes(attempt(nativeKeys, 42), 0);
    worksWithRegex = attempt(nativeKeys, /a/g).threw === false;

    res = attempt(nativeKeys, (function () {
      return arguments;
    }(1, 2)));

    worksWithArgs = isCorrectRes(res, 2) && either(res, '0', '1');

    res = attempt(nativeKeys, Object('ab'));
    worksWithStr = isCorrectRes(res, 2) && either(res, '0', '1');
  }
}

var objectKeys;
if (isWorking) {
  if (throwsWithNull && worksWithPrim && worksWithRegex && worksWithArgs && worksWithStr) {
    objectKeys = nativeKeys;
  } else {
    var isArguments = worksWithArgs !== true && require('is-arguments');
    var arraySlice = isArguments && require('array-like-slice-x');
    var splitIfBoxed = worksWithStr !== true && require('split-if-boxed-bug-x');
    var isString = splitIfBoxed && require('is-string');
    var isRegexp = worksWithRegex !== true && require('is-regexp-x');
    var has = isRegexp && require('has-own-property-x');

    objectKeys = function keys(object) {
      var obj = toObject ? toObject(object) : object;
      if (isArguments && isArguments(obj)) {
        obj = arraySlice(obj);
      } else if (isString && isString(obj)) {
        obj = splitIfBoxed(obj);
      } else if (isRegexp && isRegexp(obj)) {
        var regexKeys = [];
        // eslint-disable-next-line no-restricted-syntax
        for (var k in obj) {
          if (has(obj, k)) {
            regexKeys[regexKeys.length] = k;
          }
        }

        return regexKeys;
      }

      return nativeKeys(obj);
    };
  }
} else {
  var objKeys = require('object-keys');
  objectKeys = function keys(object) {
    return objKeys(toObject(object));
  };
}

/**
 * This method returns an array of a given object's own enumerable properties,
 * in the same order as that provided by a for...in loop (the difference being
 * that a for-in loop enumerates properties in the prototype chain as well).
 *
 * @param {*} obj The object of which the enumerable own properties are to be returned.
 * @return {Array} An array of strings that represent all the enumerable properties of the given object.
 * @example
 * var objectKeys = require('object-keys-x');
 *
 * var obj = {
 *   arr: [],
 *   bool: true,
 *   'null': null,
 *   num: 42,
 *   obj: { },
 *   str: 'boz',
 *   undefined: void 0
 * };
 *
 * objectKeys(obj); // ['arr', 'bool', 'null', 'num', 'obj', 'str', 'undefined']
 */
module.exports = objectKeys;

},{"array-like-slice-x":14,"attempt-x":32,"has-own-property-x":70,"is-arguments":98,"is-array-x":101,"is-regexp-x":129,"is-string":134,"object-keys":321,"split-if-boxed-bug-x":334,"to-object-x":344}],317:[function(require,module,exports){
/**
 * @file Sham for Object.defineProperties
 * @version 2.0.4
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-define-properties-x
 */

'use strict';

var forEach = require('array-for-each-x');
var $keys = require('object-keys-x');
var $defineProperty = require('object-define-property-x');
var $defineProperties = Object.defineProperties;
var definePropertiesFallback;

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var doesDefinePropertyWork = function _doesDefinePropertyWork(object) {
  try {
    $defineProperty(object, 'sentinel', {});
    return 'sentinel' in object;
  } catch (exception) {
    return false;
  }
};

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if ($defineProperty) {
  // eslint-disable-next-line id-length
  var definePropertyWorksOnObject = doesDefinePropertyWork({});
  var definePropertyWorksOnDom = typeof document === 'undefined' || doesDefinePropertyWork(document.createElement('div'));
  if (definePropertyWorksOnObject === false || definePropertyWorksOnDom === false) {
    definePropertiesFallback = Object.defineProperties;
  }
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (Boolean($defineProperties) === false || definePropertiesFallback) {
  $defineProperties = function defineProperties(object, properties) {
    // make a valiant attempt to use the real defineProperties
    if (definePropertiesFallback) {
      try {
        return definePropertiesFallback.call(Object, object, properties);
      } catch (exception) {
        // try the shim if the real one doesn't work
      }
    }

    forEach($keys(properties), function (property) {
      if (property !== '__proto__') {
        $defineProperty(object, property, properties[property]);
      }
    });
    return object;
  };
}

/**
 * This method defines new or modifies existing properties directly on an
 * object, returning the object.
 *
 * @param {Object} object - The object on which to define or modify properties.
 * @param {Object} properties - An object whose own enumerable properties
 *  constitute descriptors for the
 * properties to be defined or modified.
 * @returns {Object} The object that was passed to the function.
 * @example
 * var defineProperties = require('object-define-properties-x');
 *
 * var obj = {};
 * defineProperties(obj, {
 *   'property1': {
 *     value: true,
 *     writable: true
 *   },
 *   'property2': {
 *     value: 'Hello',
 *     writable: true
 *   }
 *   // etc. etc.
 * });
 */
module.exports = $defineProperties;

},{"array-for-each-x":8,"object-define-property-x":318,"object-keys-x":320}],318:[function(require,module,exports){
/**
 * @file Sham for Object.defineProperty
 * @version 2.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-define-property-x
 */

'use strict';

var isPrimitive = require('is-primitive');
var owns = require('has-own-property-x');
var $defineProperty = Object.defineProperty;

var prototypeOfObject = Object.prototype;
var definePropertyFallback;
// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
if (supportsAccessors) {
  /* eslint-disable no-underscore-dangle, no-restricted-properties */
  defineGetter = prototypeOfObject.__defineGetter__;
  defineSetter = prototypeOfObject.__defineSetter__;
  lookupGetter = prototypeOfObject.__lookupGetter__;
  lookupSetter = prototypeOfObject.__lookupSetter__;
  /* eslint-enable no-underscore-dangle, no-restricted-properties */
}

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var doesDefinePropertyWork = function _doesDefinePropertyWork(object) {
  try {
    $defineProperty(object, 'sentinel', {});
    return 'sentinel' in object;
  } catch (exception) {
    return false;
  }
};

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if ($defineProperty) {
  // eslint-disable-next-line id-length
  var definePropertyWorksOnObject = doesDefinePropertyWork({});
  var definePropertyWorksOnDom = typeof document === 'undefined' || doesDefinePropertyWork(document.createElement('div'));
  if (definePropertyWorksOnObject === false || definePropertyWorksOnDom === false) {
    definePropertyFallback = Object.defineProperty;
  }
}

if (Boolean($defineProperty) === false || definePropertyFallback) {
  var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
  var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
  // eslint-disable-next-line id-length
  var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

  $defineProperty = function defineProperty(object, property, descriptor) {
    if (isPrimitive(object)) {
      throw new TypeError(ERR_NON_OBJECT_TARGET + object);
    }
    if (isPrimitive(descriptor)) {
      throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
    }
    // make a valiant attempt to use the real defineProperty
    // for I8's DOM elements.
    if (definePropertyFallback) {
      try {
        return definePropertyFallback.call(Object, object, property, descriptor);
      } catch (exception) {
        // try the shim if the real one doesn't work
      }
    }

    // If it's a data property.
    if ('value' in descriptor) {
      // fail silently if 'writable', 'enumerable', or 'configurable'
      // are requested but not supported
      /*
      // alternate approach:
      if ( // can't implement these features; allow false but not true
          ('writable' in descriptor && !descriptor.writable) ||
          ('enumerable' in descriptor && !descriptor.enumerable) ||
          ('configurable' in descriptor && !descriptor.configurable)
      ))
          throw new RangeError(
            'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
          );
      */

      if (supportsAccessors && (lookupGetter.call(object, property) || lookupSetter.call(object, property))) {
        // As accessors are supported only on engines implementing
        // `__proto__` we can safely override `__proto__` while defining
        // a property to make sure that we don't hit an inherited
        // accessor.
        /* eslint-disable no-proto */
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;
        // Deleting a property anyway since getter / setter may be
        // defined on object itself.
        delete object[property];
        object[property] = descriptor.value;
        // Setting original `__proto__` back now.
        object.__proto__ = prototype;
        /* eslint-enable no-proto */
      } else {
        object[property] = descriptor.value;
      }
    } else {
      var hasGetter = 'get' in descriptor;
      var hasSetter = 'set' in descriptor;
      if (supportsAccessors === false && (hasGetter || hasSetter)) {
        throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
      }
      // If we got that far then getters and setters can be defined !!
      if (hasGetter) {
        defineGetter.call(object, property, descriptor.get);
      }
      if (hasSetter) {
        defineSetter.call(object, property, descriptor.set);
      }
    }
    return object;
  };
}

/**
 * This method defines a new property directly on an object, or modifies an existing property on an object,
 * and returns the object.
 *
 * @param {Object} object - The object on which to define the property.
 * @param {string} property - The name of the property to be defined or modified.
 * @param {Object} descriptor - The descriptor for the property being defined or modified.
 * @returns {Object} The object that was passed to the function.
 * @example
 * var defineProperty = require('object-define-property-x');
 *
 * var o = {}; // Creates a new object
 *
 * defineProperty(o, 'a', {
 *   value: 37,
 *   writable: true
 * });
 */
module.exports = $defineProperty;

},{"has-own-property-x":70,"is-primitive":126}],319:[function(require,module,exports){
/**
 * @file Sham for ES6 Object.getOwnPropertyDescriptor
 * @version 3.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-get-own-property-descriptor-x
 */

'use strict';

var toObject = require('to-object-x');
var toPropertyKey = require('to-property-key-x');
var isFalsey = require('is-falsey-x');
var attempt = require('attempt-x');

var nativeGOPD = typeof Object.getOwnPropertyDescriptor === 'function' && Object.getOwnPropertyDescriptor;
var getOPDFallback1;
var getOPDFallback2;

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3

var doesGOPDWork = function (object, prop) {
  object[toPropertyKey(prop)] = 0;
  var testResult = attempt(nativeGOPD, object, prop);
  return testResult.threw === false && testResult.value.value === 0;
};

// check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
var $getOwnPropertyDescriptor;
if (nativeGOPD) {
  var doc = typeof document !== 'undefined' && document;
  var getOPDWorksOnDom = doc ? doesGOPDWork(doc.createElement('div'), 'sentinel') : true;
  if (getOPDWorksOnDom) {
    var res = attempt(nativeGOPD, Object('abc'), 1);
    var worksWithStr = res.threw === false && res.value && res.value.value === 'b';
    if (worksWithStr) {
      var getOPDWorksOnObject = doesGOPDWork({}, 'sentinel');
      if (getOPDWorksOnObject) {
        var worksWithPrim = attempt(nativeGOPD, 42, 'name').threw === false;
        var worksWithObjSym = require('has-symbol-support-x') && doesGOPDWork({}, Object(Symbol('')));
        // eslint-disable-next-line max-depth
        if (worksWithObjSym) {
          // eslint-disable-next-line max-depth
          if (worksWithPrim) {
            $getOwnPropertyDescriptor = nativeGOPD;
          } else {
            $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
              return nativeGOPD(toObject(object), property);
            };
          }
        } else if (worksWithPrim) {
          $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            return nativeGOPD(object, toPropertyKey(property));
          };
        } else {
          $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            return nativeGOPD(toObject(object), toPropertyKey(property));
          };
        }
      } else {
        getOPDFallback1 = nativeGOPD;
      }
    } else {
      getOPDFallback2 = nativeGOPD;
    }
  }
}

if (isFalsey($getOwnPropertyDescriptor) || getOPDFallback1 || getOPDFallback2) {
  var owns = require('has-own-property-x');
  var isPrimitive = require('is-primitive');
  var isString = require('is-string');
  var isIndex = require('is-index-x');
  var propertyIsEnumerable = require('property-is-enumerable-x');
  var prototypeOfObject = Object.prototype;

  // If JS engine supports accessors creating shortcuts.
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
  if (supportsAccessors) {
    // eslint-disable-next-line no-underscore-dangle
    var lg = prototypeOfObject.__lookupGetter__;
    // eslint-disable-next-line no-underscore-dangle
    var ls = prototypeOfObject.__lookupSetter__;
    lookupGetter = function (object, property) {
      return lg.call(object, property);
    };

    lookupSetter = function (object, property) {
      return ls.call(object, property);
    };
  }

  $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
    var obj = toObject(object);
    var propKey = toPropertyKey(property);

    var result;
    // make a valiant attempt to use the real getOwnPropertyDescriptor for I8's DOM elements.
    if (getOPDFallback1) {
      result = attempt.call(Object, getOPDFallback1, obj, propKey);
      if (result.threw === false) {
        return result.value;
      }
      // try the shim if the real one doesn't work
    }

    var isStringIndex = isString(obj) && isIndex(propKey, obj.length);
    if (getOPDFallback2 && isStringIndex === false) {
      result = attempt.call(Object, getOPDFallback2, obj, propKey);
      if (result.threw === false) {
        return result.value;
      }
      // try the shim if the real one doesn't work
    }

    var descriptor;
    // If object does not owns property return undefined immediately.
    if (isStringIndex === false && owns(obj, propKey) === false) {
      return descriptor;
    }

    // If object has a property then it's for sure `configurable`, and
    // probably `enumerable`. Detect enumerability though.
    descriptor = {
      configurable: isPrimitive(object) === false && isStringIndex === false,
      enumerable: propertyIsEnumerable(obj, propKey)
    };

    // If JS engine supports accessor properties then property may be a
    // getter or setter.
    if (supportsAccessors) {
      // Unfortunately `__lookupGetter__` will return a getter even
      // if object has own non getter property along with a same named
      // inherited getter. To avoid misbehavior we temporary remove
      // `__proto__` so that `__lookupGetter__` will return getter only
      // if it's owned by an object.
      // eslint-disable-next-line no-proto
      var prototype = obj.__proto__;
      var notPrototypeOfObject = obj !== prototypeOfObject;
      // avoid recursion problem, breaking in Opera Mini when
      // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
      // or any other Object.prototype accessor
      if (notPrototypeOfObject) {
        // eslint-disable-next-line no-proto
        obj.__proto__ = prototypeOfObject;
      }

      var getter = lookupGetter(obj, propKey);
      var setter = lookupSetter(obj, propKey);

      if (notPrototypeOfObject) {
        // Once we have getter and setter we can put values back.
        // eslint-disable-next-line no-proto
        obj.__proto__ = prototype;
      }

      if (getter || setter) {
        if (getter) {
          descriptor.get = getter;
        }

        if (setter) {
          descriptor.set = setter;
        }

        // If it was accessor property we're done and return here
        // in order to avoid adding `value` to the descriptor.
        return descriptor;
      }
    }

    // If we got this far we know that object has an own property that is
    // not an accessor so we set it as a value and return descriptor.
    if (isStringIndex) {
      descriptor.value = obj.charAt(propKey);
      descriptor.writable = false;
    } else {
      descriptor.value = obj[propKey];
      descriptor.writable = true;
    }

    return descriptor;
  };
}

/**
 * This method returns a property descriptor for an own property (that is,
 * one directly present on an object and not in the object's prototype chain)
 * of a given object.
 *
 * @param {*} object - The object in which to look for the property.
 * @param {*} property - The name of the property whose description is to be retrieved.
 * @returns {Object} A property descriptor of the given property if it exists on the object, undefined otherwise.
 * @example
 * var getOwnPropertyDescriptor = require('object-get-own-property-descriptor-x');
 * var obj = { bar: 42 };
 * var d = getOwnPropertyDescriptor(o, 'bar');
 * // d is {
 * //   configurable: true,
 * //   enumerable: true,
 * //   value: 42,
 * //   writable: true
 * // }
 */
module.exports = $getOwnPropertyDescriptor;

},{"attempt-x":32,"has-own-property-x":70,"has-symbol-support-x":72,"is-falsey-x":108,"is-index-x":112,"is-primitive":126,"is-string":134,"property-is-enumerable-x":326,"to-object-x":344,"to-property-key-x":346}],320:[function(require,module,exports){
/**
 * @file An ES6 Object.keys shim.
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module object-keys-x
 */

'use strict';

var isArguments = require('is-arguments');
var toObject = require('to-object-x');
var originalKeys = Object.keys;

try {
  var arr = originalKeys({ a: 1, b: 2 });
  if (arr.length !== 2 || arr[0] !== 'a' || arr[1] !== 'b') {
    throw new Error('failed keys');
  }
} catch (ignore) {
  originalKeys = require('object-keys');
}

var keysWorksWithArguments = (function () {
  // Safari 5.0 bug
  return originalKeys(arguments).length === 2;
}(1, 2));

var keysHasArgumentsLengthBug = (function () {
  var argKeys = originalKeys(arguments);
  return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
}(1));

var objectKeys;
if (!keysWorksWithArguments || keysHasArgumentsLengthBug) {
  var arraySlice = Array.prototype.slice;
  objectKeys = function keys(object) {
    var obj = toObject(object);
    if (isArguments(object)) {
      return originalKeys(arraySlice.call(obj));
    }

    return originalKeys(obj);
  };
} else {
  objectKeys = function keys(object) {
    return originalKeys(toObject(object));
  };
}

/**
 * This method returns an array of a given object's own enumerable properties,
 * in the same order as that provided by a for...in loop (the difference being
 * that a for-in loop enumerates properties in the prototype chain as well).
 *
 * @param {*} obj The object of which the enumerable own properties are to be returned.
 * @return {Array} An array of strings that represent all the enumerable properties of the given object.
 * @example
 * var objectKeys = require('object-keys-x');
 *
 * var obj = {
 *   arr: [],
 *   bool: true,
 *   'null': null,
 *   num: 42,
 *   obj: { },
 *   str: 'boz',
 *   undefined: void 0
 * };
 *
 * objectKeys(obj); // ['arr', 'bool', 'null', 'num', 'obj', 'str', 'undefined']
 */
module.exports = objectKeys;

},{"is-arguments":98,"object-keys":321,"to-object-x":344}],321:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$applicationCache: true,
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":322}],322:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],323:[function(require,module,exports){
"use strict";

// <https://lacke.mn/reduce-your-bundle-js-file-size/>
// // <https://github.com/lodash/babel-plugin-lodash/issues/221>
var isError = require('lodash/isError');

var isArray = require('lodash/isArray');

var isEmpty = require('lodash/isEmpty');

var pick = require('lodash/pick');

var isFunction = require('lodash/isFunction'); // we want to support parsing other fields than the standard:
// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors>
// <https://github.com/stripe/stripe-node/blob/3c07d851cf897490d8b93dd4457dda0c4c8e667f/lib/Error.js#L33>


var parseErr = function parseErr(err) {
  var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!isError(err)) throw new Error('`err` must be an Error');
  if (!isArray(fields)) throw new Error('`fields` must be an Array');
  var keys = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(err)).concat(Object.getOwnPropertyNames(err)).forEach(function (key) {
    if (!isFunction(err[key])) keys[key] = err[key];
  });
  if (!keys.name && err.constructor.name) keys.name = err.constructor.name;
  return isArray(fields) && !isEmpty(fields) ? pick(keys, fields) : keys;
};

module.exports = parseErr;
},{"lodash/isArray":268,"lodash/isEmpty":271,"lodash/isError":272,"lodash/isFunction":273,"lodash/pick":290}],324:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"cached-constructors-x":35,"dup":81,"nan-x":307,"to-string-x":349,"trim-left-x":350}],325:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],326:[function(require,module,exports){
/**
 * @file Indicates whether the specified property is enumerable.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module property-is-enumerable-x
 */

'use strict';

var toPropertyKey = require('to-property-key-x');
var toObject = require('to-object-x');
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

/**
 * This method returns a Boolean indicating whether the specified property is
 * enumerable. Does not attempt to fix bugs in IE<9 or old Opera, otherwise it
 * does ES6ify the method.
 *
 * @param {!Object} object - The object on which to test the property.
 * @param {string|Symbol} property - The name of the property to test.
 * @throws {TypeError} If target is null or undefined.
 * @returns {boolean} A Boolean indicating whether the specified property is
 *  enumerable.
 * @example
 * var propertyIsEnumerable = require('property-is-enumerable-x');
 *
 * var o = {};
 * var a = [];
 * o.prop = 'is enumerable';
 * a[0] = 'is enumerable';
 *
 * propertyIsEnumerable(o, 'prop'); // true
 * propertyIsEnumerable(a, 0); // true
 */
module.exports = function propertyIsEnumerable(object, property) {
  return propIsEnumerable.call(toObject(object), toPropertyKey(property));
};

},{"to-object-x":344,"to-property-key-x":346}],327:[function(require,module,exports){
/**
 * @file Sham for Reflect.ownKeys
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module reflect-own-keys-x
 */

'use strict';

var hasReflect = require('has-reflect-support-x');
var reflectOwnKeys = hasReflect && Reflect.ownKeys;

if (reflectOwnKeys) {
  try {
    var k = reflectOwnKeys({ a: 1, b: 2 }).sort();
    if (k.length !== 2 || k[0] !== 'a' || k[1] !== 'b') {
      throw new Error('failed');
    }
  } catch (ignore) {
    reflectOwnKeys = null;
  }
}

if (Boolean(reflectOwnKeys) === false) {
  var assertIsObject = require('assert-is-object-x');
  var getOwnPropertyNames = require('get-own-property-names-x');
  var getOwnPropertySymbols = require('get-own-property-symbols-x');
  var concat = Array.prototype.concat;

  reflectOwnKeys = function ownKeys(target) {
    assertIsObject(target);
    return concat.call(getOwnPropertyNames(target), getOwnPropertySymbols(target));
  };
}

/**
 * This method returns an array of the target object's own property keys.
 * Its return value is equivalent to
 * Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)).
 *
 * @param {*} target - The target object from which to get the own keys.
 * @throws {TypeError} If target is not an Object.
 * @returns {Object} An Array of the target object's own property keys.
 * @example
 * var reflectOwnKeys = require('reflect-own-keys-x');
 * reflectOwnKeys({ a: 1, b: 2 }); // ['a', 'b']
 */
module.exports = reflectOwnKeys;

},{"assert-is-object-x":31,"get-own-property-names-x":66,"get-own-property-symbols-x":67,"has-reflect-support-x":71}],328:[function(require,module,exports){
/**
 * @file Replace the comments in a string.
 * @version 2.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module replace-comments-x
 */

'use strict';

var toStr = require('to-string-x');
var requireCoercibleToString = require('require-coercible-to-string-x');
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var replace = ''.replace;

/**
 * This method replaces comments in a string.
 *
 * @param {string} string - The string to be stripped.
 * @param {string} [replacement] - The string to be used as a replacement.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @throws {TypeError} If replacement is not coercible.
 * @returns {string} The new string with the comments replaced.
 * @example
 * var replaceComments = require('replace-comments-x');
 *
 * replaceComments(test;/* test * /, ''), // 'test;'
 * replaceComments(test; // test, ''), // 'test;'
 */
module.exports = function replaceComments(string) {
  return replace.call(requireCoercibleToString(string), STRIP_COMMENTS, arguments.length > 1 ? toStr(arguments[1]) : '');
};

},{"require-coercible-to-string-x":329,"to-string-x":349}],329:[function(require,module,exports){
/**
 * @file Requires an argument is corecible then converts using ToString.
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module require-coercible-to-string-x
 */

'use strict';

var requireObjectCoercible = require('require-object-coercible-x');
var toStr = require('to-string-x');

/**
 * This method requires an argument is corecible then converts using ToString.
 *
 * @param {*} value - The value to converted to a string.
 * @throws {TypeError} If value is null or undefined.
 * @returns {string} The value as a string.
 * @example
 * var requireCoercibleToString = require('require-coercible-to-string-x');
 *
 * requireCoercibleToString(); // TypeError
 * requireCoercibleToString(null); // TypeError
 * requireCoercibleToString(Symbol('')); // TypeError
 * requireCoercibleToString(Object.create(null)); // TypeError
 * requireCoercibleToString(1); // '1'
 * requireCoercibleToString(true); // 'true'
 */
module.exports = function requireCoercibleToString(value) {
  return toStr(requireObjectCoercible(value));
};

},{"require-object-coercible-x":330,"to-string-x":349}],330:[function(require,module,exports){
/**
 * @file ES6-compliant shim for RequireObjectCoercible.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-requireobjectcoercible|7.2.1 RequireObjectCoercible ( argument )}
 * @version 1.4.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module require-object-coercible-x
 */

'use strict';

var isNil = require('is-nil-x');

/**
 * The abstract operation RequireObjectCoercible throws an error if argument
 * is a value that cannot be converted to an Object using ToObject.
 *
 * @param {*} value - The `value` to check.
 * @throws {TypeError} If `value` is a `null` or `undefined`.
 * @returns {string} The `value`.
 * @example
 * var RequireObjectCoercible = require('require-object-coercible-x');
 *
 * RequireObjectCoercible(); // TypeError
 * RequireObjectCoercible(null); // TypeError
 * RequireObjectCoercible('abc'); // 'abc'
 * RequireObjectCoercible(true); // true
 * RequireObjectCoercible(Symbol('foo')); // Symbol('foo')
 */
module.exports = function RequireObjectCoercible(value) {
  if (isNil(value)) {
    throw new TypeError('Cannot call method on ' + value);
  }

  return value;
};

},{"is-nil-x":122}],331:[function(require,module,exports){
/**
 * @file Like ES6 ToString but handles Symbols too.
 * @see {@link https://github.com/Xotic750/to-string-x|to-string-x}
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module safe-to-string-x
 */

'use strict';

var isSymbol = require('is-symbol');
var pToString = require('has-symbol-support-x') && Symbol.prototype.toString;

/**
 * The abstract operation `safeToString` converts a `Symbol` literal or
 * object to `Symbol()` instead of throwing a `TypeError`.
 *
 * @param {*} value - The value to convert to a string.
 * @returns {string} The converted value.
 * @example
 * var safeToString = require('safe-to-string-x');
 *
 * safeToString(); // 'undefined'
 * safeToString(null); // 'null'
 * safeToString('abc'); // 'abc'
 * safeToString(true); // 'true'
 * safeToString(Symbol('foo')); // 'Symbol(foo)'
 * safeToString(Symbol.iterator); // 'Symbol(Symbol.iterator)'
 * safeToString(Object(Symbol.iterator)); // 'Symbol(Symbol.iterator)'
 */
module.exports = function safeToString(value) {
  return pToString && isSymbol(value) ? pToString.call(value) : String(value);
};

},{"has-symbol-support-x":72,"is-symbol":136}],332:[function(require,module,exports){
/**
 * @file Determines whether two values are the same value.
 * @version 1.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module same-value-x
 */

'use strict';

var numberIsNaN = require('is-nan-x');

/**
 * This method is the comparison abstract operation SameValue(x, y), where x
 * and y are ECMAScript language values, produces true or false.
 *
 * @param {*} value1 - The first value to compare.
 * @param {*} value2 - The second value to compare.
 * @returns {boolean} A Boolean indicating whether or not the two arguments are
 *  the same value.
 * @example
 * var sameValue = require('same-value-x');
 *
 * sameValue(1, 1); // true
 * sameValue(true, true); // true
 * sameValue(NaN, NaN); // true
 * sameValue(true, false); // false
 * sameValue(0, -0); // false
 */
module.exports = function sameValue(value1, value2) {
  if (value1 === 0 && value2 === 0) {
    return 1 / value1 === 1 / value2;
  }

  if (value1 === value2) {
    return true;
  }

  return numberIsNaN(value1) && numberIsNaN(value2);
};

},{"is-nan-x":116}],333:[function(require,module,exports){
/**
 * @file ES6-compliant shim for SameValueZero.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero|7.2.10 SameValueZero(x, y)}
 * @version 1.3.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module same-value-zero-x
 */

'use strict';

var sameValue = require('same-value-x');

/**
 * This method determines whether two values are the same value.
 * SameValueZero differs from SameValue (`Object.is`) only in its treatment
 * of +0 and -0.
 *
 * @param {*} x - The first value to compare.
 * @param {*} y - The second value to compare.
 * @returns {boolean} A Boolean indicating whether or not the two arguments
 * are the same value.
 * @example
 * var sameValueZero = require('same-value-zero-x');
 * sameValueZero(0, 0); // true
 * sameValueZero(-0, -0); // true
 * sameValueZero(0, -0); // true
 * sameValueZero(NaN, NaN); //true
 * sameValueZero(Infinity, Infinity); // true
 * sameValueZero(-Infinity, -Infinity); // true
 */
module.exports = function sameValueZero(x, y) {
  return x === y || sameValue(x, y);
};

},{"same-value-x":332}],334:[function(require,module,exports){
/**
 * @file Tests if a value is a string with the boxed bug; splits to an array.
 * @version 1.1.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module split-if-boxed-bug-x
 */

'use strict';

var strSplit;
var isString;
if (require('has-boxed-string-x') === false) {
  strSplit = ''.split;
  isString = typeof strSplit === 'function' && require('is-string');
}

/**
 * This method tests if a value is a string with the boxed bug; splits to an
 * array for iteration; otherwise returns the original value.
 *
 * @param {*} value - The value to be tested.
 * @returns {*} An array or characters if value was a string with the boxed bug;
 *  otherwise the value.
 * @example
 * var splitIfBoxedBug = require('split-if-boxed-bug-x');
 *
 * // No boxed bug
 * splitIfBoxedBug('abc'); // 'abc'
 *
 * // Boxed bug
 * splitIfBoxedBug('abc'); // ['a', 'b', 'c']
 */
module.exports = function splitIfBoxedBug(value) {
  return isString && isString(value) ? strSplit.call(value, '') : value;
};


},{"has-boxed-string-x":69,"is-string":134}],335:[function(require,module,exports){
/**
 * @file Pads a string with another string (repeated, if needed).
 * @version 1.2.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module string-pad-start-x
 */

'use strict';

var requireObjectCoercible = require('require-object-coercible-x');
var toStr = require('to-string-x');
var toLength = require('to-length-x').toLength2018;
var isUndefined = require('validate.io-undefined');
var strSlice = String.prototype.slice;

/**
 * This method pads the current string with another string (repeated, if needed)
 * so that the resulting string reaches the given length. The padding is applied
 * from the start (left) of the current string.
 *
 * @param {string} string - The string to pad.
 * @throws {TypeError} If target is null or undefined.
 * @param {number} targetLength - The length of the resulting string once the
 *  current string has been padded. If the value is lower than the current
 *  string's length, the current string will be returned as is.
 * @param {string} [padString] - The string to pad the current string with. If
 *  this string is too long to stay within the target length, it will be
 *  truncated and the left-most part will be applied. The default value for this
 *  parameter is " " (U+0020).
 * @returns {string} A String of the specified length with the pad string
 *  applied from the start.
 * @example
 * var padStart = require('string-pad-start-x');
 *
 * padStart('a', 3, 'b'); // 'bba'
 * padStart('a', 3); // '  a'
 * padStart('a', 2, 'bc'); // 'ba'
 */
module.exports = function padStart(string, targetLength) {
  var str = toStr(requireObjectCoercible(string));
  var stringLength = toLength(str.length);
  var fillString;
  if (arguments.length > 2) {
    fillString = arguments[2];
  }

  var filler = isUndefined(fillString) ? '' : toStr(fillString);
  if (filler === '') {
    filler = ' ';
  }

  var intMaxLength = toLength(targetLength);
  if (intMaxLength <= stringLength) {
    return str;
  }

  var fillLen = intMaxLength - stringLength;
  while (filler.length < fillLen) {
    var fLen = filler.length;
    var remainingCodeUnits = fillLen - fLen;
    filler += fLen > remainingCodeUnits ? strSlice.call(filler, 0, remainingCodeUnits) : filler;
  }

  var truncatedStringFiller = filler.length > fillLen ? strSlice.call(filler, 0, fillLen) : filler;

  return truncatedStringFiller + str;
};

},{"require-object-coercible-x":330,"to-length-x":339,"to-string-x":349,"validate.io-undefined":356}],336:[function(require,module,exports){
/**
 * @file Converts argument to a value of type Boolean.
 * @version 1.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-boolean-x
 */

'use strict';

/**
 * The abstract operation ToBoolean converts argument to a value of type Boolean.
 *
 * @param {*} value - The value to be converted.
 * @returns {boolean} 'true' if value is truthy; otherwise 'false'.
 * @example
 * var toBoolean = require('to-boolean-x');
 *
 * toBoolean(null); // false
 * toBoolean(''); // false
 * toBoolean(1); // true
 * toBoolean('0'); // true
 */
module.exports = function toBoolean(value) {
  return !!value;
};

},{}],337:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"dup":82,"is-finite-x":109,"is-nan-x":116,"math-sign-x":299,"to-number-x":340}],338:[function(require,module,exports){
/**
 * @file Cross-browser toISOString support.
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-iso-string-x
 */

'use strict';

var nativeToISOString = typeof Date.prototype.toISOString === 'function' && Date.prototype.toISOString;

var isWorking;
if (nativeToISOString) {
  var attempt = require('attempt-x');
  var res = attempt.call(new Date(0), nativeToISOString);
  isWorking = res.threw === false && res.value === '1970-01-01T00:00:00.000Z';
  if (isWorking) {
    res = attempt.call(new Date(-62198755200000), nativeToISOString);
    isWorking = res.threw === false && res.value.indexOf('-000001') > -1;
  }

  if (isWorking) {
    res = attempt.call(new Date(-1), nativeToISOString);
    isWorking = res.threw === false && res.value === '1969-12-31T23:59:59.999Z';
  }
}

var $toISOString;
if (isWorking) {
  $toISOString = function toISOString(date) {
    return nativeToISOString.call(date);
  };
} else {
  var isDate = require('is-date-object');
  var padStart = require('string-pad-start-x');
  var map = require('array-map-x');
  var arraySlice = require('array-slice-x');
  var join = Array.prototype.join;

  $toISOString = function toISOString(date) {
    if (isDate(date) === false) {
      throw new TypeError('toISOString called on incompatible receiver.');
    }

    if (isFinite(date) === false || isFinite(date.getTime()) === false) {
      // Adope Photoshop requires the second check.
      throw new RangeError('toISOString called on non-finite value.');
    }

    var year = date.getUTCFullYear();
    var month = date.getUTCMonth();
    // see https://github.com/es-shims/es5-shim/issues/111
    year += (month / 12) >> 0; // floor
    month = ((month % 12) + 12) % 12;

    // the date time string format is specified in 15.9.1.15.
    var parts = [
      month + 1,
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds()
    ];

    var sign;
    if (year < 0) {
      sign = '-';
    } else if (year > 9999) {
      sign = '+';
    } else {
      sign = '';
    }

    year = sign + padStart(Math.abs(year), sign ? 6 : 4, '0');
    var result = map(parts, function _mapper(item) {
      // pad months, days, hours, minutes, and seconds to have two digits.
      return padStart(item, 2, '0');
    });

    var dateStr = year + '-' + join.call(arraySlice(result, 0, 2), '-');
    // pad milliseconds to have three digits.
    var msStr = padStart(date.getUTCMilliseconds(date), 3, '0');
    var timeStr = join.call(arraySlice(result, 2), ':') + '.' + msStr;

    return dateStr + 'T' + timeStr + 'Z';
  };
}

/**
 * This method returns a string in simplified extended ISO format (ISO 8601),
 * which is always 24 or 27 characters long (YYYY-MM-DDTHH:mm:ss.sssZ or
 * ±YYYYYY-MM-DDTHH:mm:ss.sssZ, respectively). The timezone is always zero UTC
 * offset, as denoted by the suffix "Z".
 *
 * @param {Object} date A Date object.
 * @throws {TypeError} If date is not a Date object.
 * @throws {RangeError} If date is invalid.
 * @return {string} Given date in the ISO 8601 format according to universal time.

 * @example
 * var toISOString = require('to-iso-string-x');
 * toISOString(new Date(0)); // '1970-01-01T00:00:00.000Z'
 */
module.exports = $toISOString;

},{"array-map-x":15,"array-slice-x":24,"attempt-x":32,"is-date-object":106,"string-pad-start-x":335}],339:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"dup":83,"max-safe-integer":300,"to-integer-x":337}],340:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"cached-constructors-x":35,"dup":84,"nan-x":307,"parse-int-x":324,"to-primitive-x":345,"trim-x":342}],341:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"cached-constructors-x":35,"dup":92,"require-coercible-to-string-x":329,"white-space-x":343}],342:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"dup":85,"trim-left-x":350,"trim-right-x":341}],343:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],344:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToObject.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-toobject|7.1.13 ToObject ( argument )}
 * @version 1.5.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-object-x
 */

'use strict';

var requireObjectCoercible = require('require-object-coercible-x');
var castObject = require('cached-constructors-x').Object;

/**
 * The abstract operation ToObject converts argument to a value of
 * type Object.
 *
 * @param {*} value - The `value` to convert.
 * @throws {TypeError} If `value` is a `null` or `undefined`.
 * @returns {!Object} The `value` converted to an object.
 * @example
 * var ToObject = require('to-object-x');
 *
 * ToObject(); // TypeError
 * ToObject(null); // TypeError
 * ToObject('abc'); // Object('abc')
 * ToObject(true); // Object(true)
 * ToObject(Symbol('foo')); // Object(Symbol('foo'))
 */
module.exports = function toObject(value) {
  return castObject(requireObjectCoercible(value));
};

},{"cached-constructors-x":35,"require-object-coercible-x":330}],345:[function(require,module,exports){
/**
 * @file Converts a JavaScript object to a primitive value.
 * @version 1.1.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-primitive-x
 */

'use strict';

var hasSymbols = require('has-symbol-support-x');
var isPrimitive = require('is-primitive');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');
var isFunction = require('is-function-x');
var requireObjectCoercible = require('require-object-coercible-x');
var isNil = require('is-nil-x');
var isUndefined = require('validate.io-undefined');
var symToPrimitive = hasSymbols && Symbol.toPrimitive;
var symValueOf = hasSymbols && Symbol.prototype.valueOf;

var toStringOrder = ['toString', 'valueOf'];
var toNumberOrder = ['valueOf', 'toString'];
var orderLength = 2;

var ordinaryToPrimitive = function _ordinaryToPrimitive(O, hint) {
  requireObjectCoercible(O);
  if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
    throw new TypeError('hint must be "string" or "number"');
  }

  var methodNames = hint === 'string' ? toStringOrder : toNumberOrder;
  var method;
  var result;
  for (var i = 0; i < orderLength; i += 1) {
    method = O[methodNames[i]];
    if (isFunction(method)) {
      result = method.call(O);
      if (isPrimitive(result)) {
        return result;
      }
    }
  }

  throw new TypeError('No default value');
};

var getMethod = function _getMethod(O, P) {
  var func = O[P];
  if (isNil(func) === false) {
    if (isFunction(func) === false) {
      throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
    }

    return func;
  }

  return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive

/**
 * This method converts a JavaScript object to a primitive value.
 * Note: When toPrimitive is called with no hint, then it generally behaves as
 * if the hint were Number. However, objects may over-ride this behaviour by
 * defining a @@toPrimitive method. Of the objects defined in this specification
 * only Date objects (see 20.3.4.45) and Symbol objects (see 19.4.3.4) over-ride
 * the default ToPrimitive behaviour. Date objects treat no hint as if the hint
 * were String.
 *
 * @param {*} input - The input to convert.
 * @param {constructor} [prefferedtype] - The preffered type (String or Number).
 * @throws {TypeError} If unable to convert input to a primitive.
 * @returns {string|number} The converted input as a primitive.
 * @example
 * var toPrimitive = require('to-primitive-x');
 *
 * var date = new Date(0);
 * toPrimitive(date)); // Thu Jan 01 1970 01:00:00 GMT+0100 (CET)
 * toPrimitive(date, String)); // Thu Jan 01 1970 01:00:00 GMT+0100 (CET)
 * toPrimitive(date, Number)); // 0
 */
module.exports = function toPrimitive(input, preferredType) {
  if (isPrimitive(input)) {
    return input;
  }

  var hint = 'default';
  if (arguments.length > 1) {
    if (preferredType === String) {
      hint = 'string';
    } else if (preferredType === Number) {
      hint = 'number';
    }
  }

  var exoticToPrim;
  if (hasSymbols) {
    if (symToPrimitive) {
      exoticToPrim = getMethod(input, symToPrimitive);
    } else if (isSymbol(input)) {
      exoticToPrim = symValueOf;
    }
  }

  if (isUndefined(exoticToPrim) === false) {
    var result = exoticToPrim.call(input, hint);
    if (isPrimitive(result)) {
      return result;
    }

    throw new TypeError('unable to convert exotic object to primitive');
  }

  if (hint === 'default' && (isDate(input) || isSymbol(input))) {
    hint = 'string';
  }

  return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"has-symbol-support-x":72,"is-date-object":106,"is-function-x":110,"is-nil-x":122,"is-primitive":126,"is-symbol":136,"require-object-coercible-x":330,"validate.io-undefined":356}],346:[function(require,module,exports){
/**
 * @file Converts argument to a value that can be used as a property key.
 * @version 2.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-property-key-x
 */

'use strict';

var hasSymbols = require('has-symbol-support-x');
var toPrimitive = require('to-primitive-x');
var toStr = require('to-string-x');

/**
 * This method Converts argument to a value that can be used as a property key.
 *
 * @param {*} argument - The argument to onvert to a property key.
 * @throws {TypeError} If argument is not a symbol and is not coercible to a string.
 * @returns {string|symbol} The converted argument.
 * @example
 * var toPropertyKey = require('to-property-key-x');
 *
 * toPropertyKey(); // 'undefined'
 * toPropertyKey(1); // '1'
 * toPropertyKey(true); // 'true'
 *
 * var symbol = Symbol('a');
 * toPropertyKey(symbol); // symbol
 *
 * toPropertyKey(Object.create(null)); // TypeError
 */
module.exports = function toPropertyKey(argument) {
  var key = toPrimitive(argument, String);
  return hasSymbols && typeof key === 'symbol' ? key : toStr(key);
};

},{"has-symbol-support-x":72,"to-primitive-x":345,"to-string-x":349}],347:[function(require,module,exports){
/**
 * @file ES6 abstract ToString with Symbol conversion support.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tostring|7.1.12 ToString ( argument )}
 * @version 1.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-string-symbols-supported-x
 */

'use strict';

var castString = require('cached-constructors-x').String;
var pToString = require('has-symbol-support-x') && Symbol.prototype.toString;
var isSymbol = typeof pToString === 'function' && require('is-symbol');

/**
 * The abstract operation ToString converts argument to a value of type String,
 * however the specification states that if the argument is a Symbol then a
 * 'TypeError' is thrown. This version also allows Symbols be converted to
 * a string. Other uncoercible exotics will still throw though.
 *
 * @param {*} value - The value to convert to a string.
 * @returns {string} The converted value.
 * @example
 * var toStringSymbolsSupported = require('to-string-symbols-supported-x');
 *
 * toStringSymbolsSupported(); // 'undefined'
 * toStringSymbolsSupported(null); // 'null'
 * toStringSymbolsSupported('abc'); // 'abc'
 * toStringSymbolsSupported(true); // 'true'
 * toStringSymbolsSupported(Symbol('foo')); // 'Symbol('foo')'
 * toStringSymbolsSupported(Object(Symbol('foo'))); // 'Symbol('foo')'
 * toStringSymbolsSupported(Object.create(null)); // TypeError
 */
module.exports = function toStringSymbolsSupported(value) {
  return isSymbol && isSymbol(value) ? pToString.call(value) : castString(value);
};

},{"cached-constructors-x":35,"has-symbol-support-x":72,"is-symbol":136}],348:[function(require,module,exports){
/**
 * @file Get an object's ES6 @@toStringTag.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring|19.1.3.6 Object.prototype.toString ( )}
 * @version 1.4.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-string-tag-x
 */

'use strict';

var isNull = require('lodash.isnull');
var isUndefined = require('validate.io-undefined');
var toStr = {}.toString;

/**
 * The `toStringTag` method returns "[object type]", where type is the
 * object type.
 *
 * @param {*} value - The object of which to get the object type string.
 * @returns {string} The object type string.
 * @example
 * var toStringTag = require('to-string-tag-x');
 *
 * var o = new Object();
 * toStringTag(o); // returns '[object Object]'
 */
module.exports = function toStringTag(value) {
  if (isNull(value)) {
    return '[object Null]';
  }

  if (isUndefined(value)) {
    return '[object Undefined]';
  }

  return toStr.call(value);
};

},{"lodash.isnull":139,"validate.io-undefined":356}],349:[function(require,module,exports){
/**
 * @file ES6-compliant shim for ToString.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-tostring|7.1.12 ToString ( argument )}
 * @version 1.4.5
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module to-string-x
 */

'use strict';

var castString = require('cached-constructors-x').String;
var isSymbol = require('is-symbol');

/**
 * The abstract operation ToString converts argument to a value of type String.
 *
 * @param {*} value - The value to convert to a string.
 * @throws {TypeError} If `value` is a Symbol.
 * @returns {string} The converted value.
 * @example
 * var $toString = require('to-string-x');
 *
 * $toString(); // 'undefined'
 * $toString(null); // 'null'
 * $toString('abc'); // 'abc'
 * $toString(true); // 'true'
 * $toString(Symbol('foo')); // TypeError
 * $toString(Symbol.iterator); // TypeError
 * $toString(Object(Symbol.iterator)); // TypeError
 * $toString(Object.create(null)); // TypeError
 */
module.exports = function ToString(value) {
  if (isSymbol(value)) {
    throw new TypeError('Cannot convert a Symbol value to a string');
  }

  return castString(value);
};

},{"cached-constructors-x":35,"is-symbol":136}],350:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left end of a string.
 * @version 3.0.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-left-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reLeft2016 = new Rx('^[' + require('white-space-x').string2016 + ']+');
var reLeft2018 = new Rx('^[' + require('white-space-x').string2018 + ']+');
var replace = ''.replace;

var $trimLeft2016 = function trimLeft2016(string) {
  return replace.call(requireCoercibleToString(string), reLeft2016, '');
};

var $trimLeft2018 = function trimLeft2018(string) {
  return replace.call(requireCoercibleToString(string), reLeft2018, '');
};

module.exports = {
  /**
   * A reference to leftTrim2018.
   */
  trimLeft: $trimLeft2018,

  /**
   * This method removes whitespace from the left end of a string. (ES2016)
   *
   * @param {string} string - The string to trim the left end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The left trimmed string.
   * @example
   * var trimLeft = require('trim-left-x').trimLeft2016;
   *
   * trimLeft(' \t\na \t\n') === 'a \t\n'; // true
   */
  trimLeft2016: $trimLeft2016,

  /**
   * This method removes whitespace from the left end of a string. (ES2018)
   *
   * @param {string} string - The string to trim the left end whitespace from.
   * @throws {TypeError} If string is null or undefined or not coercible.
   * @returns {string} The left trimmed string.
   * @example
   * var trimLeft = require('trim-left-x').trimLeft2018;
   *
   * trimLeft(' \t\na \t\n') === 'a \t\n'; // true
   */
  trimLeft2018: $trimLeft2018
};

},{"cached-constructors-x":35,"require-coercible-to-string-x":329,"white-space-x":351}],351:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],352:[function(require,module,exports){
/**
 * @file This method removes whitespace from the right end of a string.
 * @version 2.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-right-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reRight = new Rx('[' + require('white-space-x').string + ']+$');
var replace = ''.replace;

/**
 * This method removes whitespace from the right end of a string.
 *
 * @param {string} string - The string to trim the right end whitespace from.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @returns {string} The right trimmed string.
 * @example
 * var trimRight = require('trim-right-x');
 *
 * trimRight(' \t\na \t\n') === ' \t\na'; // true
 */
module.exports = function trimRight(string) {
  return replace.call(requireCoercibleToString(string), reRight, '');
};

},{"cached-constructors-x":35,"require-coercible-to-string-x":329,"white-space-x":357}],353:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left and right end of a string.
 * @version 2.0.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-x
 */

'use strict';

var trimLeft = require('trim-left-x');
var trimRight = require('trim-right-x');

/**
 * This method removes whitespace from the left and right end of a string.
 *
 * @param {string} string - The string to trim the whitespace from.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @returns {string} The trimmed string.
 * @example
 * var trim = require('trim-x');
 *
 * trim(' \t\na \t\n') === 'a'; // true
 */
module.exports = function trim(string) {
  return trimLeft(trimRight(string));
};

},{"trim-left-x":354,"trim-right-x":352}],354:[function(require,module,exports){
/**
 * @file This method removes whitespace from the left end of a string.
 * @version 2.0.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module trim-left-x
 */

'use strict';

var requireCoercibleToString = require('require-coercible-to-string-x');
var Rx = require('cached-constructors-x').RegExp;
var reLeft = new Rx('^[' + require('white-space-x').string + ']+');
var replace = ''.replace;

/**
 * This method removes whitespace from the left end of a string.
 *
 * @param {string} string - The string to trim the left end whitespace from.
 * @throws {TypeError} If string is null or undefined or not coercible.
 * @returns {string} The left trimmed string.
 * @example
 * var trimLeft = require('trim-left-x');
 *
 * trimLeft(' \t\na \t\n') === 'a \t\n'; // true
 */
module.exports = function trimLeft(string) {
  return replace.call(requireCoercibleToString(string), reLeft, '');
};

},{"cached-constructors-x":35,"require-coercible-to-string-x":329,"white-space-x":357}],355:[function(require,module,exports){
/**
 * @file An implementation of node's util.format
 * @version 1.3.0
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module util-format-x
 */

'use strict';

var inspect = require('inspect-x');
var JSON3 = require('json3');
var safeToString = require('safe-to-string-x');
var isNull = require('lodash.isnull');

var CIRCULAR_ERROR_MESSAGE;
var tryStringify = function _tryStringify(arg) {
  try {
    return JSON3.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        var a = {};
        a.a = a;
        JSON3.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = e.message;
      }
    }

    if (err.name === 'TypeError' && err.message === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }

    throw err;
  }
};

// eslint-disable-next-line complexity
var format = function _format(f) {
  if (typeof f !== 'string') {
    var objects = new Array(arguments.length);
    for (var index = 0; index < arguments.length; index += 1) {
      objects[index] = inspect(arguments[index]);
    }

    return objects.join(' ');
  }

  if (arguments.length === 1) {
    return f;
  }

  var str = '';
  var a = 1;
  var lastPos = 0;
  for (var i = 0; i < f.length;) {
    if (f.charCodeAt(i) === 37/* '%'*/ && i + 1 < f.length) {
      if (f.charCodeAt(i + 1) !== 37/* '%'*/ && a >= arguments.length) {
        i += 1;
        // eslint-disable-next-line no-continue
        continue; // eslint-disable-line no-restricted-syntax
      }

      switch (f.charCodeAt(i + 1)) {
      case 100: // 'd'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += Number(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 105: // 'i'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += parseInt(arguments[a], 10);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 102: // 'f'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += parseFloat(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 106: // 'j'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += tryStringify(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 115: // 's'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += safeToString(arguments[a]);
        a += 1;
        // eslint-disable-next-line no-restricted-syntax
        break;
      case 37: // '%'
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += '%';
        // eslint-disable-next-line no-restricted-syntax
        break;
      default: // any other character is not a correct placeholder
        if (lastPos < i) {
          str += f.slice(lastPos, i);
        }

        str += '%';
        i += 1;
        lastPos = i;
        // eslint-disable-next-line no-continue
        continue; // eslint-disable-line no-restricted-syntax
      }

      i += 2;
      lastPos = i;
      // eslint-disable-next-line no-continue
      continue; // eslint-disable-line no-restricted-syntax
    }

    i += 1;
  }

  if (lastPos === 0) {
    str = f;
  } else if (lastPos < f.length) {
    str += f.slice(lastPos);
  }

  while (a < arguments.length) {
    var x = arguments[a];
    a += 1;

    if (isNull(x) || (typeof x !== 'object' && typeof x !== 'symbol')) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
};

/**
 * The format() method returns a formatted string using the first argument as a
 * printf-like format.
 *
 * The first argument is a string containing zero or more placeholder tokens.
 * Each placeholder token is replaced with the converted value from the
 * corresponding argument. Supported placeholders are:
 *
 * %s - String.
 * %d - Number (integer or floating point value).
 * %i - Integer.
 * %f - Floating point value.
 * %j - JSON. Replaced with the string '[Circular]' if the argument contains circular references.
 * %% - single percent sign ('%'). This does not consume an argument.
 *
 * @param {string} f - Template.
 * @param {*} [...args] - Values.
 * @returns {*} The target.
 * @example
 * var format = require('util-format-x');
 *
 * // If the placeholder does not have a corresponding argument,
 * // the placeholder is not replaced.
 * format('%s:%s', 'foo'); // Returns: 'foo:%s'
 *
 * // If there are more arguments passed to the format() method than the number
 * // of placeholders, the extra arguments are coerced into strings (for objects
 * // and symbols, inspect() is used) then concatenated to the returned
 * // string, each delimited by a space.
 * format('%s:%s', 'foo', 'bar', 'baz'); // 'foo:bar baz'
 *
 * // If the first argument is not a format string then format() returns a
 * // string that is the concatenation of all arguments separated by spaces.
 * // Each argument is converted to a string using inspect().
 * format(1, 2, 3); // '1 2 3'
 *
 * // If only one argument is passed to format(), it is returned as it is
 * //without any formatting.
 * format('%% %s'); // '%% %s'
 */
module.exports = format;

},{"inspect-x":95,"json3":138,"lodash.isnull":139,"safe-to-string-x":331}],356:[function(require,module,exports){
/**
*
*	VALIDATE: undefined
*
*
*	DESCRIPTION:
*		- Validates if a value is undefined.
*
*
*	NOTES:
*		[1]
*
*
*	TODO:
*		[1]
*
*
*	LICENSE:
*		MIT
*
*	Copyright (c) 2014. Athan Reines.
*
*
*	AUTHOR:
*		Athan Reines. kgryte@gmail.com. 2014.
*
*/

'use strict';

/**
* FUNCTION: isUndefined( value )
*	Validates if a value is undefined.
*
* @param {*} value - value to be validated
* @returns {Boolean} boolean indicating whether value is undefined
*/
function isUndefined( value ) {
	return value === void 0;
} // end FUNCTION isUndefined()


// EXPORTS //

module.exports = isUndefined;

},{}],357:[function(require,module,exports){
/**
 * @file List of ECMAScript5 white space characters.
 * @version 2.0.3
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module white-space-x
 */

'use strict';

/**
 * An array of the ES5 whitespace char codes, string, and their descriptions.
 *
 * @name list
 * @type Array.<Object>
 * @example
 * var whiteSpace = require('white-space-x');
 * whiteSpaces.list.foreach(function (item) {
 *   console.log(lib.description, item.code, item.string);
 * });
 */
var list = [
  {
    code: 0x0009,
    description: 'Tab',
    string: '\u0009'
  },
  {
    code: 0x000a,
    description: 'Line Feed',
    string: '\u000a'
  },
  {
    code: 0x000b,
    description: 'Vertical Tab',
    string: '\u000b'
  },
  {
    code: 0x000c,
    description: 'Form Feed',
    string: '\u000c'
  },
  {
    code: 0x000d,
    description: 'Carriage Return',
    string: '\u000d'
  },
  {
    code: 0x0020,
    description: 'Space',
    string: '\u0020'
  },
  /*
  {
    code: 0x0085,
    description: 'Next line - Not ES5 whitespace',
    string: '\u0085'
  }
  */
  {
    code: 0x00a0,
    description: 'No-break space',
    string: '\u00a0'
  },
  {
    code: 0x1680,
    description: 'Ogham space mark',
    string: '\u1680'
  },
  {
    code: 0x180e,
    description: 'Mongolian vowel separator',
    string: '\u180e'
  },
  {
    code: 0x2000,
    description: 'En quad',
    string: '\u2000'
  },
  {
    code: 0x2001,
    description: 'Em quad',
    string: '\u2001'
  },
  {
    code: 0x2002,
    description: 'En space',
    string: '\u2002'
  },
  {
    code: 0x2003,
    description: 'Em space',
    string: '\u2003'
  },
  {
    code: 0x2004,
    description: 'Three-per-em space',
    string: '\u2004'
  },
  {
    code: 0x2005,
    description: 'Four-per-em space',
    string: '\u2005'
  },
  {
    code: 0x2006,
    description: 'Six-per-em space',
    string: '\u2006'
  },
  {
    code: 0x2007,
    description: 'Figure space',
    string: '\u2007'
  },
  {
    code: 0x2008,
    description: 'Punctuation space',
    string: '\u2008'
  },
  {
    code: 0x2009,
    description: 'Thin space',
    string: '\u2009'
  },
  {
    code: 0x200a,
    description: 'Hair space',
    string: '\u200a'
  },
  /*
  {
    code: 0x200b,
    description: 'Zero width space - Not ES5 whitespace',
    string: '\u200b'
  },
  */
  {
    code: 0x2028,
    description: 'Line separator',
    string: '\u2028'
  },
  {
    code: 0x2029,
    description: 'Paragraph separator',
    string: '\u2029'
  },
  {
    code: 0x202f,
    description: 'Narrow no-break space',
    string: '\u202f'
  },
  {
    code: 0x205f,
    description: 'Medium mathematical space',
    string: '\u205f'
  },
  {
    code: 0x3000,
    description: 'Ideographic space',
    string: '\u3000'
  },
  {
    code: 0xfeff,
    description: 'Byte Order Mark',
    string: '\ufeff'
  }
];

var string = '';
var length = list.length;
for (var i = 0; i < length; i += 1) {
  string += list[i].string;
}

/**
 * A string of the ES5 whitespace characters.
 *
 * @name string
 * @type string
 * @example
 * var whiteSpace = require('white-space-x');
 * var characters = [
 *   '\u0009',
 *   '\u000a',
 *   '\u000b',
 *   '\u000c',
 *   '\u000d',
 *   '\u0020',
 *   '\u00a0',
 *   '\u1680',
 *   '\u180e',
 *   '\u2000',
 *   '\u2001',
 *   '\u2002',
 *   '\u2003',
 *   '\u2004',
 *   '\u2005',
 *   '\u2006',
 *   '\u2007',
 *   '\u2008',
 *   '\u2009',
 *   '\u200a',
 *   '\u2028',
 *   '\u2029',
 *   '\u202f',
 *   '\u205f',
 *   '\u3000',
 *   '\ufeff'
 * ];
 * var ws = characters.join('');
 * var re1 = new RegExp('^[' + whiteSpace.string + ']+$)');
 * re1.test(ws); // true
 */
module.exports = {
  list: list,
  string: string
};

},{}],358:[function(require,module,exports){
(function (process){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var format = require('util-format-x');

var superagent = require('@ladjs/superagent');

var cuid = require('cuid');

var parseErr = require('parse-err');

var safeStringify = require('fast-safe-stringify'); // <https://lacke.mn/reduce-your-bundle-js-file-size/>
// <https://github.com/lodash/babel-plugin-lodash/issues/221>


var isError = require('lodash/isError');

var isObject = require('lodash/isObject');

var isString = require('lodash/isString');

var includes = require('lodash/includes');

var omit = require('lodash/omit');

var isEmpty = require('lodash/isEmpty');

var isPlainObject = require('lodash/isPlainObject');

var isUndefined = require('lodash/isUndefined');

var isNull = require('lodash/isNull');

var boolean = require('boolean');

var _require = require('message-headers'),
    standard = _require.standard;

var formatSpecifiers = require('format-specifiers');

var standardHeaders = standard.map(function (o) {
  return o['Header Field Name'].toLowerCase();
});
var hasWindow = typeof window !== 'undefined' && typeof window.document !== 'undefined'; // eslint-disable-next-line import/no-unassigned-import

require('console-polyfill');

var levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
var endpoint = 'https://api.cabinjs.com';
var env = process.env.NODE_ENV || 'development';

var Axe =
/*#__PURE__*/
function () {
  function Axe() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Axe);

    this.config = _objectSpread({
      key: '',
      endpoint: endpoint,
      headers: {},
      timeout: 5000,
      retry: 3,
      showStack: boolean(process.env.SHOW_STACK || env !== 'production'),
      showMeta: boolean(process.env.SHOW_META),
      silent: false,
      logger: console,
      levels: ['info', 'warn', 'error', 'fatal'],
      capture: env === 'production'
    }, config);
    Object.assign(this, omit(this.config.logger, ['config', 'log'])); // we could have used `auto-bind` but it's not compiled for browser

    this.log = this.log.bind(this); // bind helper functions for each log level

    levels.forEach(function (level) {
      _this[level] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this.log.apply(_this, _toConsumableArray([level].concat([].slice.call(args))));
      };
    }); // aliases

    this.err = this.error;
    this.warning = this.warn;
  } // eslint-disable-next-line complexity


  _createClass(Axe, [{
    key: "log",
    value: function log(level, message, meta) {
      var _this2 = this;

      var originalArgs = [level, message];
      if (!isUndefined(meta)) originalArgs.push(meta);

      for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        args[_key2 - 3] = arguments[_key2];
      }

      originalArgs = originalArgs.concat([].slice.call(args));
      var config = this.config;
      var modifier = 0;
      if (level === 'warning') level = 'warn';
      if (level === 'err') level = 'error';

      if (isError(level)) {
        meta = message;
        message = level;
        level = 'error';
      } else if (!isString(level) || !includes(levels, level)) {
        meta = message;
        message = level;
        level = 'info';
        modifier = -1;
      } // if there are four or more args
      // then infer to use util.format on everything


      if (originalArgs.length >= 4 + modifier) {
        message = format.apply(void 0, _toConsumableArray(originalArgs.slice(1 + modifier)));
        meta = {};
      } else if (originalArgs.length === 3 + modifier && isString(message) && formatSpecifiers.some(function (t) {
        return includes(message, t);
      })) {
        // otherwise if there are three args and if the `message` contains
        // a placeholder token (e.g. '%s' or '%d' - see above `formatSpecifiers` variable)
        // then we can infer that the `meta` arg passed is used for formatting
        message = format(message, meta);
        meta = {};
      } else if (!isError(message)) {
        if (isError(meta)) {
          meta = {
            err: parseErr(meta)
          };
        } else if (!isPlainObject(meta) && !isUndefined(meta) && !isNull(meta)) {
          // if the `meta` variable passed was not an Object then convert it
          message = format(message, meta);
          meta = {};
        } else if (!isString(message)) {
          // if the message is not a string then we should run `util.format` on it
          // assuming we're formatting it like it was another argument
          // (as opposed to using something like fast-json-stringify)
          message = format(message);
        }
      }

      if (!isPlainObject(meta)) meta = {};
      var err;

      if (isError(message)) {
        err = message;
        if (!isObject(meta.err)) meta.err = parseErr(err);
        var _message = message;
        message = _message.message;
      } // set default level on meta


      meta.level = level; // set the body used for returning with and sending logs
      // (and also remove circular references)

      var body = safeStringify({
        message: message,
        meta: meta
      }); // send to Cabin or other logging service here the `message` and `meta`

      if (config.capture && includes(config.levels, level) && (!isError(err) || !err._captureFailed)) {
        // if the user didn't specify a key
        // and they are using the default endpoint
        // then we should throw an error to them
        if (config.endpoint === endpoint && !config.key) throw new Error("Cabin API key required (e.g. `{ key: 'YOUR-CABIN-API-KEY' })`)\n<https://cabinjs.com>"); // capture the log over HTTP

        var req = superagent.post(config.endpoint).set('X-Request-Id', cuid()).timeout(config.timeout); // basic auth (e.g. Cabin API key)

        if (config.key) req.auth(config.key); // set headers if any

        if (!isEmpty(config.headers)) {
          var headers = config.headers;
          if (hasWindow) headers = Object.keys(config.headers).reduce(function (memo, header) {
            if (!includes(standardHeaders, config.headers[header].toLowerCase())) memo[header] = config.headers[header];
            return memo;
          }, {});
          req.set(headers);
        }

        req.retry(config.retry).send(body).end(function (err) {
          if (err) {
            err._captureFailed = true;

            _this2.config.logger.error(err);
          }
        });
      } // Suppress logs if it was silent


      if (config.silent) return body; // if there was meta information then output it

      var omitted = omit(meta, ['level', 'err']); // fatal should use error (e.g. in browser)

      if (level === 'fatal') level = 'error'; // if we didn't pass a level as a method
      // (e.g. console.info), then we should still
      // use the logger's `log` method to output

      if (modifier === -1) level = 'log'; // show stack trace if necessary (along with any metadata)

      if (level === 'error' && isError(err) && config.showStack) {
        if (!config.showMeta || isEmpty(omitted)) this.config.logger.error(err);else this.config.logger.error(err, omitted);
      } else if (!config.showMeta || isEmpty(omitted)) {
        this.config.logger[level](message);
      } else {
        this.config.logger[level](message, omitted);
      } // return the parsed body in case we need it


      return body;
    }
  }]);

  return Axe;
}();

module.exports = Axe;

}).call(this,require('_process'))

},{"@ladjs/superagent":2,"_process":325,"boolean":34,"console-polyfill":44,"cuid":45,"fast-safe-stringify":52,"format-specifiers":59,"lodash/includes":266,"lodash/isEmpty":271,"lodash/isError":272,"lodash/isNull":276,"lodash/isObject":277,"lodash/isPlainObject":279,"lodash/isString":281,"lodash/isUndefined":284,"lodash/omit":289,"message-headers":303,"parse-err":323,"util-format-x":355}]},{},[358])(358)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL2FnZW50LWJhc2UuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9AbGFkanMvc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL0BsYWRqcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvQGxhZGpzL3N1cGVyYWdlbnQvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LWZpbHRlci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LWZvci1lYWNoLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktaW5jbHVkZXMteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1pbmNsdWRlcy14L25vZGVfbW9kdWxlcy9pcy1maW5pdGUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1pbmNsdWRlcy14L25vZGVfbW9kdWxlcy9tYXRoLXNpZ24teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1pbmNsdWRlcy14L25vZGVfbW9kdWxlcy90by1pbnRlZ2VyLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktaW5jbHVkZXMteC9ub2RlX21vZHVsZXMvdG8tbGVuZ3RoLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktbGlrZS1zbGljZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LW1hcC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LW1hcC14L25vZGVfbW9kdWxlcy9hc3NlcnQtaXMtZnVuY3Rpb24teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1yZWR1Y2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1yZWR1Y2UteC9ub2RlX21vZHVsZXMvbWF0aC1zaWduLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktcmVkdWNlLXgvbm9kZV9tb2R1bGVzL3BhcnNlLWludC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXJlZHVjZS14L25vZGVfbW9kdWxlcy90by1pbnRlZ2VyLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXJyYXktcmVkdWNlLXgvbm9kZV9tb2R1bGVzL3RvLWxlbmd0aC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXJlZHVjZS14L25vZGVfbW9kdWxlcy90by1udW1iZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheS1zbGljZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FycmF5LXNvbWUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQtaXMtZnVuY3Rpb24teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQtaXMtb2JqZWN0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXR0ZW1wdC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1jb3VudGVyLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYm9vbGVhbi9kaXN0L2Jvb2xlYW4uanMiLCJub2RlX21vZHVsZXMvY2FjaGVkLWNvbnN0cnVjdG9ycy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sbGVjdGlvbnMteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xsZWN0aW9ucy14L25vZGVfbW9kdWxlcy9oYXMtb3duLXByb3BlcnR5LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29uc29sZS1wb2x5ZmlsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jdWlkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N1aWQvbGliL2ZpbmdlcnByaW50LmJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY3VpZC9saWIvcGFkLmpzIiwibm9kZV9tb2R1bGVzL2RlZmluZS1wcm9wZXJ0aWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzLXRvLXByaW1pdGl2ZS9lczIwMTUuanMiLCJub2RlX21vZHVsZXMvZXMtdG8tcHJpbWl0aXZlL2VzNi5qcyIsIm5vZGVfbW9kdWxlcy9lcy10by1wcmltaXRpdmUvaGVscGVycy9pc1ByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZpbmQtaW5kZXgteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zvcm1hdC1zcGVjaWZpZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtZnVuY3Rpb24tbmFtZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1vd24tZW51bWVyYWJsZS1wcm9wZXJ0eS1zeW1ib2xzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LW93bi1lbnVtZXJhYmxlLXByb3BlcnR5LXN5bWJvbHMteC9ub2RlX21vZHVsZXMvYXJyYXktZmlsdGVyLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1vd24tcHJvcGVydHktc3ltYm9scy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldC1wcm90b3R5cGUtb2YteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtYm94ZWQtc3RyaW5nLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLW93bi1wcm9wZXJ0eS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1yZWZsZWN0LXN1cHBvcnQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9sLXN1cHBvcnQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9zaGFtcy5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtdG8tc3RyaW5nLXRhZy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXgtb2YteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgvbm9kZV9tb2R1bGVzL21hdGgtc2lnbi14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgvbm9kZV9tb2R1bGVzL3BhcnNlLWludC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgvbm9kZV9tb2R1bGVzL3RvLWludGVnZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L25vZGVfbW9kdWxlcy90by1sZW5ndGgteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L25vZGVfbW9kdWxlcy90by1udW1iZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy9jYWxjdWxhdGUtZnJvbS1pbmRleC14L25vZGVfbW9kdWxlcy90cmltLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXgtb2YteC9ub2RlX21vZHVsZXMvZmluZC1pbmRleC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4LW9mLXgvbm9kZV9tb2R1bGVzL3RyaW0tcmlnaHQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleC1vZi14L25vZGVfbW9kdWxlcy90cmltLXJpZ2h0LXgvbm9kZV9tb2R1bGVzL3doaXRlLXNwYWNlLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5maW5pdHkteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbnNwZWN0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5zcGVjdC14L25vZGVfbW9kdWxlcy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWFycmF5LWJ1ZmZlci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWFycmF5LWxpa2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hcnJheS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWFzeW5jLWZ1bmN0aW9uLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYm9vbGVhbi1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGF0YS12aWV3LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGF0ZS1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZXJyb3IteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mYWxzZXkteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1maW5pdGUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1pbmRleC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWludGVnZXIteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1sZW5ndGgteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1tYXAteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uYW4teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uYW4vaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvaXMtbmFuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLW5hbi9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uYW4vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1uZWdhdGl2ZS16ZXJvL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLW5pbC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLW51bWJlci1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtb2JqZWN0LWxpa2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1vYmplY3QtbGlrZS14L25vZGVfbW9kdWxlcy9pcy1wcmltaXRpdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcHJpbWl0aXZlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXByb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXhwLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtcmVnZXhwLXgvbm9kZV9tb2R1bGVzL2Fzc2VydC1pcy1vYmplY3QteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1yZWdleHAteC9ub2RlX21vZHVsZXMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXNhZmUtaW50ZWdlci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXNldC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1zdXJyb2dhdGUtcGFpci14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXN5bWJvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZC1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uMy9saWIvanNvbjMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmlzbnVsbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGljay5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuc2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2N1c3RvbU9taXRDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZmxhdFJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcGFyZW50LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2luY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1VuZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9sYXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9vbWl0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvSW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC92YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvbWF0aC1jbGFtcC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21heC1zYWZlLWludGVnZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVzc2FnZS1oZWFkZXJzL2FsbC5qc29uIiwibm9kZV9tb2R1bGVzL21lc3NhZ2UtaGVhZGVycy9kZXByZWNhdGVkLmpzb24iLCJub2RlX21vZHVsZXMvbWVzc2FnZS1oZWFkZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lc3NhZ2UtaGVhZGVycy9wZXJtYW5lbnQuanNvbiIsIm5vZGVfbW9kdWxlcy9tZXNzYWdlLWhlYWRlcnMvcHJvdmlzaW9uYWwuanNvbiIsIm5vZGVfbW9kdWxlcy9tZXNzYWdlLWhlYWRlcnMvc3RhbmRhcmQuanNvbiIsIm5vZGVfbW9kdWxlcy9uYW4teC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtc3BhY2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi14L25vZGVfbW9kdWxlcy9hcnJheS1yZWR1Y2UteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduLXgvbm9kZV9tb2R1bGVzL2dldC1vd24tcHJvcGVydHktbmFtZXMteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduLXgvbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3Qta2V5cy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLWVyci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3BlcnR5LWlzLWVudW1lcmFibGUteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWZsZWN0LW93bi1rZXlzLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVwbGFjZS1jb21tZW50cy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlcXVpcmUtY29lcmNpYmxlLXRvLXN0cmluZy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtdG8tc3RyaW5nLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2FtZS12YWx1ZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhbWUtdmFsdWUtemVyby14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwbGl0LWlmLWJveGVkLWJ1Zy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZy1wYWQtc3RhcnQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1ib29sZWFuLXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG8taXNvLXN0cmluZy14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLW9iamVjdC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXByaW1pdGl2ZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXByb3BlcnR5LWtleS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXN0cmluZy1zeW1ib2xzLXN1cHBvcnRlZC14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RvLXN0cmluZy10YWcteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1zdHJpbmcteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmltLWxlZnQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmltLXJpZ2h0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpbS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyaW0teC9ub2RlX21vZHVsZXMvdHJpbS1sZWZ0LXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXRpbC1mb3JtYXQteC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0ZS5pby11bmRlZmluZWQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3doaXRlLXNwYWNlLXgvaW5kZXguanMiLCJzcmMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDLy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Q0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3REQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanpFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL21DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxTkEsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLGVBQUQsQ0FBdEI7O0FBQ0EsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLG1CQUFELENBQTFCOztBQUNBLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUNBLElBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxXQUFELENBQXhCOztBQUNBLElBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxxQkFBRCxDQUE3QixDLENBQ0E7QUFDQTs7O0FBQ0EsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLGdCQUFELENBQXZCOztBQUNBLElBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxpQkFBRCxDQUF4Qjs7QUFDQSxJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsaUJBQUQsQ0FBeEI7O0FBQ0EsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLGlCQUFELENBQXhCOztBQUNBLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxhQUFELENBQXBCOztBQUNBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxnQkFBRCxDQUF2Qjs7QUFDQSxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsc0JBQUQsQ0FBN0I7O0FBQ0EsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLG9CQUFELENBQTNCOztBQUNBLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxlQUFELENBQXRCOztBQUNBLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxTQUFELENBQXZCOztlQUNxQixPQUFPLENBQUMsaUJBQUQsQztJQUFwQixRLFlBQUEsUTs7QUFDUixJQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxtQkFBRCxDQUFoQzs7QUFFQSxJQUFNLGVBQWUsR0FBRyxRQUFRLENBQUMsR0FBVCxDQUFhLFVBQUEsQ0FBQztBQUFBLFNBQUksQ0FBQyxDQUFDLG1CQUFELENBQUQsQ0FBdUIsV0FBdkIsRUFBSjtBQUFBLENBQWQsQ0FBeEI7QUFFQSxJQUFNLFNBQVMsR0FDYixPQUFPLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsT0FBTyxNQUFNLENBQUMsUUFBZCxLQUEyQixXQUQ5RCxDLENBR0E7O0FBQ0EsT0FBTyxDQUFDLGtCQUFELENBQVA7O0FBRUEsSUFBTSxNQUFNLEdBQUcsQ0FBQyxPQUFELEVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQixNQUEzQixFQUFtQyxPQUFuQyxFQUE0QyxPQUE1QyxDQUFmO0FBQ0EsSUFBTSxRQUFRLEdBQUcseUJBQWpCO0FBQ0EsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQVIsQ0FBWSxRQUFaLElBQXdCLGFBQXBDOztJQUVNLEc7OztBQUNKLGlCQUF5QjtBQUFBOztBQUFBLFFBQWIsTUFBYSx1RUFBSixFQUFJOztBQUFBOztBQUN2QixTQUFLLE1BQUw7QUFDRSxNQUFBLEdBQUcsRUFBRSxFQURQO0FBRUUsTUFBQSxRQUFRLEVBQVIsUUFGRjtBQUdFLE1BQUEsT0FBTyxFQUFFLEVBSFg7QUFJRSxNQUFBLE9BQU8sRUFBRSxJQUpYO0FBS0UsTUFBQSxLQUFLLEVBQUUsQ0FMVDtBQU1FLE1BQUEsU0FBUyxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBUixDQUFZLFVBQVosSUFBMEIsR0FBRyxLQUFLLFlBQW5DLENBTnBCO0FBT0UsTUFBQSxRQUFRLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFSLENBQVksU0FBYixDQVBuQjtBQVFFLE1BQUEsTUFBTSxFQUFFLEtBUlY7QUFTRSxNQUFBLE1BQU0sRUFBRSxPQVRWO0FBVUUsTUFBQSxNQUFNLEVBQUUsQ0FBQyxNQUFELEVBQVMsTUFBVCxFQUFpQixPQUFqQixFQUEwQixPQUExQixDQVZWO0FBV0UsTUFBQSxPQUFPLEVBQUUsR0FBRyxLQUFLO0FBWG5CLE9BWUssTUFaTDtBQWVBLElBQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLEVBQW9CLElBQUksQ0FBQyxLQUFLLE1BQUwsQ0FBWSxNQUFiLEVBQXFCLENBQUMsUUFBRCxFQUFXLEtBQVgsQ0FBckIsQ0FBeEIsRUFoQnVCLENBa0J2Qjs7QUFDQSxTQUFLLEdBQUwsR0FBVyxLQUFLLEdBQUwsQ0FBUyxJQUFULENBQWMsSUFBZCxDQUFYLENBbkJ1QixDQXFCdkI7O0FBQ0EsSUFBQSxNQUFNLENBQUMsT0FBUCxDQUFlLFVBQUEsS0FBSyxFQUFJO0FBQ3RCLE1BQUEsS0FBSSxDQUFDLEtBQUQsQ0FBSixHQUFjO0FBQUEsMENBQUksSUFBSjtBQUFJLFVBQUEsSUFBSjtBQUFBOztBQUFBLGVBQ1osS0FBSSxDQUFDLEdBQUwsT0FBQSxLQUFJLHFCQUFRLENBQUMsS0FBRCxFQUFRLE1BQVIsQ0FBZSxHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsSUFBZCxDQUFmLENBQVIsRUFEUTtBQUFBLE9BQWQ7QUFFRCxLQUhELEVBdEJ1QixDQTJCdkI7O0FBQ0EsU0FBSyxHQUFMLEdBQVcsS0FBSyxLQUFoQjtBQUNBLFNBQUssT0FBTCxHQUFlLEtBQUssSUFBcEI7QUFDRCxHLENBRUQ7Ozs7O3dCQUNJLEssRUFBTyxPLEVBQVMsSSxFQUFlO0FBQUE7O0FBQ2pDLFVBQUksWUFBWSxHQUFHLENBQUMsS0FBRCxFQUFRLE9BQVIsQ0FBbkI7QUFDQSxVQUFJLENBQUMsV0FBVyxDQUFDLElBQUQsQ0FBaEIsRUFBd0IsWUFBWSxDQUFDLElBQWIsQ0FBa0IsSUFBbEI7O0FBRlMseUNBQU4sSUFBTTtBQUFOLFFBQUEsSUFBTTtBQUFBOztBQUdqQyxNQUFBLFlBQVksR0FBRyxZQUFZLENBQUMsTUFBYixDQUFvQixHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsSUFBZCxDQUFwQixDQUFmO0FBSGlDLFVBSXpCLE1BSnlCLEdBSWQsSUFKYyxDQUl6QixNQUp5QjtBQUtqQyxVQUFJLFFBQVEsR0FBRyxDQUFmO0FBRUEsVUFBSSxLQUFLLEtBQUssU0FBZCxFQUF5QixLQUFLLEdBQUcsTUFBUjtBQUN6QixVQUFJLEtBQUssS0FBSyxLQUFkLEVBQXFCLEtBQUssR0FBRyxPQUFSOztBQUVyQixVQUFJLE9BQU8sQ0FBQyxLQUFELENBQVgsRUFBb0I7QUFDbEIsUUFBQSxJQUFJLEdBQUcsT0FBUDtBQUNBLFFBQUEsT0FBTyxHQUFHLEtBQVY7QUFDQSxRQUFBLEtBQUssR0FBRyxPQUFSO0FBQ0QsT0FKRCxNQUlPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBRCxDQUFULElBQW9CLENBQUMsUUFBUSxDQUFDLE1BQUQsRUFBUyxLQUFULENBQWpDLEVBQWtEO0FBQ3ZELFFBQUEsSUFBSSxHQUFHLE9BQVA7QUFDQSxRQUFBLE9BQU8sR0FBRyxLQUFWO0FBQ0EsUUFBQSxLQUFLLEdBQUcsTUFBUjtBQUNBLFFBQUEsUUFBUSxHQUFHLENBQUMsQ0FBWjtBQUNELE9BbkJnQyxDQXFCakM7QUFDQTs7O0FBQ0EsVUFBSSxZQUFZLENBQUMsTUFBYixJQUF1QixJQUFJLFFBQS9CLEVBQXlDO0FBQ3ZDLFFBQUEsT0FBTyxHQUFHLE1BQU0sTUFBTiw0QkFBVSxZQUFZLENBQUMsS0FBYixDQUFtQixJQUFJLFFBQXZCLENBQVYsRUFBVjtBQUNBLFFBQUEsSUFBSSxHQUFHLEVBQVA7QUFDRCxPQUhELE1BR08sSUFDTCxZQUFZLENBQUMsTUFBYixLQUF3QixJQUFJLFFBQTVCLElBQ0EsUUFBUSxDQUFDLE9BQUQsQ0FEUixJQUVBLGdCQUFnQixDQUFDLElBQWpCLENBQXNCLFVBQUEsQ0FBQztBQUFBLGVBQUksUUFBUSxDQUFDLE9BQUQsRUFBVSxDQUFWLENBQVo7QUFBQSxPQUF2QixDQUhLLEVBSUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFBLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBRCxFQUFVLElBQVYsQ0FBaEI7QUFDQSxRQUFBLElBQUksR0FBRyxFQUFQO0FBQ0QsT0FWTSxNQVVBLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBRCxDQUFaLEVBQXVCO0FBQzVCLFlBQUksT0FBTyxDQUFDLElBQUQsQ0FBWCxFQUFtQjtBQUNqQixVQUFBLElBQUksR0FBRztBQUFFLFlBQUEsR0FBRyxFQUFFLFFBQVEsQ0FBQyxJQUFEO0FBQWYsV0FBUDtBQUNELFNBRkQsTUFFTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUQsQ0FBZCxJQUF3QixDQUFDLFdBQVcsQ0FBQyxJQUFELENBQXBDLElBQThDLENBQUMsTUFBTSxDQUFDLElBQUQsQ0FBekQsRUFBaUU7QUFDdEU7QUFDQSxVQUFBLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBRCxFQUFVLElBQVYsQ0FBaEI7QUFDQSxVQUFBLElBQUksR0FBRyxFQUFQO0FBQ0QsU0FKTSxNQUlBLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBRCxDQUFiLEVBQXdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQUEsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFELENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJLENBQUMsYUFBYSxDQUFDLElBQUQsQ0FBbEIsRUFBMEIsSUFBSSxHQUFHLEVBQVA7QUFFMUIsVUFBSSxHQUFKOztBQUNBLFVBQUksT0FBTyxDQUFDLE9BQUQsQ0FBWCxFQUFzQjtBQUNwQixRQUFBLEdBQUcsR0FBRyxPQUFOO0FBQ0EsWUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBTixDQUFiLEVBQXlCLElBQUksQ0FBQyxHQUFMLEdBQVcsUUFBUSxDQUFDLEdBQUQsQ0FBbkI7QUFGTCx1QkFHTCxPQUhLO0FBR2pCLFFBQUEsT0FIaUIsWUFHakIsT0FIaUI7QUFJckIsT0ExRGdDLENBNERqQzs7O0FBQ0EsTUFBQSxJQUFJLENBQUMsS0FBTCxHQUFhLEtBQWIsQ0E3RGlDLENBK0RqQztBQUNBOztBQUNBLFVBQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQztBQUFFLFFBQUEsT0FBTyxFQUFQLE9BQUY7QUFBVyxRQUFBLElBQUksRUFBSjtBQUFYLE9BQUQsQ0FBMUIsQ0FqRWlDLENBbUVqQzs7QUFDQSxVQUNFLE1BQU0sQ0FBQyxPQUFQLElBQ0EsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFSLEVBQWdCLEtBQWhCLENBRFIsS0FFQyxDQUFDLE9BQU8sQ0FBQyxHQUFELENBQVIsSUFBaUIsQ0FBQyxHQUFHLENBQUMsY0FGdkIsQ0FERixFQUlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSSxNQUFNLENBQUMsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDLE1BQU0sQ0FBQyxHQUE1QyxFQUNFLE1BQU0sSUFBSSxLQUFKLENBQ0osdUZBREksQ0FBTixDQUxGLENBU0E7O0FBQ0EsWUFBTSxHQUFHLEdBQUcsVUFBVSxDQUNuQixJQURTLENBQ0osTUFBTSxDQUFDLFFBREgsRUFFVCxHQUZTLENBRUwsY0FGSyxFQUVXLElBQUksRUFGZixFQUdULE9BSFMsQ0FHRCxNQUFNLENBQUMsT0FITixDQUFaLENBVkEsQ0FlQTs7QUFDQSxZQUFJLE1BQU0sQ0FBQyxHQUFYLEVBQWdCLEdBQUcsQ0FBQyxJQUFKLENBQVMsTUFBTSxDQUFDLEdBQWhCLEVBaEJoQixDQWtCQTs7QUFDQSxZQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFSLENBQVosRUFBOEI7QUFBQSxjQUN0QixPQURzQixHQUNWLE1BRFUsQ0FDdEIsT0FEc0I7QUFFNUIsY0FBSSxTQUFKLEVBQ0UsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFQLENBQVksTUFBTSxDQUFDLE9BQW5CLEVBQTRCLE1BQTVCLENBQW1DLFVBQUMsSUFBRCxFQUFPLE1BQVAsRUFBa0I7QUFDN0QsZ0JBQ0UsQ0FBQyxRQUFRLENBQUMsZUFBRCxFQUFrQixNQUFNLENBQUMsT0FBUCxDQUFlLE1BQWYsRUFBdUIsV0FBdkIsRUFBbEIsQ0FEWCxFQUdFLElBQUksQ0FBQyxNQUFELENBQUosR0FBZSxNQUFNLENBQUMsT0FBUCxDQUFlLE1BQWYsQ0FBZjtBQUNGLG1CQUFPLElBQVA7QUFDRCxXQU5TLEVBTVAsRUFOTyxDQUFWO0FBT0YsVUFBQSxHQUFHLENBQUMsR0FBSixDQUFRLE9BQVI7QUFDRDs7QUFFRCxRQUFBLEdBQUcsQ0FDQSxLQURILENBQ1MsTUFBTSxDQUFDLEtBRGhCLEVBRUcsSUFGSCxDQUVRLElBRlIsRUFHRyxHQUhILENBR08sVUFBQSxHQUFHLEVBQUk7QUFDVixjQUFJLEdBQUosRUFBUztBQUNQLFlBQUEsR0FBRyxDQUFDLGNBQUosR0FBcUIsSUFBckI7O0FBQ0EsWUFBQSxNQUFJLENBQUMsTUFBTCxDQUFZLE1BQVosQ0FBbUIsS0FBbkIsQ0FBeUIsR0FBekI7QUFDRDtBQUNGLFNBUkg7QUFTRCxPQWpIZ0MsQ0FtSGpDOzs7QUFDQSxVQUFJLE1BQU0sQ0FBQyxNQUFYLEVBQW1CLE9BQU8sSUFBUCxDQXBIYyxDQXNIakM7O0FBQ0EsVUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUQsRUFBTyxDQUFDLE9BQUQsRUFBVSxLQUFWLENBQVAsQ0FBcEIsQ0F2SGlDLENBeUhqQzs7QUFDQSxVQUFJLEtBQUssS0FBSyxPQUFkLEVBQXVCLEtBQUssR0FBRyxPQUFSLENBMUhVLENBNEhqQztBQUNBO0FBQ0E7O0FBQ0EsVUFBSSxRQUFRLEtBQUssQ0FBQyxDQUFsQixFQUFxQixLQUFLLEdBQUcsS0FBUixDQS9IWSxDQWlJakM7O0FBQ0EsVUFBSSxLQUFLLEtBQUssT0FBVixJQUFxQixPQUFPLENBQUMsR0FBRCxDQUE1QixJQUFxQyxNQUFNLENBQUMsU0FBaEQsRUFBMkQ7QUFDekQsWUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFSLElBQW9CLE9BQU8sQ0FBQyxPQUFELENBQS9CLEVBQTBDLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsS0FBbkIsQ0FBeUIsR0FBekIsRUFBMUMsS0FDSyxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQW5CLENBQXlCLEdBQXpCLEVBQThCLE9BQTlCO0FBQ04sT0FIRCxNQUdPLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUixJQUFvQixPQUFPLENBQUMsT0FBRCxDQUEvQixFQUEwQztBQUMvQyxhQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQW5CLEVBQTBCLE9BQTFCO0FBQ0QsT0FGTSxNQUVBO0FBQ0wsYUFBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFuQixFQUEwQixPQUExQixFQUFtQyxPQUFuQztBQUNELE9BeklnQyxDQTJJakM7OztBQUNBLGFBQU8sSUFBUDtBQUNEOzs7Ozs7QUFHSCxNQUFNLENBQUMsT0FBUCxHQUFpQixHQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gfVxuXG5mdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuWyd1c2UnLCAnb24nLCAnb25jZScsICdzZXQnLCAncXVlcnknLCAndHlwZScsICdhY2NlcHQnLCAnYXV0aCcsICd3aXRoQ3JlZGVudGlhbHMnLCAnc29ydFF1ZXJ5JywgJ3JldHJ5JywgJ29rJywgJ3JlZGlyZWN0cycsICd0aW1lb3V0JywgJ2J1ZmZlcicsICdzZXJpYWxpemUnLCAncGFyc2UnLCAnY2EnLCAna2V5JywgJ3BmeCcsICdjZXJ0J10uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgLy8gRGVmYXVsdCBzZXR0aW5nIGZvciBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGFnZW50XG4gIEFnZW50LnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmF1bHRzLnB1c2goe1xuICAgICAgZm46IGZuLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgdGhpcy5fZGVmYXVsdHMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBfdG9Db25zdW1hYmxlQXJyYXkoZGVmLmFyZ3MpKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG52YXIgcm9vdDtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEJyb3dzZXIgd2luZG93XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBXZWIgV29ya2VyXG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIHtcbiAgLy8gT3RoZXIgZW52aXJvbm1lbnRzXG4gIGNvbnNvbGUud2FybignVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudCcpO1xuICByb290ID0gdm9pZCAwO1xufVxuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbnZhciBSZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbnZhciBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcblxudmFyIEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudC1iYXNlJyk7XG4vKipcbiAqIE5vb3AuXG4gKi9cblxuXG5mdW5jdGlvbiBub29wKCkge31cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG5cbnZhciByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICh0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH0gLy8gdXJsIGZpcnN0XG5cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdChtZXRob2QsIHVybCk7XG59O1xuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gZnVuY3Rpb24gKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdCAmJiAoIXJvb3QubG9jYXRpb24gfHwgcm9vdC5sb2NhdGlvbi5wcm90b2NvbCAhPSAnZmlsZTonIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSJyk7XG59O1xuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxudmFyIHRyaW0gPSAnJy50cmltID8gZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIHMudHJpbSgpO1xufSA6IGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpO1xufTtcbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IgKHZhciBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBcIlwiLmNvbmNhdChrZXksIFwiW1wiKS5jb25jYXQoc3Via2V5LCBcIl1cIiksIHZhbFtzdWJrZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gIH1cbn1cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cblxucmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYWlyO1xuICB2YXIgcG9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcblxuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICd0ZXh0L3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICBmb3JtOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuLyoqXG4gKiBEZWZhdWx0IHBhcnNlcnMuXG4gKlxuICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcbiAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAqICAgICB9O1xuICpcbiAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7IC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcblxuICB0aGlzLnRleHQgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJyA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dCA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB2YXIgc3RhdHVzID0gdGhpcy54aHIuc3RhdHVzOyAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG5cbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuXG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcblxuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTsgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcblxuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAodGhpcy50ZXh0ID09PSBudWxsICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJyA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSkgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fcGFyc2VCb2R5ID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG5cbiAgaWYgKHRoaXMucmVxLl9wYXJzZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXEuX3BhcnNlcih0aGlzLCBzdHIpO1xuICB9XG5cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpID8gcGFyc2Uoc3RyKSA6IG51bGw7XG59O1xuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlc3BvbnNlLnByb3RvdHlwZS50b0Vycm9yID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcbiAgdmFyIG1zZyA9IFwiY2Fubm90IFwiLmNvbmNhdChtZXRob2QsIFwiIFwiKS5jb25jYXQodXJsLCBcIiAoXCIpLmNvbmNhdCh0aGlzLnN0YXR1cywgXCIpXCIpO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcbiAgcmV0dXJuIGVycjtcbn07XG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuXG4gIHRoaXMuX2hlYWRlciA9IHt9OyAvLyBjb2VyY2VzIGhlYWRlciBuYW1lcyB0byBsb3dlcmNhc2VcblxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlOyAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuXG4gICAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgICAgLy8gaWU5IGRvZXNuJ3QgaGF2ZSAncmVzcG9uc2UnIHByb3BlcnR5XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IHR5cGVvZiBzZWxmLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7IC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuXG4gICAgICAgIGVyci5zdGF0dXMgPSBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IGVyci5zdGF0dXM7IC8vIGJhY2t3YXJkcy1jb21wYXQgb25seVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG4gICAgdmFyIG5ld19lcnI7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFzZWxmLl9pc1Jlc3BvbnNlT0socmVzKSkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH0gLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG5cblxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbiAodXNlciwgcGFzcywgb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcGFzcyA9ICcnO1xuXG4gIGlmIChfdHlwZW9mKHBhc3MpID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7XG4gICAgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBwYXNzO1xuICAgIHBhc3MgPSAnJztcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJyA/ICdiYXNpYycgOiAnYXV0bydcbiAgICB9O1xuICB9XG5cbiAgdmFyIGVuY29kZXIgPSBmdW5jdGlvbiBlbmNvZGVyKHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGZpZWxkLCBmaWxlLCBvcHRpb25zKSB7XG4gIGlmIChmaWxlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gIGlmICh0aGlzLl9zaG91bGRSZXRyeShlcnIsIHJlcykpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV0cnkoKTtcbiAgfVxuXG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIGlmIChlcnIpIHtcbiAgICBpZiAodGhpcy5fbWF4UmV0cmllcykgZXJyLnJldHJpZXMgPSB0aGlzLl9yZXRyaWVzIC0gMTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZuKGVyciwgcmVzKTtcbn07XG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59OyAvLyBUaGlzIG9ubHkgd2FybnMsIGJlY2F1c2UgdGhlIHJlcXVlc3QgaXMgc3RpbGwgbGlrZWx5IHRvIHdvcmtcblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5idWZmZXIgPSBSZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLndhcm4oJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudCcpO1xuICByZXR1cm4gdGhpcztcbn07IC8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5cblxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50Jyk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXF1ZXN0LnByb3RvdHlwZS5faXNIb3N0ID0gZnVuY3Rpb24gX2lzSG9zdChvYmopIHtcbiAgLy8gTmF0aXZlIG9iamVjdHMgc3RyaW5naWZ5IHRvIFtvYmplY3QgRmlsZV0sIFtvYmplY3QgQmxvYl0sIFtvYmplY3QgRm9ybURhdGFdLCBldGMuXG4gIHJldHVybiBvYmogJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn07XG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChmbikge1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnQnKTtcbiAgfVxuXG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7IC8vIHN0b3JlIGNhbGxiYWNrXG5cbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wOyAvLyBxdWVyeXN0cmluZ1xuXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm4gdGhpcy5jYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQgZXZlbiBiZWZvcmUgLmVuZCgpIHdhcyBjYWxsZWQnKSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9IHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKTtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIHRoaXMuX3NldFRpbWVvdXRzKCk7IC8vIHN0YXRlIGNoYW5nZVxuXG5cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuXG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG5cbiAgICBpZiAocmVhZHlTdGF0ZSAhPSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG5cblxuICAgIHZhciBzdGF0dXM7XG5cbiAgICB0cnkge1xuICAgICAgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdGF0dXMgPSAwO1xuICAgIH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTsgLy8gcHJvZ3Jlc3NcblxuXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKGRpcmVjdGlvbiwgZSkge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cblxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcblxuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKSk7XG5cbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICd1cGxvYWQnKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkgey8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9IC8vIGluaXRpYXRlIHJlcXVlc3RcblxuXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH0gLy8gQ09SU1xuXG5cbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7IC8vIGJvZHlcblxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmIHRoaXMubWV0aG9kICE9ICdHRVQnICYmIHRoaXMubWV0aG9kICE9ICdIRUFEJyAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgICB2YXIgX3NlcmlhbGl6ZSA9IHRoaXMuX3NlcmlhbGl6ZXIgfHwgcmVxdWVzdC5zZXJpYWxpemVbY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdIDogJyddO1xuXG4gICAgaWYgKCFfc2VyaWFsaXplICYmIGlzSlNPTihjb250ZW50VHlwZSkpIHtcbiAgICAgIF9zZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cblxuICAgIGlmIChfc2VyaWFsaXplKSBkYXRhID0gX3NlcmlhbGl6ZShkYXRhKTtcbiAgfSAvLyBzZXQgaGVhZGVyIGZpZWxkc1xuXG5cbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAodGhpcy5oZWFkZXJbZmllbGRdID09IG51bGwpIGNvbnRpbnVlO1xuICAgIGlmICh0aGlzLmhlYWRlci5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH0gLy8gc2VuZCBzdHVmZlxuXG5cbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7IC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG5cbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xufTtcblxucmVxdWVzdC5hZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBBZ2VudCgpO1xufTtcblxuWydHRVQnLCAnUE9TVCcsICdPUFRJT05TJywgJ1BBVENIJywgJ1BVVCcsICdERUxFVEUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uICh1cmwsIGZuKSB7XG4gICAgdmFyIHJlcSA9IG5ldyByZXF1ZXN0LlJlcXVlc3QobWV0aG9kLCB1cmwpO1xuXG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcblxuICAgIGlmIChmbikge1xuICAgICAgcmVxLmVuZChmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbn0pO1xuQWdlbnQucHJvdG90eXBlLmRlbCA9IEFnZW50LnByb3RvdHlwZS5kZWxldGU7XG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxucmVxdWVzdC5vcHRpb25zID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59XG5cbnJlcXVlc3QuZGVsID0gZGVsO1xucmVxdWVzdC5kZWxldGUgPSBkZWw7XG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0OyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlcXVlc3RCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVxdWVzdEJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBkZWxldGUgdGhpcy5fdGltZXI7XG4gIGRlbGV0ZSB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKSB7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdGhpcy5fcmVzcG9uc2VUeXBlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pIHtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9uKSB7XG4gICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIHRpbWVvdXQgb3B0aW9uJywgb3B0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKSB7XG4gIC8vIERlZmF1bHQgdG8gMSBpZiBubyBjb3VudCBwYXNzZWQgb3IgdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudCA9PT0gdHJ1ZSkgY291bnQgPSAxO1xuICBpZiAoY291bnQgPD0gMCkgY291bnQgPSAwO1xuICB0aGlzLl9tYXhSZXRyaWVzID0gY291bnQ7XG4gIHRoaXMuX3JldHJpZXMgPSAwO1xuICB0aGlzLl9yZXRyeUNhbGxiYWNrID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIEVSUk9SX0NPREVTID0gWydFQ09OTlJFU0VUJywgJ0VUSU1FRE9VVCcsICdFQUREUklORk8nLCAnRVNPQ0tFVFRJTUVET1VUJ107XG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuXG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlOyAvLyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0c1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlcyAmJiByZXMuc3RhdHVzICYmIHJlcy5zdGF0dXMgPj0gNTAwICYmIHJlcy5zdGF0dXMgIT0gNTAxKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7IC8vIFN1cGVyYWdlbnQgdGltZW91dFxuXG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9yZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTsgLy8gbm9kZVxuXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxID0gbnVsbDtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0ID0gZmFsc2U7XG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXMnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSB7XG4gICAgICBzZWxmLm9uKCdlcnJvcicsIGlubmVyUmVqZWN0KTtcbiAgICAgIHNlbGYuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpO2Vsc2UgaW5uZXJSZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgcmVxdWlyZWQnKTtcbiAgdGhpcy5fb2tDYWxsYmFjayA9IGNiO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5faXNSZXNwb25zZU9LID0gZnVuY3Rpb24gKHJlcykge1xuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9va0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX29rQ2FsbGJhY2socmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwO1xufTtcbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldDtcbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZmllbGQsIHZhbCkge1xuICBpZiAoaXNPYmplY3QoZmllbGQpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZpZWxkKSB7XG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobmFtZSA9PT0gbnVsbCB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCIuZmllbGQoKSBjYW4ndCBiZSB1c2VkIGlmIC5zZW5kKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcblxuXG4gIGlmICh2YWwgPT09IG51bGwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gIH1cblxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG5cbiAgdGhpcy5yZXEgJiYgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbiAodXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgXCJCYXNpYyBcIi5jb25jYXQoYmFzZTY0RW5jb2RlcihcIlwiLmNvbmNhdCh1c2VyLCBcIjpcIikuY29uY2F0KHBhc3MpKSkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6XG4gICAgICAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBcIkJlYXJlciBcIi5jb25jYXQodXNlcikpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uIChvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblxuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyXG4gIH07XG59O1xuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGlzT2JqID0gaXNPYmplY3QoZGF0YSk7XG4gIHZhciB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcblxuICBpZiAodGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmogJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfSAvLyBtZXJnZVxuXG5cbiAgaWYgKGlzT2JqICYmIGlzT2JqZWN0KHRoaXMuX2RhdGEpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhID8gXCJcIi5jb25jYXQodGhpcy5fZGF0YSwgXCImXCIpLmNvbmNhdChkYXRhKSA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gZGVmYXVsdCB0byBqc29uXG5cblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uIChzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fZmluYWxpemVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuXG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuXG4gIHRoaXMuX3F1ZXJ5Lmxlbmd0aCA9IDA7IC8vIE1ha2VzIHRoZSBjYWxsIGlkZW1wb3RlbnRcblxuICBpZiAodGhpcy5fc29ydCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudXJsLmluZGV4T2YoJz8nKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX3NvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJz8nICsgcXVlcnlBcnIuam9pbignJicpO1xuICAgIH1cbiAgfVxufTsgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUudHJhY2UoJ1Vuc3VwcG9ydGVkJyk7XG59O1xuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbiAocmVhc29uLCB0aW1lb3V0LCBlcnJubykge1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJcIi5jb25jYXQocmVhc29uICsgdGltZW91dCwgXCJtcyBleGNlZWRlZFwiKSk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gZGVhZGxpbmVcblxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9IC8vIHJlc3BvbnNlIHRpbWVvdXRcblxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzcG9uc2VCYXNlO1xuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGhlYWRlcikge1xuICAvLyBUT0RPOiBtb2FyIVxuICAvLyBUT0RPOiBtYWtlIHRoaXMgYSB1dGlsXG4gIC8vIGNvbnRlbnQtdHlwZVxuICB2YXIgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTsgLy8gcGFyYW1zXG5cbiAgdmFyIHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG5cbiAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgIHRoaXNba2V5XSA9IHBhcmFtc1trZXldO1xuICB9XG5cbiAgdGhpcy5saW5rcyA9IHt9OyAvLyBsaW5rc1xuXG4gIHRyeSB7XG4gICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHsvLyBpZ25vcmVcbiAgfVxufTtcbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7IC8vIHN0YXR1cyAvIGNsYXNzXG5cbiAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7IC8vIGJhc2ljc1xuXG4gIHRoaXMuaW5mbyA9IHR5cGUgPT0gMTtcbiAgdGhpcy5vayA9IHR5cGUgPT0gMjtcbiAgdGhpcy5yZWRpcmVjdCA9IHR5cGUgPT0gMztcbiAgdGhpcy5jbGllbnRFcnJvciA9IHR5cGUgPT0gNDtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IHR5cGUgPT0gNTtcbiAgdGhpcy5lcnJvciA9IHR5cGUgPT0gNCB8fCB0eXBlID09IDUgPyB0aGlzLnRvRXJyb3IoKSA6IGZhbHNlOyAvLyBzdWdhclxuXG4gIHRoaXMuY3JlYXRlZCA9IHN0YXR1cyA9PSAyMDE7XG4gIHRoaXMuYWNjZXB0ZWQgPSBzdGF0dXMgPT0gMjAyO1xuICB0aGlzLm5vQ29udGVudCA9IHN0YXR1cyA9PSAyMDQ7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IHN0YXR1cyA9PSA0MDA7XG4gIHRoaXMudW5hdXRob3JpemVkID0gc3RhdHVzID09IDQwMTtcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gc3RhdHVzID09IDQwNjtcbiAgdGhpcy5mb3JiaWRkZW4gPSBzdGF0dXMgPT0gNDAzO1xuICB0aGlzLm5vdEZvdW5kID0gc3RhdHVzID09IDQwNDtcbiAgdGhpcy51bnByb2Nlc3NhYmxlRW50aXR5ID0gc3RhdHVzID09IDQyMjtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xufTtcbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5wYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uIChvYmosIHN0cikge1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICB2YXIgdmFsID0gcGFydHMuc2hpZnQoKTtcbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcbi8qKlxuICogUGFyc2UgTGluayBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBzdHIpIHtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gICAgdmFyIHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgICB2YXIgcmVsID0gcGFydHNbMV0uc3BsaXQoLyAqPSAqLylbMV0uc2xpY2UoMSwgLTEpO1xuICAgIG9ialtyZWxdID0gdXJsO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5leHBvcnRzLmNsZWFuSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlciwgY2hhbmdlc09yaWdpbikge1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC1sZW5ndGgnXTtcbiAgZGVsZXRlIGhlYWRlclsndHJhbnNmZXItZW5jb2RpbmcnXTtcbiAgZGVsZXRlIGhlYWRlci5ob3N0OyAvLyBzZWN1aXJ0eVxuXG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlci5hdXRob3JpemF0aW9uO1xuICAgIGRlbGV0ZSBoZWFkZXIuY29va2llO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcjtcbn07IiwiLyoqXG4gKiBAZmlsZSBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktZmlsdGVyLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG52YXIgc29tZSA9IHJlcXVpcmUoJ2FycmF5LXNvbWUteCcpO1xuXG52YXIgJGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgY2FsbEJhY2sgLyogLCB0aGlzQXJnICovKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gIGFzc2VydElzRnVuY3Rpb24oY2FsbEJhY2spO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB3cmFwcGVkID0gZnVuY3Rpb24gX3dyYXBwZWQoaXRlbSwgaWR4LCBvYmopIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gICAgaWYgKGNhbGxCYWNrLmNhbGwodGhpcywgaXRlbSwgaWR4LCBvYmopKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYXJncyA9IFtvYmplY3QsIHdyYXBwZWRdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICBhcmdzWzJdID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgc29tZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxCYWNrIC0gRnVuY3Rpb24gaXMgYSBwcmVkaWNhdGUsIHRvIHRlc3QgZWFjaCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2FycmF5fSBBIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbHRlciA9IHJlcXVpcmUoJ2FycmF5LWZpbHRlci14Jyk7XG4gKlxuICogZnVuY3Rpb24gaXNCaWdFbm91Z2godmFsdWUpIHtcbiAqICAgcmV0dXJuIHZhbHVlID49IDEwO1xuICogfVxuICpcbiAqIHZhciBmaWx0ZXJlZCA9IGZpbHRlcihbMTIsIDUsIDgsIDEzMCwgNDRdLCBpc0JpZ0Vub3VnaCk7XG4gKiAvLyBmaWx0ZXJlZCBpcyBbMTIsIDEzMCwgNDRdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGZpbHRlcjtcbiIsIi8qKlxuICogQGZpbGUgRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGFycmF5IGVsZW1lbnQuXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktZm9yLWVhY2gteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcbnZhciBzb21lID0gcmVxdWlyZSgnYXJyYXktc29tZS14Jyk7XG5cbnZhciAkZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goYXJyYXksIGNhbGxCYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxCYWNrKTtcbiAgdmFyIHdyYXBwZWQgPSBmdW5jdGlvbiBfd3JhcHBlZChpdGVtLCBpZHgsIG9iaikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICBjYWxsQmFjay5jYWxsKHRoaXMsIGl0ZW0sIGlkeCwgb2JqKTtcbiAgfTtcblxuICB2YXIgYXJncyA9IFtvYmplY3QsIHdyYXBwZWRdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICBhcmdzWzJdID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgc29tZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBleGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsQmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIC0gVmFsdWUgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFycmF5IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBjYWxsQmFjayBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2FycmF5LWZvci1lYWNoLXgnKTtcbiAqXG4gKiB2YXIgaXRlbXMgPSBbJ2l0ZW0xJywgJ2l0ZW0yJywgJ2l0ZW0zJ107XG4gKiB2YXIgY29weSA9IFtdO1xuICpcbiAqIGZvckVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pe1xuICogICBjb3B5LnB1c2goaXRlbSlcbiAqIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRmb3JFYWNoO1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gYXJyYXkgaW5jbHVkZXMgYSBjZXJ0YWluIGVsZW1lbnQuXG4gKiBAdmVyc2lvbiAxLjAuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktaW5jbHVkZXMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBuYXRpdmVJbmNsdWRlcyA9IEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcztcbnZhciAkaW5jbHVkZXM7XG5cbmlmIChuYXRpdmVJbmNsdWRlcykge1xuICB2YXIgYXJyID0ge1xuICAgIDE6ICdhJyxcbiAgICAyOiBOYU4sXG4gICAgMzogLTAsXG4gICAgbGVuZ3RoOiA1XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBpZiAobmF0aXZlSW5jbHVkZXMuY2FsbChhcnIsIHZvaWQgMCwgLTEpICYmIG5hdGl2ZUluY2x1ZGVzLmNhbGwoYXJyLCBOYU4pICYmIG5hdGl2ZUluY2x1ZGVzLmNhbGwoJ2FiYycsICdjJykpIHtcbiAgICAgICRpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKGFycmF5LCBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gICAgICAgIHZhciBhcmdzID0gW3NlYXJjaEVsZW1lbnRdO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBhcmdzWzFdID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUluY2x1ZGVzLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxufVxuXG5pZiAoQm9vbGVhbigkaW5jbHVkZXMpID09PSBmYWxzZSkge1xuICB2YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgdmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14Jyk7XG4gIHZhciBzYW1lVmFsdWVaZXJvID0gcmVxdWlyZSgnc2FtZS12YWx1ZS16ZXJvLXgnKTtcbiAgdmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJ2ZpbmQtaW5kZXgteCcpO1xuICB2YXIgc3BsaXRTdHJpbmcgPSByZXF1aXJlKCdoYXMtYm94ZWQtc3RyaW5nLXgnKSA9PT0gZmFsc2U7XG4gIHZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXgtb2YteCcpO1xuICB2YXIgY2FsY0Zyb21JbmRleCA9IHJlcXVpcmUoJ2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgnKTtcblxuICAvKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGluZGV4IGluIHRoZSBhcnJheSwgaWYgYW4gZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICogc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLiBPdGhlcndpc2UgLTEgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdCAtIFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCAtIEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGluZGV4IG9mIGZvdW5kIGVsZW1lbnQsIG90aGVyd2lzZSAtMS5cbiAgICovXG4gIHZhciBmaW5kSWR4RnJvbSA9IGZ1bmN0aW9uIGZpbmRJbmRleEZyb20ob2JqZWN0LCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgZklkeCA9IGZyb21JbmRleDtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgob2JqZWN0Lmxlbmd0aCk7XG4gICAgd2hpbGUgKGZJZHggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChzYW1lVmFsdWVaZXJvKG9iamVjdFtmSWR4XSwgc2VhcmNoRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZJZHg7XG4gICAgICB9XG5cbiAgICAgIGZJZHggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgJGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHNlYXJjaEVsZW1lbnQpIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAgIHZhciBpdGVyYWJsZSA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKG9iamVjdCkgPyBvYmplY3Quc3BsaXQoJycpIDogb2JqZWN0O1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWZpbmVkKHNlYXJjaEVsZW1lbnQpKSB7XG4gICAgICB2YXIgZnJvbUluZGV4ID0gY2FsY0Zyb21JbmRleChpdGVyYWJsZSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGlmIChmcm9tSW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21JbmRleCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmRJZHhGcm9tKGl0ZXJhYmxlLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaW5kSW5kZXgoaXRlcmFibGUsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBzYW1lVmFsdWVaZXJvKHNlYXJjaEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgICAgfSkgPiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhPZihpdGVyYWJsZSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzJdLCAnc2FtZXZhbHVlemVybycpID4gLTE7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGFycmF5IGluY2x1ZGVzIGEgY2VydGFpbiBlbGVtZW50LFxuICogcmV0dXJuaW5nIHRydWUgb3IgZmFsc2UgYXMgYXBwcm9wcmlhdGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgYXJyYXlgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCAtIEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBgYXJyYXlgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXhdIC0gVGhlIHBvc2l0aW9uIGluIHRoaXMgYXJyYXkgYXQgd2hpY2ggdG8gYmVnaW5cbiAqICBzZWFyY2hpbmcgZm9yIHNlYXJjaEVsZW1lbnQuIEEgbmVnYXRpdmUgdmFsdWUgc2VhcmNoZXMgZnJvbSB0aGUgaW5kZXggb2ZcbiAqICBhcnJheS5sZW5ndGggKyBmcm9tSW5kZXggYnkgYXNjLiBEZWZhdWx0cyB0byAwLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBzZWFyY2hlZCBlbGVtZW50IGlzIGluY2x1ZGVkOyBvdGhlcndpc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5jbHVkZXMgPSByZXF1aXJlKCdhcnJheS1pbmNsdWRlcy14Jyk7XG4gKlxuICogdmFyIHN1YmplY3QgPSBbMiwgMywgdW5kZWZpbmVkLCB0cnVlLCAnaGVqJywgbnVsbCwgMiwgZmFsc2UsIDAsIC0wLCBOYU5dO1xuICogaW5jbHVkZXMoc3ViamVjdCwgdW5kZWZpbmVkKTsgLy8gdHJ1ZVxuICogaW5jbHVkZXMoc3ViamVjdCwgdW5kZWZpbmVkLCAzKTsgLy8gZmFsc2VcbiAqIGluY2x1ZGVzKHN1YmplY3QsIE5hTik7IC8vIHRydWVcbiAqIGluY2x1ZGVzKHN1YmplY3QsIDEwKTsgLy8gZmFsc2VcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGluY2x1ZGVzO1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE51bWJlci5pc0Zpbml0ZS5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNmaW5pdGV8MjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlICggbnVtYmVyICl9XG4gKiBAdmVyc2lvbiAxLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtZmluaXRlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkaXNOYU4gPSByZXF1aXJlKCdpcy1uYW4nKTtcblxudmFyICRpc0Zpbml0ZTtcbmlmICh0eXBlb2YgTnVtYmVyLmlzRmluaXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZSgnbWF4LXNhZmUtaW50ZWdlcicpO1xuICB0cnkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoTUFYX1NBRkVfSU5URUdFUikgJiYgTnVtYmVyLmlzRmluaXRlKEluZmluaXR5KSA9PT0gZmFsc2UpIHtcbiAgICAgICRpc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGlnbm9yZSkge31cbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSBudW1iZXIgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBmaW5pdGVuZXNzLlxuICogQHJldHVybnMge2Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICogdmFyIG51bUlzRmluaXRlID0gcmVxdWlyZSgnaXMtZmluaXRlLXgnKTtcbiAqXG4gKiBudW1Jc0Zpbml0ZShJbmZpbml0eSk7ICAvLyBmYWxzZVxuICogbnVtSXNGaW5pdGUoTmFOKTsgICAgICAgLy8gZmFsc2VcbiAqIG51bUlzRmluaXRlKC1JbmZpbml0eSk7IC8vIGZhbHNlXG4gKlxuICogbnVtSXNGaW5pdGUoMCk7ICAgICAgICAgLy8gdHJ1ZVxuICogbnVtSXNGaW5pdGUoMmU2NCk7ICAgICAgLy8gdHJ1ZVxuICpcbiAqIG51bUlzRmluaXRlKCcwJyk7ICAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsIGlzRmluaXRlKCcwJylcbiAqIG51bUlzRmluaXRlKG51bGwpOyAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRpc0Zpbml0ZSB8fCBmdW5jdGlvbiBpc0Zpbml0ZShudW1iZXIpIHtcbiAgcmV0dXJuICEodHlwZW9mIG51bWJlciAhPT0gJ251bWJlcicgfHwgJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSBJbmZpbml0eSB8fCBudW1iZXIgPT09IC1JbmZpbml0eSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE1hdGguc2lnbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1tYXRoLnNpZ258MjAuMi4yLjI5IE1hdGguc2lnbih4KX1cbiAqIEB2ZXJzaW9uIDEuMy4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBtYXRoLXNpZ24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJ2lzLW5hbicpO1xuXG52YXIgJHNpZ247XG5pZiAodHlwZW9mIE1hdGguc2lnbiA9PT0gJ2Z1bmN0aW9uJykge1xuICB0cnkge1xuICAgIGlmIChNYXRoLnNpZ24oMTApID09PSAxICYmIE1hdGguc2lnbigtMTApID09PSAtMSAmJiBNYXRoLnNpZ24oMCkgPT09IDApIHtcbiAgICAgICRzaWduID0gTWF0aC5zaWduO1xuICAgIH1cbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXIsIGluZGljYXRpbmcgd2hldGhlciB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLFxuICogbmVnYXRpdmUgb3IgemVyby5cbiAqXG4gKiBAcGFyYW0geyp9IHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgc2lnbiBvZiB0aGUgZ2l2ZW4gYXJndW1lbnQuIElmIHRoZSBhcmd1bWVudFxuICogaXMgYSBwb3NpdGl2ZSBudW1iZXIsIG5lZ2F0aXZlIG51bWJlciwgcG9zaXRpdmUgemVybyBvciBuZWdhdGl2ZSB6ZXJvLCB0aGUgZnVuY3Rpb24gd2lsbFxuICogcmV0dXJuIDEsIC0xLCAwIG9yIC0wIHJlc3BlY3RpdmVseS4gT3RoZXJ3aXNlLCBOYU4gaXMgcmV0dXJuZWQuXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hdGhTaWduID0gcmVxdWlyZSgnbWF0aC1zaWduLXgnKTtcbiAqXG4gKiBtYXRoU2lnbigzKTsgICAgIC8vICAxXG4gKiBtYXRoU2lnbigtMyk7ICAgIC8vIC0xXG4gKiBtYXRoU2lnbignLTMnKTsgIC8vIC0xXG4gKiBtYXRoU2lnbigwKTsgICAgIC8vICAwXG4gKiBtYXRoU2lnbigtMCk7ICAgIC8vIC0wXG4gKiBtYXRoU2lnbihOYU4pOyAgIC8vIE5hTlxuICogbWF0aFNpZ24oJ2ZvbycpOyAvLyBOYU5cbiAqIG1hdGhTaWduKCk7ICAgICAgLy8gTmFOXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJHNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIHZhciBuID0gTnVtYmVyKHgpO1xuICBpZiAobiA9PT0gMCB8fCAkaXNOYU4obikpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHJldHVybiBuID4gMCA/IDEgOiAtMTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFRvSW50ZWdlciBjb252ZXJ0cyAnYXJndW1lbnQnIHRvIGFuIGludGVncmFsIG51bWVyaWMgdmFsdWUuXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnRlZ2VyfDcuMS40IFRvSW50ZWdlciAoIGFyZ3VtZW50ICl9XG4gKiBAdmVyc2lvbiAxLjQuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8taW50ZWdlci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGlzTmFOID0gcmVxdWlyZSgnaXMtbmFuJyk7XG52YXIgJGlzRmluaXRlID0gcmVxdWlyZSgnaXMtZmluaXRlLXgnKTtcbnZhciAkc2lnbiA9IHJlcXVpcmUoJ21hdGgtc2lnbi14Jyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgndG8taW50ZWdlci14Jyk7XG4gKiB0b0ludGVnZXIoMyk7IC8vIDNcbiAqIHRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gMFxuICogdG9JbnRlZ2VyKEluZmluaXR5KTsgLy8gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqIHRvSW50ZWdlcignMycpOyAvLyAzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciBudW1iZXIgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAoJGlzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IDAgfHwgJGlzRmluaXRlKG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiAkc2lnbihudW1iZXIpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEVTNi1jb21wbGlhbnQgc2hpbSBmb3IgVG9MZW5ndGguXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGh8Ny4xLjE1IFRvTGVuZ3RoICggYXJndW1lbnQgKX1cbiAqIEB2ZXJzaW9uIDEuNC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1sZW5ndGgteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSByZXF1aXJlKCdtYXgtc2FmZS1pbnRlZ2VyJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICogYXJyYXktbGlrZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAqIHRvTGVuZ3RoKDMpOyAvLyAzXG4gKiB0b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gMFxuICogdG9MZW5ndGgoSW5maW5pdHkpOyAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICogdG9MZW5ndGgoJzMnKTsgLy8gM1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvTGVuZ3RoKHZhbHVlKSB7XG4gIHZhciBsZW4gPSB0b0ludGVnZXIodmFsdWUpO1xuICAvLyBpbmNsdWRlcyBjb252ZXJ0aW5nIC0wIHRvICswXG4gIGlmIChsZW4gPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDcm9zcy1icm93c2VyIGFycmF5LWxpa2Ugc2xpY2VyLlxuICogQHZlcnNpb24gMS4yLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFycmF5LWxpa2Utc2xpY2UteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCd0by1pbnRlZ2VyLXgnKS50b0ludGVnZXIyMDE4O1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKS50b0xlbmd0aDIwMTg7XG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCd2YWxpZGF0ZS5pby11bmRlZmluZWQnKTtcbnZhciBzcGxpdElmQm94ZWRCdWcgPSByZXF1aXJlKCdzcGxpdC1pZi1ib3hlZC1idWcteCcpO1xuXG52YXIgZ2V0TWF4ID0gZnVuY3Rpb24gX2dldE1heChhLCBiKSB7XG4gIHJldHVybiBhID49IGIgPyBhIDogYjtcbn07XG5cbnZhciBnZXRNaW4gPSBmdW5jdGlvbiBfZ2V0TWluKGEsIGIpIHtcbiAgcmV0dXJuIGEgPD0gYiA/IGEgOiBiO1xufTtcblxudmFyIHNldFJlbGF0aXZlID0gZnVuY3Rpb24gX3NldFJlbGF0aXZlKHZhbHVlLCBsZW5ndGgpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IGdldE1heChsZW5ndGggKyB2YWx1ZSwgMCkgOiBnZXRNaW4odmFsdWUsIGxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFRoZSBzbGljZSgpIG1ldGhvZCByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhbiBhcnJheSBpbnRvIGEgbmV3XG4gKiBhcnJheSBvYmplY3Qgc2VsZWN0ZWQgZnJvbSBiZWdpbiB0byBlbmQgKGVuZCBub3QgaW5jbHVkZWQpLiBUaGUgb3JpZ2luYWxcbiAqIGFycmF5IHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gYXJnc09iamVjdCAtIFRoZSBgYXJndW1lbnRzYCB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdIC0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBiZWdpbiBleHRyYWN0aW9uLlxuICogIEEgbmVnYXRpdmUgaW5kZXggY2FuIGJlIHVzZWQsIGluZGljYXRpbmcgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGVcbiAqICBzZXF1ZW5jZS4gc2xpY2UoLTIpIGV4dHJhY3RzIHRoZSBsYXN0IHR3byBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgYmVnaW4gaXMgdW5kZWZpbmVkLCBzbGljZSBiZWdpbnMgZnJvbSBpbmRleCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gWmVyby1iYXNlZCBpbmRleCBiZWZvcmUgd2hpY2ggdG8gZW5kIGV4dHJhY3Rpb24uXG4gKiAgU2xpY2UgZXh0cmFjdHMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLiBGb3IgZXhhbXBsZSwgc2xpY2UoWzAsMSwyLDMsNF0sMSw0KVxuICogIGV4dHJhY3RzIHRoZSBzZWNvbmQgZWxlbWVudCB0aHJvdWdoIHRoZSBmb3VydGggZWxlbWVudCAoZWxlbWVudHMgaW5kZXhlZFxuICogIDEsIDIsIGFuZCAzKS5cbiAqICBBIG5lZ2F0aXZlIGluZGV4IGNhbiBiZSB1c2VkLCBpbmRpY2F0aW5nIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlXG4gKiAgc2VxdWVuY2UuIHNsaWNlKDIsLTEpIGV4dHJhY3RzIHRoZSB0aGlyZCBlbGVtZW50IHRocm91Z2ggdGhlIHNlY29uZC10by1sYXN0XG4gKiAgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgZW5kIGlzIG9taXR0ZWQsIHNsaWNlIGV4dHJhY3RzIHRocm91Z2ggdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UgKGFyci5sZW5ndGgpLlxuICogIElmIGVuZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgc2VxdWVuY2UsIHNsaWNlIGV4dHJhY3RzIHRocm91Z2hcbiAqICB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSAoYXJyLmxlbmd0aCkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIGV4dHJhY3RlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXJyYXlMaWtlU2xpY2UgPSByZXF1aXJlKCdhcnJheS1saWtlLXNsaWNlLXgnKTtcbiAqIHZhciBhcmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzO1xuICogfSgnQmFuYW5hJywgJ09yYW5nZScsICdMZW1vbicsICdBcHBsZScsICdNYW5nbycpKTtcbiAqXG4gKiB2YXIgY2l0cnVzID0gYXJyYXlMaWtlU2xpY2UoYXJncywgMSwgMyk7XG4gKlxuICogLy8gYXJncyBjb250YWlucyBbJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGVtb24nLCAnQXBwbGUnLCAnTWFuZ28nXVxuICogLy8gY2l0cnVzIGNvbnRhaW5zIFsnT3JhbmdlJywnTGVtb24nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNsaWNlKGFycmF5TGlrZSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaXRlcmFibGUgPSBzcGxpdElmQm94ZWRCdWcodG9PYmplY3QoYXJyYXlMaWtlKSk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICB2YXIgayA9IHNldFJlbGF0aXZlKHRvSW50ZWdlcihzdGFydCksIGxlbmd0aCk7XG4gIHZhciByZWxhdGl2ZUVuZCA9IGlzVW5kZWZpbmVkKGVuZCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgdmFyIGZpbmFsRW5kID0gc2V0UmVsYXRpdmUocmVsYXRpdmVFbmQsIGxlbmd0aCk7XG4gIHZhciB2YWwgPSBbXTtcbiAgdmFsLmxlbmd0aCA9IGdldE1heChmaW5hbEVuZCAtIGssIDApO1xuICB2YXIgbmV4dCA9IDA7XG4gIHdoaWxlIChrIDwgZmluYWxFbmQpIHtcbiAgICBpZiAoayBpbiBpdGVyYWJsZSkge1xuICAgICAgdmFsW25leHRdID0gaXRlcmFibGVba107XG4gICAgfVxuXG4gICAgbmV4dCArPSAxO1xuICAgIGsgKz0gMTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDcmVhdGVzIGFuIGFycmF5IHdpdGggdGhlIHJlc3VsdHMgb2YgY2FsbGluZyBhIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQuXG4gKiBAdmVyc2lvbiAyLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktbWFwLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYWNoZWRDdHJzID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14Jyk7XG52YXIgQXJyYXlDdHIgPSBjYWNoZWRDdHJzLkFycmF5O1xudmFyIGNhc3RPYmplY3QgPSBjYWNoZWRDdHJzLk9iamVjdDtcbnZhciBuYXRpdmVNYXAgPSB0eXBlb2YgQXJyYXlDdHIucHJvdG90eXBlLm1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheUN0ci5wcm90b3R5cGUubWFwO1xuXG52YXIgaXNXb3JraW5nO1xuaWYgKG5hdGl2ZU1hcCkge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICB2YXIgc3B5ID0gMDtcbiAgdmFyIHJlcyA9IGF0dGVtcHQuY2FsbChbMSwgMl0sIG5hdGl2ZU1hcCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG5cbiAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMiAmJiByZXMudmFsdWVbMF0gPT09IDEgJiYgcmVzLnZhbHVlWzFdID09PSAyO1xuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSAnJztcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoY2FzdE9iamVjdCgnYWInKSwgbmF0aXZlTWFwLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAyICYmIHJlcy52YWx1ZVswXSA9PT0gJ2EnICYmIHJlcy52YWx1ZVsxXSA9PT0gJ2InO1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHNweSA9IDA7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgIH0oMSwgMikpLCBuYXRpdmVNYXAsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDIgJiYgcmVzLnZhbHVlWzBdID09PSAxICYmIHJlcy52YWx1ZVsxXSA9PT0gMjtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSAwO1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCh7XG4gICAgICAwOiAxLFxuICAgICAgMjogMixcbiAgICAgIGxlbmd0aDogM1xuICAgIH0sIG5hdGl2ZU1hcCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMyAmJiAoMSBpbiByZXMudmFsdWUpID09PSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICBzcHkgPSBudWxsO1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKGZyYWdtZW50LmNoaWxkTm9kZXMsIG5hdGl2ZU1hcCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcblxuICAgICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiByZXMudmFsdWVbMF0gPT09IGRpdjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgdmFyIGlzU3RyaWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMpID09PSBmYWxzZTtcbiAgICB9KCkpO1xuXG4gICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICBzcHkgPSBudWxsO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKFsxXSwgbmF0aXZlTWFwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgICAgc3B5ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgfSwgJ3gnKTtcblxuICAgICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiBzcHkgPT09IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHNweSA9IHt9O1xuICAgIHZhciBmbiA9IFtcbiAgICAgICdyZXR1cm4gbmF0aXZlTWFwLmNhbGwoXCJmb29cIiwgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7JyxcbiAgICAgICdpZiAoQm9vbGVhbihjb250ZXh0KSA9PT0gZmFsc2UgfHwgdHlwZW9mIGNvbnRleHQgIT09IFwib2JqZWN0XCIpIHsnLFxuICAgICAgJ3NweS52YWx1ZSA9IHRydWU7fX0pOydcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgcmVzID0gYXR0ZW1wdChGdW5jdGlvbignbmF0aXZlTWFwJywgJ3NweScsIGZuKSwgbmF0aXZlTWFwLCBzcHkpO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMyAmJiBzcHkudmFsdWUgIT09IHRydWU7XG4gIH1cbn1cblxudmFyICRtYXA7XG5pZiAobmF0aXZlTWFwKSB7XG4gICRtYXAgPSBmdW5jdGlvbiBtYXAoYXJyYXksIGNhbGxCYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBhcmdzID0gW2NhbGxCYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZU1hcC5hcHBseShhcnJheSwgYXJncyk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgc3BsaXRJZkJveGVkQnVnID0gcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKS50b0xlbmd0aDIwMTg7XG4gIHZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xuICB2YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG5cbiAgJG1hcCA9IGZ1bmN0aW9uIG1hcChhcnJheSwgY2FsbEJhY2sgLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgIGFzc2VydElzRnVuY3Rpb24oY2FsbEJhY2spO1xuICAgIHZhciBpdGVyYWJsZSA9IHNwbGl0SWZCb3hlZEJ1ZyhvYmplY3QpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICAgIHZhciB0aGlzQXJnO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG5cbiAgICB2YXIgbm9UaGlzID0gaXNVbmRlZmluZWQodGhpc0FyZyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgcmVzdWx0W2ldID0gbm9UaGlzID8gY2FsbEJhY2soaXRlbSwgaSwgb2JqZWN0KSA6IGNhbGxCYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cyBvZiBjYWxsaW5nIGEgcHJvdmlkZWRcbiAqIGZ1bmN0aW9uIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNhbGxpbmcgYXJyYXkuXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbEJhY2sgLSBGdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGVsZW1lbnQgb2YgdGhlIEFycmF5LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2FycmF5fSBBIG5ldyBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICogY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hcCA9IHJlcXVpcmUoJ2FycmF5LW1hcC14Jyk7XG4gKlxuICogdmFyIG51bWJlcnMgPSBbMSwgNCwgOV07XG4gKiB2YXIgcm9vdHMgPSBtYXAobnVtYmVycywgTWF0aC5zcXJ0KTtcbiAqIC8vIHJvb3RzIGlzIG5vdyBbMSwgMiwgM11cbiAqIC8vIG51bWJlcnMgaXMgc3RpbGwgWzEsIDQsIDldXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJG1hcDtcbiIsIi8qKlxuICogQGZpbGUgSWYgaXNGdW5jdGlvbihjYWxsYmFja2ZuKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICogQHZlcnNpb24gMi4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFzc2VydC1pcy1mdW5jdGlvbi14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uLXgnKTtcbnZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKCd0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteCcpO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnaXMtcHJpbWl0aXZlJyk7XG5cbi8qKlxuICogVGVzdHMgYGNhbGxiYWNrYCB0byBzZWUgaWYgaXQgaXMgYSBmdW5jdGlvbiwgdGhyb3dzIGEgYFR5cGVFcnJvcmAgaWYgaXQgaXNcbiAqIG5vdC4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIGBjYWxsYmFja2AuXG4gKlxuICogQHBhcmFtIHsqfSBjYWxsYmFjayAtIFRoZSBhcmd1bWVudCB0byBiZSB0ZXN0ZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IFRocm93cyBpZiBgY2FsbGJhY2tgIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYGNhbGxiYWNrYCBpZiBpdCBpcyBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG4gKiB2YXIgcHJpbWl0aXZlID0gdHJ1ZTtcbiAqIHZhciBteVN5bWJvbCA9IFN5bWJvbCgnbXlTeW1ib2wnKTtcbiAqIHZhciBzeW1PYmogPSBPYmplY3QobXlTeW1ib2wpO1xuICogdmFyIG9iamVjdCA9IHt9O1xuICogZnVuY3Rpb24gZm4gKCkge31cbiAqXG4gKiBhc3NlcnRJc0Z1bmN0aW9uKHByaW1pdGl2ZSk7XG4gKiAgICAvLyBUeXBlRXJyb3IgJ3RydWUgaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihvYmplY3QpO1xuICogICAgLy8gVHlwZUVycm9yICcjPE9iamVjdD4gaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihteVN5bWJvbCk7XG4gKiAgICAvLyBUeXBlRXJyb3IgJ1N5bWJvbChteVN5bWJvbCkgaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihzeW1PYmopO1xuICogICAgLy8gVHlwZUVycm9yICcjPE9iamVjdD4gaXMgbm90IGEgZnVuY3Rpb24nLlxuICogYXNzZXJ0SXNGdW5jdGlvbihmbik7XG4gKiAgICAvLyBSZXR1cm5zIGZuLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2VydElzRnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spID09PSBmYWxzZSkge1xuICAgIHZhciBtc2cgPSBpc1ByaW1pdGl2ZShjYWxsYmFjaykgPyBzYWZlVG9TdHJpbmcoY2FsbGJhY2spIDogJyM8T2JqZWN0Pic7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2s7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBSZWR1Y2UgYW4gYXJyYXkgKGZyb20gbGVmdCB0byByaWdodCkgdG8gYSBzaW5nbGUgdmFsdWUuXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktcmVkdWNlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG52YXIgbmF0aXZlUmVkdWNlID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPT09ICdmdW5jdGlvbicgJiYgQXJyYXkucHJvdG90eXBlLnJlZHVjZTtcblxuLy8gRVM1IDE1LjQuNC4yMVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIxXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVxudmFyIGlzV29ya2luZztcbmlmIChuYXRpdmVSZWR1Y2UpIHtcbiAgaXNXb3JraW5nID0gYXR0ZW1wdC5jYWxsKFtdLCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChhY2MpIHtcbiAgICByZXR1cm4gYWNjO1xuICB9KS50aHJldztcblxuICB2YXIgcmVzO1xuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKE9iamVjdCgnYWJjJyksIG5hdGl2ZVJlZHVjZSwgZnVuY3Rpb24gKGFjYywgYykge1xuICAgICAgcmV0dXJuIGFjYyArIGM7XG4gICAgfSwgJ3gnKTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSAneGFiYyc7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgIH0oMSwgMiwgMykpLCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChhY2MsIGFyZykge1xuICAgICAgcmV0dXJuIGFjYyArIGFyZztcbiAgICB9LCAxKTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSA3O1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCh7XG4gICAgICAwOiAxLFxuICAgICAgMTogMixcbiAgICAgIDM6IDMsXG4gICAgICA0OiA0LFxuICAgICAgbGVuZ3RoOiA0XG4gICAgfSwgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjLCBhcmcpIHtcbiAgICAgIHJldHVybiBhY2MgKyBhcmc7XG4gICAgfSwgMik7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gODtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICByZXMgPSBhdHRlbXB0LmNhbGwoZnJhZ21lbnQuY2hpbGROb2RlcywgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgICAgIGFjY1thY2MubGVuZ3RoXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBbXSk7XG5cbiAgICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiByZXMudmFsdWVbMF0gPT09IGRpdjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoJ2FiJywgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHR5cGVvZiByZXMudmFsdWUgPT09ICdvYmplY3QnO1xuICB9XG59XG5cbnZhciAkcmVkdWNlO1xuaWYgKG5hdGl2ZVJlZHVjZSAmJiBpc1dvcmtpbmcpIHtcbiAgJHJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShhcnJheSwgY2FsbEJhY2sgLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICB2YXIgYXJncyA9IFtjYWxsQmFja107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBhcmdzWzFdID0gYXJndW1lbnRzWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVSZWR1Y2UuYXBwbHkoYXJyYXksIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gQ2hlY2sgZmFpbHVyZSBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMgKElFIDwgOSlcbiAgLy8gYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbiAgdmFyIHNwbGl0SWZCb3hlZEJ1ZyA9IHJlcXVpcmUoJ3NwbGl0LWlmLWJveGVkLWJ1Zy14Jyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcblxuICAkcmVkdWNlID0gZnVuY3Rpb24gcmVkdWNlKGFycmF5LCBjYWxsQmFjayAvKiAsIGluaXRpYWxWYWx1ZSovKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgIGFzc2VydElzRnVuY3Rpb24oY2FsbEJhY2spO1xuICAgIHZhciBpdGVyYWJsZSA9IHNwbGl0SWZCb3hlZEJ1ZyhvYmplY3QpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJyYXlcbiAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3NMZW5ndGggPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKGFyZ3NMZW5ndGggPiAyKSB7XG4gICAgICByZXN1bHQgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKGkgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEJhY2socmVzdWx0LCBpdGVyYWJsZVtpXSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYXBwbGllcyBhIGZ1bmN0aW9uIGFnYWluc3QgYW4gYWNjdW11bGF0b3IgYW5kIGVhY2ggZWxlbWVudCBpbiB0aGVcbiAqIGFycmF5IChmcm9tIGxlZnQgdG8gcmlnaHQpIHRvIHJlZHVjZSBpdCB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsQmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gLSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdFxuICogIGNhbGwgb2YgdGhlIGNhbGxiYWNrLiBJZiBubyBpbml0aWFsIHZhbHVlIGlzIHN1cHBsaWVkLCB0aGUgZmlyc3QgZWxlbWVudCBpblxuICogIHRoZSBhcnJheSB3aWxsIGJlIHVzZWQuIENhbGxpbmcgcmVkdWNlIG9uIGFuIGVtcHR5IGFycmF5IHdpdGhvdXQgYW4gaW5pdGlhbFxuICogIHZhbHVlIGlzIGFuIGVycm9yLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcnJheSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgY2FsbEJhY2sgaXMgbm90IGEgZnVuY3Rpb24uXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxlZCBvbiBhbiBlbXB0eSBhcnJheSB3aXRob3V0IGFuIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIHJlZHVjZSA9IHJlcXVpcmUoJ2FycmF5LXJlZHVjZS14Jyk7XG4gKlxuICogdmFyIHN1bSA9IHJlZHVjZShbMCwgMSwgMiwgM10sIGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgIHJldHVybiBhICsgYjtcbiAqIH0sIDApO1xuICogLy8gc3VtIGlzIDZcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkcmVkdWNlO1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE1hdGguc2lnbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1tYXRoLnNpZ258MjAuMi4yLjI5IE1hdGguc2lnbih4KX1cbiAqIEB2ZXJzaW9uIDIuMS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBtYXRoLXNpZ24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciBudW1iZXJJc05hTiA9IHJlcXVpcmUoJ2lzLW5hbi14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlciwgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsXG4gKiBuZWdhdGl2ZSBvciB6ZXJvLlxuICpcbiAqIEBwYXJhbSB7Kn0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMge251bWJlcn0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaWduIG9mIHRoZSBnaXZlbiBhcmd1bWVudC4gSWYgdGhlIGFyZ3VtZW50XG4gKiBpcyBhIHBvc2l0aXZlIG51bWJlciwgbmVnYXRpdmUgbnVtYmVyLCBwb3NpdGl2ZSB6ZXJvIG9yIG5lZ2F0aXZlIHplcm8sIHRoZSBmdW5jdGlvbiB3aWxsXG4gKiByZXR1cm4gMSwgLTEsIDAgb3IgLTAgcmVzcGVjdGl2ZWx5LiBPdGhlcndpc2UsIE5hTiBpcyByZXR1cm5lZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbWF0aFNpZ24gPSByZXF1aXJlKCdtYXRoLXNpZ24teCcpO1xuICpcbiAqIG1hdGhTaWduKDMpOyAgICAgLy8gIDFcbiAqIG1hdGhTaWduKC0zKTsgICAgLy8gLTFcbiAqIG1hdGhTaWduKCctMycpOyAgLy8gLTFcbiAqIG1hdGhTaWduKDApOyAgICAgLy8gIDBcbiAqIG1hdGhTaWduKC0wKTsgICAgLy8gLTBcbiAqIG1hdGhTaWduKE5hTik7ICAgLy8gTmFOXG4gKiBtYXRoU2lnbignZm9vJyk7IC8vIE5hTlxuICogbWF0aFNpZ24oKTsgICAgICAvLyBOYU5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaWduKHgpIHtcbiAgdmFyIG4gPSB0b051bWJlcih4KTtcbiAgaWYgKG4gPT09IDAgfHwgbnVtYmVySXNOYU4obikpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHJldHVybiBuID4gMCA/IDEgOiAtMTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFBhcnNlcyBhIHN0cmluZyBhcmd1bWVudCBhbmQgcmV0dXJucyBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgcGFyc2UtaW50LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuYXRpdmVQYXJzZUludCA9IHBhcnNlSW50O1xudmFyIHdzID0gcmVxdWlyZSgnd2hpdGUtc3BhY2UteCcpLnN0cmluZztcbnZhciB0b1N0ciA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG5cbnZhciAkcGFyc2VJbnQ7XG5pZiAobmF0aXZlUGFyc2VJbnQod3MgKyAnMDgnKSA9PT0gOCAmJiBuYXRpdmVQYXJzZUludCh3cyArICcweDE2JykgPT09IDIyKSB7XG4gICRwYXJzZUludCA9IGZ1bmN0aW9uIHBhcnNlSW50ZWdlcihzdHJpbmcsIHJhZGl4KSB7XG4gICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyKHN0cmluZyksIHJhZGl4KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciB0cmltID0gcmVxdWlyZSgndHJpbS14Jyk7XG4gIHZhciBjYXN0TnVtYmVyID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuTnVtYmVyO1xuICB2YXIgaGV4UmVnZXggPSAvXlstK10/MFt4WF0vO1xuICB2YXIgdGVzdCA9IGhleFJlZ2V4LnRlc3Q7XG5cbiAgJHBhcnNlSW50ID0gZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZywgcmFkaXgpIHtcbiAgICB2YXIgc3RyID0gdHJpbSh0b1N0cihzdHJpbmcpKTtcblxuICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHIsIGNhc3ROdW1iZXIocmFkaXgpIHx8ICh0ZXN0LmNhbGwoaGV4UmVnZXgsIHN0cikgPyAxNiA6IDEwKSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcGFyc2VzIGEgc3RyaW5nIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZFxuICogcmFkaXggKHRoZSBiYXNlIGluIG1hdGhlbWF0aWNhbCBudW1lcmFsIHN5c3RlbXMpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgdmFsdWUgdG8gcGFyc2UuIElmIHRoZSBzdHJpbmcgYXJndW1lbnQgaXMgbm90IGFcbiAqICBzdHJpbmcsIHRoZW4gaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nICh1c2luZyB0aGUgVG9TdHJpbmcgYWJzdHJhY3RcbiAqICBvcGVyYXRpb24pLiBMZWFkaW5nIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl4IC0gQW4gaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDM2IHRoYXQgcmVwcmVzZW50cyB0aGUgcmFkaXhcbiAqICAodGhlIGJhc2UgaW4gbWF0aGVtYXRpY2FsIG51bWVyYWwgc3lzdGVtcykgb2YgdGhlIGFib3ZlIG1lbnRpb25lZCBzdHJpbmcuXG4gKiAgU3BlY2lmeSAxMCBmb3IgdGhlIGRlY2ltYWwgbnVtZXJhbCBzeXN0ZW0gY29tbW9ubHkgdXNlZCBieSBodW1hbnMuIEFsd2F5c1xuICogIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIgdG8gZWxpbWluYXRlIHJlYWRlciBjb25mdXNpb24gYW5kIHRvIGd1YXJhbnRlZVxuICogIHByZWRpY3RhYmxlIGJlaGF2aW9yLiBEaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdHNcbiAqICB3aGVuIGEgcmFkaXggaXMgbm90IHNwZWNpZmllZCwgdXN1YWxseSBkZWZhdWx0aW5nIHRoZSB2YWx1ZSB0byAxMC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGFyZ2V0IGlzIGEgU3ltYm9sIG9yIGlzIG5vdCBjb2VyY2libGUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBbiBpbnRlZ2VyIG51bWJlciBwYXJzZWQgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLiBJZiB0aGUgZmlyc3RcbiAqICBjaGFyYWN0ZXIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgTmFOIGlzIHJldHVybmVkLlxuICogQGV4YW1wbGVcbiAqIHZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCdwYXJzZS1pbnQteCcpO1xuICpcbiAqIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgYWxsIHJldHVybiAxNVxuICogJHBhcnNlSW50KCcgMHhGJywgMTYpO1xuICogJHBhcnNlSW50KCcgRicsIDE2KTtcbiAqICRwYXJzZUludCgnMTcnLCA4KTtcbiAqICRwYXJzZUludCgwMjEsIDgpO1xuICogJHBhcnNlSW50KCcwMTUnLCAxMCk7ICAgLy8gJHBhcnNlSW50KDAxNSwgMTApOyB3aWxsIHJldHVybiAxNVxuICogJHBhcnNlSW50KDE1Ljk5LCAxMCk7XG4gKiAkcGFyc2VJbnQoJzE1LDEyMycsIDEwKTtcbiAqICRwYXJzZUludCgnRlhYMTIzJywgMTYpO1xuICogJHBhcnNlSW50KCcxMTExJywgMik7XG4gKiAkcGFyc2VJbnQoJzE1ICogMycsIDEwKTtcbiAqICRwYXJzZUludCgnMTVlMicsIDEwKTtcbiAqICRwYXJzZUludCgnMTVweCcsIDEwKTtcbiAqICRwYXJzZUludCgnMTInLCAxMyk7XG4gKlxuICogLy9UaGUgZm9sbG93aW5nIGV4YW1wbGVzIGFsbCByZXR1cm4gTmFOOlxuICogJHBhcnNlSW50KCdIZWxsbycsIDgpOyAvLyBOb3QgYSBudW1iZXIgYXQgYWxsXG4gKiAkcGFyc2VJbnQoJzU0NicsIDIpOyAgIC8vIERpZ2l0cyBhcmUgbm90IHZhbGlkIGZvciBiaW5hcnkgcmVwcmVzZW50YXRpb25zXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50O1xuIiwiLyoqXG4gKiBAZmlsZSBUb0ludGVnZXIgY29udmVydHMgJ2FyZ3VtZW50JyB0byBhbiBpbnRlZ3JhbCBudW1lcmljIHZhbHVlLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50ZWdlcnw3LjEuNCBUb0ludGVnZXIgKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMi4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWludGVnZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciBudW1iZXJJc05hTiA9IHJlcXVpcmUoJ2lzLW5hbi14Jyk7XG52YXIgbnVtYmVySXNGaW5pdGUgPSByZXF1aXJlKCdpcy1maW5pdGUteCcpO1xudmFyIG1hdGhTaWduID0gcmVxdWlyZSgnbWF0aC1zaWduLXgnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCd0by1pbnRlZ2VyLXgnKTtcbiAqIHRvSW50ZWdlcigzKTsgLy8gM1xuICogdG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpOyAvLyAwXG4gKiB0b0ludGVnZXIoSW5maW5pdHkpOyAvLyAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICogdG9JbnRlZ2VyKCczJyk7IC8vIDNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIG51bWJlciA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKG51bWJlcklzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChudW1iZXIgPT09IDAgfHwgbnVtYmVySXNGaW5pdGUobnVtYmVyKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgcmV0dXJuIG1hdGhTaWduKG51bWJlcikgKiBNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgRVM2LWNvbXBsaWFudCBzaGltIGZvciBUb0xlbmd0aC5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aHw3LjEuMTUgVG9MZW5ndGggKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMi4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWxlbmd0aC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgndG8taW50ZWdlci14Jyk7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IHJlcXVpcmUoJ21heC1zYWZlLWludGVnZXInKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gKiBhcnJheS1saWtlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpO1xuICogdG9MZW5ndGgoMyk7IC8vIDNcbiAqIHRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpOyAvLyAwXG4gKiB0b0xlbmd0aChJbmZpbml0eSk7IC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gKiB0b0xlbmd0aCgnMycpOyAvLyAzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgdmFyIGxlbiA9IHRvSW50ZWdlcih2YWx1ZSk7XG4gIC8vIGluY2x1ZGVzIGNvbnZlcnRpbmcgLTAgdG8gKzBcbiAgaWYgKGxlbiA8PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobGVuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2YgdHlwZSBOdW1iZXIuXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8tbnVtYmVyLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdHJ1Y3RvcnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbnZhciBjYXN0TnVtYmVyID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuTnVtYmVyO1xudmFyIFJ4ID0gY29uc3RydWN0b3JzLlJlZ0V4cDtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ3RvLXByaW1pdGl2ZS14Jyk7XG52YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJ3BhcnNlLWludC14Jyk7XG52YXIgcFN0clNsaWNlID0gJycuc2xpY2U7XG52YXIgTkFOID0gcmVxdWlyZSgnbmFuLXgnKTtcblxudmFyIGJpbmFyeVJlZ2V4ID0gL14wYlswMV0rJC9pO1xuLy8gTm90ZSB0aGF0IGluIElFIDgsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCBkb2Vzbid0IHNlZW0gdG8gZXhpc3Q6IGllLCBcInRlc3RcIiBpcyBhbiBvd24gcHJvcGVydHkgb2YgcmVnZXhlcy4gd3RmLlxudmFyIHRlc3QgPSBiaW5hcnlSZWdleC50ZXN0O1xudmFyIGlzQmluYXJ5ID0gZnVuY3Rpb24gX2lzQmluYXJ5KHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoYmluYXJ5UmVnZXgsIHZhbHVlKTtcbn07XG5cbnZhciBvY3RhbFJlZ2V4ID0gL14wb1swLTddKyQvaTtcbnZhciBpc09jdGFsID0gZnVuY3Rpb24gX2lzT2N0YWwodmFsdWUpIHtcbiAgcmV0dXJuIHRlc3QuY2FsbChvY3RhbFJlZ2V4LCB2YWx1ZSk7XG59O1xuXG52YXIgbm9uV1NyZWdleCA9IG5ldyBSeCgnW1xcdTAwODVcXHUyMDBiXFx1ZmZmZV0nLCAnZycpO1xudmFyIGhhc05vbldTID0gZnVuY3Rpb24gX2hhc05vbldTKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwobm9uV1NyZWdleCwgdmFsdWUpO1xufTtcblxudmFyIGludmFsaWRIZXhMaXRlcmFsID0gL15bLStdMHhbMC05YS1mXSskL2k7XG52YXIgaXNJbnZhbGlkSGV4TGl0ZXJhbCA9IGZ1bmN0aW9uIF9pc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoaW52YWxpZEhleExpdGVyYWwsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci5cblxuICogQHBhcmFtIHsqfSBhcmd1bWVudCAtIFRoZSBhcmd1bWVudCB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHRocm93cyB7VHlwZUVycm9yfSAtIElmIGFyZ3VtZW50IGlzIGEgU3ltYm9sIG9yIG5vdCBjb2VyY2libGUuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIGFyZ3VtZW50IGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCd0by1udW1iZXIteCcpO1xuICpcbiAqIHRvTnVtYmVyKCcxJyk7IC8vIDFcbiAqIHRvTnVtYmVyKG51bGwpOyAvLyAwXG4gKiB0b051bWJlcih0cnVlKTsgLy8gMVxuICogdG9OdW1iZXIoJzBvMTAnKTsgLy8gOFxuICogdG9OdW1iZXIoJzBiMTAnKTsgLy8gMlxuICogdG9OdW1iZXIoJzB4RicpOyAvLyAxNlxuICpcbiAqIHRvTnVtYmVyKCcgMSAnKTsgLy8gMVxuICpcbiAqIHRvTnVtYmVyKFN5bWJvbCgnJykpIC8vIFR5cGVFcnJvclxuICogdG9OdW1iZXIoT2JqZWN0LmNyZWF0ZShudWxsKSkgLy8gVHlwZUVycm9yXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9OdW1iZXIoYXJndW1lbnQpIHtcbiAgdmFyIHZhbHVlID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIE51bWJlcik7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKCRwYXJzZUludChwU3RyU2xpY2UuY2FsbCh2YWx1ZSwgMiksIDIpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPY3RhbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b051bWJlcigkcGFyc2VJbnQocFN0clNsaWNlLmNhbGwodmFsdWUsIDIpLCA4KSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc05vbldTKHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5BTjtcbiAgICB9XG5cbiAgICB2YXIgdHJpbW1lZCA9IHRyaW0odmFsdWUpO1xuICAgIGlmICh0cmltbWVkICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHRyaW1tZWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYXN0TnVtYmVyKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENyb3NzLWJyb3dzZXIgYXJyYXkgc2xpY2VyLlxuICogQHZlcnNpb24gMy41LjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFycmF5LXNsaWNlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xudmFyIGFycmF5TGlrZVNsaWNlID0gcmVxdWlyZSgnYXJyYXktbGlrZS1zbGljZS14Jyk7XG52YXIgbmF0aXZlU2xpY2UgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNTdHJpbmc7XG52YXIgZmFpbEFycjtcbnZhciBmYWlsRE9NO1xuaWYgKG5hdGl2ZVNsaWNlKSB7XG4gIHZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gIHZhciByZXMgPSBhdHRlbXB0LmNhbGwoW1xuICAgIDEsXG4gICAgMixcbiAgICAzXG4gIF0sIG5hdGl2ZVNsaWNlLCAxLCAyKTtcblxuICBmYWlsQXJyID0gcmVzLnRocmV3IHx8IGlzQXJyYXkocmVzLnZhbHVlKSA9PT0gZmFsc2UgfHwgcmVzLnZhbHVlLmxlbmd0aCAhPT0gMSB8fCByZXMudmFsdWVbMF0gIT09IDI7XG4gIGlmIChmYWlsQXJyID09PSBmYWxzZSkge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCgnYWJjJywgbmF0aXZlU2xpY2UsIDEsIDIpO1xuICAgIGlzU3RyaW5nID0gKHJlcy50aHJldyB8fCByZXMudmFsdWUubGVuZ3RoICE9PSAxIHx8IHJlcy52YWx1ZVswXSAhPT0gJ2InKSAmJiByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBmYWlsRE9NID0gZG9jICYmIGF0dGVtcHQuY2FsbChkb2MuZG9jdW1lbnRFbGVtZW50LCBuYXRpdmVTbGljZSkudGhyZXc7XG4gIH1cbn0gZWxzZSB7XG4gIGZhaWxBcnIgPSB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBzbGljZSgpIG1ldGhvZCByZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhbiBhcnJheSBpbnRvIGEgbmV3XG4gKiBhcnJheSBvYmplY3Qgc2VsZWN0ZWQgZnJvbSBiZWdpbiB0byBlbmQgKGVuZCBub3QgaW5jbHVkZWQpLiBUaGUgb3JpZ2luYWxcbiAqIGFycmF5IHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcnJheSAtIFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdIC0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBiZWdpbiBleHRyYWN0aW9uLlxuICogIEEgbmVnYXRpdmUgaW5kZXggY2FuIGJlIHVzZWQsIGluZGljYXRpbmcgYW4gb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGVcbiAqICBzZXF1ZW5jZS4gc2xpY2UoLTIpIGV4dHJhY3RzIHRoZSBsYXN0IHR3byBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgYmVnaW4gaXMgdW5kZWZpbmVkLCBzbGljZSBiZWdpbnMgZnJvbSBpbmRleCAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gWmVyby1iYXNlZCBpbmRleCBiZWZvcmUgd2hpY2ggdG8gZW5kIGV4dHJhY3Rpb24uXG4gKiAgU2xpY2UgZXh0cmFjdHMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLiBGb3IgZXhhbXBsZSwgc2xpY2UoMSw0KVxuICogIGV4dHJhY3RzIHRoZSBzZWNvbmQgZWxlbWVudCB0aHJvdWdoIHRoZSBmb3VydGggZWxlbWVudCAoZWxlbWVudHMgaW5kZXhlZFxuICogIDEsIDIsIGFuZCAzKS5cbiAqICBBIG5lZ2F0aXZlIGluZGV4IGNhbiBiZSB1c2VkLCBpbmRpY2F0aW5nIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlXG4gKiAgc2VxdWVuY2UuIHNsaWNlKDIsLTEpIGV4dHJhY3RzIHRoZSB0aGlyZCBlbGVtZW50IHRocm91Z2ggdGhlIHNlY29uZC10by1sYXN0XG4gKiAgZWxlbWVudCBpbiB0aGUgc2VxdWVuY2UuXG4gKiAgSWYgZW5kIGlzIG9taXR0ZWQsIHNsaWNlIGV4dHJhY3RzIHRocm91Z2ggdGhlIGVuZCBvZiB0aGVcbiAqICBzZXF1ZW5jZSAoYXJyLmxlbmd0aCkuXG4gKiAgSWYgZW5kIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSwgc2xpY2UgZXh0cmFjdHMgdGhyb3VnaFxuICogIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlIChhcnIubGVuZ3RoKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgZXh0cmFjdGVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqIHZhciBzbGljZSA9IHJlcXVpcmUoJ2FycmF5LXNsaWNlLXgnKTtcbiAqIHZhciBmcnVpdHMgPSBbJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGVtb24nLCAnQXBwbGUnLCAnTWFuZ28nXTtcbiAqIHZhciBjaXRydXMgPSBzbGljZShmcnVpdHMsIDEsIDMpO1xuICpcbiAqIC8vIGZydWl0cyBjb250YWlucyBbJ0JhbmFuYScsICdPcmFuZ2UnLCAnTGVtb24nLCAnQXBwbGUnLCAnTWFuZ28nXVxuICogLy8gY2l0cnVzIGNvbnRhaW5zIFsnT3JhbmdlJywnTGVtb24nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gIGlmIChmYWlsQXJyIHx8IChmYWlsRE9NICYmIGlzQXJyYXkob2JqZWN0KSA9PT0gZmFsc2UpIHx8IChpc1N0cmluZyAmJiBpc1N0cmluZyhvYmplY3QpKSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKSB7XG4gICAgcmV0dXJuIGFycmF5TGlrZVNsaWNlKG9iamVjdCwgc3RhcnQsIGVuZCk7XG4gIH1cblxuICByZXR1cm4gbmF0aXZlU2xpY2UuYXBwbHkob2JqZWN0LCBhcnJheUxpa2VTbGljZShhcmd1bWVudHMsIDEpKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFRlc3RzIHdoZXRoZXIgc29tZSBlbGVtZW50IHBhc3NlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAxLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktc29tZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIGFzc2VydElzRnVuY3Rpb24gPSByZXF1aXJlKCdhc3NlcnQtaXMtZnVuY3Rpb24teCcpO1xuXG52YXIgdGVzdHMgPSB7XG4gIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gIHByb3Blcmx5Qm94ZXNOb25TdHJpY3Q6IHRydWUsXG4gIHByb3Blcmx5Qm94ZXNTdHJpY3Q6IHRydWVcbn07XG5cbnZhciBuYXRpdmVTb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG5pZiAobmF0aXZlU29tZSkge1xuICB0cnkge1xuICAgIG5hdGl2ZVNvbWUuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgIHRlc3RzLnByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgfSwgJ3gnKTtcblxuICAgIHZhciBmbiA9IFtcbiAgICAgICdyZXR1cm4gbmF0aXZlU29tZS5jYWxsKFwiZm9vXCIsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkgeycsXG4gICAgICAnaWYgKEJvb2xlYW4oY29udGV4dCkgPT09IGZhbHNlIHx8IHR5cGVvZiBjb250ZXh0ICE9PSBcIm9iamVjdFwiKSB7JyxcbiAgICAgICd0ZXN0cy5wcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7fX0pOydcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgRnVuY3Rpb24oJ25hdGl2ZVNvbWUnLCAndGVzdHMnLCBmbikobmF0aXZlU29tZSwgdGVzdHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmF0aXZlU29tZSA9IG51bGw7XG4gIH1cbn1cblxudmFyICRzb21lO1xuaWYgKG5hdGl2ZVNvbWUgJiYgdGVzdHMucHJvcGVybHlCb3hlc05vblN0cmljdCAmJiB0ZXN0cy5wcm9wZXJseUJveGVzU3RyaWN0KSB7XG4gICRzb21lID0gZnVuY3Rpb24gc29tZShhcnJheSwgY2FsbEJhY2sgLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICB2YXIgYXJncyA9IFthc3NlcnRJc0Z1bmN0aW9uKGNhbGxCYWNrKV07XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzWzJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlU29tZS5hcHBseShvYmplY3QsIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gRVM1IDE1LjQuNC4xN1xuICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTdcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxuICB2YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAgdmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG4gIHZhciBzcGxpdFN0cmluZyA9IHJlcXVpcmUoJ2hhcy1ib3hlZC1zdHJpbmcteCcpID09PSBmYWxzZTtcbiAgJHNvbWUgPSBmdW5jdGlvbiBzb21lKGFycmF5LCBjYWxsQmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsQmFjayk7XG4gICAgdmFyIGl0ZXJhYmxlID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcob2JqZWN0KSA/IG9iamVjdC5zcGxpdCgnJykgOiBvYmplY3Q7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7XG4gICAgdmFyIHRoaXNBcmc7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChpIGluIGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzQXJnKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxCYWNrKGl0ZXJhYmxlW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxCYWNrLmNhbGwodGhpc0FyZywgaXRlcmFibGVbaV0sIGksIG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGVzdHMgd2hldGhlciBzb21lIGVsZW1lbnQgaW4gdGhlIGFycmF5IHBhc3NlcyB0aGUgdGVzdFxuICogaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxCYWNrIC0gRnVuY3Rpb24gdG8gdGVzdCBmb3IgZWFjaCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3JcbiAqICBhbnkgYXJyYXkgZWxlbWVudDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBzb21lID0gcmVxdWlyZSgnYXJyYXktc29tZS14Jyk7XG4gKlxuICogZnVuY3Rpb24gaXNCaWdnZXJUaGFuMTAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gKiAgIHJldHVybiBlbGVtZW50ID4gMTA7XG4gKiB9XG4gKlxuICogc29tZShbMiwgNSwgOCwgMSwgNF0sIGlzQmlnZ2VyVGhhbjEwKTsgIC8vIGZhbHNlXG4gKiBzb21lKFsxMiwgNSwgOCwgMSwgNF0sIGlzQmlnZ2VyVGhhbjEwKTsgLy8gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRzb21lO1xuIiwiLyoqXG4gKiBAZmlsZSBJZiBpc0Z1bmN0aW9uKGNhbGxiYWNrZm4pIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXNzZXJ0LWlzLWZ1bmN0aW9uLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIHNhZmVUb1N0cmluZyA9IHJlcXVpcmUoJ3NhZmUtdG8tc3RyaW5nLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAqIFRlc3RzIGBjYWxsYmFja2AgdG8gc2VlIGlmIGl0IGlzIGEgZnVuY3Rpb24sIHRocm93cyBhIGBUeXBlRXJyb3JgIGlmIGl0IGlzXG4gKiBub3QuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBgY2FsbGJhY2tgLlxuICpcbiAqIEBwYXJhbSB7Kn0gY2FsbGJhY2sgLSBUaGUgYXJndW1lbnQgdG8gYmUgdGVzdGVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBUaHJvd3MgaWYgYGNhbGxiYWNrYCBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGBjYWxsYmFja2AgaWYgaXQgaXMgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGFzc2VydElzRnVuY3Rpb24gPSByZXF1aXJlKCdhc3NlcnQtaXMtZnVuY3Rpb24teCcpO1xuICogdmFyIHByaW1pdGl2ZSA9IHRydWU7XG4gKiB2YXIgbXlTeW1ib2wgPSBTeW1ib2woJ215U3ltYm9sJyk7XG4gKiB2YXIgc3ltT2JqID0gT2JqZWN0KG15U3ltYm9sKTtcbiAqIHZhciBvYmplY3QgPSB7fTtcbiAqIGZ1bmN0aW9uIGZuICgpIHt9XG4gKlxuICogYXNzZXJ0SXNGdW5jdGlvbihwcmltaXRpdmUpO1xuICogICAgLy8gVHlwZUVycm9yICd0cnVlIGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24ob2JqZWN0KTtcbiAqICAgIC8vIFR5cGVFcnJvciAnIzxPYmplY3Q+IGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24obXlTeW1ib2wpO1xuICogICAgLy8gVHlwZUVycm9yICdTeW1ib2wobXlTeW1ib2wpIGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24oc3ltT2JqKTtcbiAqICAgIC8vIFR5cGVFcnJvciAnIzxPYmplY3Q+IGlzIG5vdCBhIGZ1bmN0aW9uJy5cbiAqIGFzc2VydElzRnVuY3Rpb24oZm4pO1xuICogICAgLy8gUmV0dXJucyBmbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgbXNnID0gaXNQcmltaXRpdmUoY2FsbGJhY2spID8gc2FmZVRvU3RyaW5nKGNhbGxiYWNrKSA6ICcjPE9iamVjdD4nO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBjYWxsYmFjaztcbn07XG4iLCIvKipcbiAqIEBmaWxlIElmIElzT2JqZWN0KHZhbHVlKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICogQHZlcnNpb24gMS4zLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFzc2VydC1pcy1vYmplY3QteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHNhZmVUb1N0cmluZyA9IHJlcXVpcmUoJ3NhZmUtdG8tc3RyaW5nLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAgICogVGVzdHMgYHZhbHVlYCB0byBzZWUgaWYgaXQgaXMgYW4gb2JqZWN0LCB0aHJvd3MgYSBgVHlwZUVycm9yYCBpZiBpdCBpc1xuICAgKiBub3QuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIGFyZ3VtZW50IHRvIGJlIHRlc3RlZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBUaHJvd3MgaWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgIGlmIGl0IGlzIGFuIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGFzc2VydElzT2JqZWN0ID0gcmVxdWlyZSgnYXNzZXJ0LWlzLW9iamVjdC14Jyk7XG4gICAqIHZhciBwcmltaXRpdmUgPSB0cnVlO1xuICAgKiB2YXIgbXlTeW1ib2wgPSBTeW1ib2woJ215U3ltYm9sJyk7XG4gICAqIHZhciBzeW1PYmogPSBPYmplY3QobXlTeW1ib2wpO1xuICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAqIGZ1bmN0aW9uIGZuICgpIHt9XG4gICAqXG4gICAqIGFzc2VydElzT2JqZWN0KHByaW1pdGl2ZSk7IC8vIFR5cGVFcnJvciAndHJ1ZSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChteVN5bWJvbCk7IC8vIFR5cGVFcnJvciAnU3ltYm9sKG15U3ltYm9sKSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChzeW1PYmopOyAvLyBSZXR1cm5zIHN5bU9iai5cbiAgICogYXNzZXJ0SXNPYmplY3Qob2JqZWN0KTsgLy8gUmV0dXJucyBvYmplY3QuXG4gICAqIGFzc2VydElzT2JqZWN0KGZuKTsgLy8gUmV0dXJucyBmbi5cbiAgICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2VydElzT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBJbnZva2VzIGZ1bmN0aW9uLCByZXR1cm5pbmcgYW4gb2JqZWN0IG9mIHRoZSByZXN1bHRzLlxuICogQHZlcnNpb24gMS4xLjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGF0dGVtcHQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEFyZ3MgPSBmdW5jdGlvbiBfZ2V0QXJncyhhcmdzKSB7XG4gIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aCA+Pj4gMDtcbiAgdmFyIGFycmF5ID0gW107XG4gIHZhciBhcmdMZW5ndGggPSBsZW5ndGggLSAxO1xuICBpZiAoYXJnTGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIGFycmF5Lmxlbmd0aCA9IGFyZ0xlbmd0aDtcbiAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFycmF5W2luZGV4IC0gMV0gPSBhcmdzW2luZGV4XTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yXG4gKiB0aGUgY2F1Z2h0IGVycm9yIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGVcbiAqIGZ1bmN0aW9uIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgb2YgdGhlIHJlc3VsdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICpcbiAqIGZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gKiAgIHRocm93IG5ldyBFcnJvcignVGhyZXcnKTtcbiAqIH1cbiAqXG4gKiBhdHRlbXB0KHRocm93ZXIsIDEsIDIpO1xuICogLy8ge1xuICogLy8gICB0aHJldzogdHJ1ZSxcbiAqIC8vICAgdmFsdWU6IC8vIEVycm9yKCdUaHJldycpIG9iamVjdFxuICogLy8gfVxuICpcbiAqIGZ1bmN0aW9uIHN1bUFyZ3MoYSwgYikge1xuICogICByZXR1cm4gYSArIGI7XG4gKiB9XG4gKlxuICogYXR0ZW1wdChzdW1BcmdzLCAxLCAyKTtcbiAqIC8vIHtcbiAqIC8vICAgdGhyZXc6IGZhbHNlLFxuICogLy8gICB2YWx1ZTogM1xuICogLy8gfVxuICpcbiAqIHZhciB0aGlzQXJnID0gW107XG4gKiBmdW5jdGlvbiBwdXNoZXIoYSwgYikge1xuICogICByZXR1cm4gdGhpcy5wdXNoKGEsIGIpO1xuICogfVxuICpcbiAqIGF0dGVtcHQuY2FsbCh0aGlzQXJnLCBwdXNoZXIsIDEsIDIpO1xuICogLy8ge1xuICogLy8gICB0aHJldzogZmFsc2UsXG4gKiAvLyAgIHZhbHVlOiAyXG4gKiAvLyB9XG4gKiAvLyB0aGlzQXJnID0+IFsxLCAyXTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdHRlbXB0KGZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmV3OiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmbi5hcHBseSh0aGlzLCBnZXRBcmdzKGFyZ3VtZW50cykpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0aHJldzogdHJ1ZSxcbiAgICAgIHZhbHVlOiBlXG4gICAgfTtcbiAgfVxufTtcbiIsIi8qKlxuKiBAZmlsZSBBIGJpZyBjb3VudGVyLlxuKiBAdmVyc2lvbiAyLjAuMVxuKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4qIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4qIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiogQG1vZHVsZSBiaWctY291bnRlci14XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLXgnKTtcblxuLyoqXG4gKiBTZXJpYWxpc2UgdGhlIGNvdW50ZXLCtHMgY3VycmVudCB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMgQmlnQ291bnRlclxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxuICovXG52YXIgY291bnRlclRvU3RyaW5nID0gZnVuY3Rpb24gVG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLmNvdW50LnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBUaGUgQmlnQ291bnRlciBjbGFzcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNsYXNzXG4gKi9cbnZhciBCaWdDID0gZnVuY3Rpb24gQmlnQ291bnRlcigpIHtcbiAgaWYgKEJvb2xlYW4odGhpcykgPT09IGZhbHNlIHx8ICh0aGlzIGluc3RhbmNlb2YgQmlnQykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdDKCk7XG4gIH1cblxuICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBjb3VudDoge1xuICAgICAgdmFsdWU6IFswXVxuICAgIH1cbiAgfSk7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEJpZ0MucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb3VudGVywrRzIGN1cnJlbnQgdmFsdWUuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgZ2V0OiB7XG4gICAgdmFsdWU6IGNvdW50ZXJUb1N0cmluZ1xuICB9LFxuICAvKipcbiAgICogSW5jcmVtZW50cyB0aGUgY291bnRlcsK0cyB2YWx1ZSBieSBgMWAuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY291bnRlciBvYmplY3QuXG4gICAqL1xuICBuZXh0OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgY2xvbmUgPSB0aGlzLmNvdW50LnNsaWNlKCk7XG4gICAgICB0aGlzLmNvdW50Lmxlbmd0aCA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gY2xvbmUubGVuZ3RoO1xuICAgICAgdmFyIGhvd01hbnkgPSBNYXRoLm1heChsZW5ndGgsIDEpO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAoaW5kZXggPCBob3dNYW55IHx8IGNhcnJ5KSB7XG4gICAgICAgIHZhciB6aSA9IGNhcnJ5ICsgKGluZGV4IDwgbGVuZ3RoID8gY2xvbmVbaW5kZXhdIDogMCkgKyAoaW5kZXggPT09IDAgPyAxIDogMCk7XG4gICAgICAgIHRoaXMuY291bnQucHVzaCh6aSAlIDEwKTtcbiAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKHppIC8gMTApO1xuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGNvdW50ZXIgYmFjayB0byBgMGAuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY291bnRlciBvYmplY3QuXG4gICAqL1xuICByZXNldDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuY291bnQubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuY291bnQucHVzaCgwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvdW50ZXLCtHMgY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIuXG4gICAqL1xuICB0b0pTT046IHtcbiAgICB2YWx1ZTogY291bnRlclRvU3RyaW5nXG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb3VudGVywrRzIGN1cnJlbnQgdmFsdWUuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgdG9TdHJpbmc6IHtcbiAgICB2YWx1ZTogY291bnRlclRvU3RyaW5nXG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb3VudGVywrRzIGN1cnJlbnQgdmFsdWUuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgdmFsdWVPZjoge1xuICAgIHZhbHVlOiBjb3VudGVyVG9TdHJpbmdcbiAgfVxufSk7XG5cbi8qKlxuICogSW5jcmVtZW50YWwgaW50ZWdlciBjb3VudGVyLiBDb3VudHMgZnJvbSBgMGAgdG8gdmVyeSBiaWcgaW50ZXJnZXJzLlxuICogSmF2YXNjcmlwdMK0cyBudW1iZXIgdHlwZSBhbGxvd3MgeW91IHRvIGNvdW50IGluIGludGVnZXIgc3RlcHNcbiAqIGZyb20gYDBgIHRvIGA5MDA3MTk5MjU0NzQwOTkxYC4gQXMgb2YgRVM1LCBTdHJpbmdzIGNhbiBjb250YWluXG4gKiBhcHByb3hpbWF0ZWx5IDY1MDAwIGNoYXJhY3RlcnMgYW5kIEVTNiBpcyBzdXBwb3NlZCB0byBoYW5kbGVcbiAqIHRoZSBgTUFYX1NBRkVfSU5URUdFUmAgKHRob3VnaCBJIGRvbsK0dCBiZWxpZXZlIGFueSBlbnZpcm9ubWVudHMgc3VwcG9ydHNcbiAqIHRoaXMpLiBUaGlzIGNvdW50ZXIgcmVwcmVzZW50cyBpbnRlZ2VyIHZhbHVlcyBhcyBzdHJpbmdzIGFuZCBjYW4gdGhlcmVmb3JlXG4gKiBjb3VudCBpbiBpbnRlZ2VyIHN0ZXBzIGZyb20gYDBgIHRvIHRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGggKHRoYXTCtHMgc29tZVxuICogNjUwMDAgZGlnaXRzKS4gSW4gdGhlIGxvd2VyIHJhbmdlLCB1cHRvIGA5MDA3MTk5MjU0NzQwOTkxYCwgdGhlIHN0cmluZ3MgY2FuXG4gKiBiZSBjb252ZXJ0ZWQgdG8gc2FmZSBKYXZhc2NyaXB0IGludGVnZXJzIGBOdW1iZXIodmFsdWUpYCBvciBgK3ZhbHVlYC4gVGhpc1xuICogY291bnRlciBpcyBncmVhdCBmb3IgYW55IGFwcGxpY2F0aW9ucyB0aGF0IG5lZWQgYSByZWFsbHkgYmlnIGNvdW50XG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZywgKGFuIElEIHN0cmluZykuXG4gKlxuICogQGNsYXNzXG4gKiBAZXhhbXBsZVxuICogdmFyIEJpZ0NvdW50ZXIgPSByZXF1aXJlKCdiaWctY291bnRlci14Jyk7XG4gKiB2YXIgY291bnRlciA9IG5ldyBCaWdDb3VudGVyKCk7XG4gKlxuICogY291bnRlci5nZXQoKTsgLy8gJzAnXG4gKiBjb3VudGVyLm5leHQoKTsgLy8gY291bnRlciBvYmplY3RcbiAqIGNvdW50ZXIuZ2V0KCk7IC8vICcxJ1xuICpcbiAqIC8vIE1ldGhvZHMgYXJlIGNoYWluYWJsZS5cbiAqIGNvdW50ZXIubmV4dCgpLm5leHQoKTsgLy8gY291bnRlciBvYmplY3RcbiAqIGNvdW50ZXIuZ2V0KCk7IC8vICczJ1xuICpcbiAqIGNvdW50ZXIucmVzZXQoKTsgLy8gY291bnRlciBvYmplY3RcbiAqIGNvdW50ZXIuZ2V0KCk7IC8vICcwJ1xuICogY291bnRlci50b1N0cmluZygpOyAvLyAnMCdcbiAqIGNvdW50ZXIudmFsdWVPZigpOyAvLyAnMCdcbiAqIGNvdW50ZXIudG9KU09OKCk7IC8vICcwJ1xuICpcbiAqIC8vIFZhbHVlcyB1cHRvIGA5MDA3MTk5MjU0NzQwOTkxYCBjb252ZXJ0IHRvIG51bWJlcnMuXG4gKiBOdW1iZXIoY291bnRlcik7IC8vIDBcbiAqICtjb3VudGVyOyAvLyAwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmlnQztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJvb2xlYW4gPSBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICgvXih0cnVlfHR8eWVzfHl8MSkkL2kudGVzdCh2YWx1ZS50cmltKCkpXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSAwO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBib29sZWFuOyIsIi8qKlxuICogQGZpbGUgQ29uc3RydWN0b3JzIGNhY2hlZCBmcm9tIGxpdGVyYWxzLlxuICogQHZlcnNpb24gMS4wLjJcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGNhY2hlZC1jb25zdHJ1Y3RvcnMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvcnMgY2FjaGVkIGZyb20gbGl0ZXJhbHMuXG4gKlxuICogQHR5cGUgT2JqZWN0XG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnN0cnVjdG9ycyA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQXJyYXk6IFtdLmNvbnN0cnVjdG9yLFxuICBCb29sZWFuOiB0cnVlLmNvbnN0cnVjdG9yLFxuICBGdW5jdGlvbjogZnVuY3Rpb24gKCkge30uY29uc3RydWN0b3IsXG4gIE51bWJlcjogKDApLmNvbnN0cnVjdG9yLFxuICBPYmplY3Q6IHt9LmNvbnN0cnVjdG9yLFxuICBSZWdFeHA6ICgvKD86KS8pLmNvbnN0cnVjdG9yLFxuICBTdHJpbmc6ICcnLmNvbnN0cnVjdG9yXG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDYWxjdWxhdGVzIGEgZnJvbUluZGV4IG9mIGEgZ2l2ZW4gdmFsdWUgZm9yIGFuIGFycmF5LlxuICogQHZlcnNpb24gMS4wLjJcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGNhbGN1bGF0ZS1mcm9tLWluZGV4LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpO1xudmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnaXMtYXJyYXktbGlrZS14Jyk7XG5cbnZhciAkY2FsY0Zyb21JbmRleCA9IGZ1bmN0aW9uIGNhbGNGcm9tSW5kZXgoYXJyYXksIGZyb21JbmRleCkge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICBpZiAoaXNBcnJheUxpa2Uob2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChvYmplY3QubGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIHJldHVybiBpbmRleCA+PSAwID8gaW5kZXggOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpbmRleCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgYSBmcm9tSW5kZXggb2YgYSBnaXZlbiB2YWx1ZSBmb3IgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgVGhlIGFycmF5IG9uIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgc3RhcnRpbmcgaW5kZXguXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFycmF5IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgcG9zaXRpb24gaW4gdGhpcyBhcnJheSBhdCB3aGljaCB0byBiZWdpbi4gQVxuICogIG5lZ2F0aXZlIHZhbHVlIGdpdmVzIHRoZSBpbmRleCBvZiBhcnJheS5sZW5ndGggKyBmcm9tSW5kZXggYnkgYXNjLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBmcm9tSW5kZXguIERlZmF1bHQgaXMgMC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgY2FsY0Zyb21JbmRleCA9IHJlcXVpcmUoJ2NhbGN1bGF0ZS1mcm9tLWluZGV4LXgnKTtcbiAqXG4gKiBjYWxjRnJvbUluZGV4KFsxLCAyLCAzXSwgMSk7IC8vIDFcbiAqIGNhbGNGcm9tSW5kZXgoWzEsIDIsIDNdLCBJbmZpbml0eSk7IC8vIEluZmluaXR5XG4gKiBjYWxjRnJvbUluZGV4KFsxLCAyLCAzXSwgLUluZmluaXR5KTsgLy8gMFxuICogY2FsY0Zyb21JbmRleChbMSwgMiwgM10sIC0xKTsgLy8gMlxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRjYWxjRnJvbUluZGV4O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYgY29sbGVjdGlvbnMgZmFsbGJhY2sgbGlicmFyeTogTWFwIGFuZCBTZXQuXG4gKiBAdmVyc2lvbiAyLjAuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgY29sbGVjdGlvbnMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbi14Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdvYmplY3QtZGVmaW5lLXByb3BlcnR5LXgnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLXgnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJ2lzLXN0cmluZycpO1xudmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnaXMtYXJyYXktbGlrZS14Jyk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCdpcy1wcmltaXRpdmUnKTtcbnZhciBpc1N1cnJvZ2F0ZVBhaXIgPSByZXF1aXJlKCdpcy1zdXJyb2dhdGUtcGFpci14Jyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4LW9mLXgnKTtcbnZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcbnZhciBhc3NlcnRJc09iamVjdCA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1vYmplY3QteCcpO1xudmFyIElkR2VuZXJhdG9yID0gcmVxdWlyZSgnYmlnLWNvdW50ZXIteCcpO1xudmFyIGlzTmlsID0gcmVxdWlyZSgnaXMtbmlsLXgnKTtcbnZhciBpc01hcCA9IHJlcXVpcmUoJ2lzLW1hcC14Jyk7XG52YXIgaXNTZXQgPSByZXF1aXJlKCdpcy1zZXQteCcpO1xudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoJ2lzLWJvb2xlYW4tb2JqZWN0Jyk7XG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCd2YWxpZGF0ZS5pby11bmRlZmluZWQnKTtcbnZhciBzb21lID0gcmVxdWlyZSgnYXJyYXktc29tZS14Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdnZXQtcHJvdG90eXBlLW9mLXgnKTtcbnZhciBoYXNTeW1ib2xTdXBwb3J0ID0gcmVxdWlyZSgnaGFzLXN5bWJvbC1zdXBwb3J0LXgnKTtcbnZhciBoYXNSZWFsU3ltYm9sSXRlcmF0b3IgPSBoYXNTeW1ib2xTdXBwb3J0ICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnO1xudmFyIGhhc0Zha2VTeW1ib2xJdGVyYXRvciA9IHR5cGVvZiBTeW1ib2wgPT09ICdvYmplY3QnICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzdHJpbmcnO1xudmFyIHN5bUl0O1xuXG5pZiAoaGFzUmVhbFN5bWJvbEl0ZXJhdG9yIHx8IGhhc0Zha2VTeW1ib2xJdGVyYXRvcikge1xuICBzeW1JdCA9IFN5bWJvbC5pdGVyYXRvcjtcbn0gZWxzZSBpZiAoaXNGdW5jdGlvbihBcnJheS5wcm90b3R5cGVbJ19lczYtc2hpbSBpdGVyYXRvcl8nXSkpIHtcbiAgc3ltSXQgPSAnX2VzNi1zaGltIGl0ZXJhdG9yXyc7XG59IGVsc2Uge1xuICBzeW1JdCA9ICdAQGl0ZXJhdG9yJztcbn1cblxudmFyIGlzTnVtYmVyVHlwZSA9IGZ1bmN0aW9uIF9pc051bWJlclR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG59O1xuXG4vKipcbiAqIERldGVjdCBhbiBpbnRlcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gaXRlcmFibGUgLSBWYWx1ZSB0byBkZXRlY3QgaXRlcmF0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3ltYm9sfHN0cmluZ3x1bmRlZmluZWR9IFRoZSBpdGVyYXRvciBwcm9wZXJ0eSBpZGVudGlmaWVyLlxuICovXG52YXIgZ2V0U3ltYm9sSXRlcmF0b3IgPSBmdW5jdGlvbiBfZ2V0U3ltYm9sSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgaWYgKGlzTmlsKGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICBpZiAoKGhhc1JlYWxTeW1ib2xJdGVyYXRvciB8fCBoYXNGYWtlU3ltYm9sSXRlcmF0b3IpICYmIGl0ZXJhYmxlW3N5bUl0XSkge1xuICAgICAgcmV0dXJuIHN5bUl0O1xuICAgIH1cblxuICAgIGlmIChpdGVyYWJsZVsnX2VzNi1zaGltIGl0ZXJhdG9yXyddKSB7XG4gICAgICByZXR1cm4gJ19lczYtc2hpbSBpdGVyYXRvcl8nO1xuICAgIH1cblxuICAgIGlmIChpdGVyYWJsZVsnQEBpdGVyYXRvciddKSB7XG4gICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2b2lkIDA7XG59O1xuXG4vKipcbiAqIElmIGFuIGl0ZXJhYmxlIG9iamVjdCBpcyBwYXNzZWQsIGFsbCBvZiBpdHMgZWxlbWVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAqIG5ldyBNYXAvU2V0LCBudWxsIGlzIHRyZWF0ZWQgYXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCAtIEVpdGhlciAnbWFwJyBvciAnc2V0Jy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBpdGVyYWJsZSAtIFZhbHVlIHRvIHBhcnNlZC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbnZhciBwYXJzZUl0ZXJhYmxlID0gZnVuY3Rpb24gX3BhcnNlSXRlcmFibGUoa2luZCwgY29udGV4dCwgaXRlcmFibGUpIHtcbiAgdmFyIHN5bWJvbEl0ZXJhdG9yID0gZ2V0U3ltYm9sSXRlcmF0b3IoaXRlcmFibGUpO1xuICBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShjb250ZXh0LCAnW1t2YWx1ZV1dJywge1xuICAgICAgdmFsdWU6IFtdXG4gICAgfSk7XG4gIH1cblxuICBkZWZpbmVQcm9wZXJ0aWVzKGNvbnRleHQsIHtcbiAgICAnW1tjaGFuZ2VkXV0nOiB7XG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuICAgICdbW2lkXV0nOiB7XG4gICAgICB2YWx1ZTogbmV3IElkR2VuZXJhdG9yKClcbiAgICB9LFxuICAgICdbW2tleV1dJzoge1xuICAgICAgdmFsdWU6IFtdXG4gICAgfSxcbiAgICAnW1tvcmRlcl1dJzoge1xuICAgICAgdmFsdWU6IFtdXG4gICAgfVxuICB9KTtcblxuICB2YXIgbmV4dDtcbiAgdmFyIGtleTtcbiAgdmFyIGluZGV4b2Y7XG4gIGlmIChpdGVyYWJsZSAmJiBpc0Z1bmN0aW9uKGl0ZXJhYmxlW3N5bWJvbEl0ZXJhdG9yXSkpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZVtzeW1ib2xJdGVyYXRvcl0oKTtcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKG5leHQudmFsdWUpID09PSBmYWxzZSB8fCBuZXh0LnZhbHVlLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnSXRlcmF0b3IgdmFsdWUgJyArIGlzQXJyYXlMaWtlKG5leHQudmFsdWUpICsgJyBpcyBub3QgYW4gZW50cnkgb2JqZWN0J1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChuZXh0LmRvbmUgPT09IGZhbHNlKSB7XG4gICAgICBrZXkgPSBraW5kID09PSAnbWFwJyA/IG5leHQudmFsdWVbMF0gOiBuZXh0LnZhbHVlO1xuICAgICAgaW5kZXhvZiA9IGluZGV4T2YoXG4gICAgICAgIGFzc2VydElzT2JqZWN0KGNvbnRleHQpWydbW2tleV1dJ10sXG4gICAgICAgIGtleSxcbiAgICAgICAgJ1NhbWVWYWx1ZVplcm8nXG4gICAgICApO1xuXG4gICAgICBpZiAoaW5kZXhvZiA8IDApIHtcbiAgICAgICAgaWYgKGtpbmQgPT09ICdtYXAnKSB7XG4gICAgICAgICAgY29udGV4dFsnW1t2YWx1ZV1dJ10ucHVzaChuZXh0LnZhbHVlWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHRbJ1tba2V5XV0nXS5wdXNoKGtleSk7XG4gICAgICAgIGNvbnRleHRbJ1tbb3JkZXJdXSddLnB1c2goY29udGV4dFsnW1tpZF1dJ10uZ2V0KCkpO1xuICAgICAgICBjb250ZXh0WydbW2lkXV0nXS5uZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdtYXAnKSB7XG4gICAgICAgIGNvbnRleHRbJ1tbdmFsdWVdXSddW2luZGV4b2ZdID0gbmV4dC52YWx1ZVsxXTtcbiAgICAgIH1cblxuICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNTdHJpbmcoaXRlcmFibGUpKSB7XG4gICAgaWYgKGtpbmQgPT09ICdtYXAnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnSXRlcmF0b3IgdmFsdWUgJyArIGl0ZXJhYmxlLmNoYXJBdCgwKSArICcgaXMgbm90IGFuIGVudHJ5IG9iamVjdCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbmV4dCA9IDA7XG4gICAgd2hpbGUgKG5leHQgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGFyMSA9IGl0ZXJhYmxlLmNoYXJBdChuZXh0KTtcbiAgICAgIHZhciBjaGFyMiA9IGl0ZXJhYmxlLmNoYXJBdChuZXh0ICsgMSk7XG4gICAgICBpZiAoaXNTdXJyb2dhdGVQYWlyKGNoYXIxLCBjaGFyMikpIHtcbiAgICAgICAga2V5ID0gY2hhcjEgKyBjaGFyMjtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gY2hhcjE7XG4gICAgICB9XG5cbiAgICAgIGluZGV4b2YgPSBpbmRleE9mKFxuICAgICAgICBhc3NlcnRJc09iamVjdChjb250ZXh0KVsnW1trZXldXSddLFxuICAgICAgICBrZXksXG4gICAgICAgICdTYW1lVmFsdWVaZXJvJ1xuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4b2YgPCAwKSB7XG4gICAgICAgIGNvbnRleHRbJ1tba2V5XV0nXS5wdXNoKGtleSk7XG4gICAgICAgIGNvbnRleHRbJ1tbb3JkZXJdXSddLnB1c2goY29udGV4dFsnW1tpZF1dJ10uZ2V0KCkpO1xuICAgICAgICBjb250ZXh0WydbW2lkXV0nXS5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gMTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UoaXRlcmFibGUpKSB7XG4gICAgbmV4dCA9IDA7XG4gICAgd2hpbGUgKG5leHQgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgICBpZiAoaXNQcmltaXRpdmUoaXRlcmFibGVbbmV4dF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJdGVyYXRvciB2YWx1ZSAnICsgaXNBcnJheUxpa2UobmV4dC52YWx1ZSkgKyAnIGlzIG5vdCBhbiBlbnRyeSBvYmplY3QnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGl0ZXJhYmxlW25leHRdWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gaXRlcmFibGVbbmV4dF07XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGtpbmQgPT09ICdtYXAnID8gaXRlcmFibGVbbmV4dF1bMF0gOiBpdGVyYWJsZVtuZXh0XTtcbiAgICAgIGluZGV4b2YgPSBpbmRleE9mKFxuICAgICAgICBhc3NlcnRJc09iamVjdChjb250ZXh0KVsnW1trZXldXSddLFxuICAgICAgICBrZXksXG4gICAgICAgICdTYW1lVmFsdWVaZXJvJ1xuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4b2YgPCAwKSB7XG4gICAgICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgICAgIGNvbnRleHRbJ1tbdmFsdWVdXSddLnB1c2goaXRlcmFibGVbbmV4dF1bMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dFsnW1trZXldXSddLnB1c2goa2V5KTtcbiAgICAgICAgY29udGV4dFsnW1tvcmRlcl1dJ10ucHVzaChjb250ZXh0WydbW2lkXV0nXS5nZXQoKSk7XG4gICAgICAgIGNvbnRleHRbJ1tbaWRdXSddLm5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICAgICAgY29udGV4dFsnW1t2YWx1ZV1dJ11baW5kZXhvZl0gPSBpdGVyYWJsZVtuZXh0XVsxXTtcbiAgICAgIH1cblxuICAgICAgbmV4dCArPSAxO1xuICAgIH1cbiAgfVxuXG4gIGRlZmluZVByb3BlcnR5KGNvbnRleHQsICdzaXplJywge1xuICAgIHZhbHVlOiBjb250ZXh0WydbW2tleV1dJ10ubGVuZ3RoLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGUgYmFzZSBmb3JFYWNoIG1ldGhvZCBleGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2ggdmFsdWVcbiAqIGluIHRoZSBNYXAvU2V0IG9iamVjdCwgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCAtIEVpdGhlciAnbWFwJyBvciAnc2V0Jy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSAtIFZhbHVlIHRvIHVzZSBhcyB0aGlzIHdoZW4gZXhlY3V0aW5nIGNhbGxiYWNrLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGJhc2VGb3JFYWNoID0gZnVuY3Rpb24gX2Jhc2VGb3JFYWNoKGtpbmQsIGNvbnRleHQsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIGFzc2VydElzT2JqZWN0KGNvbnRleHQpO1xuICBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxiYWNrKTtcbiAgdmFyIHBvaW50ZXJzID0ge1xuICAgIGluZGV4OiAwLFxuICAgIG9yZGVyOiBjb250ZXh0WydbW29yZGVyXV0nXVswXVxuICB9O1xuXG4gIGNvbnRleHRbJ1tbY2hhbmdlXV0nXSA9IGZhbHNlO1xuICB2YXIgbGVuZ3RoID0gY29udGV4dFsnW1trZXldXSddLmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXJzLmluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGhhc093bihjb250ZXh0WydbW2tleV1dJ10sIHBvaW50ZXJzLmluZGV4KSkge1xuICAgICAgdmFyIGtleSA9IGNvbnRleHRbJ1tba2V5XV0nXVtwb2ludGVycy5pbmRleF07XG4gICAgICB2YXIgdmFsdWUgPSBraW5kID09PSAnbWFwJyA/IGNvbnRleHRbJ1tbdmFsdWVdXSddW3BvaW50ZXJzLmluZGV4XSA6IGtleTtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHRbJ1tbY2hhbmdlXV0nXSkge1xuICAgICAgbGVuZ3RoID0gY29udGV4dFsnW1trZXldXSddLmxlbmd0aDtcbiAgICAgIHNvbWUoY29udGV4dFsnW1tvcmRlcl1dJ10sIGZ1bmN0aW9uIF9zb21lMShpZCwgY291bnQpIHtcbiAgICAgICAgcG9pbnRlcnMuaW5kZXggPSBjb3VudDtcbiAgICAgICAgcmV0dXJuIGlkID4gcG9pbnRlcnMub3JkZXI7XG4gICAgICB9KTtcblxuICAgICAgY29udGV4dFsnW1tjaGFuZ2VdXSddID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJzLmluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgcG9pbnRlcnMub3JkZXIgPSBjb250ZXh0WydbW29yZGVyXV0nXVtwb2ludGVycy5pbmRleF07XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogVGhlIGJhc2UgaGFzIG1ldGhvZCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoXG4gKiB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBleGlzdHMgaW4gYSBNYXAvU2V0IG9iamVjdCBvciBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleS92YWx1ZSB0byB0ZXN0IGZvciBwcmVzZW5jZSBpbiB0aGUgTWFwL1NldCBvYmplY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZVxuICogIGV4aXN0cyBpbiB0aGUgTWFwL1NldCBvYmplY3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAqL1xudmFyIGJhc2VIYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgcmV0dXJuIGluZGV4T2YoYXNzZXJ0SXNPYmplY3QodGhpcylbJ1tba2V5XV0nXSwga2V5LCAnU2FtZVZhbHVlWmVybycpID4gLTE7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsZWFyIG1ldGhvZCByZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGEgTWFwL1NldCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kIC0gRWl0aGVyICdtYXAnIG9yICdzZXQnLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBUaGUgTWFwL1NldCBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgTWFwL1NldCBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ2xlYXIgPSBmdW5jdGlvbiBfYmFzZUNsZWFyKGtpbmQsIGNvbnRleHQpIHtcbiAgYXNzZXJ0SXNPYmplY3QoY29udGV4dCk7XG4gIGNvbnRleHRbJ1tbaWRdXSddLnJlc2V0KCk7XG4gIGNvbnRleHRbJ1tbY2hhbmdlXV0nXSA9IHRydWU7XG4gIGNvbnRleHQuc2l6ZSA9IDA7XG4gIGNvbnRleHRbJ1tbb3JkZXJdXSddLmxlbmd0aCA9IDA7XG4gIGNvbnRleHRbJ1tba2V5XV0nXS5sZW5ndGggPSAwO1xuICBpZiAoa2luZCA9PT0gJ21hcCcpIHtcbiAgICBjb250ZXh0WydbW3ZhbHVlXV0nXS5sZW5ndGggPSAwO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGRlbGV0ZSBtZXRob2QgcmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSBhIE1hcC9TZXQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCAtIEVpdGhlciAnbWFwJyBvciAnc2V0Jy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgLSBUaGUga2V5L3ZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZSBmcm9tIE1hcC9TZXQgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIE1hcC9TZXQgb2JqZWN0LlxuICovXG52YXIgYmFzZURlbGV0ZSA9IGZ1bmN0aW9uIF9iYXNlRGVsZXRlKGtpbmQsIGNvbnRleHQsIGtleSkge1xuICB2YXIgaW5kZXhvZiA9IGluZGV4T2YoXG4gICAgYXNzZXJ0SXNPYmplY3QoY29udGV4dClbJ1tba2V5XV0nXSxcbiAgICBrZXksXG4gICAgJ1NhbWVWYWx1ZVplcm8nXG4gICk7XG5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAoaW5kZXhvZiA+IC0xKSB7XG4gICAgaWYgKGtpbmQgPT09ICdtYXAnKSB7XG4gICAgICBjb250ZXh0WydbW3ZhbHVlXV0nXS5zcGxpY2UoaW5kZXhvZiwgMSk7XG4gICAgfVxuXG4gICAgY29udGV4dFsnW1trZXldXSddLnNwbGljZShpbmRleG9mLCAxKTtcbiAgICBjb250ZXh0WydbW29yZGVyXV0nXS5zcGxpY2UoaW5kZXhvZiwgMSk7XG4gICAgY29udGV4dFsnW1tjaGFuZ2VdXSddID0gdHJ1ZTtcbiAgICBjb250ZXh0LnNpemUgPSBjb250ZXh0WydbW2tleV1dJ10ubGVuZ3RoO1xuICAgIHJlc3VsdCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUaGUgYmFzZSBzZXQgYW5kIGFkZCBtZXRob2QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kIC0gRWl0aGVyICdtYXAnIG9yICdzZXQnLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBUaGUgTWFwL1NldCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGtleSAtIFRoZSBrZXkgb3IgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkL3NldCBvbiB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIE1hcCBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgTWFwL1NldCBvYmplY3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG52YXIgYmFzZUFkZFNldCA9IGZ1bmN0aW9uIF9iYXNlQWRkU2V0KGtpbmQsIGNvbnRleHQsIGtleSwgdmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZihcbiAgICBhc3NlcnRJc09iamVjdChjb250ZXh0KVsnW1trZXldXSddLFxuICAgIGtleSxcbiAgICAnU2FtZVZhbHVlWmVybydcbiAgKTtcblxuICBpZiAoaW5kZXggPiAtMSkge1xuICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgY29udGV4dFsnW1t2YWx1ZV1dJ11baW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChraW5kID09PSAnbWFwJykge1xuICAgICAgY29udGV4dFsnW1t2YWx1ZV1dJ10ucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgY29udGV4dFsnW1trZXldXSddLnB1c2goa2V5KTtcbiAgICBjb250ZXh0WydbW29yZGVyXV0nXS5wdXNoKGNvbnRleHRbJ1tbaWRdXSddLmdldCgpKTtcbiAgICBjb250ZXh0WydbW2lkXV0nXS5uZXh0KCk7XG4gICAgY29udGV4dFsnW1tjaGFuZ2VdXSddID0gdHJ1ZTtcbiAgICBjb250ZXh0LnNpemUgPSBjb250ZXh0WydbW2tleV1dJ10ubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCBpcyBhbiBpdGVyYXRvciB3aGVuIGl0IGtub3dzIGhvdyB0byBhY2Nlc3MgaXRlbXMgZnJvbSBhXG4gKiBjb2xsZWN0aW9uIG9uZSBhdCBhIHRpbWUsIHdoaWxlIGtlZXBpbmcgdHJhY2sgb2YgaXRzIGN1cnJlbnQgcG9zaXRpb25cbiAqIHdpdGhpbiB0aGF0IHNlcXVlbmNlLiBJbiBKYXZhU2NyaXB0IGFuIGl0ZXJhdG9yIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzXG4gKiBhIG5leHQoKSBtZXRob2Qgd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBpdGVtIGluIHRoZSBzZXF1ZW5jZS4gVGhpcyBtZXRob2RcbiAqIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6IGRvbmUgYW5kIHZhbHVlLiBPbmNlIGNyZWF0ZWQsXG4gKiBhbiBpdGVyYXRvciBvYmplY3QgY2FuIGJlIHVzZWQgZXhwbGljaXRseSBieSByZXBlYXRlZGx5IGNhbGxpbmcgbmV4dCgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIFNldCBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlcmF0b3JLaW5kIC0gVmFsdWVzIGFyZSBgdmFsdWVgLCBga2V5YCBvciBga2V5K3ZhbHVlYC5cbiAqL1xudmFyIFNldEl0ID0gZnVuY3Rpb24gU2V0SXRlcmF0b3IoY29udGV4dCwgaXRlcmF0b3JLaW5kKSB7XG4gIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICdbW0l0ZXJhdG9ySGFzTW9yZV1dJzoge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgJ1tbU2V0XV0nOiB7XG4gICAgICB2YWx1ZTogYXNzZXJ0SXNPYmplY3QoY29udGV4dClcbiAgICB9LFxuICAgICdbW1NldEl0ZXJhdGlvbktpbmRdXSc6IHtcbiAgICAgIHZhbHVlOiBpdGVyYXRvcktpbmQgfHwgJ3ZhbHVlJ1xuICAgIH0sXG4gICAgJ1tbU2V0TmV4dEluZGV4XV0nOiB7XG4gICAgICB2YWx1ZTogMCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogT25jZSBpbml0aWFsaXplZCwgdGhlIG5leHQoKSBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byBhY2Nlc3Mga2V5LXZhbHVlXG4gKiBwYWlycyBmcm9tIHRoZSBvYmplY3QgaW4gdHVybi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIG5leHRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6IGRvbmUgYW5kIHZhbHVlLlxuICovXG5kZWZpbmVQcm9wZXJ0eShTZXRJdC5wcm90b3R5cGUsICduZXh0Jywge1xuICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IGFzc2VydElzT2JqZWN0KHRoaXNbJ1tbU2V0XV0nXSk7XG4gICAgdmFyIGluZGV4ID0gdGhpc1snW1tTZXROZXh0SW5kZXhdXSddO1xuICAgIHZhciBpdGVyYXRvcktpbmQgPSB0aGlzWydbW1NldEl0ZXJhdGlvbktpbmRdXSddO1xuICAgIHZhciBtb3JlID0gdGhpc1snW1tJdGVyYXRvckhhc01vcmVdXSddO1xuICAgIHZhciBvYmplY3Q7XG4gICAgaWYgKGluZGV4IDwgY29udGV4dFsnW1trZXldXSddLmxlbmd0aCAmJiBtb3JlKSB7XG4gICAgICBvYmplY3QgPSB7IGRvbmU6IGZhbHNlIH07XG4gICAgICBpZiAoaXRlcmF0b3JLaW5kID09PSAna2V5K3ZhbHVlJykge1xuICAgICAgICBvYmplY3QudmFsdWUgPSBbY29udGV4dFsnW1trZXldXSddW2luZGV4XSwgY29udGV4dFsnW1trZXldXSddW2luZGV4XV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QudmFsdWUgPSBjb250ZXh0WydbW2tleV1dJ11baW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB0aGlzWydbW1NldE5leHRJbmRleF1dJ10gKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1snW1tJdGVyYXRvckhhc01vcmVdXSddID0gZmFsc2U7XG4gICAgICBvYmplY3QgPSB7XG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIEBAaXRlcmF0b3IgcHJvcGVydHkgaXMgdGhlIHNhbWUgSXRlcmF0b3Igb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gc3ltSXRcbiAqIEBtZW1iZXJvZiBTZXRJdGVyYXRvci5wcm90b3R5cGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoaXMgSXRlcmF0b3Igb2JqZWN0LlxuICovXG5kZWZpbmVQcm9wZXJ0eShTZXRJdC5wcm90b3R5cGUsIHN5bUl0LCB7XG4gIHZhbHVlOiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAqIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBTZXQgb2JqZWN0IGluIGluc2VydGlvbiBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMgU2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIG5ldyBJdGVyYXRvciBvYmplY3QuXG4gKi9cbnZhciBzZXRWYWx1ZXNJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgcmV0dXJuIG5ldyBTZXRJdCh0aGlzKTtcbn07XG5cbi8qKlxuICogVGhlIFNldCBvYmplY3QgbGV0cyB5b3Ugc3RvcmUgdW5pcXVlIHZhbHVlcyBvZiBhbnkgdHlwZSwgd2hldGhlciBwcmltaXRpdmVcbiAqIHZhbHVlcyBvciBvYmplY3QgcmVmZXJlbmNlcy5cbiAqXG4gKiBAY2xhc3MgU2V0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbaXRlcmFibGVdIC0gSWYgYW4gaXRlcmFibGUgb2JqZWN0IGlzIHBhc3NlZCwgYWxsIG9mIGl0cyBlbGVtZW50c1xuICogd2lsbCBiZSBhZGRlZCB0byB0aGUgbmV3IFNldC4gbnVsbCBpcyB0cmVhdGVkIGFzIHVuZGVmaW5lZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gKlxuICogbXlTZXQuYWRkKDEpO1xuICogbXlTZXQuYWRkKDUpO1xuICogbXlTZXQuYWRkKFwic29tZSB0ZXh0XCIpO1xuICogdmFyIG8gPSB7YTogMSwgYjogMn07XG4gKiBteVNldC5hZGQobyk7XG4gKlxuICogbXlTZXQuaGFzKDEpOyAvLyB0cnVlXG4gKiBteVNldC5oYXMoMyk7IC8vIGZhbHNlLCAzIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgc2V0XG4gKiBteVNldC5oYXMoNSk7ICAgICAgICAgICAgICAvLyB0cnVlXG4gKiBteVNldC5oYXMoTWF0aC5zcXJ0KDI1KSk7ICAvLyB0cnVlXG4gKiBteVNldC5oYXMoXCJTb21lIFRleHRcIi50b0xvd2VyQ2FzZSgpKTsgLy8gdHJ1ZVxuICogbXlTZXQuaGFzKG8pOyAvLyB0cnVlXG4gKlxuICogbXlTZXQuc2l6ZTsgLy8gNFxuICpcbiAqIG15U2V0LmRlbGV0ZSg1KTsgLy8gcmVtb3ZlcyA1IGZyb20gdGhlIHNldFxuICogbXlTZXQuaGFzKDUpOyAgICAvLyBmYWxzZSwgNSBoYXMgYmVlbiByZW1vdmVkXG4gKlxuICogbXlTZXQuc2l6ZTsgLy8gMywgd2UganVzdCByZW1vdmVkIG9uZSB2YWx1ZVxuICpcbiAqIC8vIFJlbGF0aW9uIHdpdGggQXJyYXkgb2JqZWN0c1xuICpcbiAqIHZhciBteUFycmF5ID0gW1widmFsdWUxXCIsIFwidmFsdWUyXCIsIFwidmFsdWUzXCJdO1xuICpcbiAqIC8vIFVzZSB0aGUgcmVndWxhciBTZXQgY29uc3RydWN0b3IgdG8gdHJhbnNmb3JtIGFuIEFycmF5IGludG8gYSBTZXRcbiAqIHZhciBteVNldCA9IG5ldyBTZXQobXlBcnJheSk7XG4gKlxuICogbXlTZXQuaGFzKFwidmFsdWUxXCIpOyAvLyByZXR1cm5zIHRydWVcbiAqXG4gKiAvLyBVc2UgdGhlIHNwcmVhZCBvcGVyYXRvciB0byB0cmFuc2Zvcm0gYSBzZXQgaW50byBhbiBBcnJheS5cbiAqIGNvbnNvbGUubG9nKHVuZXZhbChbLi4ubXlTZXRdKSk7IC8vIFdpbGwgc2hvdyB5b3UgZXhhY3RseSB0aGUgc2FtZSBBcnJheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgbXlBcnJheVxuICovXG52YXIgU2V0T2JqZWN0ID0gZnVuY3Rpb24gU2V0KCkge1xuICBpZiAoQm9vbGVhbih0aGlzKSA9PT0gZmFsc2UgfHwgKHRoaXMgaW5zdGFuY2VvZiBTZXRPYmplY3QpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnN0cnVjdG9yIFNldCByZXF1aXJlcyBcXCduZXdcXCcnKTtcbiAgfVxuXG4gIHBhcnNlSXRlcmFibGUoJ3NldCcsIHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB2b2lkIDApO1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhTZXRPYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIG1vZHVsZTpjb2xsZWN0aW9ucy14LlNldC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogVGhlIGFkZCgpIG1ldGhvZCBhcHBlbmRzIGEgbmV3IGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCB2YWx1ZSB0byB0aGUgZW5kXG4gICAqIG9mIGEgU2V0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFJlcXVpcmVkLiBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBTZXRcbiAgICogIG9iamVjdC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIFNldCBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0XG4gICAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAgICpcbiAgICogbXlTZXQuYWRkKDEpO1xuICAgKiBteVNldC5hZGQoNSkuYWRkKFwic29tZSB0ZXh0XCIpOyAvLyBjaGFpbmFibGVcbiAgICpcbiAgICogY29uc29sZS5sb2cobXlTZXQpO1xuICAgKiAvLyBTZXQgWzEsIDUsIFwic29tZSB0ZXh0XCJdXG4gICAqL1xuICBhZGQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUFkZFNldCgnc2V0JywgdGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBjbGVhcigpIG1ldGhvZCByZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGEgU2V0IG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIFNldCBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0XG4gICAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAgICogbXlTZXQuYWRkKDEpO1xuICAgKiBteVNldC5hZGQoXCJmb29cIik7XG4gICAqXG4gICAqIG15U2V0LnNpemU7ICAgICAgIC8vIDJcbiAgICogbXlTZXQuaGFzKFwiZm9vXCIpOyAvLyB0cnVlXG4gICAqXG4gICAqIG15U2V0LmNsZWFyKCk7XG4gICAqXG4gICAqIG15U2V0LnNpemU7ICAgICAgIC8vIDBcbiAgICogbXlTZXQuaGFzKFwiYmFyXCIpICAvLyBmYWxzZVxuICAgKi9cbiAgY2xlYXI6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICByZXR1cm4gYmFzZUNsZWFyKCdzZXQnLCB0aGlzKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZGVsZXRlKCkgbWV0aG9kIHJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGZyb20gYSBTZXQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZSBmcm9tIHRoZSBTZXQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgaW4gdGhlIFNldCBvYmplY3QgaGFzIGJlZW5cbiAgICogIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5OyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0XG4gICAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAgICogbXlTZXQuYWRkKFwiZm9vXCIpO1xuICAgKlxuICAgKiBteVNldC5kZWxldGUoXCJiYXJcIik7IC8vIFJldHVybnMgZmFsc2UuIE5vIFwiYmFyXCIgZWxlbWVudCBmb3VuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAvL3RvIGJlIGRlbGV0ZWQuXG4gICAqIG15U2V0LmRlbGV0ZShcImZvb1wiKTsgLy8gUmV0dXJucyB0cnVlLiAgU3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXG4gICAqXG4gICAqIG15U2V0LmhhcyhcImZvb1wiKTsgICAgLy8gUmV0dXJucyBmYWxzZS4gVGhlIFwiZm9vXCIgZWxlbWVudCBpcyBub1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAvL2xvbmdlciBwcmVzZW50LlxuICAgKi9cbiAgJ2RlbGV0ZSc6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGUxZXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGV0ZSgnc2V0JywgdGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBlbnRyaWVzKCkgbWV0aG9kIHJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgYW5cbiAgICogYXJyYXkgb2YgW3ZhbHVlLCB2YWx1ZV0gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgU2V0IG9iamVjdCwgaW5cbiAgICogaW5zZXJ0aW9uIG9yZGVyLiBGb3IgU2V0IG9iamVjdHMgdGhlcmUgaXMgbm8ga2V5IGxpa2UgaW4gTWFwIG9iamVjdHMuXG4gICAqIEhvd2V2ZXIsIHRvIGtlZXAgdGhlIEFQSSBzaW1pbGFyIHRvIHRoZSBNYXAgb2JqZWN0LCBlYWNoIGVudHJ5IGhhcyB0aGVcbiAgICogc2FtZSB2YWx1ZSBmb3IgaXRzIGtleSBhbmQgdmFsdWUgaGVyZSwgc28gdGhhdCBhbiBhcnJheSBbdmFsdWUsIHZhbHVlXVxuICAgKiBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIFNldCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5TZXRcbiAgICogdmFyIG15U2V0ID0gbmV3IFNldCgpO1xuICAgKiBteVNldC5hZGQoXCJmb29iYXJcIik7XG4gICAqIG15U2V0LmFkZCgxKTtcbiAgICogbXlTZXQuYWRkKFwiYmF6XCIpO1xuICAgKlxuICAgKiB2YXIgc2V0SXRlciA9IG15U2V0LmVudHJpZXMoKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBbXCJmb29iYXJcIiwgXCJmb29iYXJcIl1cbiAgICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBbMSwgMV1cbiAgICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBbXCJiYXpcIiwgXCJiYXpcIl1cbiAgICovXG4gIGVudHJpZXM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0SXQodGhpcywgJ2tleSt2YWx1ZScpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBmb3JFYWNoKCkgbWV0aG9kIGV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgZWFjaCB2YWx1ZVxuICAgKiBpbiB0aGUgU2V0IG9iamVjdCwgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIFNldCBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGZ1bmN0aW9uIGxvZ1NldEVsZW1lbnRzKHZhbHVlMSwgdmFsdWUyLCBzZXQpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwic1tcIiArIHZhbHVlMSArIFwiXSA9IFwiICsgdmFsdWUyKTtcbiAgICogfVxuICAgKlxuICAgKiBuZXcgU2V0KFtcImZvb1wiLCBcImJhclwiLCB1bmRlZmluZWRdKS5mb3JFYWNoKGxvZ1NldEVsZW1lbnRzKTtcbiAgICpcbiAgICogLy8gbG9nczpcbiAgICogLy8gXCJzW2Zvb10gPSBmb29cIlxuICAgKiAvLyBcInNbYmFyXSA9IGJhclwiXG4gICAqIC8vIFwic1t1bmRlZmluZWRdID0gdW5kZWZpbmVkXCJcbiAgICovXG4gIGZvckVhY2g6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VGb3JFYWNoKCdzZXQnLCB0aGlzLCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIGhhcygpIG1ldGhvZCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZVxuICAgKiBzcGVjaWZpZWQgdmFsdWUgZXhpc3RzIGluIGEgU2V0IG9iamVjdCBvciBub3QuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QgZm9yIHByZXNlbmNlIGluIHRoZSBTZXQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAqICBleGlzdHMgaW4gdGhlIFNldCBvYmplY3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIFNldCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5TZXQ7XG4gICAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAgICogbXlTZXQuYWRkKFwiZm9vXCIpO1xuICAgKlxuICAgKiBteVNldC5oYXMoXCJmb29cIik7ICAvLyByZXR1cm5zIHRydWVcbiAgICogbXlTZXQuaGFzKFwiYmFyXCIpOyAgLy8gcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgaGFzOiB7XG4gICAgdmFsdWU6IGJhc2VIYXNcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBrZXlzKCkgbWV0aG9kIGlzIGFuIGFsaWFzIGZvciB0aGUgYHZhbHVlc2AgbWV0aG9kIChmb3Igc2ltaWxhcml0eVxuICAgKiB3aXRoIE1hcCBvYmplY3RzKTsgaXQgYmVoYXZlcyBleGFjdGx5IHRoZSBzYW1lIGFuZCByZXR1cm5zIHZhbHVlcyBvZlxuICAgKiBTZXQgZWxlbWVudHMuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG5ldyBJdGVyYXRvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0XG4gICAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAgICogbXlTZXQuYWRkKFwiZm9vXCIpO1xuICAgKiBteVNldC5hZGQoXCJiYXJcIik7XG4gICAqIG15U2V0LmFkZChcImJhelwiKTtcbiAgICpcbiAgICogdmFyIHNldEl0ZXIgPSBteVNldC5rZXlzKCk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCJmb29cIlxuICAgKiBjb25zb2xlLmxvZyhzZXRJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFwiYmFyXCJcbiAgICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBcImJhelwiXG4gICAqL1xuICBrZXlzOiB7XG4gICAgdmFsdWU6IHNldFZhbHVlc0l0ZXJhdG9yXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2Ygc2l6ZSBpcyBhbiBpbnRlZ2VyIHJlcHJlc2VudGluZyBob3cgbWFueSBlbnRyaWVzIHRoZSBTZXRcbiAgICogb2JqZWN0IGhhcy5cbiAgICpcbiAgICogQG5hbWUgc2l6ZVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25zLXguU2V0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgU2V0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLlNldFxuICAgKiB2YXIgbXlTZXQgPSBuZXcgU2V0KCk7XG4gICAqIG15U2V0LmFkZCgxKTtcbiAgICogbXlTZXQuYWRkKDUpO1xuICAgKiBteVNldC5hZGQoXCJzb21lIHRleHRcIik7XG4gICAqXG4gICAqIG15U2V0LnNpemU7IC8vIDNcbiAgICovXG4gIHNpemU6IHtcbiAgICB2YWx1ZTogMCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9LFxuICAvKipcbiAgICogVGhlIHZhbHVlcygpIG1ldGhvZCByZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgU2V0IG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG5ldyBJdGVyYXRvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0XG4gICAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAgICogbXlTZXQuYWRkKFwiZm9vXCIpO1xuICAgKiBteVNldC5hZGQoXCJiYXJcIik7XG4gICAqIG15U2V0LmFkZChcImJhelwiKTtcbiAgICpcbiAgICogdmFyIHNldEl0ZXIgPSBteVNldC52YWx1ZXMoKTtcbiAgICpcbiAgICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBcImZvb1wiXG4gICAqIGNvbnNvbGUubG9nKHNldEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCJiYXJcIlxuICAgKiBjb25zb2xlLmxvZyhzZXRJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFwiYmF6XCJcbiAgICovXG4gIHZhbHVlczoge1xuICAgIHZhbHVlOiBzZXRWYWx1ZXNJdGVyYXRvclxuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgQEBpdGVyYXRvciBwcm9wZXJ0eSBpcyB0aGUgc2FtZSBmdW5jdGlvbiBvYmplY3RcbiAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSB2YWx1ZXMgcHJvcGVydHkuXG4gKlxuICogQGZ1bmN0aW9uIHN5bUl0XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25zLXguU2V0LnByb3RvdHlwZVxuICogQHJldHVybnMge09iamVjdH0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuU2V0LFxuICogdmFyIHN5bUl0ID0gdmFyIFNldCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5zeW1JdDtcbiAqIHZhciBteVNldCA9IG5ldyBTZXQoKTtcbiAqIG15U2V0LmFkZChcIjBcIik7XG4gKiBteVNldC5hZGQoMSk7XG4gKiBteVNldC5hZGQoe30pO1xuICpcbiAqIHZhciBzZXRJdGVyID0gbXlTZXRbc3ltSXRdKCk7XG4gKlxuICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyBcIjBcIlxuICogY29uc29sZS5sb2coc2V0SXRlci5uZXh0KCkudmFsdWUpOyAvLyAxXG4gKiBjb25zb2xlLmxvZyhzZXRJdGVyLm5leHQoKS52YWx1ZSk7IC8vIE9iamVjdFxuICovXG5kZWZpbmVQcm9wZXJ0eShTZXRPYmplY3QucHJvdG90eXBlLCBzeW1JdCwge1xuICB2YWx1ZTogc2V0VmFsdWVzSXRlcmF0b3Jcbn0pO1xuXG4vKipcbiAqIEFuIG9iamVjdCBpcyBhbiBpdGVyYXRvciB3aGVuIGl0IGtub3dzIGhvdyB0byBhY2Nlc3MgaXRlbXMgZnJvbSBhXG4gKiBjb2xsZWN0aW9uIG9uZSBhdCBhIHRpbWUsIHdoaWxlIGtlZXBpbmcgdHJhY2sgb2YgaXRzIGN1cnJlbnQgcG9zaXRpb25cbiAqIHdpdGhpbiB0aGF0IHNlcXVlbmNlLiBJbiBKYXZhU2NyaXB0IGFuIGl0ZXJhdG9yIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzXG4gKiBhIG5leHQoKSBtZXRob2Qgd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBpdGVtIGluIHRoZSBzZXF1ZW5jZS4gVGhpcyBtZXRob2RcbiAqIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6IGRvbmUgYW5kIHZhbHVlLiBPbmNlIGNyZWF0ZWQsXG4gKiBhbiBpdGVyYXRvciBvYmplY3QgY2FuIGJlIHVzZWQgZXhwbGljaXRseSBieSByZXBlYXRlZGx5IGNhbGxpbmcgbmV4dCgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIE1hcCBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlcmF0b3JLaW5kIC0gVmFsdWVzIGFyZSBgdmFsdWVgLCBga2V5YCBvciBga2V5K3ZhbHVlYC5cbiAqL1xudmFyIE1hcEl0ID0gZnVuY3Rpb24gTWFwSXRlcmF0b3IoY29udGV4dCwgaXRlcmF0b3JLaW5kKSB7XG4gIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICdbW0l0ZXJhdG9ySGFzTW9yZV1dJzoge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgJ1tbTWFwXV0nOiB7XG4gICAgICB2YWx1ZTogYXNzZXJ0SXNPYmplY3QoY29udGV4dClcbiAgICB9LFxuICAgICdbW01hcEl0ZXJhdGlvbktpbmRdXSc6IHtcbiAgICAgIHZhbHVlOiBpdGVyYXRvcktpbmRcbiAgICB9LFxuICAgICdbW01hcE5leHRJbmRleF1dJzoge1xuICAgICAgdmFsdWU6IDAsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIE9uY2UgaW5pdGlhbGl6ZWQsIHRoZSBuZXh0KCkgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gYWNjZXNzIGtleS12YWx1ZVxuICogcGFpcnMgZnJvbSB0aGUgb2JqZWN0IGluIHR1cm4uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBuZXh0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHR3byBwcm9wZXJ0aWVzOiBkb25lIGFuZCB2YWx1ZS5cbiAqL1xuZGVmaW5lUHJvcGVydHkoTWFwSXQucHJvdG90eXBlLCAnbmV4dCcsIHtcbiAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhc3NlcnRJc09iamVjdCh0aGlzWydbW01hcF1dJ10pO1xuICAgIHZhciBpbmRleCA9IHRoaXNbJ1tbTWFwTmV4dEluZGV4XV0nXTtcbiAgICB2YXIgaXRlcmF0b3JLaW5kID0gdGhpc1snW1tNYXBJdGVyYXRpb25LaW5kXV0nXTtcbiAgICB2YXIgbW9yZSA9IHRoaXNbJ1tbSXRlcmF0b3JIYXNNb3JlXV0nXTtcbiAgICB2YXIgb2JqZWN0O1xuICAgIGFzc2VydElzT2JqZWN0KGNvbnRleHQpO1xuICAgIGlmIChpbmRleCA8IGNvbnRleHRbJ1tba2V5XV0nXS5sZW5ndGggJiYgbW9yZSkge1xuICAgICAgb2JqZWN0ID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgaWYgKGl0ZXJhdG9yS2luZCA9PT0gJ2tleSt2YWx1ZScpIHtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gW2NvbnRleHRbJ1tba2V5XV0nXVtpbmRleF0sIGNvbnRleHRbJ1tbdmFsdWVdXSddW2luZGV4XV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3QudmFsdWUgPSBjb250ZXh0WydbWycgKyBpdGVyYXRvcktpbmQgKyAnXV0nXVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHRoaXNbJ1tbTWFwTmV4dEluZGV4XV0nXSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzWydbW0l0ZXJhdG9ySGFzTW9yZV1dJ10gPSBmYWxzZTtcbiAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgQEBpdGVyYXRvciBwcm9wZXJ0eSBpcyB0aGUgc2FtZSBJdGVyYXRvciBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvbiBzeW1JdFxuICogQG1lbWJlcm9mIE1hcEl0ZXJhdG9yLnByb3RvdHlwZVxuICogQHJldHVybnMge09iamVjdH0gVGhpcyBJdGVyYXRvciBvYmplY3QuXG4gKi9cbmRlZmluZVByb3BlcnR5KE1hcEl0LnByb3RvdHlwZSwgc3ltSXQsIHtcbiAgdmFsdWU6IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgTWFwIG9iamVjdCBpcyBhIHNpbXBsZSBrZXkvdmFsdWUgbWFwLiBBbnkgdmFsdWUgKGJvdGggb2JqZWN0cyBhbmRcbiAqIHByaW1pdGl2ZSB2YWx1ZXMpIG1heSBiZSB1c2VkIGFzIGVpdGhlciBhIGtleSBvciBhIHZhbHVlLlxuICpcbiAqIEBjbGFzcyBNYXBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFtpdGVyYWJsZV0gLSBJdGVyYWJsZSBpcyBhbiBBcnJheSBvciBvdGhlciBpdGVyYWJsZSBvYmplY3Qgd2hvc2VcbiAqICBlbGVtZW50cyBhcmUga2V5LXZhbHVlIHBhaXJzICgyLWVsZW1lbnQgQXJyYXlzKS4gRWFjaCBrZXktdmFsdWUgcGFpciBpc1xuICogIGFkZGVkIHRvIHRoZSBuZXcgTWFwLiBudWxsIGlzIHRyZWF0ZWQgYXMgdW5kZWZpbmVkLlxuICogQGV4YW1wbGVcbiAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICogdmFyIG15TWFwID0gbmV3IE1hcCgpO1xuICpcbiAqIHZhciBrZXlTdHJpbmcgPSBcImEgc3RyaW5nXCIsXG4gKiAgICAga2V5T2JqID0ge30sXG4gKiAgICAga2V5RnVuYyA9IGZ1bmN0aW9uICgpIHt9O1xuICpcbiAqIC8vIHNldHRpbmcgdGhlIHZhbHVlc1xuICogbXlNYXAuc2V0KGtleVN0cmluZywgXCJ2YWx1ZSBhc3NvY2lhdGVkIHdpdGggJ2Egc3RyaW5nJ1wiKTtcbiAqIG15TWFwLnNldChrZXlPYmosIFwidmFsdWUgYXNzb2NpYXRlZCB3aXRoIGtleU9ialwiKTtcbiAqIG15TWFwLnNldChrZXlGdW5jLCBcInZhbHVlIGFzc29jaWF0ZWQgd2l0aCBrZXlGdW5jXCIpO1xuICpcbiAqIG15TWFwLnNpemU7IC8vIDNcbiAqXG4gKiAvLyBnZXR0aW5nIHRoZSB2YWx1ZXNcbiAqIG15TWFwLmdldChrZXlTdHJpbmcpOyAgICAvLyBcInZhbHVlIGFzc29jaWF0ZWQgd2l0aCAnYSBzdHJpbmcnXCJcbiAqIG15TWFwLmdldChrZXlPYmopOyAgICAgICAvLyBcInZhbHVlIGFzc29jaWF0ZWQgd2l0aCBrZXlPYmpcIlxuICogbXlNYXAuZ2V0KGtleUZ1bmMpOyAgICAgIC8vIFwidmFsdWUgYXNzb2NpYXRlZCB3aXRoIGtleUZ1bmNcIlxuICpcbiAqIG15TWFwLmdldChcImEgc3RyaW5nXCIpOyAgIC8vIFwidmFsdWUgYXNzb2NpYXRlZCB3aXRoICdhIHN0cmluZydcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Uga2V5U3RyaW5nID09PSAnYSBzdHJpbmcnXG4gKiBteU1hcC5nZXQoe30pOyAgICAgICAgICAgLy8gdW5kZWZpbmVkLCBiZWNhdXNlIGtleU9iaiAhPT0ge31cbiAqIG15TWFwLmdldChmdW5jdGlvbigpIHt9KSAvLyB1bmRlZmluZWQsIGJlY2F1c2Uga2V5RnVuYyAhPT0gZnVuY3Rpb24gKCkge31cbiAqXG4gKiAvLyBVc2luZyBOYU4gYXMgTWFwIGtleXNcbiAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAqIG15TWFwLnNldChOYU4sIFwibm90IGEgbnVtYmVyXCIpO1xuICpcbiAqIG15TWFwLmdldChOYU4pOyAvLyBcIm5vdCBhIG51bWJlclwiXG4gKlxuICogdmFyIG90aGVyTmFOID0gTnVtYmVyKFwiZm9vXCIpO1xuICogbXlNYXAuZ2V0KG90aGVyTmFOKTsgLy8gXCJub3QgYSBudW1iZXJcIlxuICpcbiAqIC8vIFJlbGF0aW9uIHdpdGggQXJyYXkgb2JqZWN0c1xuICogdmFyIGt2QXJyYXkgPSBbW1wia2V5MVwiLCBcInZhbHVlMVwiXSwgW1wia2V5MlwiLCBcInZhbHVlMlwiXV07XG4gKlxuICogLy8gVXNlIHRoZSByZWd1bGFyIE1hcCBjb25zdHJ1Y3RvciB0byB0cmFuc2Zvcm0gYVxuICogLy8gMkQga2V5LXZhbHVlIEFycmF5IGludG8gYSBtYXBcbiAqIHZhciBteU1hcCA9IG5ldyBNYXAoa3ZBcnJheSk7XG4gKlxuICogbXlNYXAuZ2V0KFwia2V5MVwiKTsgLy8gcmV0dXJucyBcInZhbHVlMVwiXG4gKi9cbnZhciBNYXBPYmplY3QgPSBmdW5jdGlvbiBNYXAoKSB7XG4gIGlmIChCb29sZWFuKHRoaXMpID09PSBmYWxzZSB8fCAodGhpcyBpbnN0YW5jZW9mIE1hcE9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgTWFwIHJlcXVpcmVzIFxcJ25ld1xcJycpO1xuICB9XG5cbiAgcGFyc2VJdGVyYWJsZSgnbWFwJywgdGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHZvaWQgMCk7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKE1hcE9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgbW9kdWxlOmNvbGxlY3Rpb25zLXguTWFwLnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBUaGUgY2xlYXIoKSBtZXRob2QgcmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBhIE1hcCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBNYXAgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgTWFwID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLk1hcDtcbiAgICogdmFyIG15TWFwID0gbmV3IE1hcCgpO1xuICAgKiBteU1hcC5zZXQoXCJiYXJcIiwgXCJiYXpcIik7XG4gICAqIG15TWFwLnNldCgxLCBcImZvb1wiKTtcbiAgICpcbiAgICogbXlNYXAuc2l6ZTsgICAgICAgLy8gMlxuICAgKiBteU1hcC5oYXMoXCJiYXJcIik7IC8vIHRydWVcbiAgICpcbiAgICogbXlNYXAuY2xlYXIoKTtcbiAgICpcbiAgICogbXlNYXAuc2l6ZTsgICAgICAgLy8gMFxuICAgKiBteU1hcC5oYXMoXCJiYXJcIikgIC8vIGZhbHNlXG4gICAqL1xuICBjbGVhcjoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xlYXIoJ21hcCcsIHRoaXMpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBkZWxldGUoKSBtZXRob2QgcmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSBhIE1hcCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgTWFwIG9iamVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGluIHRoZSBNYXAgb2JqZWN0IGhhcyBiZWVuXG4gICAqICByZW1vdmVkIHN1Y2Nlc3NmdWxseS5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KFwiYmFyXCIsIFwiZm9vXCIpO1xuICAgKlxuICAgKiBteU1hcC5kZWxldGUoXCJiYXJcIik7IC8vIFJldHVybnMgdHJ1ZS4gU3VjY2Vzc2Z1bGx5IHJlbW92ZWQuXG4gICAqIG15TWFwLmhhcyhcImJhclwiKTsgICAgLy8gUmV0dXJucyBmYWxzZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYmFyXCIgZWxlbWVudCBpcyBubyBsb25nZXIgcHJlc2VudC5cbiAgICovXG4gICdkZWxldGUnOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlMWV0ZShrZXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsZXRlKCdtYXAnLCB0aGlzLCBrZXkpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBlbnRyaWVzKCkgbWV0aG9kIHJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIFtrZXksIHZhbHVlXSBwYWlycyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBNYXAgb2JqZWN0IGluIGluc2VydGlvbiBvcmRlci5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgTWFwID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLk1hcDtcbiAgICogdmFyIG15TWFwID0gbmV3IE1hcCgpO1xuICAgKiBteU1hcC5zZXQoXCIwXCIsIFwiZm9vXCIpO1xuICAgKiBteU1hcC5zZXQoMSwgXCJiYXJcIik7XG4gICAqIG15TWFwLnNldCh7fSwgXCJiYXpcIik7XG4gICAqXG4gICAqIHZhciBtYXBJdGVyID0gbXlNYXAuZW50cmllcygpO1xuICAgKlxuICAgKiBjb25zb2xlLmxvZyhtYXBJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFtcIjBcIiwgXCJmb29cIl1cbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBbMSwgXCJiYXJcIl1cbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBbT2JqZWN0LCBcImJhelwiXVxuICAgKi9cbiAgZW50cmllczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdCh0aGlzLCAna2V5K3ZhbHVlJyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIGZvckVhY2goKSBtZXRob2QgZXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBlYWNoXG4gICAqIGtleS92YWx1ZSBwYWlyIGluIHRoZSBNYXAgb2JqZWN0LCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBlbGVtZW50Li5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIE1hcCBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICAgKiBmdW5jdGlvbiBsb2dFbGVtZW50cyh2YWx1ZSwga2V5LCBtYXApIHtcbiAgICogICAgICBjb25zb2xlLmxvZyhcIm1bXCIgKyBrZXkgKyBcIl0gPSBcIiArIHZhbHVlKTtcbiAgICogfVxuICAgKiB2YXIgbXlNYXAgPSBuZXcgTWFwKFtbXCJmb29cIiwgM10sIFtcImJhclwiLCB7fV0sIFtcImJhelwiLCB1bmRlZmluZWRdXSk7XG4gICAqIG15TWFwLmZvckVhY2gobG9nRWxlbWVudHMpO1xuICAgKiAvLyBsb2dzOlxuICAgKiAvLyBcIm1bZm9vXSA9IDNcIlxuICAgKiAvLyBcIm1bYmFyXSA9IFtvYmplY3QgT2JqZWN0XVwiXG4gICAqIC8vIFwibVtiYXpdID0gdW5kZWZpbmVkXCJcbiAgICovXG4gIGZvckVhY2g6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VGb3JFYWNoKCdtYXAnLCB0aGlzLCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVGhlIGdldCgpIG1ldGhvZCByZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSBhIE1hcCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgTWFwIG9iamVjdC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IG9yXG4gICAqICB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgTWFwIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KFwiYmFyXCIsIFwiZm9vXCIpO1xuICAgKlxuICAgKiBteU1hcC5nZXQoXCJiYXJcIik7ICAvLyBSZXR1cm5zIFwiZm9vXCIuXG4gICAqIG15TWFwLmdldChcImJhelwiKTsgIC8vIFJldHVybnMgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4T2YoXG4gICAgICAgIGFzc2VydElzT2JqZWN0KHRoaXMpWydbW2tleV1dJ10sXG4gICAgICAgIGtleSxcbiAgICAgICAgJ1NhbWVWYWx1ZVplcm8nXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gaW5kZXggPiAtMSA/IHRoaXNbJ1tbdmFsdWVdXSddW2luZGV4XSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgaGFzKCkgbWV0aG9kIHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGhcbiAgICogdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byB0ZXN0IGZvciBwcmVzZW5jZSBpbiB0aGVcbiAgICogIE1hcCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5XG4gICAqICBleGlzdHMgaW4gdGhlIE1hcCBvYmplY3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KFwiYmFyXCIsIFwiZm9vXCIpO1xuICAgKlxuICAgKiBteU1hcC5oYXMoXCJiYXJcIik7ICAvLyByZXR1cm5zIHRydWVcbiAgICogbXlNYXAuaGFzKFwiYmF6XCIpOyAgLy8gcmV0dXJucyBmYWxzZVxuICAgKi9cbiAgaGFzOiB7XG4gICAgdmFsdWU6IGJhc2VIYXNcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBrZXlzKCkgbWV0aG9kIHJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGtleXNcbiAgICogZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgTWFwIG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbmV3IEl0ZXJhdG9yIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICogbXlNYXAuc2V0KFwiMFwiLCBcImZvb1wiKTtcbiAgICogbXlNYXAuc2V0KDEsIFwiYmFyXCIpO1xuICAgKiBteU1hcC5zZXQoe30sIFwiYmF6XCIpO1xuICAgKlxuICAgKiB2YXIgbWFwSXRlciA9IG15TWFwLmtleXMoKTtcbiAgICpcbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBcIjBcIlxuICAgKiBjb25zb2xlLmxvZyhtYXBJdGVyLm5leHQoKS52YWx1ZSk7IC8vIDFcbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBPYmplY3RcbiAgICovXG4gIGtleXM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwSXQodGhpcywgJ2tleScpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBzZXQoKSBtZXRob2QgYWRkcyBhIG5ldyBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCB2YWx1ZSB0b1xuICAgKiBhIE1hcCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0ga2V5IC0gVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIE1hcCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBNYXAgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgTWFwIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIE1hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5NYXA7XG4gICAqIHZhciBteU1hcCA9IG5ldyBNYXAoKTtcbiAgICpcbiAgICogLy8gQWRkIG5ldyBlbGVtZW50cyB0byB0aGUgbWFwXG4gICAqIG15TWFwLnNldChcImJhclwiLCBcImZvb1wiKTtcbiAgICogbXlNYXAuc2V0KDEsIFwiZm9vYmFyXCIpO1xuICAgKlxuICAgKiAvLyBVcGRhdGUgYW4gZWxlbWVudCBpbiB0aGUgbWFwXG4gICAqIG15TWFwLnNldChcImJhclwiLCBcImZ1dXVcIik7XG4gICAqL1xuICBzZXQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQWRkU2V0KCdtYXAnLCB0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2Ygc2l6ZSBpcyBhbiBpbnRlZ2VyIHJlcHJlc2VudGluZyBob3cgbWFueSBlbnRyaWVzIHRoZSBNYXBcbiAgICogb2JqZWN0IGhhcy5cbiAgICpcbiAgICogQG5hbWUgc2l6ZVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25zLXguTWFwXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgTWFwID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLk1hcDtcbiAgICogdmFyIG15TWFwID0gbmV3IE1hcCgpO1xuICAgKiBteU1hcC5zZXQoMSwgdHJ1ZSk7XG4gICAqIG15TWFwLnNldCg1LCBmYWxzZSk7XG4gICAqIG15TWFwLnNldChcInNvbWUgdGV4dFwiLCAxKTtcbiAgICpcbiAgICogbXlNYXAuc2l6ZTsgLy8gM1xuICAgKi9cbiAgc2l6ZToge1xuICAgIHZhbHVlOiAwLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgdmFsdWVzKCkgbWV0aG9kIHJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBNYXAgb2JqZWN0IGluIGluc2VydGlvbiBvcmRlci5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgTWFwID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLk1hcDtcbiAgICogdmFyIG15TWFwID0gbmV3IE1hcCgpO1xuICAgKiBteU1hcC5zZXQoXCIwXCIsIFwiZm9vXCIpO1xuICAgKiBteU1hcC5zZXQoMSwgXCJiYXJcIik7XG4gICAqIG15TWFwLnNldCh7fSwgXCJiYXpcIik7XG4gICAqXG4gICAqIHZhciBtYXBJdGVyID0gbXlNYXAudmFsdWVzKCk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKG1hcEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gXCJmb29cIlxuICAgKiBjb25zb2xlLmxvZyhtYXBJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFwiYmFyXCJcbiAgICogY29uc29sZS5sb2cobWFwSXRlci5uZXh0KCkudmFsdWUpOyAvLyBcImJhelwiXG4gICAqL1xuICB2YWx1ZXM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdCh0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBAQGl0ZXJhdG9yIHByb3BlcnR5IGlzIHRoZSBzYW1lIGZ1bmN0aW9uIG9iamVjdFxuICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVudHJpZXMgcHJvcGVydHkuXG4gKlxuICogQGZ1bmN0aW9uIHN5bUl0XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25zLXguTWFwLnByb3RvdHlwZVxuICogQHJldHVybnMge09iamVjdH0gQSBuZXcgSXRlcmF0b3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBNYXAgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14JykuTWFwO1xuICogdmFyIHN5bUl0ID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpLnN5bUl0O1xuICogdmFyIG15TWFwID0gbmV3IE1hcCgpO1xuICogbXlNYXAuc2V0KFwiMFwiLCBcImZvb1wiKTtcbiAqIG15TWFwLnNldCgxLCBcImJhclwiKTtcbiAqIG15TWFwLnNldCh7fSwgXCJiYXpcIik7XG4gKlxuICogdmFyIG1hcEl0ZXIgPSBteU1hcFtzeW1JdF0oKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhtYXBJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFtcIjBcIiwgXCJmb29cIl1cbiAqIGNvbnNvbGUubG9nKG1hcEl0ZXIubmV4dCgpLnZhbHVlKTsgLy8gWzEsIFwiYmFyXCJdXG4gKiBjb25zb2xlLmxvZyhtYXBJdGVyLm5leHQoKS52YWx1ZSk7IC8vIFtPYmplY3QsIFwiYmF6XCJdXG4gKi9cbmRlZmluZVByb3BlcnR5KE1hcE9iamVjdC5wcm90b3R5cGUsIHN5bUl0LCB7XG4gIHZhbHVlOiBNYXBPYmplY3QucHJvdG90eXBlLmVudHJpZXNcbn0pO1xuXG4vKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIHNoaW0gb3IgbmF0aXZlLlxuICovXG5cbnZhciBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG50cnkge1xuICBFeHBvcnRNYXAgPSBuZXcgTWFwKCkgPyBNYXAgOiBNYXBPYmplY3Q7XG59IGNhdGNoIChpZ25vcmUpIHt9XG5cbnZhciBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG50cnkge1xuICBFeHBvcnRTZXQgPSBuZXcgU2V0KCkgPyBTZXQgOiBTZXRPYmplY3Q7XG59IGNhdGNoIChpZ25vcmUpIHt9XG5cbnZhciB0ZXN0TWFwO1xuXG5pZiAoRXhwb3J0TWFwICE9PSBNYXBPYmplY3QpIHtcbiAgdGVzdE1hcCA9IG5ldyBFeHBvcnRNYXAoKTtcbiAgaWYgKGlzTnVtYmVyVHlwZSh0ZXN0TWFwLnNpemUpID09PSBmYWxzZSB8fCB0ZXN0TWFwLnNpemUgIT09IDApIHtcbiAgICBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByb3BzTWFwID0gW1xuICAgICAgJ2hhcycsXG4gICAgICAnc2V0JyxcbiAgICAgICdjbGVhcicsXG4gICAgICAnZGVsZXRlJyxcbiAgICAgICdmb3JFYWNoJyxcbiAgICAgICd2YWx1ZXMnLFxuICAgICAgJ2VudHJpZXMnLFxuICAgICAgJ2tleXMnLFxuICAgICAgc3ltSXRcbiAgICBdO1xuXG4gICAgdmFyIGZhaWxlZE1hcCA9IHNvbWUocHJvcHNNYXAsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRlc3RNYXBbbWV0aG9kXSkgPT09IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgaWYgKGZhaWxlZE1hcCkge1xuICAgICAgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xuICAgIH1cbiAgfVxufVxuXG5pZiAoRXhwb3J0TWFwICE9PSBNYXBPYmplY3QpIHtcbiAgLy8gU2FmYXJpIDgsIGZvciBleGFtcGxlLCBkb2Vzbid0IGFjY2VwdCBhbiBpdGVyYWJsZS5cbiAgdmFyIG1hcEFjY2VwdHNBcmd1bWVudHMgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBtYXBBY2NlcHRzQXJndW1lbnRzID0gbmV3IEV4cG9ydE1hcChbWzEsIDJdXSkuZ2V0KDEpID09PSAyO1xuICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgaWYgKG1hcEFjY2VwdHNBcmd1bWVudHMgPT09IGZhbHNlKSB7XG4gICAgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xuICB9XG59XG5cbmlmIChFeHBvcnRNYXAgIT09IE1hcE9iamVjdCkge1xuICB0ZXN0TWFwID0gbmV3IEV4cG9ydE1hcCgpO1xuICB2YXIgbWFwU3VwcG9ydHNDaGFpbmluZyA9IHRlc3RNYXAuc2V0KDEsIDIpID09PSB0ZXN0TWFwO1xuICBpZiAobWFwU3VwcG9ydHNDaGFpbmluZyA9PT0gZmFsc2UpIHtcbiAgICBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG4gIH1cbn1cblxuaWYgKEV4cG9ydE1hcCAhPT0gTWFwT2JqZWN0KSB7XG4gIC8vIENocm9tZSAzOC00Miwgbm9kZSAwLjExLzAuMTIsIGlvanMgMS8yIGFsc28gaGF2ZSBhIGJ1ZyB3aGVuIHRoZSBNYXAgaGFzIGEgc2l6ZSA+IDRcbiAgdGVzdE1hcCA9IG5ldyBFeHBvcnRNYXAoW1xuICAgIFsxLCAwXSxcbiAgICBbMiwgMF0sXG4gICAgWzMsIDBdLFxuICAgIFs0LCAwXVxuICBdKTtcbiAgdGVzdE1hcC5zZXQoLTAsIHRlc3RNYXApO1xuICB2YXIgZ2V0cyA9IHRlc3RNYXAuZ2V0KDApID09PSB0ZXN0TWFwICYmIHRlc3RNYXAuZ2V0KC0wKSA9PT0gdGVzdE1hcDtcbiAgdmFyIG1hcFVzZXNTYW1lVmFsdWVaZXJvID0gZ2V0cyAmJiB0ZXN0TWFwLmhhcygwKSAmJiB0ZXN0TWFwLmhhcygtMCk7XG5cbiAgaWYgKG1hcFVzZXNTYW1lVmFsdWVaZXJvID09PSBmYWxzZSkge1xuICAgIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbiAgfVxufVxuXG5pZiAoRXhwb3J0TWFwICE9PSBNYXBPYmplY3QpIHtcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIHZhciBNeU1hcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHRlc3RNYXAgPSBuZXcgRXhwb3J0TWFwKGFyZyk7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGVzdE1hcCwgTXlNYXAucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiB0ZXN0TWFwO1xuICAgIH07XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKE15TWFwLCBFeHBvcnRNYXApO1xuICAgIE15TWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXhwb3J0TWFwLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogTXlNYXAgfSB9KTtcblxuICAgIHZhciBtYXBTdXBwb3J0c1N1YmNsYXNzaW5nID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RNYXAgPSBuZXcgTXlNYXAoW10pO1xuICAgICAgLy8gRmlyZWZveCAzMiBpcyBvayB3aXRoIHRoZSBpbnN0YW50aWF0aW5nIHRoZSBzdWJjbGFzcyBidXQgd2lsbFxuICAgICAgLy8gdGhyb3cgd2hlbiB0aGUgbWFwIGlzIHVzZWQuXG4gICAgICB0ZXN0TWFwLnNldCg0MiwgNDIpO1xuICAgICAgbWFwU3VwcG9ydHNTdWJjbGFzc2luZyA9IHRlc3RNYXAgaW5zdGFuY2VvZiBNeU1hcDtcbiAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICBpZiAobWFwU3VwcG9ydHNTdWJjbGFzc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbiAgICB9XG4gIH1cbn1cblxuaWYgKEV4cG9ydE1hcCAhPT0gTWFwT2JqZWN0KSB7XG4gIHZhciBtYXBSZXF1aXJlc05ldztcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgIG1hcFJlcXVpcmVzTmV3ID0gKEV4cG9ydE1hcCgpIGluc3RhbmNlb2YgRXhwb3J0TWFwKSA9PT0gZmFsc2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBtYXBSZXF1aXJlc05ldyA9IGUgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gIH1cblxuICBpZiAobWFwUmVxdWlyZXNOZXcgPT09IGZhbHNlKSB7XG4gICAgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xuICB9XG59XG5cbmlmIChFeHBvcnRNYXAgIT09IE1hcE9iamVjdCkge1xuICB0ZXN0TWFwID0gbmV3IEV4cG9ydE1hcCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaWQtbGVuZ3RoXG4gIHZhciBtYXBJdGVyYXRpb25UaHJvd3NTdG9wSXRlcmF0b3I7XG4gIHRyeSB7XG4gICAgbWFwSXRlcmF0aW9uVGhyb3dzU3RvcEl0ZXJhdG9yID0gdGVzdE1hcC5rZXlzKCkubmV4dCgpLmRvbmUgPT09IGZhbHNlO1xuICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICBtYXBJdGVyYXRpb25UaHJvd3NTdG9wSXRlcmF0b3IgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG1hcEl0ZXJhdGlvblRocm93c1N0b3BJdGVyYXRvcikge1xuICAgIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbiAgfVxufVxuXG4vLyBTYWZhcmkgOFxuaWYgKEV4cG9ydE1hcCAhPT0gTWFwT2JqZWN0ICYmIGlzRnVuY3Rpb24obmV3IEV4cG9ydE1hcCgpLmtleXMoKS5uZXh0KSA9PT0gZmFsc2UpIHtcbiAgRXhwb3J0TWFwID0gTWFwT2JqZWN0O1xufVxuXG5pZiAoaGFzUmVhbFN5bWJvbEl0ZXJhdG9yICYmIEV4cG9ydE1hcCAhPT0gTWFwT2JqZWN0KSB7XG4gIHZhciB0ZXN0TWFwUHJvdG8gPSBnZXRQcm90b3R5cGVPZihuZXcgRXhwb3J0TWFwKCkua2V5cygpKTtcbiAgdmFyIGhhc0J1Z2d5TWFwSXRlcmF0b3IgPSB0cnVlO1xuICBpZiAodGVzdE1hcFByb3RvKSB7XG4gICAgaGFzQnVnZ3lNYXBJdGVyYXRvciA9IGlzRnVuY3Rpb24odGVzdE1hcFByb3RvW3N5bUl0XSkgPT09IGZhbHNlO1xuICB9XG5cbiAgaWYgKGhhc0J1Z2d5TWFwSXRlcmF0b3IpIHtcbiAgICBFeHBvcnRNYXAgPSBNYXBPYmplY3Q7XG4gIH1cbn1cblxudmFyIHRlc3RTZXQ7XG5cbmlmIChFeHBvcnRTZXQgIT09IFNldE9iamVjdCkge1xuICB0ZXN0U2V0ID0gbmV3IEV4cG9ydFNldCgpO1xuICBpZiAoaXNOdW1iZXJUeXBlKHRlc3RTZXQuc2l6ZSkgPT09IGZhbHNlIHx8IHRlc3RTZXQuc2l6ZSAhPT0gMCkge1xuICAgIEV4cG9ydE1hcCA9IE1hcE9iamVjdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJvcHNTZXQgPSBbXG4gICAgICAnaGFzJyxcbiAgICAgICdhZGQnLFxuICAgICAgJ2NsZWFyJyxcbiAgICAgICdkZWxldGUnLFxuICAgICAgJ2ZvckVhY2gnLFxuICAgICAgJ3ZhbHVlcycsXG4gICAgICAnZW50cmllcycsXG4gICAgICAna2V5cycsXG4gICAgICBzeW1JdFxuICAgIF07XG5cbiAgICB2YXIgZmFpbGVkU2V0ID0gc29tZShwcm9wc1NldCwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odGVzdFNldFttZXRob2RdKSA9PT0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBpZiAoZmFpbGVkU2V0KSB7XG4gICAgICBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG4gICAgfVxuICB9XG59XG5cbmlmIChFeHBvcnRTZXQgIT09IFNldE9iamVjdCkge1xuICB0ZXN0U2V0ID0gbmV3IEV4cG9ydFNldCgpO1xuICB0ZXN0U2V0WydkZWxldGUnXSgwKTtcbiAgdGVzdFNldC5hZGQoLTApO1xuICB2YXIgc2V0VXNlc1NhbWVWYWx1ZVplcm8gPSB0ZXN0U2V0LmhhcygwKSAmJiB0ZXN0U2V0LmhhcygtMCk7XG4gIGlmIChzZXRVc2VzU2FtZVZhbHVlWmVybyA9PT0gZmFsc2UpIHtcbiAgICBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG4gIH1cbn1cblxuaWYgKEV4cG9ydFNldCAhPT0gU2V0T2JqZWN0KSB7XG4gIHRlc3RTZXQgPSBuZXcgRXhwb3J0U2V0KCk7XG4gIHZhciBzZXRTdXBwb3J0c0NoYWluaW5nID0gdGVzdFNldC5hZGQoMSkgPT09IHRlc3RTZXQ7XG4gIGlmIChzZXRTdXBwb3J0c0NoYWluaW5nID09PSBmYWxzZSkge1xuICAgIEV4cG9ydFNldCA9IFNldE9iamVjdDtcbiAgfVxufVxuXG5pZiAoRXhwb3J0U2V0ICE9PSBTZXRPYmplY3QpIHtcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIHZhciBNeVNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHRlc3RTZXQgPSBuZXcgRXhwb3J0U2V0KGFyZyk7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGVzdFNldCwgTXlTZXQucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiB0ZXN0U2V0O1xuICAgIH07XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKE15U2V0LCBFeHBvcnRTZXQpO1xuICAgIE15U2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXhwb3J0U2V0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogTXlTZXQgfSB9KTtcblxuICAgIHZhciBzZXRTdXBwb3J0c1N1YmNsYXNzaW5nID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTZXQgPSBuZXcgTXlTZXQoW10pO1xuICAgICAgdGVzdFNldC5hZGQoNDIsIDQyKTtcbiAgICAgIHNldFN1cHBvcnRzU3ViY2xhc3NpbmcgPSB0ZXN0U2V0IGluc3RhbmNlb2YgTXlTZXQ7XG4gICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgaWYgKHNldFN1cHBvcnRzU3ViY2xhc3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG4gICAgfVxuICB9XG59XG5cbmlmIChFeHBvcnRTZXQgIT09IFNldE9iamVjdCkge1xuICB2YXIgc2V0UmVxdWlyZXNOZXc7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICBzZXRSZXF1aXJlc05ldyA9IChFeHBvcnRTZXQoKSBpbnN0YW5jZW9mIEV4cG9ydFNldCkgPT09IGZhbHNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2V0UmVxdWlyZXNOZXcgPSBlIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG5cbiAgaWYgKHNldFJlcXVpcmVzTmV3ID09PSBmYWxzZSkge1xuICAgIEV4cG9ydFNldCA9IFNldE9iamVjdDtcbiAgfVxufVxuXG5pZiAoRXhwb3J0U2V0ICE9PSBTZXRPYmplY3QpIHtcbiAgdGVzdFNldCA9IG5ldyBFeHBvcnRTZXQoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxuICB2YXIgc2V0SXRlcmF0aW9uVGhyb3dzU3RvcEl0ZXJhdG9yO1xuICB0cnkge1xuICAgIHNldEl0ZXJhdGlvblRocm93c1N0b3BJdGVyYXRvciA9IHRlc3RTZXQua2V5cygpLm5leHQoKS5kb25lID09PSBmYWxzZTtcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgc2V0SXRlcmF0aW9uVGhyb3dzU3RvcEl0ZXJhdG9yID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzZXRJdGVyYXRpb25UaHJvd3NTdG9wSXRlcmF0b3IpIHtcbiAgICBFeHBvcnRTZXQgPSBTZXRPYmplY3Q7XG4gIH1cbn1cblxuLy8gU2FmYXJpIDhcbmlmIChFeHBvcnRTZXQgIT09IFNldE9iamVjdCAmJiBpc0Z1bmN0aW9uKG5ldyBFeHBvcnRTZXQoKS5rZXlzKCkubmV4dCkgPT09IGZhbHNlKSB7XG4gIEV4cG9ydFNldCA9IFNldE9iamVjdDtcbn1cblxuaWYgKGhhc1JlYWxTeW1ib2xJdGVyYXRvciAmJiBFeHBvcnRTZXQgIT09IFNldE9iamVjdCkge1xuICB2YXIgdGVzdFNldFByb3RvID0gZ2V0UHJvdG90eXBlT2YobmV3IEV4cG9ydFNldCgpLmtleXMoKSk7XG4gIHZhciBoYXNCdWdneVNldEl0ZXJhdG9yID0gdHJ1ZTtcbiAgaWYgKHRlc3RTZXRQcm90bykge1xuICAgIGhhc0J1Z2d5U2V0SXRlcmF0b3IgPSBpc0Z1bmN0aW9uKHRlc3RTZXRQcm90b1tzeW1JdF0pID09PSBmYWxzZTtcbiAgfVxuXG4gIGlmIChoYXNCdWdneVNldEl0ZXJhdG9yKSB7XG4gICAgRXhwb3J0U2V0ID0gU2V0T2JqZWN0O1xuICB9XG59XG5cbnZhciBoYXNDb21tb24gPSBmdW5jdGlvbiBfaGFzQ29tbW9uKG9iamVjdCkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKG9iamVjdCkgJiYgaXNGdW5jdGlvbihvYmplY3Rbc3ltSXRdKSAmJiBpc0Jvb2xlYW4ob2JqZWN0WydbW2NoYW5nZWRdXSddKSAmJiBpc09iamVjdExpa2Uob2JqZWN0WydbW2lkXV0nXSkgJiYgaXNBcnJheShvYmplY3RbJ1tba2V5XV0nXSkgJiYgaXNBcnJheShvYmplY3RbJ1tbb3JkZXJdXSddKSAmJiBpc051bWJlclR5cGUob2JqZWN0LnNpemUpO1xufTtcblxudmFyICRpc01hcDtcbmlmIChFeHBvcnRNYXAgPT09IE1hcE9iamVjdCkge1xuICAkaXNNYXAgPSBmdW5jdGlvbiBfaXNNYXAob2JqZWN0KSB7XG4gICAgaWYgKGlzTWFwKG9iamVjdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNDb21tb24ob2JqZWN0KSAmJiBpc0FycmF5KG9iamVjdFsnW1t2YWx1ZV1dJ10pO1xuICB9O1xufSBlbHNlIHtcbiAgJGlzTWFwID0gaXNNYXA7XG59XG5cbnZhciAkaXNTZXQ7XG5pZiAoRXhwb3J0U2V0ID09PSBTZXRPYmplY3QpIHtcbiAgJGlzU2V0ID0gZnVuY3Rpb24gX2lzU2V0KG9iamVjdCkge1xuICAgIGlmIChpc1NldChvYmplY3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzQ29tbW9uKG9iamVjdCkgJiYgaXNVbmRlZmluZWQob2JqZWN0WydbW3ZhbHVlXV0nXSk7XG4gIH07XG59IGVsc2Uge1xuICAkaXNTZXQgPSBpc1NldDtcbn1cblxuLypcbiAqIEV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYW4gYG9iamVjdGAgaXMgYSBgTWFwYC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGBvYmplY3RgIGlzIGEgYE1hcGAsXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpc01hcCA9IHJlcXVpcmUoJ2NvbGxlY3Rpb25zLXgnKS5pc01hcDtcbiAgICogdmFyIG0gPSBuZXcgTWFwKCk7XG4gICAqXG4gICAqIGlzTWFwKFtdKTsgLy8gZmFsc2VcbiAgICogaXNNYXAodHJ1ZSk7IC8vIGZhbHNlXG4gICAqIGlzTWFwKG0pOyAvLyB0cnVlXG4gICAqL1xuICBpc01hcDogJGlzTWFwLFxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGFuIGBvYmplY3RgIGlzIGEgYFNldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBgb2JqZWN0YCBpcyBhIGBTZXRgLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaXNTZXQgPSByZXF1aXJlKCdjb2xsZWN0aW9ucy14Jyk7XG4gICAqIHZhciBzID0gbmV3IFNldCgpO1xuICAgKlxuICAgKiBpc1NldChbXSk7IC8vIGZhbHNlXG4gICAqIGlzU2V0KHRydWUpOyAvLyBmYWxzZVxuICAgKiBpc1NldChzKTsgLy8gdHJ1ZVxuICAgKi9cbiAgaXNTZXQ6ICRpc1NldCxcbiAgLyoqIEBib3Jyb3dzIE1hcCBhcyBNYXAgKi9cbiAgTWFwOiBFeHBvcnRNYXAsXG4gIC8qKiBAYm9ycm93cyBTZXQgYXMgU2V0ICovXG4gIFNldDogRXhwb3J0U2V0LFxuICAvKipcbiAgICogVGhlIGl0ZXJhdG9yIGlkZW50aWZpZXIgdGhhdCBpcyBpbiB1c2UuXG4gICAqXG4gICAqIHR5cGUge1N5bWJvbHxzdHJpbmd9XG4gICAqL1xuICBzeW1JdDogc3ltSXRcbn07XG4iLCIvKipcbiAqIEBmaWxlIFVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGtleS5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1oYXNvd25wcm9wZXJ0eXw3LjMuMTEgSGFzT3duUHJvcGVydHkgKE8sIFApfVxuICogQHZlcnNpb24gMi4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGhhcy1vd24tcHJvcGVydHkteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2VzLXRvLXByaW1pdGl2ZS9lczYnKTtcbnZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKCdzYWZlLXRvLXN0cmluZy14Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcbnZhciBob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBgaGFzT3duUHJvcGVydHlgIG1ldGhvZCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXJcbiAqIHRoZSBgb2JqZWN0YCBoYXMgdGhlIHNwZWNpZmllZCBgcHJvcGVydHlgLiBEb2VzIG5vdCBhdHRlbXB0IHRvIGZpeCBrbm93blxuICogaXNzdWVzIGluIG9sZGVyIGJyb3dzZXJzLCBidXQgZG9lcyBFUzZpZnkgdGhlIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfFN5bWJvbH0gcHJvcGVydHkgLSBUaGUgbmFtZSBvciBTeW1ib2wgb2YgdGhlIHByb3BlcnR5IHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBzZXQgb24gYG9iamVjdGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaGFzT3duUHJvcGVydHkgPSByZXF1aXJlKCdoYXMtb3duLXByb3BlcnR5LXgnKTtcbiAqIHZhciBvID0ge1xuICogICBmb286ICdiYXInXG4gKiB9O1xuICpcbiAqXG4gKiBoYXNPd25Qcm9wZXJ0eShvLCAnYmFyJyk7IC8vIGZhbHNlXG4gKiBoYXNPd25Qcm9wZXJ0eShvLCAnZm9vJyk7IC8vIHRydWVcbiAqIGhhc093blByb3BlcnR5KHVuZGVmaW5lZCwgJ2ZvbycpO1xuICogICAgICAgICAgICAgICAgICAgLy8gVHlwZUVycm9yOiBDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHZhciBwcm9wID0gaXNTeW1ib2wocHJvcGVydHkpID8gcHJvcGVydHkgOiBzYWZlVG9TdHJpbmcodG9QcmltaXRpdmUocHJvcGVydHksIFN0cmluZykpO1xuXG4gIHJldHVybiBob3AuY2FsbCh0b09iamVjdChvYmplY3QpLCBwcm9wKTtcbn07XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCIvLyBDb25zb2xlLXBvbHlmaWxsLiBNSVQgbGljZW5zZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvY29uc29sZS1wb2x5ZmlsbFxuLy8gTWFrZSBpdCBzYWZlIHRvIGRvIGNvbnNvbGUubG9nKCkgYWx3YXlzLlxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICghZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBnbG9iYWwuY29uc29sZSA9IHt9O1xuICB9XG4gIHZhciBjb24gPSBnbG9iYWwuY29uc29sZTtcbiAgdmFyIHByb3AsIG1ldGhvZDtcbiAgdmFyIGR1bW15ID0gZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHByb3BlcnRpZXMgPSBbJ21lbW9yeSddO1xuICB2YXIgbWV0aG9kcyA9ICgnYXNzZXJ0LGNsZWFyLGNvdW50LGRlYnVnLGRpcixkaXJ4bWwsZXJyb3IsZXhjZXB0aW9uLGdyb3VwLCcgK1xuICAgICAnZ3JvdXBDb2xsYXBzZWQsZ3JvdXBFbmQsaW5mbyxsb2csbWFya1RpbWVsaW5lLHByb2ZpbGUscHJvZmlsZXMscHJvZmlsZUVuZCwnICtcbiAgICAgJ3Nob3csdGFibGUsdGltZSx0aW1lRW5kLHRpbWVsaW5lLHRpbWVsaW5lRW5kLHRpbWVTdGFtcCx0cmFjZSx3YXJuJykuc3BsaXQoJywnKTtcbiAgd2hpbGUgKHByb3AgPSBwcm9wZXJ0aWVzLnBvcCgpKSBpZiAoIWNvbltwcm9wXSkgY29uW3Byb3BdID0ge307XG4gIHdoaWxlIChtZXRob2QgPSBtZXRob2RzLnBvcCgpKSBpZiAoIWNvblttZXRob2RdKSBjb25bbWV0aG9kXSA9IGR1bW15O1xuICAvLyBVc2luZyBgdGhpc2AgZm9yIHdlYiB3b3JrZXJzICYgc3VwcG9ydHMgQnJvd3NlcmlmeSAvIFdlYnBhY2suXG59KSh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHRoaXMgOiB3aW5kb3cpO1xuIiwiLyoqXG4gKiBjdWlkLmpzXG4gKiBDb2xsaXNpb24tcmVzaXN0YW50IFVJRCBnZW5lcmF0b3IgZm9yIGJyb3dzZXJzIGFuZCBub2RlLlxuICogU2VxdWVudGlhbCBmb3IgZmFzdCBkYiBsb29rdXBzIGFuZCByZWNlbmN5IHNvcnRpbmcuXG4gKiBTYWZlIGZvciBlbGVtZW50IElEcyBhbmQgc2VydmVyLXNpZGUgbG9va3Vwcy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSBDTENUUlxuICpcbiAqIENvcHlyaWdodCAoYykgRXJpYyBFbGxpb3R0IDIwMTJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxudmFyIGZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9saWIvZmluZ2VycHJpbnQuanMnKTtcbnZhciBwYWQgPSByZXF1aXJlKCcuL2xpYi9wYWQuanMnKTtcblxudmFyIGMgPSAwLFxuICBibG9ja1NpemUgPSA0LFxuICBiYXNlID0gMzYsXG4gIGRpc2NyZXRlVmFsdWVzID0gTWF0aC5wb3coYmFzZSwgYmxvY2tTaXplKTtcblxuZnVuY3Rpb24gcmFuZG9tQmxvY2sgKCkge1xuICByZXR1cm4gcGFkKChNYXRoLnJhbmRvbSgpICpcbiAgICBkaXNjcmV0ZVZhbHVlcyA8PCAwKVxuICAgIC50b1N0cmluZyhiYXNlKSwgYmxvY2tTaXplKTtcbn1cblxuZnVuY3Rpb24gc2FmZUNvdW50ZXIgKCkge1xuICBjID0gYyA8IGRpc2NyZXRlVmFsdWVzID8gYyA6IDA7XG4gIGMrKzsgLy8gdGhpcyBpcyBub3Qgc3VibGltaW5hbFxuICByZXR1cm4gYyAtIDE7XG59XG5cbmZ1bmN0aW9uIGN1aWQgKCkge1xuICAvLyBTdGFydGluZyB3aXRoIGEgbG93ZXJjYXNlIGxldHRlciBtYWtlc1xuICAvLyBpdCBIVE1MIGVsZW1lbnQgSUQgZnJpZW5kbHkuXG4gIHZhciBsZXR0ZXIgPSAnYycsIC8vIGhhcmQtY29kZWQgYWxsb3dzIGZvciBzZXF1ZW50aWFsIGFjY2Vzc1xuXG4gICAgLy8gdGltZXN0YW1wXG4gICAgLy8gd2FybmluZzogdGhpcyBleHBvc2VzIHRoZSBleGFjdCBkYXRlIGFuZCB0aW1lXG4gICAgLy8gdGhhdCB0aGUgdWlkIHdhcyBjcmVhdGVkLlxuICAgIHRpbWVzdGFtcCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkudG9TdHJpbmcoYmFzZSksXG5cbiAgICAvLyBQcmV2ZW50IHNhbWUtbWFjaGluZSBjb2xsaXNpb25zLlxuICAgIGNvdW50ZXIgPSBwYWQoc2FmZUNvdW50ZXIoKS50b1N0cmluZyhiYXNlKSwgYmxvY2tTaXplKSxcblxuICAgIC8vIEEgZmV3IGNoYXJzIHRvIGdlbmVyYXRlIGRpc3RpbmN0IGlkcyBmb3IgZGlmZmVyZW50XG4gICAgLy8gY2xpZW50cyAoc28gZGlmZmVyZW50IGNvbXB1dGVycyBhcmUgZmFyIGxlc3NcbiAgICAvLyBsaWtlbHkgdG8gZ2VuZXJhdGUgdGhlIHNhbWUgaWQpXG4gICAgcHJpbnQgPSBmaW5nZXJwcmludCgpLFxuXG4gICAgLy8gR3JhYiBzb21lIG1vcmUgY2hhcnMgZnJvbSBNYXRoLnJhbmRvbSgpXG4gICAgcmFuZG9tID0gcmFuZG9tQmxvY2soKSArIHJhbmRvbUJsb2NrKCk7XG5cbiAgcmV0dXJuIGxldHRlciArIHRpbWVzdGFtcCArIGNvdW50ZXIgKyBwcmludCArIHJhbmRvbTtcbn1cblxuY3VpZC5zbHVnID0gZnVuY3Rpb24gc2x1ZyAoKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoMzYpLFxuICAgIGNvdW50ZXIgPSBzYWZlQ291bnRlcigpLnRvU3RyaW5nKDM2KS5zbGljZSgtNCksXG4gICAgcHJpbnQgPSBmaW5nZXJwcmludCgpLnNsaWNlKDAsIDEpICtcbiAgICAgIGZpbmdlcnByaW50KCkuc2xpY2UoLTEpLFxuICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkuc2xpY2UoLTIpO1xuXG4gIHJldHVybiBkYXRlLnNsaWNlKC0yKSArXG4gICAgY291bnRlciArIHByaW50ICsgcmFuZG9tO1xufTtcblxuY3VpZC5pc0N1aWQgPSBmdW5jdGlvbiBpc0N1aWQgKHN0cmluZ1RvQ2hlY2spIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUb0NoZWNrICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICBpZiAoc3RyaW5nVG9DaGVjay5zdGFydHNXaXRoKCdjJykpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jdWlkLmlzU2x1ZyA9IGZ1bmN0aW9uIGlzU2x1ZyAoc3RyaW5nVG9DaGVjaykge1xuICBpZiAodHlwZW9mIHN0cmluZ1RvQ2hlY2sgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBzdHJpbmdUb0NoZWNrLmxlbmd0aDtcbiAgaWYgKHN0cmluZ0xlbmd0aCA+PSA3ICYmIHN0cmluZ0xlbmd0aCA8PSAxMCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmN1aWQuZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcblxubW9kdWxlLmV4cG9ydHMgPSBjdWlkO1xuIiwidmFyIHBhZCA9IHJlcXVpcmUoJy4vcGFkLmpzJyk7XG5cbnZhciBlbnYgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHNlbGY7XG52YXIgZ2xvYmFsQ291bnQgPSBPYmplY3Qua2V5cyhlbnYpLmxlbmd0aDtcbnZhciBtaW1lVHlwZXNMZW5ndGggPSBuYXZpZ2F0b3IubWltZVR5cGVzID8gbmF2aWdhdG9yLm1pbWVUeXBlcy5sZW5ndGggOiAwO1xudmFyIGNsaWVudElkID0gcGFkKChtaW1lVHlwZXNMZW5ndGggK1xuICBuYXZpZ2F0b3IudXNlckFnZW50Lmxlbmd0aCkudG9TdHJpbmcoMzYpICtcbiAgZ2xvYmFsQ291bnQudG9TdHJpbmcoMzYpLCA0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5nZXJwcmludCAoKSB7XG4gIHJldHVybiBjbGllbnRJZDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhZCAobnVtLCBzaXplKSB7XG4gIHZhciBzID0gJzAwMDAwMDAwMCcgKyBudW07XG4gIHJldHVybiBzLnN1YnN0cihzLmxlbmd0aCAtIHNpemUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJ2ZvbycpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIG9yaWdEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBhcmVQcm9wZXJ0eURlc2NyaXB0b3JzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgb2JqID0ge307XG5cdHRyeSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycywgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0XHRmb3IgKHZhciBfIGluIG9iaikgeyAvLyBqc2NzOmlnbm9yZSBkaXNhbGxvd1VudXNlZFZhcmlhYmxlc1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqLnggPT09IG9iajtcblx0fSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIElFIDguICovXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBvcmlnRGVmaW5lUHJvcGVydHkgJiYgYXJlUHJvcGVydHlEZXNjcmlwdG9yc1N1cHBvcnRlZCgpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCAmJiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BzW2ldLCBtYXBbcHJvcHNbaV1dLCBwcmVkaWNhdGVzW3Byb3BzW2ldXSk7XG5cdH1cbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1ByaW1pdGl2ZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCdpcy1jYWxsYWJsZScpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcblxudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBmdW5jdGlvbiBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpIHtcblx0aWYgKHR5cGVvZiBPID09PSAndW5kZWZpbmVkJyB8fCBPID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyBPKTtcblx0fVxuXHRpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IChoaW50ICE9PSAnbnVtYmVyJyAmJiBoaW50ICE9PSAnc3RyaW5nJykpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG5cdH1cblx0dmFyIG1ldGhvZE5hbWVzID0gaGludCA9PT0gJ3N0cmluZycgPyBbJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnXSA6IFsndmFsdWVPZicsICd0b1N0cmluZyddO1xuXHR2YXIgbWV0aG9kLCByZXN1bHQsIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuXHRcdG1ldGhvZCA9IE9bbWV0aG9kTmFtZXNbaV1dO1xuXHRcdGlmIChpc0NhbGxhYmxlKG1ldGhvZCkpIHtcblx0XHRcdHJlc3VsdCA9IG1ldGhvZC5jYWxsKE8pO1xuXHRcdFx0aWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xufTtcblxudmFyIEdldE1ldGhvZCA9IGZ1bmN0aW9uIEdldE1ldGhvZChPLCBQKSB7XG5cdHZhciBmdW5jID0gT1tQXTtcblx0aWYgKGZ1bmMgIT09IG51bGwgJiYgdHlwZW9mIGZ1bmMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0aWYgKCFpc0NhbGxhYmxlKGZ1bmMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bmMgKyAnIHJldHVybmVkIGZvciBwcm9wZXJ0eSAnICsgUCArICcgb2Ygb2JqZWN0ICcgKyBPICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuYztcblx0fVxuXHRyZXR1cm4gdm9pZCAwO1xufTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG5cdGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblx0dmFyIGhpbnQgPSAnZGVmYXVsdCc7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdGlmIChhcmd1bWVudHNbMV0gPT09IFN0cmluZykge1xuXHRcdFx0aGludCA9ICdzdHJpbmcnO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzWzFdID09PSBOdW1iZXIpIHtcblx0XHRcdGhpbnQgPSAnbnVtYmVyJztcblx0XHR9XG5cdH1cblxuXHR2YXIgZXhvdGljVG9QcmltO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdGlmIChTeW1ib2wudG9QcmltaXRpdmUpIHtcblx0XHRcdGV4b3RpY1RvUHJpbSA9IEdldE1ldGhvZChpbnB1dCwgU3ltYm9sLnRvUHJpbWl0aXZlKTtcblx0XHR9IGVsc2UgaWYgKGlzU3ltYm9sKGlucHV0KSkge1xuXHRcdFx0ZXhvdGljVG9QcmltID0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mO1xuXHRcdH1cblx0fVxuXHRpZiAodHlwZW9mIGV4b3RpY1RvUHJpbSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIGhpbnQpO1xuXHRcdGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmFibGUgdG8gY29udmVydCBleG90aWMgb2JqZWN0IHRvIHByaW1pdGl2ZScpO1xuXHR9XG5cdGlmIChoaW50ID09PSAnZGVmYXVsdCcgJiYgKGlzRGF0ZShpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSkge1xuXHRcdGhpbnQgPSAnc3RyaW5nJztcblx0fVxuXHRyZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgaGludCA9PT0gJ2RlZmF1bHQnID8gJ251bWJlcicgOiBoaW50KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9lczIwMTUnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcblxudmFyIGFyciA9IFtdXG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlcikge1xuICBkZWNpcmMob2JqLCAnJywgW10sIHVuZGVmaW5lZClcbiAgdmFyIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcilcbiAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZnVuY3Rpb24gZGVjaXJjICh2YWwsIGssIHN0YWNrLCBwYXJlbnQpIHtcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgcGFyZW50W2tdID0gJ1tDaXJjdWxhcl0nXG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIHN0YWNrLCB2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIHN0YWNrLCB2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cbn1cblxuLy8gU3RhYmxlLXN0cmluZ2lmeVxuZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChhID4gYikge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSAob2JqLCByZXBsYWNlciwgc3BhY2VyKSB7XG4gIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgJycsIFtdLCB1bmRlZmluZWQpIHx8IG9ialxuICB2YXIgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmMgKHZhbCwgaywgc3RhY2ssIHBhcmVudCkge1xuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBwYXJlbnRba10gPSAnW0NpcmN1bGFyXSdcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIHN0YWNrLCB2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgdmFyIHRtcCA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIHN0YWNrLCB2YWwpXG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICAgICAgICBwYXJlbnRba10gPSB0bXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXBcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuIiwiLyoqXG4gKiBAZmlsZSBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZmluZC1pbmRleC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcEZpbmRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXg7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zcGFyc2UtYXJyYXlzXG52YXIgaW1wbGVtZW50ZWQgPSBwRmluZEluZGV4ICYmIChbLCAxXS5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xuICByZXR1cm4gaWR4ID09PSAwO1xufSkgPT09IDApO1xuXG52YXIgZmluZElkeDtcbmlmIChpbXBsZW1lbnRlZCkge1xuICBmaW5kSWR4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gW2NhbGxiYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBGaW5kSW5kZXguYXBwbHkoYXJyYXksIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbiAgdmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG4gIHZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcbiAgdmFyIHNwbGl0U3RyaW5nID0gcmVxdWlyZSgnaGFzLWJveGVkLXN0cmluZy14JykgPT09IGZhbHNlO1xuXG4gIGZpbmRJZHggPSBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgICBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxiYWNrKTtcbiAgICB2YXIgaXRlcmFibGUgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyhvYmplY3QpID8gb2JqZWN0LnNwbGl0KCcnKSA6IG9iamVjdDtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciB0aGlzQXJnO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xufVxuXG4vKipcbiAqIExpa2UgYGZpbmRJbmRleGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYW4gaW5kZXggaW4gdGhlIGFycmF5LCBpZiBhbiBlbGVtZW50XG4gKiBpbiB0aGUgYXJyYXkgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLiBPdGhlcndpc2UgLTEgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcnJheSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXksXG4gKiAgdGFraW5nIHRocmVlIGFyZ3VtZW50czogYGVsZW1lbnRgLCBgaW5kZXhgIGFuZCBgYXJyYXlgLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgY2FsbGJhY2tgIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBpbmRleCBvZiBwb3NpdGl2ZWx5IHRlc3RlZCBlbGVtZW50LCBvdGhlcndpc2UgLTEuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJ2ZpbmQtaW5kZXgteCcpO1xuICpcbiAqIGZ1bmN0aW9uIGlzUHJpbWUoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gKiAgIHZhciBzdGFydCA9IDI7XG4gKiAgIHdoaWxlIChzdGFydCA8PSBNYXRoLnNxcnQoZWxlbWVudCkpIHtcbiAqICAgICBpZiAoZWxlbWVudCAlIHN0YXJ0KysgPCAxKSB7XG4gKiAgICAgICByZXR1cm4gZmFsc2U7XG4gKiAgICAgfVxuICogICB9XG4gKiAgIHJldHVybiBlbGVtZW50ID4gMTtcbiAqIH1cbiAqXG4gKiBjb25zb2xlLmxvZyhmaW5kSW5kZXgoWzQsIDYsIDgsIDEyLCAxNF0sIGlzUHJpbWUpKTsgLy8gLTEsIG5vdCBmb3VuZFxuICogY29uc29sZS5sb2coZmluZEluZGV4KFs0LCA2LCA3LCAxMiwgMTNdLCBpc1ByaW1lKSk7IC8vIDJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmaW5kSWR4O1xuIiwiXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAob2JqLCBmbiwgY3R4KSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgbCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGwgPT09ICtsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiIsIi8vIHRoZXNlIGFyZSBrbm93biBhcyBcInBsYWNlaG9sZGVyIHRva2Vuc1wiLCBzZWUgdGhpcyBsaW5rIGZvciBtb3JlIGluZm86XG4vLyA8aHR0cHM6Ly9ub2RlanMub3JnL2FwaS91dGlsLmh0bWwjdXRpbF91dGlsX2Zvcm1hdF9mb3JtYXRfYXJncz5cbi8vXG4vLyBzaW5jZSB0aGV5IGFyZW4ndCBleHBvc2VkIChvciBkb24ndCBzZWVtIHRvIGJlKSBieSBub2RlIChhdCBsZWFzdCBub3QgeWV0KVxuLy8gd2UganVzdCBkZWZpbmUgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGVtIGZvciBub3dcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzE3NjAxPlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzdhZjFhZDBlYzE1NTQ2NzYxMjMzYzJlOTAwMDgzMTY1NTFkYjJiYmQvZG9jL2FwaS91dGlsLm1kI3V0aWxmb3JtYXRmb3JtYXQtYXJncz5cbm1vZHVsZS5leHBvcnRzID0gWyclcycsICclZCcsICclaScsICclZicsICclaicsICclbycsICclTycsICclJSddO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIvKipcbiAqIEBmaWxlIEdldCB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LWZ1bmN0aW9uLW5hbWUteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbi14Jyk7XG52YXIgZnVuY3Rpb25DdHIgPSBmdW5jdGlvbiAoKSB7fS5jb25zdHJ1Y3RvcjtcblxudmFyIGdldE5hbWU7XG52YXIgdCA9IGZ1bmN0aW9uIHRlc3QxKCkge307XG5pZiAodC5uYW1lID09PSAndGVzdDEnKSB7XG4gIHZhciBjcmVhdGVzQW5vbnltb3VzID0gZnVuY3Rpb25DdHIoKS5uYW1lID09PSAnYW5vbnltb3VzJztcbiAgZ2V0TmFtZSA9IGZ1bmN0aW9uIF9nZXROYW1lKGZuKSB7XG4gICAgcmV0dXJuIGNyZWF0ZXNBbm9ueW1vdXMgJiYgZm4ubmFtZSA9PT0gJ2Fub255bW91cycgPyAnJyA6IGZuLm5hbWU7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgcmVwbGFjZUNvbW1lbnRzID0gcmVxdWlyZSgncmVwbGFjZS1jb21tZW50cy14Jyk7XG4gIHZhciBmVG9TdHJpbmcgPSBmdW5jdGlvbkN0ci5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBub3JtYWxpc2UgPSByZXF1aXJlKCdub3JtYWxpemUtc3BhY2UteCcpLm5vcm1hbGl6ZVNwYWNlMjAxODtcbiAgdmFyIHJlTmFtZSA9IC9eKD86YXN5bmMgKT8oPzpmdW5jdGlvbnxjbGFzcykgPyg/OlxcKiApPyhbXFx3JF0rKS9pO1xuICB2YXIgc3RyaW5nTWF0Y2ggPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5TdHJpbmcucHJvdG90eXBlLm1hdGNoO1xuICBnZXROYW1lID0gZnVuY3Rpb24gX2dldE5hbWUoZm4pIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgIG1hdGNoID0gc3RyaW5nTWF0Y2guY2FsbChub3JtYWxpc2UocmVwbGFjZUNvbW1lbnRzKGZUb1N0cmluZy5jYWxsKGZuKSwgJyAnKSksIHJlTmFtZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdhbm9ueW1vdXMnID8gJycgOiBuYW1lO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgIHJldHVybiAnJztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiwgb3IgYHVuZGVmaW5lZGAgaWYgbm90XG4gKiBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgbmFtZSBvZi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24sICBvciBgdW5kZWZpbmVkYCBpZlxuICogIG5vdCBhIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBnZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCdnZXQtZnVuY3Rpb24tbmFtZS14Jyk7XG4gKlxuICogZ2V0RnVuY3Rpb25OYW1lKCk7IC8vIHVuZGVmaW5lZFxuICogZ2V0RnVuY3Rpb25OYW1lKE51bWJlci5NSU5fVkFMVUUpOyAvLyB1bmRlZmluZWRcbiAqIGdldEZ1bmN0aW9uTmFtZSgnYWJjJyk7IC8vIHVuZGVmaW5lZFxuICogZ2V0RnVuY3Rpb25OYW1lKHRydWUpOyAvLyB1bmRlZmluZWRcbiAqIGdldEZ1bmN0aW9uTmFtZSh7IG5hbWU6ICdhYmMnIH0pOyAvLyB1bmRlZmluZWRcbiAqIGdldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiAoKSB7fSk7IC8vICcnXG4gKiBnZXRGdW5jdGlvbk5hbWUobmV3IEZ1bmN0aW9uICgpKTsgLy8gJydcbiAqIGdldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiB0ZXN0MSgpIHt9KTsgLy8gJ3Rlc3QxJ1xuICogZ2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uKiB0ZXN0MigpIHt9KTsgLy8gJ3Rlc3QyJ1xuICogZ2V0RnVuY3Rpb25OYW1lKGNsYXNzIFRlc3Qge30pOyAvLyAnVGVzdCdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZm4sIHRydWUpID8gZ2V0TmFtZShmbikgOiB2b2lkIDA7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBMaWtlIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgYnV0IGdldHMgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKiBAdmVyc2lvbiAxLjAuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LW93bi1lbnVtZXJhYmxlLXByb3BlcnR5LXN5bWJvbHMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCdhcnJheS1maWx0ZXIteCcpO1xudmFyIGdldE9QUyA9IHJlcXVpcmUoJ2dldC1vd24tcHJvcGVydHktc3ltYm9scy14Jyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSByZXF1aXJlKCdwcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIG9ubHkgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnR5IHN5bWJvbHMgb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0LlxuICogQHRocm93cyB7dHlwZUVycm9yfSAtIElmIHRhcmdldCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGVudW1lcmFibGUgb3duIHByb3BlcnR5IHN5bWJvbHMuXG4gKiBAZXhhbXBsZVxuICogdmFyIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgPSByZXF1aXJlKCdnZXQtb3duLWVudW1lcmFibGUtcHJvcGVydHktc3ltYm9scy14Jyk7XG4gKlxuICogdmFyIG9iaiA9IHsgYmFyOiAxLCBmb286IDIgfTtcbiAqXG4gKiB2YXIgc3ltYm9sMSA9IFN5bWJvbCgnZmlyc3QnKTtcbiAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHN5bWJvMWwsIHtcbiAqICAgZW51bWVyYWJsZTogZmFsc2UsXG4gKiAgIHZhbHVlOiAnZmlyc3QnXG4gKiB9KTtcbiAqXG4gKiB2YXIgc3ltYm9sMiA9IFN5bWJvbCgnc2Vjb25kJyk7XG4gKiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBzeW1ib2wyLCB7XG4gKiAgIGVudW1lcmFibGU6IHRydWUsXG4gKiAgIHZhbHVlOiAnc2Vjb25kJ1xuICogfSk7XG4gKlxuICogZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyhvYmopOyAvLyBbc3ltYm9sMl1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgcmV0dXJuIGZpbHRlcihnZXRPUFMob2JqZWN0KSwgZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZShvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcbiIsIi8qKlxuICogQGZpbGUgQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHZlcnNpb24gMi4zLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGFycmF5LWZpbHRlci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FjaGVkQ3RycyA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpO1xudmFyIEFycmF5Q3RyID0gY2FjaGVkQ3Rycy5BcnJheTtcbnZhciBjYXN0T2JqZWN0ID0gY2FjaGVkQ3Rycy5PYmplY3Q7XG52YXIgbmF0aXZGaWx0ZXIgPSB0eXBlb2YgQXJyYXlDdHIucHJvdG90eXBlLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheUN0ci5wcm90b3R5cGUuZmlsdGVyO1xuXG52YXIgaXNXb3JraW5nO1xuaWYgKG5hdGl2RmlsdGVyKSB7XG4gIHZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gIHZhciBzcHkgPSAwO1xuICB2YXIgcmVzID0gYXR0ZW1wdC5jYWxsKFsxLCAyXSwgbmF0aXZGaWx0ZXIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgc3B5ICs9IGl0ZW07XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAwICYmIHNweSA9PT0gMztcblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgc3B5ID0gJyc7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKGNhc3RPYmplY3QoJ2FiYycpLCBuYXRpdkZpbHRlciwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICBzcHkgKz0gaXRlbTtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gMTtcbiAgICB9KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDEgJiYgcmVzLnZhbHVlWzBdID09PSAnYicgJiYgc3B5ID09PSAnYWJjJztcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSAwO1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCgoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICB9KDEsIDIsIDMpKSwgbmF0aXZGaWx0ZXIsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgc3B5ICs9IGl0ZW07XG4gICAgICByZXR1cm4gaW5kZXggPT09IDI7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAxICYmIHJlcy52YWx1ZVswXSA9PT0gMyAmJiBzcHkgPT09IDY7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgc3B5ID0gMDtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoe1xuICAgICAgMDogMSxcbiAgICAgIDE6IDIsXG4gICAgICAzOiAzLFxuICAgICAgNDogNCxcbiAgICAgIGxlbmd0aDogNFxuICAgIH0sIG5hdGl2RmlsdGVyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc3B5ICs9IGl0ZW07XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAwICYmIHNweSA9PT0gNjtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICBzcHkgPSBudWxsO1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKGZyYWdtZW50LmNoaWxkTm9kZXMsIG5hdGl2RmlsdGVyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBzcHkgPSBpdGVtO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuXG4gICAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSAmJiByZXMudmFsdWUubGVuZ3RoID09PSAxICYmIHJlcy52YWx1ZVswXSA9PT0gZGl2ICYmIHNweSA9PT0gZGl2O1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgaXNTdHJpY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcykgPT09IGZhbHNlO1xuICAgIH0oKSk7XG5cbiAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgIHNweSA9IG51bGw7XG4gICAgICByZXMgPSBhdHRlbXB0LmNhbGwoWzFdLCBuYXRpdkZpbHRlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gICAgICAgIHNweSA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgIH0sICd4Jyk7XG5cbiAgICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDAgJiYgc3B5ID09PSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICBzcHkgPSB7fTtcbiAgICB2YXIgZm4gPSBbXG4gICAgICAncmV0dXJuIG5hdGl2RmlsdGVyLmNhbGwoXCJmb29cIiwgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7JyxcbiAgICAgICdpZiAoQm9vbGVhbihjb250ZXh0KSA9PT0gZmFsc2UgfHwgdHlwZW9mIGNvbnRleHQgIT09IFwib2JqZWN0XCIpIHsnLFxuICAgICAgJ3NweS52YWx1ZSA9IHRydWU7fX0pOydcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgcmVzID0gYXR0ZW1wdChGdW5jdGlvbignbmF0aXZGaWx0ZXInLCAnc3B5JywgZm4pLCBuYXRpdkZpbHRlciwgc3B5KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlICYmIHJlcy52YWx1ZS5sZW5ndGggPT09IDAgJiYgc3B5LnZhbHVlICE9PSB0cnVlO1xuICB9XG59XG5cbnZhciAkZmlsdGVyO1xuaWYgKG5hdGl2RmlsdGVyKSB7XG4gICRmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoYXJyYXksIGNhbGxCYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBhcmdzID0gW2NhbGxCYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2RmlsdGVyLmFwcGx5KGFycmF5LCBhcmdzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBzcGxpdElmQm94ZWRCdWcgPSByZXF1aXJlKCdzcGxpdC1pZi1ib3hlZC1idWcteCcpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpLnRvTGVuZ3RoMjAxODtcbiAgdmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBhc3NlcnRJc0Z1bmN0aW9uID0gcmVxdWlyZSgnYXNzZXJ0LWlzLWZ1bmN0aW9uLXgnKTtcblxuICAkZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGFycmF5LCBjYWxsQmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsQmFjayk7XG4gICAgdmFyIGl0ZXJhYmxlID0gc3BsaXRJZkJveGVkQnVnKG9iamVjdCk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7XG4gICAgdmFyIHRoaXNBcmc7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuICAgIH1cblxuICAgIHZhciBub1RoaXMgPSBpc1VuZGVmaW5lZCh0aGlzQXJnKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgaW4gaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgaWYgKG5vVGhpcyA/IGNhbGxCYWNrKGl0ZW0sIGksIG9iamVjdCkgOiBjYWxsQmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxCYWNrIC0gRnVuY3Rpb24gaXMgYSBwcmVkaWNhdGUsIHRvIHRlc3QgZWFjaCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gLSBWYWx1ZSB0byB1c2UgYXMgdGhpcyB3aGVuIGV4ZWN1dGluZyBjYWxsYmFjay5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMge2FycmF5fSBBIG5ldyBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgdGhlIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZpbHRlciA9IHJlcXVpcmUoJ2FycmF5LWZpbHRlci14Jyk7XG4gKlxuICogZnVuY3Rpb24gaXNCaWdFbm91Z2godmFsdWUpIHtcbiAqICAgcmV0dXJuIHZhbHVlID49IDEwO1xuICogfVxuICpcbiAqIHZhciBmaWx0ZXJlZCA9IGZpbHRlcihbMTIsIDUsIDgsIDEzMCwgNDRdLCBpc0JpZ0Vub3VnaCk7XG4gKiAvLyBmaWx0ZXJlZCBpcyBbMTIsIDEzMCwgNDRdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGZpbHRlcjtcbiIsIi8qKlxuICogQGZpbGUgQ3JlYXRlcyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyAoZW51bWVyYWJsZSBvciBub3QpIGZvdW5kIGRpcmVjdGx5IHVwb24gYSBnaXZlbiBvYmplY3QuXG4gKiBAdmVyc2lvbiAxLjAuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIG5hdGl2ZUdPUE4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcblxudmFyICRnb3BuO1xuaWYgKHR5cGVvZiBuYXRpdmVHT1BOID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbiAgdmFyIG9iamVjdEdPUE5BY2NlcHRzUHJpbWl0aXZlcztcbiAgdHJ5IHtcbiAgICBuYXRpdmVHT1BOKCdmb28nKTtcbiAgICBvYmplY3RHT1BOQWNjZXB0c1ByaW1pdGl2ZXMgPSB0cnVlO1xuICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgaWYgKG9iamVjdEdPUE5BY2NlcHRzUHJpbWl0aXZlcykge1xuICAgICRnb3BuID0gbmF0aXZlR09QTjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCd0by1zdHJpbmctdGFnLXgnKTtcbiAgICB2YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbiAgICB2YXIgY2FjaGVkV2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IG5hdGl2ZUdPUE4od2luZG93KSA6IFtdO1xuXG4gICAgJGdvcG4gPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgICAgdmFyIHZhbCA9IHRvT2JqZWN0KG9iaik7XG4gICAgICBpZiAodG9TdHJpbmdUYWcodmFsKSA9PT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlR09QTih2YWwpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgICAvLyBJRSBidWcgd2hlcmUgbGF5b3V0IGVuZ2luZSBjYWxscyB1c2VybGFuZCBnT1BOIGZvciBjcm9zcy1kb21haW4gYHdpbmRvd2Agb2JqZWN0c1xuICAgICAgICAgIHJldHVybiBjb25jYXQuY2FsbChbXSwgY2FjaGVkV2luZG93TmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVHT1BOKHZhbCk7XG4gICAgfTtcbiAgfVxufSBlbHNlIHtcbiAgdmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cy14Jyk7XG4gICRnb3BuID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhvYmopO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgKGVudW1lcmFibGUgb3Igbm90KSBmb3VuZFxuICogZGlyZWN0bHkgdXBvbiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBvd25cbiAqICBwcm9wZXJ0aWVzIGFyZSB0byBiZSByZXR1cm5lZC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGFyZ2V0IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgcHJvcGVydGllcyBmb3VuZFxuICogIGRpcmVjdGx5IHVwb24gdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0T3duUHJvcGVydHlOYW1lID0gcmVxdWlyZSgnZ2V0LW93bi1wcm9wZXJ0eS1uYW1lLXgnKTtcbiAqXG4gKiBnZXRPd25Qcm9wZXJ0eU5hbWVzKCdmb28nKTsgLy8gW1wiMFwiLCBcIjFcIiwgXCIyXCIsIFwibGVuZ3RoXCJdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJGdvcG47XG4iLCIvKipcbiAqIEBmaWxlIENyZWF0ZXMgYW4gYXJyYXkgb2YgYWxsIHN5bWJvbCBwcm9wZXJ0aWVzIGZvdW5kIGRpcmVjdGx5IHVwb24gYSBnaXZlbiBvYmplY3QuXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgbmF0aXZlR09QUyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaXNXb3JraW5nO1xuaWYgKHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14JykgJiYgbmF0aXZlR09QUyAmJiB0eXBlb2YgbmF0aXZlR09QUyA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCcnKTtcbiAgdmFyIHRlc3RPYmogPSB7IGE6IDEgfTtcbiAgdGVzdE9ialtzeW1ib2xdID0gMjtcbiAgdmFyIHIgPSByZXF1aXJlKCdhdHRlbXB0LXgnKShuYXRpdmVHT1BTLCB0ZXN0T2JqKTtcbiAgaXNXb3JraW5nID0gci50aHJldyA9PT0gZmFsc2UgJiYgci52YWx1ZSAmJiByLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiByLnZhbHVlWzBdID09PSBzeW1ib2w7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY3JlYXRlcyBhbiBhcnJheSBvZiBhbGwgc3ltYm9sIHByb3BlcnRpZXMgZm91bmQgZGlyZWN0bHkgdXBvbiBhXG4gKiBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3Qgd2hvc2Ugc3ltYm9sIHByb3BlcnRpZXMgYXJlIHRvIGJlIHJldHVybmVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGFsbCBzeW1ib2wgcHJvcGVydGllcyBmb3VuZCBkaXJlY3RseSB1cG9uIHRoZVxuICogIGdpdmVuIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnZ2V0LW93bi1wcm9wZXJ0eS1pc1dvcmtpbmcteCcpO1xuICpcbiAqIHZhciBzeW1ib2wgPSBTeW1ib2woJycpO1xuICogdmFyIHRlc3RPYmogPSB7IGE6IDEgfTtcbiAqIHRlc3RPYmpbc3ltYm9sXSA9IDI7XG4gKiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHModGVzdE9iaik7IC8vIFtzeW1ib2xdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3Qob2JqKTtcbiAgcmV0dXJuIGlzV29ya2luZyA/IG5hdGl2ZUdPUFMob2JqZWN0KSA6IFtdO1xufTtcbiIsIi8qKlxuICogQGZpbGUgU2hhbSBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gKiBAdmVyc2lvbiAxLjQuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LXByb3RvdHlwZS1vZi14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uLXgnKTtcbnZhciBpc051bGwgPSByZXF1aXJlKCdsb2Rhc2guaXNudWxsJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIGdwbyA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuaWYgKGdwbykge1xuICB0cnkge1xuICAgIGdwbyA9IGdwbyhPYmplY3QpID09PSBPYmplY3QucHJvdG90eXBlICYmIGdwbztcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgZ3BvID0gbnVsbDtcbiAgfVxufVxuXG5pZiAoZ3BvKSB7XG4gIHRyeSB7XG4gICAgZ3BvKDEpO1xuICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICB2YXIgJGdldFByb3RvdHlwZU9mID0gZ3BvO1xuICAgIGdwbyA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iaikge1xuICAgICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChvYmopKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICBncG8gPSBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihvYmopIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3Qob2JqKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cbiAgICB2YXIgcHJvdG8gPSBvYmplY3QuX19wcm90b19fO1xuICAgIGlmIChwcm90byB8fCBpc051bGwocHJvdG8pKSB7XG4gICAgICByZXR1cm4gcHJvdG87XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqZWN0LmNvbnN0cnVjdG9yKSkge1xuICAgICAgcmV0dXJuIG9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgcHJvdG90eXBlIChpLmUuIHRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJuYWwgW1tQcm90b3R5cGVdXSBwcm9wZXJ0eSlcbiAqIG9mIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIG9iamVjdCB3aG9zZSBwcm90b3R5cGUgaXMgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvdG90eXBlIG9mIHRoZSBnaXZlbiBvYmplY3QuIElmIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgcHJvcGVydGllcywgbnVsbCBpcyByZXR1cm5lZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdnZXQtcHJvdG90eXBlLW9mLXgnKTtcbiAqIGdldFByb3RvdHlwZU9mKCdmb28nKTsgLy8gU3RyaW5nLnByb3RvdHlwZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGdwbztcbiIsIi8qKlxuICogQGZpbGUgQ2hlY2sgc3VwcG9ydCBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMuXG4gKiBAdmVyc2lvbiAxLjEuMVxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaGFzLWJveGVkLXN0cmluZy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYm94ZWRTdHJpbmcgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5PYmplY3QoJ2EnKTtcblxuLyoqXG4gKiBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuICogYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubykuXG4gKlxuICogYHRydWVgIGlmIG5vIGZhaWx1cmU7IG90aGVyd2lzZSBgZmFsc2VgLlxuICpcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBib3hlZFN0cmluZ1swXSA9PT0gJ2EnICYmICgwIGluIGJveGVkU3RyaW5nKTtcbiIsIi8qKlxuICogQGZpbGUgVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkga2V5LlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWhhc293bnByb3BlcnR5fDcuMy4xMSBIYXNPd25Qcm9wZXJ0eSAoTywgUCl9XG4gKiBAdmVyc2lvbiAzLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaGFzLW93bi1wcm9wZXJ0eS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCd0by1wcm9wZXJ0eS1rZXkteCcpO1xudmFyIGhvcCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGBoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kIHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlclxuICogdGhlIGBvYmplY3RgIGhhcyB0aGUgc3BlY2lmaWVkIGBwcm9wZXJ0eWAuIERvZXMgbm90IGF0dGVtcHQgdG8gZml4IGtub3duXG4gKiBpc3N1ZXMgaW4gb2xkZXIgYnJvd3NlcnMsIGJ1dCBkb2VzIEVTNmlmeSB0aGUgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBvYmplY3QgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge3N0cmluZ3xTeW1ib2x9IHByb3BlcnR5IC0gVGhlIG5hbWUgb3IgU3ltYm9sIG9mIHRoZSBwcm9wZXJ0eSB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgc2V0IG9uIGBvYmplY3RgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGhhc093blByb3BlcnR5ID0gcmVxdWlyZSgnaGFzLW93bi1wcm9wZXJ0eS14Jyk7XG4gKiB2YXIgbyA9IHtcbiAqICAgZm9vOiAnYmFyJ1xuICogfTtcbiAqXG4gKlxuICogaGFzT3duUHJvcGVydHkobywgJ2JhcicpOyAvLyBmYWxzZVxuICogaGFzT3duUHJvcGVydHkobywgJ2ZvbycpOyAvLyB0cnVlXG4gKiBoYXNPd25Qcm9wZXJ0eSh1bmRlZmluZWQsICdmb28nKTtcbiAqICAgICAgICAgICAgICAgICAgIC8vIFR5cGVFcnJvcjogQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gaG9wLmNhbGwodG9PYmplY3Qob2JqZWN0KSwgdG9Qcm9wZXJ0eUtleShwcm9wZXJ0eSkpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGVzdHMgaWYgRVM2IFJlZmxlY3QgaXMgc3VwcG9ydGVkLlxuICogQHZlcnNpb24gMS4xLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGhhcy1yZWZsZWN0LXN1cHBvcnQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgYFJlZmxlY3RgZXhpc3RzLlxuICogYHRydWVgLCBpZiBpdCBleGlzdHMgYW5kIGNyZWF0ZXMgdGhlIGNvcnJlY3QgdHlwZSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKlxuICogQHR5cGUgYm9vbGVhblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsO1xuIiwiLyoqXG4gKiBAZmlsZSBUZXN0cyBpZiBFUzYgU3ltYm9sIGlzIHN1cHBvcnRlZC5cbiAqIEB2ZXJzaW9uIDEuNC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBoYXMtc3ltYm9sLXN1cHBvcnQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgYFN5bWJvbGBleGlzdHMgYW5kIGNyZWF0ZXMgdGhlIGNvcnJlY3QgdHlwZS5cbiAqIGB0cnVlYCwgaWYgaXQgZXhpc3RzIGFuZCBjcmVhdGVzIHRoZSBjb3JyZWN0IHR5cGUsIG90aGVyd2lzZSBgZmFsc2VgLlxuICpcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJycpID09PSAnc3ltYm9sJztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMTddLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGVzdHMgaWYgRVM2IEBAdG9TdHJpbmdUYWcgaXMgc3VwcG9ydGVkLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLUBAdG9zdHJpbmd0YWd8MjYuMy4xIEBAdG9TdHJpbmdUYWd9XG4gKiBAdmVyc2lvbiAxLjQuMVxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaGFzLXRvLXN0cmluZy10YWcteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgYFN5bWJvbC50b1N0cmluZ1RhZ2BleGlzdHMgYW5kIGlzIHRoZSBjb3JyZWN0IHR5cGUuXG4gKiBgdHJ1ZWAsIGlmIGl0IGV4aXN0cyBhbmQgaXMgdGhlIGNvcnJlY3QgdHlwZSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKlxuICogQHR5cGUgYm9vbGVhblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14JykgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIi8qKlxuICogQGZpbGUgQW4gZXh0ZW5kZWQgRVM2IGluZGV4T2YuXG4gKiBAdmVyc2lvbiAyLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaW5kZXgtb2YteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJ2lzLXN0cmluZycpO1xudmFyIGlzRmFsc2V5ID0gcmVxdWlyZSgnaXMtZmFsc2V5LXgnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpO1xudmFyIHNhbWVWYWx1ZVplcm8gPSByZXF1aXJlKCdzYW1lLXZhbHVlLXplcm8teCcpO1xudmFyIHNhbWVWYWx1ZSA9IHJlcXVpcmUoJ3NhbWUtdmFsdWUteCcpO1xudmFyIGZpbmRJbmRleCA9IHJlcXVpcmUoJ2ZpbmQtaW5kZXgteCcpO1xudmFyIGNhbGNGcm9tSW5kZXggPSByZXF1aXJlKCdjYWxjdWxhdGUtZnJvbS1pbmRleC14Jyk7XG52YXIgc3BsaXRJZkJveGVkQnVnID0gcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcbnZhciBwSW5kZXhPZiA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcblxudmFyIGlzV29ya2luZztcbmlmIChwSW5kZXhPZikge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICB2YXIgcmVzID0gYXR0ZW1wdC5jYWxsKFswLCAxXSwgcEluZGV4T2YsIDEsIDIpO1xuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gLTE7XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbChbMCwgMV0sIHBJbmRleE9mLCAxKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMTtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoWzAsIC0wXSwgcEluZGV4T2YsIC0wKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMDtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgdGVzdEFyciA9IFtdO1xuICAgIHRlc3RBcnIubGVuZ3RoID0gMjtcbiAgICB0ZXN0QXJyWzFdID0gdm9pZCAwO1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCh0ZXN0QXJyLCBwSW5kZXhPZiwgdm9pZCAwKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMTtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoJ2FiYycsIHBJbmRleE9mLCAnYycpO1xuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSAyO1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCgoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICB9KCdhJywgJ2InLCAnYycpKSwgcEluZGV4T2YsICdjJyk7XG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgPT09IDI7XG4gIH1cbn1cblxuaWYgKGlzV29ya2luZyAhPT0gdHJ1ZSkge1xuICBwSW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGkgPSBhcmd1bWVudHNbMV07XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGluZGV4IGluIHRoZSBhcnJheSwgaWYgYW4gZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAqIHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHNlYXJjaEVsZW1lbnQgLSBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleHRlbmRGbiAtIFRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgaW5kZXggb2YgZm91bmQgZWxlbWVudCwgb3RoZXJ3aXNlIC0xLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGZpbmRJZHhGcm9tID0gZnVuY3Rpb24gZmluZEluZGV4RnJvbShhcnJheSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4LCBleHRlbmRGbikge1xuICB2YXIgZklkeCA9IGZyb21JbmRleDtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGFycmF5Lmxlbmd0aCk7XG4gIHdoaWxlIChmSWR4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGZJZHggaW4gYXJyYXkgJiYgZXh0ZW5kRm4oYXJyYXlbZklkeF0sIHNlYXJjaEVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZklkeDtcbiAgICB9XG5cbiAgICBmSWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmRcbiAqIGluIHRoZSBhcnJheSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgYXJyYXlgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCAtIEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBgYXJyYXlgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXhdIC0gVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBzZWFyY2ggYXQuIElmIHRoZVxuICogIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgYXJyYXkncyBsZW5ndGgsIC0xIGlzIHJldHVybmVkLFxuICogIHdoaWNoIG1lYW5zIHRoZSBhcnJheSB3aWxsIG5vdCBiZSBzZWFyY2hlZC4gSWYgdGhlIHByb3ZpZGVkIGluZGV4IHZhbHVlIGlzXG4gKiAgYSBuZWdhdGl2ZSBudW1iZXIsIGl0IGlzIHRha2VuIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAqICBOb3RlOiBpZiB0aGUgcHJvdmlkZWQgaW5kZXggaXMgbmVnYXRpdmUsIHRoZSBhcnJheSBpcyBzdGlsbCBzZWFyY2hlZCBmcm9tXG4gKiAgZnJvbnQgdG8gYmFjay4gSWYgdGhlIGNhbGN1bGF0ZWQgaW5kZXggaXMgbGVzcyB0aGFuIDAsIHRoZW4gdGhlIHdob2xlXG4gKiAgYXJyYXkgd2lsbCBiZSBzZWFyY2hlZC4gRGVmYXVsdDogMCAoZW50aXJlIGFycmF5IGlzIHNlYXJjaGVkKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXh0ZW5kXSAtIEV4dGVuc2lvbiB0eXBlOiBgU2FtZVZhbHVlYCBvciBgU2FtZVZhbHVlWmVyb2AuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGluZGV4IG9mIGZvdW5kIGVsZW1lbnQsIG90aGVyd2lzZSAtMS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4LW9mLXgnKTtcbiAqIHZhciBzdWJqZWN0ID0gWzIsIDMsIHVuZGVmaW5lZCwgdHJ1ZSwgJ2hlaicsIG51bGwsIDIsIGZhbHNlLCAwLCAtMCwgTmFOXTtcbiAqXG4gKiAvLyBTdGFuZGFyZCBtb2RlLCBvcGVyYXRlcyBqdXN0IGxpa2UgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYC5cbiAqIGluZGV4T2Yoc3ViamVjdCwgbnVsbCk7IC8vIDVcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsICcyJyk7IC8vIC0xXG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCBOYU4pOyAvLyAtMVxuICogaW5kZXhPZih0ZXN0U3ViamVjdCwgLTApOyAvLyA4XG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAyLCAyKTsgLy82XG4gKlxuICogLy8gYFNhbWVWYWx1ZVplcm9gIG1vZGUgZXh0ZW5kcyBgaW5kZXhPZmAgdG8gbWF0Y2ggYE5hTmAuXG4gKiBpbmRleE9mKHN1YmplY3QsIG51bGwsICdTYW1lVmFsdWVaZXJvJyk7IC8vIDVcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsICcyJywgJ1NhbWVWYWx1ZVplcm8nKTsgLy8gLTFcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsIE5hTiwgJ1NhbWVWYWx1ZVplcm8nKTsgLy8gMTBcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsIC0wLCAnU2FtZVZhbHVlWmVybycpOyAvLyA4XG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAyLCAyLCAnU2FtZVZhbHVlWmVybycpOyAvLzZcbiAqXG4gKiAvLyBgU2FtZVZhbHVlYCBtb2RlIGV4dGVuZHMgYGluZGV4T2ZgIHRvIG1hdGNoIGBOYU5gIGFuZCBzaWduZWQgYDBgLlxuICogaW5kZXhPZihzdWJqZWN0LCBudWxsLCAnU2FtZVZhbHVlJyk7IC8vIDVcbiAqIGluZGV4T2YodGVzdFN1YmplY3QsICcyJywgJ1NhbWVWYWx1ZScpOyAvLyAtMVxuICogaW5kZXhPZih0ZXN0U3ViamVjdCwgTmFOLCAnU2FtZVZhbHVlJyk7IC8vIDEwXG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAtMCwgJ1NhbWVWYWx1ZScpOyAvLyA5XG4gKiBpbmRleE9mKHRlc3RTdWJqZWN0LCAyLCAyLCAnU2FtZVZhbHVlJyk7IC8vNlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHNlYXJjaEVsZW1lbnQpIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KGFycmF5KTtcbiAgdmFyIGl0ZXJhYmxlID0gc3BsaXRJZkJveGVkQnVnKG9iamVjdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpO1xuICBpZiAobGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgZXh0ZW5kID0gYXJnTGVuZ3RoID4gMiAmJiBhcmdMZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogYXJndW1lbnRzWzJdO1xuICB2YXIgZXh0ZW5kRm47XG4gIGlmIChpc1N0cmluZyhleHRlbmQpKSB7XG4gICAgZXh0ZW5kID0gZXh0ZW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGV4dGVuZCA9PT0gJ3NhbWV2YWx1ZScpIHtcbiAgICAgIGV4dGVuZEZuID0gc2FtZVZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZXh0ZW5kID09PSAnc2FtZXZhbHVlemVybycpIHtcbiAgICAgIGV4dGVuZEZuID0gc2FtZVZhbHVlWmVybztcbiAgICB9XG4gIH1cblxuICB2YXIgZnJvbUluZGV4ID0gMDtcbiAgaWYgKGV4dGVuZEZuICYmIChzZWFyY2hFbGVtZW50ID09PSAwIHx8IG51bWJlcklzTmFOKHNlYXJjaEVsZW1lbnQpKSkge1xuICAgIGlmIChhcmdMZW5ndGggPiAzKSB7XG4gICAgICBmcm9tSW5kZXggPSBjYWxjRnJvbUluZGV4KGl0ZXJhYmxlLCBhcmd1bWVudHNbMl0pO1xuICAgICAgaWYgKGZyb21JbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcm9tSW5kZXggPiAwKSB7XG4gICAgICByZXR1cm4gZmluZElkeEZyb20oaXRlcmFibGUsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCwgZXh0ZW5kRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5kSW5kZXgoaXRlcmFibGUsIGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4IGluIGl0ZXJhYmxlICYmIGV4dGVuZEZuKHNlYXJjaEVsZW1lbnQsIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFyZ0xlbmd0aCA+IDMgfHwgKGFyZ0xlbmd0aCA+IDIgJiYgaXNGYWxzZXkoZXh0ZW5kRm4pKSkge1xuICAgIGZyb21JbmRleCA9IGNhbGNGcm9tSW5kZXgoaXRlcmFibGUsIGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKGZyb21JbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcEluZGV4T2YuY2FsbChpdGVyYWJsZSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENhbGN1bGF0ZXMgYSBmcm9tSW5kZXggb2YgYSBnaXZlbiB2YWx1ZSBmb3IgYW4gYXJyYXkuXG4gKiBAdmVyc2lvbiAyLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgY2FsY3VsYXRlLWZyb20taW5kZXgteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14JykudG9MZW5ndGgyMDE4O1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTg7XG52YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCdpcy1hcnJheS1saWtlLXgnKTtcblxudmFyIGdldE1heCA9IGZ1bmN0aW9uIF9nZXRNYXgoYSwgYikge1xuICByZXR1cm4gYSA+PSBiID8gYSA6IGI7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgYSBmcm9tSW5kZXggb2YgYSBnaXZlbiB2YWx1ZSBmb3IgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgKiBUaGUgYXJyYXkgb24gd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBzdGFydGluZyBpbmRleC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4ICogVGhlIHBvc2l0aW9uIGluIHRoaXMgYXJyYXkgYXQgd2hpY2ggdG8gYmVnaW4uIEFcbiAqICBuZWdhdGl2ZSB2YWx1ZSBnaXZlcyB0aGUgaW5kZXggb2YgYXJyYXkubGVuZ3RoICsgZnJvbUluZGV4IGJ5IGFzYy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjYWxjdWxhdGVkIGZyb21JbmRleC4gRGVmYXVsdCBpcyAwLlxuICogQGV4YW1wbGVcbiAqIHZhciBjYWxjRnJvbUluZGV4ID0gcmVxdWlyZSgnY2FsY3VsYXRlLWZyb20taW5kZXgteCcpO1xuICpcbiAqIGNhbGNGcm9tSW5kZXgoWzEsIDIsIDNdLCAxKTsgLy8gMVxuICogY2FsY0Zyb21JbmRleChbMSwgMiwgM10sIEluZmluaXR5KTsgLy8gSW5maW5pdHlcbiAqIGNhbGNGcm9tSW5kZXgoWzEsIDIsIDNdLCAtSW5maW5pdHkpOyAvLyAwXG4gKiBjYWxjRnJvbUluZGV4KFsxLCAyLCAzXSwgLTEpOyAvLyAyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsY0Zyb21JbmRleChhcnJheSwgZnJvbUluZGV4KSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gIGlmIChpc0FycmF5TGlrZShvYmplY3QpID09PSBmYWxzZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG5cbiAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IGdldE1heCgwLCB0b0xlbmd0aChvYmplY3QubGVuZ3RoKSArIGluZGV4KTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFNoaW0gZm9yIE1hdGguc2lnbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1tYXRoLnNpZ258MjAuMi4yLjI5IE1hdGguc2lnbih4KX1cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBtYXRoLXNpZ24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYlRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciB0b051bWJlcjIwMTYgPSBsaWJUb051bWJlci50b051bWJlcjIwMTY7XG52YXIgdG9OdW1iZXIyMDE4ID0gbGliVG9OdW1iZXIudG9OdW1iZXIyMDE4O1xudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcblxudmFyICRzaWduMjAxNiA9IGZ1bmN0aW9uIHNpZ24yMDE2KHgpIHtcbiAgdmFyIG4gPSB0b051bWJlcjIwMTYoeCk7XG4gIGlmIChuID09PSAwIHx8IG51bWJlcklzTmFOKG4pKSB7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICByZXR1cm4gbiA+IDAgPyAxIDogLTE7XG59O1xuXG52YXIgJHNpZ24yMDE4ID0gZnVuY3Rpb24gc2lnbjIwMTgoeCkge1xuICB2YXIgbiA9IHRvTnVtYmVyMjAxOCh4KTtcbiAgaWYgKG4gPT09IDAgfHwgbnVtYmVySXNOYU4obikpIHtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHJldHVybiBuID4gMCA/IDEgOiAtMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHNpZ24yMDE4LlxuICAgKi9cbiAgc2lnbjogJHNpZ24yMDE4LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBzaWduIG9mIGEgbnVtYmVyLCBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUgb3IgemVyby4gKEVTMjAxNilcbiAgICpcbiAgICogQHBhcmFtIHsqfSB4IC0gQSBudW1iZXIuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgc2lnbiBvZiB0aGUgZ2l2ZW4gYXJndW1lbnQuIElmIHRoZSBhcmd1bWVudFxuICAgKiBpcyBhIHBvc2l0aXZlIG51bWJlciwgbmVnYXRpdmUgbnVtYmVyLCBwb3NpdGl2ZSB6ZXJvIG9yIG5lZ2F0aXZlIHplcm8sIHRoZSBmdW5jdGlvbiB3aWxsXG4gICAqIHJldHVybiAxLCAtMSwgMCBvciAtMCByZXNwZWN0aXZlbHkuIE90aGVyd2lzZSwgTmFOIGlzIHJldHVybmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgbWF0aFNpZ24gPSByZXF1aXJlKCdtYXRoLXNpZ24teCcpLnNpZ24yMDE2O1xuICAgKlxuICAgKiBtYXRoU2lnbigzKTsgICAgIC8vICAxXG4gICAqIG1hdGhTaWduKC0zKTsgICAgLy8gLTFcbiAgICogbWF0aFNpZ24oJy0zJyk7ICAvLyAtMVxuICAgKiBtYXRoU2lnbigwKTsgICAgIC8vICAwXG4gICAqIG1hdGhTaWduKC0wKTsgICAgLy8gLTBcbiAgICogbWF0aFNpZ24oTmFOKTsgICAvLyBOYU5cbiAgICogbWF0aFNpZ24oJ2ZvbycpOyAvLyBOYU5cbiAgICogbWF0aFNpZ24oKTsgICAgICAvLyBOYU5cbiAgICovXG4gIHNpZ24yMDE2OiAkc2lnbjIwMTYsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXIsIGluZGljYXRpbmcgd2hldGhlciB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLFxuICAgKiBuZWdhdGl2ZSBvciB6ZXJvLiAoRVMyMDE4KVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHggLSBBIG51bWJlci5cbiAgICogQHJldHVybnMge251bWJlcn0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaWduIG9mIHRoZSBnaXZlbiBhcmd1bWVudC4gSWYgdGhlIGFyZ3VtZW50XG4gICAqIGlzIGEgcG9zaXRpdmUgbnVtYmVyLCBuZWdhdGl2ZSBudW1iZXIsIHBvc2l0aXZlIHplcm8gb3IgbmVnYXRpdmUgemVybywgdGhlIGZ1bmN0aW9uIHdpbGxcbiAgICogcmV0dXJuIDEsIC0xLCAwIG9yIC0wIHJlc3BlY3RpdmVseS4gT3RoZXJ3aXNlLCBOYU4gaXMgcmV0dXJuZWQuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBtYXRoU2lnbiA9IHJlcXVpcmUoJ21hdGgtc2lnbi14Jykuc2lnbjIwMTg7XG4gICAqXG4gICAqIG1hdGhTaWduKDMpOyAgICAgLy8gIDFcbiAgICogbWF0aFNpZ24oLTMpOyAgICAvLyAtMVxuICAgKiBtYXRoU2lnbignLTMnKTsgIC8vIC0xXG4gICAqIG1hdGhTaWduKDApOyAgICAgLy8gIDBcbiAgICogbWF0aFNpZ24oLTApOyAgICAvLyAtMFxuICAgKiBtYXRoU2lnbihOYU4pOyAgIC8vIE5hTlxuICAgKiBtYXRoU2lnbignZm9vJyk7IC8vIE5hTlxuICAgKiBtYXRoU2lnbigpOyAgICAgIC8vIE5hTlxuICAgKi9cbiAgc2lnbjIwMTg6ICRzaWduMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgUGFyc2VzIGEgc3RyaW5nIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBwYXJzZS1pbnQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5hdGl2ZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG52YXIgTkFOID0gcmVxdWlyZSgnbmFuLXgnKTtcbnZhciB0b1N0ciA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG52YXIgdHJpbUxlZnQyMDE2ID0gcmVxdWlyZSgndHJpbS1sZWZ0LXgnKS50cmltTGVmdDIwMTY7XG52YXIgdHJpbUxlZnQyMDE4ID0gcmVxdWlyZSgndHJpbS1sZWZ0LXgnKS50cmltTGVmdDIwMTg7XG52YXIgY2hhY2hlZEN0cnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbnZhciBjYXN0TnVtYmVyID0gY2hhY2hlZEN0cnMuTnVtYmVyO1xudmFyIGNoYXJBdCA9IGNoYWNoZWRDdHJzLlN0cmluZy5wcm90b3R5cGUuY2hhckF0O1xudmFyIGhleFJlZ2V4ID0gL15bLStdPzBbeFhdLztcbnZhciB0ZXN0ID0gaGV4UmVnZXgudGVzdDtcblxudmFyICRwYXJzZUludDIwMTYgPSBmdW5jdGlvbiBwYXJzZUludDIwMTYoc3RyaW5nLCByYWRpeCkge1xuICB2YXIgc3RyID0gdHJpbUxlZnQyMDE2KHRvU3RyKHN0cmluZykpO1xuXG4gIHJldHVybiBuYXRpdmVQYXJzZUludChzdHIsIGNhc3ROdW1iZXIocmFkaXgpIHx8ICh0ZXN0LmNhbGwoaGV4UmVnZXgsIHN0cikgPyAxNiA6IDEwKSk7XG59O1xuXG52YXIgJHBhcnNlSW50MjAxOCA9IGZ1bmN0aW9uIHBhcnNlSW50MjAxOChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBzdHIgPSB0cmltTGVmdDIwMTgodG9TdHIoc3RyaW5nKSk7XG4gIGlmIChjaGFyQXQuY2FsbChzdHIsIDApID09PSAnXFx1MTgwRScpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG5cbiAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHN0ciwgY2FzdE51bWJlcihyYWRpeCkgfHwgKHRlc3QuY2FsbChoZXhSZWdleCwgc3RyKSA/IDE2IDogMTApKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHBhcnNlSW50MjAxOC5cbiAgICovXG4gIHBhcnNlSW50OiAkcGFyc2VJbnQyMDE4LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkXG4gICAqIHJhZGl4ICh0aGUgYmFzZSBpbiBtYXRoZW1hdGljYWwgbnVtZXJhbCBzeXN0ZW1zKS4gKEVTMjAxNilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS4gSWYgdGhlIHN0cmluZyBhcmd1bWVudCBpcyBub3QgYVxuICAgKiAgc3RyaW5nLCB0aGVuIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyAodXNpbmcgdGhlIFRvU3RyaW5nIGFic3RyYWN0XG4gICAqICBvcGVyYXRpb24pLiBMZWFkaW5nIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXggLSBBbiBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMzYgdGhhdCByZXByZXNlbnRzIHRoZSByYWRpeFxuICAgKiAgKHRoZSBiYXNlIGluIG1hdGhlbWF0aWNhbCBudW1lcmFsIHN5c3RlbXMpIG9mIHRoZSBhYm92ZSBtZW50aW9uZWQgc3RyaW5nLlxuICAgKiAgU3BlY2lmeSAxMCBmb3IgdGhlIGRlY2ltYWwgbnVtZXJhbCBzeXN0ZW0gY29tbW9ubHkgdXNlZCBieSBodW1hbnMuIEFsd2F5c1xuICAgKiAgc3BlY2lmeSB0aGlzIHBhcmFtZXRlciB0byBlbGltaW5hdGUgcmVhZGVyIGNvbmZ1c2lvbiBhbmQgdG8gZ3VhcmFudGVlXG4gICAqICBwcmVkaWN0YWJsZSBiZWhhdmlvci4gRGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHRzXG4gICAqICB3aGVuIGEgcmFkaXggaXMgbm90IHNwZWNpZmllZCwgdXN1YWxseSBkZWZhdWx0aW5nIHRoZSB2YWx1ZSB0byAxMC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgYSBTeW1ib2wgb3IgaXMgbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge251bWJlcn0gQW4gaW50ZWdlciBudW1iZXIgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gSWYgdGhlIGZpcnN0XG4gICAqICBjaGFyYWN0ZXIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgTmFOIGlzIHJldHVybmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgncGFyc2UtaW50LXgnKS5wYXJzZUludDIwMTY7XG4gICAqXG4gICAqIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgYWxsIHJldHVybiAxNVxuICAgKiAkcGFyc2VJbnQoJyAweEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnIEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnMTcnLCA4KTtcbiAgICogJHBhcnNlSW50KDAyMSwgOCk7XG4gICAqICRwYXJzZUludCgnMDE1JywgMTApOyAgIC8vICRwYXJzZUludCgwMTUsIDEwKTsgd2lsbCByZXR1cm4gMTVcbiAgICogJHBhcnNlSW50KDE1Ljk5LCAxMCk7XG4gICAqICRwYXJzZUludCgnMTUsMTIzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJ0ZYWDEyMycsIDE2KTtcbiAgICogJHBhcnNlSW50KCcxMTExJywgMik7XG4gICAqICRwYXJzZUludCgnMTUgKiAzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJzE1ZTInLCAxMCk7XG4gICAqICRwYXJzZUludCgnMTVweCcsIDEwKTtcbiAgICogJHBhcnNlSW50KCcxMicsIDEzKTtcbiAgICpcbiAgICogLy9UaGUgZm9sbG93aW5nIGV4YW1wbGVzIGFsbCByZXR1cm4gTmFOOlxuICAgKiAkcGFyc2VJbnQoJ0hlbGxvJywgOCk7IC8vIE5vdCBhIG51bWJlciBhdCBhbGxcbiAgICogJHBhcnNlSW50KCc1NDYnLCAyKTsgICAvLyBEaWdpdHMgYXJlIG5vdCB2YWxpZCBmb3IgYmluYXJ5IHJlcHJlc2VudGF0aW9uc1xuICAgKi9cbiAgcGFyc2VJbnQyMDE2OiAkcGFyc2VJbnQyMDE2LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkXG4gICAqIHJhZGl4ICh0aGUgYmFzZSBpbiBtYXRoZW1hdGljYWwgbnVtZXJhbCBzeXN0ZW1zKS4gKEVTMjAxOClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS4gSWYgdGhlIHN0cmluZyBhcmd1bWVudCBpcyBub3QgYVxuICAgKiAgc3RyaW5nLCB0aGVuIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyAodXNpbmcgdGhlIFRvU3RyaW5nIGFic3RyYWN0XG4gICAqICBvcGVyYXRpb24pLiBMZWFkaW5nIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXggLSBBbiBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMzYgdGhhdCByZXByZXNlbnRzIHRoZSByYWRpeFxuICAgKiAgKHRoZSBiYXNlIGluIG1hdGhlbWF0aWNhbCBudW1lcmFsIHN5c3RlbXMpIG9mIHRoZSBhYm92ZSBtZW50aW9uZWQgc3RyaW5nLlxuICAgKiAgU3BlY2lmeSAxMCBmb3IgdGhlIGRlY2ltYWwgbnVtZXJhbCBzeXN0ZW0gY29tbW9ubHkgdXNlZCBieSBodW1hbnMuIEFsd2F5c1xuICAgKiAgc3BlY2lmeSB0aGlzIHBhcmFtZXRlciB0byBlbGltaW5hdGUgcmVhZGVyIGNvbmZ1c2lvbiBhbmQgdG8gZ3VhcmFudGVlXG4gICAqICBwcmVkaWN0YWJsZSBiZWhhdmlvci4gRGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBwcm9kdWNlIGRpZmZlcmVudCByZXN1bHRzXG4gICAqICB3aGVuIGEgcmFkaXggaXMgbm90IHNwZWNpZmllZCwgdXN1YWxseSBkZWZhdWx0aW5nIHRoZSB2YWx1ZSB0byAxMC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgYSBTeW1ib2wgb3IgaXMgbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge251bWJlcn0gQW4gaW50ZWdlciBudW1iZXIgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gSWYgdGhlIGZpcnN0XG4gICAqICBjaGFyYWN0ZXIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlciwgTmFOIGlzIHJldHVybmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgncGFyc2UtaW50LXgnKS5wYXJzZUludDIwMTg7XG4gICAqXG4gICAqIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgYWxsIHJldHVybiAxNVxuICAgKiAkcGFyc2VJbnQoJyAweEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnIEYnLCAxNik7XG4gICAqICRwYXJzZUludCgnMTcnLCA4KTtcbiAgICogJHBhcnNlSW50KDAyMSwgOCk7XG4gICAqICRwYXJzZUludCgnMDE1JywgMTApOyAgIC8vICRwYXJzZUludCgwMTUsIDEwKTsgd2lsbCByZXR1cm4gMTVcbiAgICogJHBhcnNlSW50KDE1Ljk5LCAxMCk7XG4gICAqICRwYXJzZUludCgnMTUsMTIzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJ0ZYWDEyMycsIDE2KTtcbiAgICogJHBhcnNlSW50KCcxMTExJywgMik7XG4gICAqICRwYXJzZUludCgnMTUgKiAzJywgMTApO1xuICAgKiAkcGFyc2VJbnQoJzE1ZTInLCAxMCk7XG4gICAqICRwYXJzZUludCgnMTVweCcsIDEwKTtcbiAgICogJHBhcnNlSW50KCcxMicsIDEzKTtcbiAgICpcbiAgICogLy9UaGUgZm9sbG93aW5nIGV4YW1wbGVzIGFsbCByZXR1cm4gTmFOOlxuICAgKiAkcGFyc2VJbnQoJ0hlbGxvJywgOCk7IC8vIE5vdCBhIG51bWJlciBhdCBhbGxcbiAgICogJHBhcnNlSW50KCc1NDYnLCAyKTsgICAvLyBEaWdpdHMgYXJlIG5vdCB2YWxpZCBmb3IgYmluYXJ5IHJlcHJlc2VudGF0aW9uc1xuICAgKi9cbiAgcGFyc2VJbnQyMDE4OiAkcGFyc2VJbnQyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUb0ludGVnZXIgY29udmVydHMgJ2FyZ3VtZW50JyB0byBhbiBpbnRlZ3JhbCBudW1lcmljIHZhbHVlLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50ZWdlcnw3LjEuNCBUb0ludGVnZXIgKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMy4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWludGVnZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYlRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKTtcbnZhciB0b051bWJlcjIwMTYgPSBsaWJUb051bWJlci50b051bWJlcjIwMTY7XG52YXIgdG9OdW1iZXIyMDE4ID0gbGliVG9OdW1iZXIudG9OdW1iZXIyMDE4O1xudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbnZhciBudW1iZXJJc0Zpbml0ZSA9IHJlcXVpcmUoJ2lzLWZpbml0ZS14Jyk7XG52YXIgbGliTWF0aFNpZ24gPSByZXF1aXJlKCdtYXRoLXNpZ24teCcpO1xudmFyIG1hdGhTaWduMjAxNiA9IGxpYk1hdGhTaWduLnNpZ24yMDE2O1xudmFyIG1hdGhTaWduMjAxOCA9IGxpYk1hdGhTaWduLnNpZ24yMDE4O1xudmFyIG1hdGhGbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG52YXIgJHRvSW50ZWdlcjIwMTYgPSBmdW5jdGlvbiB0b0ludGVnZXIyMDE2KHZhbHVlKSB7XG4gIHZhciBudW1iZXIgPSB0b051bWJlcjIwMTYodmFsdWUpO1xuICBpZiAobnVtYmVySXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKG51bWJlciA9PT0gMCB8fCBudW1iZXJJc0Zpbml0ZShudW1iZXIpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICByZXR1cm4gbWF0aFNpZ24yMDE2KG51bWJlcikgKiBtYXRoRmxvb3IobWF0aEFicyhudW1iZXIpKTtcbn07XG5cbnZhciAkdG9JbnRlZ2VyMjAxOCA9IGZ1bmN0aW9uIHRvSW50ZWdlcjIwMTgodmFsdWUpIHtcbiAgdmFyIG51bWJlciA9IHRvTnVtYmVyMjAxOCh2YWx1ZSk7XG4gIGlmIChudW1iZXJJc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobnVtYmVyID09PSAwIHx8IG51bWJlcklzRmluaXRlKG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBtYXRoU2lnbjIwMTgobnVtYmVyKSAqIG1hdGhGbG9vcihtYXRoQWJzKG51bWJlcikpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdG9JbnRlZ2VyMjAxOC5cbiAgICovXG4gIHRvSW50ZWdlcjogJHRvSW50ZWdlcjIwMTgsXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci4gKEVTMjAxNilcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTY7XG4gICAqIHRvSW50ZWdlcigzKTsgLy8gM1xuICAgKiB0b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7IC8vIDBcbiAgICogdG9JbnRlZ2VyKEluZmluaXR5KTsgLy8gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICogdG9JbnRlZ2VyKCczJyk7IC8vIDNcbiAgICovXG4gIHRvSW50ZWdlcjIwMTY6ICR0b0ludGVnZXIyMDE2LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuIChFUzIwMTgpXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCd0by1pbnRlZ2VyLXgnKS50b0ludGVnZXIyMDE4O1xuICAgKiB0b0ludGVnZXIoMyk7IC8vIDNcbiAgICogdG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpOyAvLyAwXG4gICAqIHRvSW50ZWdlcihJbmZpbml0eSk7IC8vIDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAqIHRvSW50ZWdlcignMycpOyAvLyAzXG4gICAqL1xuICB0b0ludGVnZXIyMDE4OiAkdG9JbnRlZ2VyMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgU2hpbSBmb3IgVG9MZW5ndGguXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGh8Ny4xLjE1IFRvTGVuZ3RoICggYXJndW1lbnQgKX1cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1sZW5ndGgteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYlRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpO1xudmFyIHRvSW50ZWdlcjIwMTYgPSBsaWJUb0ludGVnZXIudG9JbnRlZ2VyMjAxNjtcbnZhciB0b0ludGVnZXIyMDE4ID0gbGliVG9JbnRlZ2VyLnRvSW50ZWdlcjIwMTg7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IHJlcXVpcmUoJ21heC1zYWZlLWludGVnZXInKTtcblxudmFyICR0b0xlbmd0aDIwMTYgPSBmdW5jdGlvbiB0b0xlbmd0aDIwMTYodmFsdWUpIHtcbiAgdmFyIGxlbiA9IHRvSW50ZWdlcjIwMTYodmFsdWUpO1xuICAvLyBpbmNsdWRlcyBjb252ZXJ0aW5nIC0wIHRvICswXG4gIGlmIChsZW4gPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gTUFYX1NBRkVfSU5URUdFUjtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59O1xuXG52YXIgJHRvTGVuZ3RoMjAxOCA9IGZ1bmN0aW9uIHRvTGVuZ3RoMjAxOCh2YWx1ZSkge1xuICB2YXIgbGVuID0gdG9JbnRlZ2VyMjAxOCh2YWx1ZSk7XG4gIC8vIGluY2x1ZGVzIGNvbnZlcnRpbmcgLTAgdG8gKzBcbiAgaWYgKGxlbiA8PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAobGVuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRvTGVuZ3RoMjAxOC5cbiAgICovXG4gIHRvTGVuZ3RoOiAkdG9MZW5ndGgyMDE4LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAqIGFycmF5LWxpa2Ugb2JqZWN0LiAoRVMyMDE2KVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpLnRvTGVuZ3RoMjAxNjtcbiAgICogdG9MZW5ndGgoMyk7IC8vIDNcbiAgICogdG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7IC8vIDBcbiAgICogdG9MZW5ndGgoSW5maW5pdHkpOyAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgKiB0b0xlbmd0aCgnMycpOyAvLyAzXG4gICAqL1xuICB0b0xlbmd0aDIwMTY6ICR0b0xlbmd0aDIwMTYsXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICogYXJyYXktbGlrZSBvYmplY3QuIChFUzIwMTgpXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14JykudG9MZW5ndGgyMDE4O1xuICAgKiB0b0xlbmd0aCgzKTsgLy8gM1xuICAgKiB0b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gMFxuICAgKiB0b0xlbmd0aChJbmZpbml0eSk7IC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAqIHRvTGVuZ3RoKCczJyk7IC8vIDNcbiAgICovXG4gIHRvTGVuZ3RoMjAxODogJHRvTGVuZ3RoMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgQ29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci5cbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1udW1iZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhY2hlZEN0cnMgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKTtcbnZhciBjYXN0TnVtYmVyID0gY2FjaGVkQ3Rycy5OdW1iZXI7XG52YXIgUnggPSBjYWNoZWRDdHJzLlJlZ0V4cDtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ3RvLXByaW1pdGl2ZS14Jyk7XG52YXIgbGliVHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xudmFyIHRyaW0yMDE2ID0gbGliVHJpbS50cmltMjAxNjtcbnZhciB0cmltMjAxOCA9IGxpYlRyaW0udHJpbTIwMTg7XG52YXIgbGliUGFyc2VJbnQgPSByZXF1aXJlKCdwYXJzZS1pbnQteCcpO1xudmFyICRwYXJzZUludDIwMTYgPSBsaWJQYXJzZUludC5wYXJzZUludDIwMTY7XG52YXIgJHBhcnNlSW50MjAxOCA9IGxpYlBhcnNlSW50LnBhcnNlSW50MjAxODtcbnZhciBwU3RyU2xpY2UgPSBjYWNoZWRDdHJzLlN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgTkFOID0gcmVxdWlyZSgnbmFuLXgnKTtcblxudmFyIGJpbmFyeVJlZ2V4ID0gL14wYlswMV0rJC9pO1xuLy8gTm90ZSB0aGF0IGluIElFIDgsIFJlZ0V4cC5wcm90b3R5cGUudGVzdCBkb2Vzbid0IHNlZW0gdG8gZXhpc3Q6IGllLCBcInRlc3RcIiBpc1xuLy8gYW4gb3duIHByb3BlcnR5IG9mIHJlZ2V4ZXMuIHd0Zi5cbnZhciB0ZXN0ID0gYmluYXJ5UmVnZXgudGVzdDtcbnZhciBpc0JpbmFyeSA9IGZ1bmN0aW9uIF9pc0JpbmFyeSh2YWx1ZSkge1xuICByZXR1cm4gdGVzdC5jYWxsKGJpbmFyeVJlZ2V4LCB2YWx1ZSk7XG59O1xuXG52YXIgb2N0YWxSZWdleCA9IC9eMG9bMC03XSskL2k7XG52YXIgaXNPY3RhbCA9IGZ1bmN0aW9uIF9pc09jdGFsKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwob2N0YWxSZWdleCwgdmFsdWUpO1xufTtcblxudmFyIG5vbldTcmVnZXgyMDE2ID0gbmV3IFJ4KCdbXFx1MDA4NVxcdTIwMGJcXHVmZmZlXScsICdnJyk7XG52YXIgaGFzTm9uV1MyMDE2ID0gZnVuY3Rpb24gX2hhc05vbldTKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwobm9uV1NyZWdleDIwMTYsIHZhbHVlKTtcbn07XG5cbnZhciBub25XU3JlZ2V4MjAxOCA9IG5ldyBSeCgnW1xcdTAwODVcXHUxODBlXFx1MjAwYlxcdWZmZmVdJywgJ2cnKTtcbnZhciBoYXNOb25XUzIwMTggPSBmdW5jdGlvbiBfaGFzTm9uV1ModmFsdWUpIHtcbiAgcmV0dXJuIHRlc3QuY2FsbChub25XU3JlZ2V4MjAxOCwgdmFsdWUpO1xufTtcblxudmFyIGludmFsaWRIZXhMaXRlcmFsID0gL15bLStdMHhbMC05YS1mXSskL2k7XG52YXIgaXNJbnZhbGlkSGV4TGl0ZXJhbCA9IGZ1bmN0aW9uIF9pc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoaW52YWxpZEhleExpdGVyYWwsIHZhbHVlKTtcbn07XG5cbnZhciAkdG9OdW1iZXIyMDE2ID0gZnVuY3Rpb24gdG9OdW1iZXIyMDE2KGFyZ3VtZW50KSB7XG4gIHZhciB2YWx1ZSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBOdW1iZXIpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc0JpbmFyeSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b051bWJlcjIwMTYoJHBhcnNlSW50MjAxNihwU3RyU2xpY2UuY2FsbCh2YWx1ZSwgMiksIDIpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPY3RhbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0b051bWJlcjIwMTYoJHBhcnNlSW50MjAxNihwU3RyU2xpY2UuY2FsbCh2YWx1ZSwgMiksIDgpKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzTm9uV1MyMDE2KHZhbHVlKSB8fCBpc0ludmFsaWRIZXhMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5BTjtcbiAgICB9XG5cbiAgICB2YXIgdHJpbW1lZCA9IHRyaW0yMDE2KHZhbHVlKTtcbiAgICBpZiAodHJpbW1lZCAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0b051bWJlcjIwMTYodHJpbW1lZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhc3ROdW1iZXIodmFsdWUpO1xufTtcblxudmFyICR0b051bWJlcjIwMTggPSBmdW5jdGlvbiB0b051bWJlcjIwMTgoYXJndW1lbnQpIHtcbiAgdmFyIHZhbHVlID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIE51bWJlcik7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlzQmluYXJ5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyMjAxOCgkcGFyc2VJbnQyMDE4KHBTdHJTbGljZS5jYWxsKHZhbHVlLCAyKSwgMikpO1xuICAgIH1cblxuICAgIGlmIChpc09jdGFsKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyMjAxOCgkcGFyc2VJbnQyMDE4KHBTdHJTbGljZS5jYWxsKHZhbHVlLCAyKSwgOCkpO1xuICAgIH1cblxuICAgIGlmIChoYXNOb25XUzIwMTgodmFsdWUpIHx8IGlzSW52YWxpZEhleExpdGVyYWwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTkFOO1xuICAgIH1cblxuICAgIHZhciB0cmltbWVkID0gdHJpbTIwMTgodmFsdWUpO1xuICAgIGlmICh0cmltbWVkICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyMjAxOCh0cmltbWVkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FzdE51bWJlcih2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIHJlZmVyZW5jZSB0byB0b051bWJlcjIwMTguXG4gICAqL1xuICB0b051bWJlcjogJHRvTnVtYmVyMjAxOCxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci4gKEVTMjAxNilcblxuICAgKiBAcGFyYW0geyp9IGFyZ3VtZW50IC0gVGhlIGFyZ3VtZW50IHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gLSBJZiBhcmd1bWVudCBpcyBhIFN5bWJvbCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFyZ3VtZW50IGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKS50b051bWJlcjIwMTY7XG4gICAqXG4gICAqIHRvTnVtYmVyKCcxJyk7IC8vIDFcbiAgICogdG9OdW1iZXIobnVsbCk7IC8vIDBcbiAgICogdG9OdW1iZXIodHJ1ZSk7IC8vIDFcbiAgICogdG9OdW1iZXIoJzBvMTAnKTsgLy8gOFxuICAgKiB0b051bWJlcignMGIxMCcpOyAvLyAyXG4gICAqIHRvTnVtYmVyKCcweEYnKTsgLy8gMTZcbiAgICpcbiAgICogdG9OdW1iZXIoJyAxICcpOyAvLyAxXG4gICAqXG4gICAqIHRvTnVtYmVyKFN5bWJvbCgnJykpIC8vIFR5cGVFcnJvclxuICAgKiB0b051bWJlcihPYmplY3QuY3JlYXRlKG51bGwpKSAvLyBUeXBlRXJyb3JcbiAgICovXG4gIHRvTnVtYmVyMjAxNjogJHRvTnVtYmVyMjAxNixcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSBvZiB0eXBlIE51bWJlci4gKEVTMjAxOClcblxuICAgKiBAcGFyYW0geyp9IGFyZ3VtZW50IC0gVGhlIGFyZ3VtZW50IHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gLSBJZiBhcmd1bWVudCBpcyBhIFN5bWJvbCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFyZ3VtZW50IGNvbnZlcnRlZCB0byBhIG51bWJlci5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRvTnVtYmVyID0gcmVxdWlyZSgndG8tbnVtYmVyLXgnKS50b051bWJlcjIwMTg7XG4gICAqXG4gICAqIHRvTnVtYmVyKCcxJyk7IC8vIDFcbiAgICogdG9OdW1iZXIobnVsbCk7IC8vIDBcbiAgICogdG9OdW1iZXIodHJ1ZSk7IC8vIDFcbiAgICogdG9OdW1iZXIoJzBvMTAnKTsgLy8gOFxuICAgKiB0b051bWJlcignMGIxMCcpOyAvLyAyXG4gICAqIHRvTnVtYmVyKCcweEYnKTsgLy8gMTZcbiAgICpcbiAgICogdG9OdW1iZXIoJyAxICcpOyAvLyAxXG4gICAqXG4gICAqIHRvTnVtYmVyKFN5bWJvbCgnJykpIC8vIFR5cGVFcnJvclxuICAgKiB0b051bWJlcihPYmplY3QuY3JlYXRlKG51bGwpKSAvLyBUeXBlRXJyb3JcbiAgICovXG4gIHRvTnVtYmVyMjAxODogJHRvTnVtYmVyMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy5cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0cmltLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsaWJUcmltTGVmdCA9IHJlcXVpcmUoJ3RyaW0tbGVmdC14Jyk7XG52YXIgdHJpbUxlZnQyMDE2ID0gbGliVHJpbUxlZnQudHJpbUxlZnQyMDE2O1xudmFyIHRyaW1MZWZ0MjAxOCA9IGxpYlRyaW1MZWZ0LnRyaW1MZWZ0MjAxODtcbnZhciBsaWJUcmltUmlnaHQgPSByZXF1aXJlKCd0cmltLXJpZ2h0LXgnKTtcbnZhciB0cmltUmlnaHQyMDE2ID0gbGliVHJpbVJpZ2h0LnRyaW1SaWdodDIwMTY7XG52YXIgdHJpbVJpZ2h0MjAxOCA9IGxpYlRyaW1SaWdodC50cmltUmlnaHQyMDE2O1xuXG52YXIgJHRyaW0yMDE2ID0gZnVuY3Rpb24gdHJpbTIwMTYoc3RyaW5nKSB7XG4gIHJldHVybiB0cmltTGVmdDIwMTYodHJpbVJpZ2h0MjAxNihzdHJpbmcpKTtcbn07XG5cbnZhciAkdHJpbTIwMTggPSBmdW5jdGlvbiB0cmltMjAxOChzdHJpbmcpIHtcbiAgcmV0dXJuIHRyaW1MZWZ0MjAxOCh0cmltUmlnaHQyMDE4KHN0cmluZykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0cmltMjAxOC5cbiAgICovXG4gIHRyaW06ICR0cmltMjAxOCxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy5cbiAgICogKEVTMjAxNilcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHN0cmluZyBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0cmltID0gcmVxdWlyZSgndHJpbS14Jyk7XG4gICAqXG4gICAqIHRyaW0oJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSc7IC8vIHRydWVcbiAgICovXG4gIHRyaW0yMDE2OiAkdHJpbTIwMTYsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gICAqIChFUzIwMTgpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIHRyaW0gdGhlIHdoaXRlc3BhY2UgZnJvbS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xuICAgKlxuICAgKiB0cmltKCcgXFx0XFxuYSBcXHRcXG4nKSA9PT0gJ2EnOyAvLyB0cnVlXG4gICAqL1xuICB0cmltMjAxODogJHRyaW0yMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZmluZC1pbmRleC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcEZpbmRJbmRleCA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID09PSAnZnVuY3Rpb24nICYmIEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXg7XG5cbnZhciBpc1dvcmtpbmc7XG5pZiAocEZpbmRJbmRleCkge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICB2YXIgdGVzdEFyciA9IFtdO1xuICB0ZXN0QXJyLmxlbmd0aCA9IDI7XG4gIHRlc3RBcnJbMV0gPSAxO1xuICB2YXIgcmVzID0gYXR0ZW1wdC5jYWxsKHRlc3RBcnIsIHBGaW5kSW5kZXgsIGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICByZXR1cm4gaWR4ID09PSAwO1xuICB9KTtcblxuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gMDtcblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKDEsIHBGaW5kSW5kZXgsIGZ1bmN0aW9uIChpdGVtLCBpZHgpIHtcbiAgICAgIHJldHVybiBpZHggPT09IDA7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gLTE7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgaXNXb3JraW5nID0gYXR0ZW1wdC5jYWxsKFtdLCBwRmluZEluZGV4KS50aHJldztcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoJ2FiYycsIHBGaW5kSW5kZXgsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSA9PT0gJ2MnO1xuICAgIH0pO1xuXG4gICAgaXNXb3JraW5nID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgPT09IDI7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgIH0oJ2EnLCAnYicsICdjJykpLCBwRmluZEluZGV4LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gPT09ICdjJztcbiAgICB9KTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSAyO1xuICB9XG59XG5cbnZhciBmaW5kSWR4O1xuaWYgKGlzV29ya2luZykge1xuICBmaW5kSWR4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gW2NhbGxiYWNrXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZ3NbMV0gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBGaW5kSW5kZXguYXBwbHkoYXJyYXksIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgndG8tbGVuZ3RoLXgnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbiAgdmFyIGFzc2VydElzRnVuY3Rpb24gPSByZXF1aXJlKCdhc3NlcnQtaXMtZnVuY3Rpb24teCcpO1xuICB2YXIgc3BsaXRJZkJveGVkQnVnID0gcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcblxuICBmaW5kSWR4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICAgIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gICAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsYmFjayk7XG4gICAgdmFyIGl0ZXJhYmxlID0gc3BsaXRJZkJveGVkQnVnKG9iamVjdCk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0FyZztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuXG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cblxuLyoqXG4gKiBMaWtlIGBmaW5kSW5kZXhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIGluZGV4IGluIHRoZSBhcnJheSwgaWYgYW4gZWxlbWVudFxuICogaW4gdGhlIGFycmF5IHNhdGlzZmllcyB0aGUgcHJvdmlkZWQgdGVzdGluZyBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LFxuICogIHRha2luZyB0aHJlZSBhcmd1bWVudHM6IGBlbGVtZW50YCwgYGluZGV4YCBhbmQgYGFycmF5YC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYGNhbGxiYWNrYCBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIC0gT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgaW5kZXggb2YgcG9zaXRpdmVseSB0ZXN0ZWQgZWxlbWVudCwgb3RoZXJ3aXNlIC0xLlxuICogQGV4YW1wbGVcbiAqIHZhciBmaW5kSW5kZXggPSByZXF1aXJlKCdmaW5kLWluZGV4LXgnKTtcbiAqXG4gKiBmdW5jdGlvbiBpc1ByaW1lKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICogICB2YXIgc3RhcnQgPSAyO1xuICogICB3aGlsZSAoc3RhcnQgPD0gTWF0aC5zcXJ0KGVsZW1lbnQpKSB7XG4gKiAgICAgaWYgKGVsZW1lbnQgJSBzdGFydCsrIDwgMSkge1xuICogICAgICAgcmV0dXJuIGZhbHNlO1xuICogICAgIH1cbiAqICAgfVxuICogICByZXR1cm4gZWxlbWVudCA+IDE7XG4gKiB9XG4gKlxuICogY29uc29sZS5sb2coZmluZEluZGV4KFs0LCA2LCA4LCAxMiwgMTRdLCBpc1ByaW1lKSk7IC8vIC0xLCBub3QgZm91bmRcbiAqIGNvbnNvbGUubG9nKGZpbmRJbmRleChbNCwgNiwgNywgMTIsIDEzXSwgaXNQcmltZSkpOyAvLyAyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZmluZElkeDtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy5cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0cmltLXJpZ2h0LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcgPSByZXF1aXJlKCdyZXF1aXJlLWNvZXJjaWJsZS10by1zdHJpbmcteCcpO1xudmFyIFJ4ID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuUmVnRXhwO1xudmFyIHJlUmlnaHQyMDE2ID0gbmV3IFJ4KCdbJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcyMDE2ICsgJ10rJCcpO1xudmFyIHJlUmlnaHQyMDE4ID0gbmV3IFJ4KCdbJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcyMDE4ICsgJ10rJCcpO1xudmFyIHJlcGxhY2UgPSAnJy5yZXBsYWNlO1xuXG52YXIgJHRyaW1SaWdodDIwMTYgPSBmdW5jdGlvbiB0cmltUmlnaHQyMDE2KHN0cmluZykge1xuICByZXR1cm4gcmVwbGFjZS5jYWxsKHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyhzdHJpbmcpLCByZVJpZ2h0MjAxNiwgJycpO1xufTtcblxudmFyICR0cmltUmlnaHQyMDE4ID0gZnVuY3Rpb24gdHJpbVJpZ2h0MjAxOChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlcGxhY2UuY2FsbChyZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoc3RyaW5nKSwgcmVSaWdodDIwMTgsICcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogQSByZWZlcmVuY2UgdG8gdHJpbVJpZ2h0MjAxOC5cbiAgICovXG4gIHRyaW1SaWdodDogJHRyaW1SaWdodDIwMTgsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSByaWdodCBlbmQgb2YgYSBzdHJpbmcuIChFUzIwMTYpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIHRyaW0gdGhlIHJpZ2h0IGVuZCB3aGl0ZXNwYWNlIGZyb20uXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByaWdodCB0cmltbWVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRyaW1SaWdodCA9IHJlcXVpcmUoJ3RyaW0tcmlnaHQteCcpO1xuICAgKlxuICAgKiB0cmltUmlnaHQoJyBcXHRcXG5hIFxcdFxcbicpID09PSAnIFxcdFxcbmEnOyAvLyB0cnVlXG4gICAqL1xuICB0cmltUmlnaHQyMDE2OiAkdHJpbVJpZ2h0MjAxNixcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIHJpZ2h0IGVuZCBvZiBhIHN0cmluZy4gKEVTMjAxOClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgcmlnaHQgZW5kIHdoaXRlc3BhY2UgZnJvbS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJpZ2h0IHRyaW1tZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdHJpbVJpZ2h0ID0gcmVxdWlyZSgndHJpbS1yaWdodC14Jyk7XG4gICAqXG4gICAqIHRyaW1SaWdodCgnIFxcdFxcbmEgXFx0XFxuJykgPT09ICcgXFx0XFxuYSc7IC8vIHRydWVcbiAgICovXG4gIHRyaW1SaWdodDIwMTg6ICR0cmltUmlnaHQyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBMaXN0IG9mIEVDTUFTY3JpcHQgd2hpdGUgc3BhY2UgY2hhcmFjdGVycy5cbiAqIEB2ZXJzaW9uIDMuMC4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB3aGl0ZS1zcGFjZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgcmVjb3JkIG9mIGEgd2hpdGUgc3BhY2UgY2hhcmFjdGVyLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYXJSZWNvcmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gVGhlIGNoYXJhY3RlciBjb2RlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY2hhcmFjdGVyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBlczUgLSBXaGV0aGVyIHRoZSBzcGVjIGxpc3RzIHRoaXMgYXMgYSB3aGl0ZSBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXMyMDE1IC0gV2hldGhlciB0aGUgc3BlYyBsaXN0cyB0aGlzIGFzIGEgd2hpdGUgc3BhY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVzMjAxNiAtIFdoZXRoZXIgdGhlIHNwZWMgbGlzdHMgdGhpcyBhcyBhIHdoaXRlIHNwYWNlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBlczIwMTcgLSBXaGV0aGVyIHRoZSBzcGVjIGxpc3RzIHRoaXMgYXMgYSB3aGl0ZSBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXMyMDE4IC0gV2hldGhlciB0aGUgc3BlYyBsaXN0cyB0aGlzIGFzIGEgd2hpdGUgc3BhY2UuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RyaW5nIC0gVGhlIGNoYXJhY3RlciBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBBbiBhcnJheSBvZiB0aGUgd2hpdGVzcGFjZSBjaGFyIGNvZGVzLCBzdHJpbmcsIGRlc2NyaXB0aW9ucyBhbmQgbGFuZ3VhZ2VcbiAqIHByZXNlbmNlIGluIHRoZSBzcGVjaWZpY2F0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUgQXJyYXkuPENoYXJSZWNvcmQ+XG4gKi9cbnZhciBsaXN0ID0gW1xuICB7XG4gICAgY29kZTogMHgwMDA5LFxuICAgIGRlc2NyaXB0aW9uOiAnVGFiJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTAwMDknXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGEsXG4gICAgZGVzY3JpcHRpb246ICdMaW5lIEZlZWQnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MDAwYSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAwYixcbiAgICBkZXNjcmlwdGlvbjogJ1ZlcnRpY2FsIFRhYicsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUwMDBiJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgwMDBjLFxuICAgIGRlc2NyaXB0aW9uOiAnRm9ybSBGZWVkJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTAwMGMnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDAwMGQsXG4gICAgZGVzY3JpcHRpb246ICdDYXJyaWFnZSBSZXR1cm4nLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MDAwZCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAyMCxcbiAgICBkZXNjcmlwdGlvbjogJ1NwYWNlJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTAwMjAnXG4gIH0sXG4gIC8qXG4gIHtcbiAgICBjb2RlOiAweDAwODUsXG4gICAgZGVzY3JpcHRpb246ICdOZXh0IGxpbmUnLFxuICAgIGVzNTogZmFsc2UsXG4gICAgZXMyMDE1OiBmYWxzZSxcbiAgICBlczIwMTY6IGZhbHNlLFxuICAgIGVzMjAxNzogZmFsc2UsXG4gICAgZXMyMDE4OiBmYWxzZSxcbiAgICBzdHJpbmc6ICdcXHUwMDg1J1xuICB9XG4gICovXG4gIHtcbiAgICBjb2RlOiAweDAwYTAsXG4gICAgZGVzY3JpcHRpb246ICdOby1icmVhayBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUwMGEwJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgxNjgwLFxuICAgIGRlc2NyaXB0aW9uOiAnT2doYW0gc3BhY2UgbWFyaycsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUxNjgwJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgxODBlLFxuICAgIGRlc2NyaXB0aW9uOiAnTW9uZ29saWFuIHZvd2VsIHNlcGFyYXRvcicsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiBmYWxzZSxcbiAgICBlczIwMTg6IGZhbHNlLFxuICAgIHN0cmluZzogJ1xcdTE4MGUnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDAsXG4gICAgZGVzY3JpcHRpb246ICdFbiBxdWFkJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTIwMDAnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDEsXG4gICAgZGVzY3JpcHRpb246ICdFbSBxdWFkJyxcbiAgICBlczU6IHRydWUsXG4gICAgZXMyMDE1OiB0cnVlLFxuICAgIGVzMjAxNjogdHJ1ZSxcbiAgICBlczIwMTc6IHRydWUsXG4gICAgZXMyMDE4OiB0cnVlLFxuICAgIHN0cmluZzogJ1xcdTIwMDEnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDIsXG4gICAgZGVzY3JpcHRpb246ICdFbiBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDAyJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDAzLFxuICAgIGRlc2NyaXB0aW9uOiAnRW0gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwMydcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNCxcbiAgICBkZXNjcmlwdGlvbjogJ1RocmVlLXBlci1lbSBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDA0J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA1LFxuICAgIGRlc2NyaXB0aW9uOiAnRm91ci1wZXItZW0gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwNSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNixcbiAgICBkZXNjcmlwdGlvbjogJ1NpeC1wZXItZW0gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwNidcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwNyxcbiAgICBkZXNjcmlwdGlvbjogJ0ZpZ3VyZSBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDA3J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA4LFxuICAgIGRlc2NyaXB0aW9uOiAnUHVuY3R1YXRpb24gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwOCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwOSxcbiAgICBkZXNjcmlwdGlvbjogJ1RoaW4gc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwOSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwYSxcbiAgICBkZXNjcmlwdGlvbjogJ0hhaXIgc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAwYSdcbiAgfSxcbiAgLypcbiAge1xuICAgIGNvZGU6IDB4MjAwYixcbiAgICBkZXNjcmlwdGlvbjogJ1plcm8gd2lkdGggc3BhY2UnLFxuICAgIGVzNTogZmFsc2UsXG4gICAgZXMyMDE1OiBmYWxzZSxcbiAgICBlczIwMTY6IGZhbHNlLFxuICAgIGVzMjAxNzogZmFsc2UsXG4gICAgZXMyMDE4OiBmYWxzZSxcbiAgICBzdHJpbmc6ICdcXHUyMDBiJ1xuICB9LFxuICAqL1xuICB7XG4gICAgY29kZTogMHgyMDI4LFxuICAgIGRlc2NyaXB0aW9uOiAnTGluZSBzZXBhcmF0b3InLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAyOCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAyOSxcbiAgICBkZXNjcmlwdGlvbjogJ1BhcmFncmFwaCBzZXBhcmF0b3InLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MjAyOSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAyZixcbiAgICBkZXNjcmlwdGlvbjogJ05hcnJvdyBuby1icmVhayBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDJmJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDVmLFxuICAgIGRlc2NyaXB0aW9uOiAnTWVkaXVtIG1hdGhlbWF0aWNhbCBzcGFjZScsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHUyMDVmJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgzMDAwLFxuICAgIGRlc2NyaXB0aW9uOiAnSWRlb2dyYXBoaWMgc3BhY2UnLFxuICAgIGVzNTogdHJ1ZSxcbiAgICBlczIwMTU6IHRydWUsXG4gICAgZXMyMDE2OiB0cnVlLFxuICAgIGVzMjAxNzogdHJ1ZSxcbiAgICBlczIwMTg6IHRydWUsXG4gICAgc3RyaW5nOiAnXFx1MzAwMCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4ZmVmZixcbiAgICBkZXNjcmlwdGlvbjogJ0J5dGUgT3JkZXIgTWFyaycsXG4gICAgZXM1OiB0cnVlLFxuICAgIGVzMjAxNTogdHJ1ZSxcbiAgICBlczIwMTY6IHRydWUsXG4gICAgZXMyMDE3OiB0cnVlLFxuICAgIGVzMjAxODogdHJ1ZSxcbiAgICBzdHJpbmc6ICdcXHVmZWZmJ1xuICB9XG5dO1xuXG52YXIgc3RyaW5nRVMyMDE2ID0gJyc7XG52YXIgc3RyaW5nRVMyMDE4ID0gJyc7XG52YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gIGlmIChsaXN0W2ldLmVzMjAxNikge1xuICAgIHN0cmluZ0VTMjAxNiArPSBsaXN0W2ldLnN0cmluZztcbiAgfVxuXG4gIGlmIChsaXN0W2ldLmVzMjAxOCkge1xuICAgIHN0cmluZ0VTMjAxOCArPSBsaXN0W2ldLnN0cmluZztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHRoZSB3aGl0ZXNwYWNlIGNoYXIgY29kZXMsIHN0cmluZywgZGVzY3JpcHRpb25zIGFuZCBsYW5ndWFnZVxuICAgKiBwcmVzZW5jZSBpbiB0aGUgc3BlY2lmaWNhdGlvbnMuXG4gICAqXG4gICAqIEB0eXBlIEFycmF5LjxDaGFyUmVjb3JkPlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgd2hpdGVTcGFjZSA9IHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKTtcbiAgICogd2hpdGVTcGFjZXMubGlzdC5mb3JlYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAqICAgY29uc29sZS5sb2cobGliLmRlc2NyaXB0aW9uLCBpdGVtLmNvZGUsIGl0ZW0uc3RyaW5nKTtcbiAgICogfSk7XG4gICAqL1xuICBsaXN0OiBsaXN0LFxuICAvKipcbiAgICogQSBzdHJpbmcgb2YgdGhlIEVTMjAxNyB0byBFUzIwMTggd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAdHlwZSBzdHJpbmdcbiAgICovXG4gIHN0cmluZzogc3RyaW5nRVMyMDE4LFxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB0aGUgRVM1IHRvIEVTMjAxNiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5nNTogc3RyaW5nRVMyMDE2LFxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB0aGUgRVM1IHRvIEVTMjAxNiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5nMjAxNTogc3RyaW5nRVMyMDE2LFxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBvZiB0aGUgRVM1IHRvIEVTMjAxNiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEB0eXBlIHN0cmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgd2hpdGVTcGFjZSA9IHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKTtcbiAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAqICAgJ1xcdTAwMDknLFxuICAgKiAgICdcXHUwMDBhJyxcbiAgICogICAnXFx1MDAwYicsXG4gICAqICAgJ1xcdTAwMGMnLFxuICAgKiAgICdcXHUwMDBkJyxcbiAgICogICAnXFx1MDAyMCcsXG4gICAqICAgJ1xcdTAwYTAnLFxuICAgKiAgICdcXHUxNjgwJyxcbiAgICogICAnXFx1MTgwZScsXG4gICAqICAgJ1xcdTIwMDAnLFxuICAgKiAgICdcXHUyMDAxJyxcbiAgICogICAnXFx1MjAwMicsXG4gICAqICAgJ1xcdTIwMDMnLFxuICAgKiAgICdcXHUyMDA0JyxcbiAgICogICAnXFx1MjAwNScsXG4gICAqICAgJ1xcdTIwMDYnLFxuICAgKiAgICdcXHUyMDA3JyxcbiAgICogICAnXFx1MjAwOCcsXG4gICAqICAgJ1xcdTIwMDknLFxuICAgKiAgICdcXHUyMDBhJyxcbiAgICogICAnXFx1MjAyOCcsXG4gICAqICAgJ1xcdTIwMjknLFxuICAgKiAgICdcXHUyMDJmJyxcbiAgICogICAnXFx1MjA1ZicsXG4gICAqICAgJ1xcdTMwMDAnLFxuICAgKiAgICdcXHVmZWZmJ1xuICAgKiBdO1xuICAgKiB2YXIgd3MgPSBjaGFyYWN0ZXJzLmpvaW4oJycpO1xuICAgKiB2YXIgcmUxID0gbmV3IFJlZ0V4cCgnXlsnICsgd2hpdGVTcGFjZS5zdHJpbmcyMDE2ICsgJ10rJCknKTtcbiAgICogcmUxLnRlc3Qod3MpOyAvLyB0cnVlXG4gICAqL1xuICBzdHJpbmcyMDE2OiBzdHJpbmdFUzIwMTYsXG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHRoZSBFUzIwMTcgdG8gRVMyMDE4IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHR5cGUgc3RyaW5nXG4gICAqL1xuICBzdHJpbmcyMDE3OiBzdHJpbmdFUzIwMTgsXG5cbiAgLyoqXG4gICAqIEEgc3RyaW5nIG9mIHRoZSBFUzIwMTcgdG8gRVMyMDE4IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHR5cGUgc3RyaW5nXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB3aGl0ZVNwYWNlID0gcmVxdWlyZSgnd2hpdGUtc3BhY2UteCcpO1xuICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICogICAnXFx1MDAwOScsXG4gICAqICAgJ1xcdTAwMGEnLFxuICAgKiAgICdcXHUwMDBiJyxcbiAgICogICAnXFx1MDAwYycsXG4gICAqICAgJ1xcdTAwMGQnLFxuICAgKiAgICdcXHUwMDIwJyxcbiAgICogICAnXFx1MDBhMCcsXG4gICAqICAgJ1xcdTE2ODAnLFxuICAgKiAgICdcXHUyMDAwJyxcbiAgICogICAnXFx1MjAwMScsXG4gICAqICAgJ1xcdTIwMDInLFxuICAgKiAgICdcXHUyMDAzJyxcbiAgICogICAnXFx1MjAwNCcsXG4gICAqICAgJ1xcdTIwMDUnLFxuICAgKiAgICdcXHUyMDA2JyxcbiAgICogICAnXFx1MjAwNycsXG4gICAqICAgJ1xcdTIwMDgnLFxuICAgKiAgICdcXHUyMDA5JyxcbiAgICogICAnXFx1MjAwYScsXG4gICAqICAgJ1xcdTIwMjgnLFxuICAgKiAgICdcXHUyMDI5JyxcbiAgICogICAnXFx1MjAyZicsXG4gICAqICAgJ1xcdTIwNWYnLFxuICAgKiAgICdcXHUzMDAwJyxcbiAgICogICAnXFx1ZmVmZidcbiAgICogXTtcbiAgICogdmFyIHdzID0gY2hhcmFjdGVycy5qb2luKCcnKTtcbiAgICogdmFyIHJlMSA9IG5ldyBSZWdFeHAoJ15bJyArIHdoaXRlU3BhY2Uuc3RyaW5nMjAxOCArICddKyQpJyk7XG4gICAqIHJlMS50ZXN0KHdzKTsgLy8gdHJ1ZVxuICAgKi9cbiAgc3RyaW5nMjAxODogc3RyaW5nRVMyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUaGUgY29uc3RhbnQgdmFsdWUgSW5maW5pdHkuXG4gKiBAdmVyc2lvbiAxLjAuMlxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaW5maW5pdHkteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgY29uc3RhbnQgdmFsdWUgSW5maW5pdHkgZGVyaXZlZCBtYXRoZW1hdGljYWxseSBieSAxIC8gMC5cbiAqXG4gKiBAdHlwZSBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiB2YXIgSU5GSU5JVFkgPSByZXF1aXJlKCdpbmZpbml0eS14Jyk7XG4gKlxuICogSU5GSU5JVFkgPT09IEluZmluaXR5OyAvLyB0cnVlXG4gKiAtSU5GSU5JVFkgPT09IC1JbmZpbml0eTsgLy8gdHJ1ZVxuICogSU5GSU5JVFkgPT09IC1JbmZpbml0eTsgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAxIC8gMDtcbiIsIi8qKlxuICogQGZpbGUgQW4gaW1wbGVtZW50YXRpb24gb2Ygbm9kZSdzIEVTNiBpbnNwZWN0IG1vZHVsZS5cbiAqIEB2ZXJzaW9uIDEuOS4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3V0aWwuaHRtbCN1dGlsX3V0aWxfaW5zcGVjdF9vYmplY3Rfb3B0aW9uc1xuICogQG1vZHVsZSBpbnNwZWN0LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciBpc0FzeW5jRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1hc3luYy1mdW5jdGlvbi14Jyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCdpcy1yZWdleCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCdvYmplY3QtZGVmaW5lLXByb3BlcnRpZXMteCcpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ2lzLWFycmF5LWJ1ZmZlci14Jyk7XG52YXIgaXNTZXQgPSByZXF1aXJlKCdpcy1zZXQteCcpO1xudmFyIGlzTWFwID0gcmVxdWlyZSgnaXMtbWFwLXgnKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xudmFyIGlzRGF0YVZpZXcgPSByZXF1aXJlKCdpcy1kYXRhLXZpZXcteCcpO1xudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG52YXIgaXNOaWwgPSByZXF1aXJlKCdpcy1uaWwteCcpO1xudmFyIGlzTnVsbCA9IHJlcXVpcmUoJ2xvZGFzaC5pc251bGwnKTtcbnZhciBpc0Vycm9yID0gcmVxdWlyZSgnaXMtZXJyb3IteCcpO1xudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbnZhciBpc1Byb21pc2UgPSByZXF1aXJlKCdpcy1wcm9taXNlJyk7XG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2lzLW51bWJlci1vYmplY3QnKTtcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCdpcy1ib29sZWFuLW9iamVjdCcpO1xudmFyIGlzTmVnWmVybyA9IHJlcXVpcmUoJ2lzLW5lZ2F0aXZlLXplcm8nKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJ2lzLXN5bWJvbCcpO1xudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnaXMtcHJpbWl0aXZlJyk7XG52YXIgZ2V0RnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnZ2V0LWZ1bmN0aW9uLW5hbWUteCcpO1xudmFyIGhhc1N5bWJvbFN1cHBvcnQgPSByZXF1aXJlKCdoYXMtc3ltYm9sLXN1cHBvcnQteCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xudmFyIHdoaXRlU3BhY2UgPSByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jyk7XG52YXIgcmVTaW5nbGUgPSBuZXcgUmVnRXhwKCdcXFxce1snICsgd2hpdGVTcGFjZS5zdHJpbmcgKyAnXStcXFxcfScpO1xudmFyIGhhc1NldCA9IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNTZXQobmV3IFNldCgpKTtcbnZhciB0ZXN0U2V0ID0gaGFzU2V0ICYmIG5ldyBTZXQoWydTZXRTZW50aW5lbCddKTtcbnZhciBzRm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgc1ZhbHVlcyA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLnZhbHVlcztcbnZhciBoYXNNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIGlzTWFwKG5ldyBNYXAoKSk7XG52YXIgdGVzdE1hcCA9IGhhc01hcCAmJiBuZXcgTWFwKFtbMSwgJ01hcFNlbnRpbmVsJ11dKTtcbnZhciBtRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgbVZhbHVlcyA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLnZhbHVlcztcbnZhciBwU3ltVG9TdHIgPSBoYXNTeW1ib2xTdXBwb3J0ICYmIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcFN5bVZhbE9mID0gaGFzU3ltYm9sU3VwcG9ydCAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4LW9mLXgnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdhcnJheS1yZWR1Y2UteCcpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCdhcnJheS1mb3ItZWFjaC14Jyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnYXJyYXktZmlsdGVyLXgnKTtcbnZhciByZWZsZWN0T3duS2V5cyA9IHJlcXVpcmUoJ3JlZmxlY3Qtb3duLWtleXMteCcpO1xudmFyICRzdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uMycpLnN0cmluZ2lmeTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzLXgnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCdvYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLXgnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdnZXQtcHJvdG90eXBlLW9mLXgnKTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyICRpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJ2FycmF5LWluY2x1ZGVzLXgnKTtcbnZhciAkYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbi14Jyk7XG52YXIgJGlzTmFOID0gcmVxdWlyZSgnaXMtbmFuJyk7XG52YXIgcFJlZ0V4cFRvU3RyaW5nID0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBwRXJyb3JUb1N0cmluZyA9IEVycm9yLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBwTnVtYmVyVG9TdHJpbmcgPSBOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHBCb29sZWFuVG9TdHJpbmcgPSBCb29sZWFuLnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJ3RvLWlzby1zdHJpbmcteCcpO1xudmFyIGNvbGxlY3Rpb25zID0gcmVxdWlyZSgnY29sbGVjdGlvbnMteCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14Jyk7XG4vLyB2YXIgaGFzVG9TdHJpbmdUYWcgPSBoYXNTeW1ib2xTdXBwb3J0ICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGJwZSA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG52YXIgaW5zcGVjdDtcbnZhciBmbXRWYWx1ZTtcblxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSBoYXNTeW1ib2xTdXBwb3J0ID8gU3ltYm9sKCdpbnNwZWN0LmN1c3RvbScpIDogJ19pbnNwZWN0LmN1c3RvbV8nO1xuXG52YXIgc3VwcG9ydHNDbGFzc2VzO1xudHJ5IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIG5ldyBGdW5jdGlvbigncmV0dXJuIGNsYXNzIE15IHt9JykoKTtcbiAgc3VwcG9ydHNDbGFzc2VzID0gdHJ1ZTtcbn0gY2F0Y2ggKGUpIHt9XG5cbnZhciBzdXBwb3J0c0dldFNldDtcbnRyeSB7XG4gIHZhciB0ZXN0VmFyO1xuICB2YXIgdGVzdE9iamVjdCA9IGRlZmluZVByb3BlcnR5KHt9LCAnZGVmYXVsdE9wdGlvbnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBfZ2V0KCkge1xuICAgICAgcmV0dXJuIHRlc3RWYXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIF9zZXQodmFsKSB7XG4gICAgICB0ZXN0VmFyID0gdmFsO1xuICAgICAgcmV0dXJuIHRlc3RWYXI7XG4gICAgfVxuICB9KTtcblxuICB0ZXN0T2JqZWN0LmRlZmF1bHRPcHRpb25zID0gJ3Rlc3QnO1xuICBzdXBwb3J0c0dldFNldCA9IHRlc3RWYXIgPT09ICd0ZXN0JyAmJiB0ZXN0T2JqZWN0LmRlZmF1bHRPcHRpb25zID09PSAndGVzdCc7XG59IGNhdGNoIChpZ25vcmUpIHt9XG5cbnZhciAkc2VhbCA9IGlzRnVuY3Rpb24oT2JqZWN0LnNlYWwpID8gT2JqZWN0LnNlYWwgOiBmdW5jdGlvbiBzZWFsKG9iaikge1xuICByZXR1cm4gb2JqO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBpc0Z1bmN0aW9uKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5pZiAoJGdldE93blByb3BlcnR5U3ltYm9scykge1xuICB0cnkge1xuICAgIHZhciBnT1BTeW1ib2wgPSBoYXNTeW1ib2xTdXBwb3J0ICYmIFN5bWJvbCgnJyk7XG4gICAgdmFyIGdPUFNPYmogPSB7IGE6IDEgfTtcbiAgICBnT1BTT2JqW2dPUFN5bWJvbF0gPSAyO1xuXG4gICAgdmFyIGdPUFN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzKGdPUFNPYmopO1xuICAgIGlmIChnT1BTeW1ib2wpIHtcbiAgICAgIGlmIChnT1BTeW1ib2xzLmxlbmd0aCAhPT0gMSB8fCBnT1BTeW1ib2xzWzBdICE9PSBnT1BTeW1ib2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmF2bGlkIHJlc3VsdCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ09QU3ltYm9scy5sZW5ndGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5hdmxpZCByZXN1bHQnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBudWxsO1xuICB9XG59XG5cbnZhciBtaXNzaW5nRXJyb3I7XG52YXIgZXJyUHJvcHM7XG50cnkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Rlc3QnKTtcbn0gY2F0Y2ggKGUpIHtcbiAgZXJyUHJvcHMgPSAka2V5cyhlKTtcbiAgZm9yRWFjaCgka2V5cyhuZXcgRXJyb3IoKSksIGZ1bmN0aW9uIF9wdXNoZXIocCkge1xuICAgIGlmICgkaW5jbHVkZXMoZXJyUHJvcHMsIHApID09PSBmYWxzZSkge1xuICAgICAgZXJyUHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBlcnJvclN0cmluZyA9IHBFcnJvclRvU3RyaW5nLmNhbGwoZSk7XG4gIHZhciBlcnJvclN0YWNrID0gZS5zdGFjaztcbiAgaWYgKGVycm9yU3RhY2spIHtcbiAgICB2YXIgZXJyb3JSeCA9IG5ldyBSZWdFeHAoJ14nICsgZXJyb3JTdHJpbmcpO1xuICAgIGlmIChlcnJvclJ4LnRlc3QoZXJyb3JTdGFjaykgPT09IGZhbHNlKSB7XG4gICAgICBtaXNzaW5nRXJyb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5pZiAoaXNEYXRlKERhdGUucHJvdG90eXBlKSkge1xuICBpc0RhdGUgPSBmdW5jdGlvbiBfaXNEYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGRhdGVQcm9wcyA9ICRrZXlzKERhdGUpO1xudmFyIHNoaW1tZWREYXRlO1xuaWYgKGRhdGVQcm9wcy5sZW5ndGggJiYgJGluY2x1ZGVzKGRhdGVQcm9wcywgJ25vdycpICYmICRpbmNsdWRlcyhkYXRlUHJvcHMsICdVVEMnKSAmJiAkaW5jbHVkZXMoZGF0ZVByb3BzLCAncGFyc2UnKSkge1xuICBzaGltbWVkRGF0ZSA9ICRpbmNsdWRlcygka2V5cyhuZXcgRGF0ZSgpKSwgJ2NvbnN0cnVjdG9yJyk7XG59XG5cbnZhciBpbnNwZWN0RGVmYXVsdE9wdGlvbnMgPSAkc2VhbCh7XG4gIGJyZWFrTGVuZ3RoOiA2MCxcbiAgY29sb3JzOiBmYWxzZSxcbiAgY3VzdG9tSW5zcGVjdDogdHJ1ZSxcbiAgZGVwdGg6IDIsXG4gIG1heEFycmF5TGVuZ3RoOiAxMDAsXG4gIHNob3dIaWRkZW46IGZhbHNlLFxuICBzaG93UHJveHk6IGZhbHNlXG59KTtcblxudmFyIGlzQm9vbGVhblR5cGUgPSBmdW5jdGlvbiBfaXNCb29sZWFuVHlwZShhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn07XG5cbnZhciBpc051bWJlclR5cGUgPSBmdW5jdGlvbiBfaXNOdW1iZXJUeXBlKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59O1xuXG52YXIgaXNTdHJpbmdUeXBlID0gZnVuY3Rpb24gX2lzU3RyaW5nVHlwZShhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufTtcblxudmFyIGlzU3ltYm9sVHlwZSA9IGZ1bmN0aW9uIF9pc1N5bWJvbFR5cGUoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn07XG5cbnZhciBpc01hcEl0ZXJhdG9yID0gZnVuY3Rpb24gX2lzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgaWYgKGhhc01hcCA9PT0gZmFsc2UgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB2YWx1ZS5uZXh0LmNhbGwobVZhbHVlcy5jYWxsKHRlc3RNYXApKS52YWx1ZSA9PT0gJ01hcFNlbnRpbmVsJztcbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpc1NldEl0ZXJhdG9yID0gZnVuY3Rpb24gX2lzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgaWYgKGhhc1NldCA9PT0gZmFsc2UgfHwgaXNPYmplY3RMaWtlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB2YWx1ZS5uZXh0LmNhbGwoc1ZhbHVlcy5jYWxsKHRlc3RTZXQpKS52YWx1ZSA9PT0gJ1NldFNlbnRpbmVsJztcbiAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBmaWx0ZXJJbmRleGVzID0gZnVuY3Rpb24gX2ZpbHRlckluZGV4ZXMoa2V5cywgbGVuZ3RoKSB7XG4gIHZhciBpID0ga2V5cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoaSA+IC0xKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA+IC0xICYmIGtleSAlIDEgPT09IDAgJiYga2V5IDwgbGVuZ3RoICYmIGlzU3ltYm9sVHlwZShrZXkpID09PSBmYWxzZSkge1xuICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgaSAtPSAxO1xuICB9XG59O1xuXG52YXIgcHVzaFVuaXEgPSBmdW5jdGlvbiBfcHVzaFVuaXEoYXJyLCB2YWx1ZSkge1xuICBpZiAoJGluY2x1ZGVzKGFyciwgdmFsdWUpID09PSBmYWxzZSkge1xuICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgfVxufTtcblxudmFyIHVuc2hpZnRVbmlxID0gZnVuY3Rpb24gX3Vuc2hpZnRVbmlxKGFyciwgdmFsdWUpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnIsIHZhbHVlKTtcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGFyci51bnNoaWZ0KHZhbHVlKTtcbn07XG5cbnZhciBzdHlsaXplV2l0aENvbG9yID0gZnVuY3Rpb24gX3N0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgdmFyIGNvbG9ycyA9IGluc3BlY3QuY29sb3JzW3N0eWxlXTtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGNvbG9yc1swXSArICdtJyArIHN0ciArICdcXHUwMDFiWycgKyBjb2xvcnNbMV0gKyAnbSc7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxudmFyIHN0eWxpemVOb0NvbG9yID0gZnVuY3Rpb24gX3N0eWxpemVOb0NvbG9yKHN0cikge1xuICByZXR1cm4gc3RyO1xufTtcblxudmFyIGdldE5hbWVTZXAgPSBmdW5jdGlvbiBfZ2V0TmFtZVNlcChvYmopIHtcbiAgdmFyIG5hbWUgPSBnZXRGdW5jdGlvbk5hbWUob2JqKTtcbiAgcmV0dXJuIG5hbWUgPyAnOiAnICsgbmFtZSA6IG5hbWU7XG59O1xuXG52YXIgY29sbGVjdGlvbkVhY2ggPSBmdW5jdGlvbiBfY29sbGVjdGlvbkVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKGlzTWFwKGNvbGxlY3Rpb24pKSB7XG4gICAgbUZvckVhY2guY2FsbChjb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoaXNTZXQoY29sbGVjdGlvbikpIHtcbiAgICBzRm9yRWFjaC5jYWxsKGNvbGxlY3Rpb24sIGNhbGxiYWNrKTtcbiAgfVxufTtcblxudmFyIGdldENvbnN0cnVjdG9yT2YgPSBmdW5jdGlvbiBfZ2V0Q29uc3RydWN0b3JPZihvYmopIHtcbiAgdmFyIG8gPSBvYmo7XG4gIHZhciBtYXhMb29wID0gMTAwO1xuICB3aGlsZSAoaXNOaWwobykgPT09IGZhbHNlICYmIG1heExvb3AgPiAtMSkge1xuICAgIG8gPSBPYmplY3Qobyk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgJ2NvbnN0cnVjdG9yJyk7XG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuXG4gICAgbyA9ICRnZXRQcm90b3R5cGVPZihvKTtcbiAgICBtYXhMb29wIC09IDE7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBpc1N1YiA9IGZ1bmN0aW9uIF9pc1N1Yih2YWx1ZSkge1xuICBpZiAoc3VwcG9ydHNDbGFzc2VzICE9PSB0cnVlIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yT2YodmFsdWUpO1xuICByZXR1cm4gaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgPT09IGZhbHNlICYmIGlzRnVuY3Rpb24oY29uc3RydWN0b3IsIHRydWUpO1xufTtcblxudmFyIGdldFN1Yk5hbWUgPSBmdW5jdGlvbiBfZ2V0U3ViTmFtZSh2YWx1ZSwgbmFtZSkge1xuICBpZiAoaXNTdWIodmFsdWUpKSB7XG4gICAgdmFyIHN1Yk5hbWUgPSBnZXRGdW5jdGlvbk5hbWUoZ2V0Q29uc3RydWN0b3JPZih2YWx1ZSkpO1xuICAgIGlmIChzdWJOYW1lICYmIHN1Yk5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBzdWJOYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lID8gbmFtZSA6IGdldEZ1bmN0aW9uTmFtZShnZXRDb25zdHJ1Y3Rvck9mKHZhbHVlKSk7XG59O1xuXG52YXIgZm10TnVtYmVyID0gZnVuY3Rpb24gX2ZtdE51bWJlcihjdHgsIHZhbHVlKSB7XG4gIC8vIEZvcm1hdCAtMCBhcyAnLTAnLlxuICByZXR1cm4gY3R4LnN0eWxpemUoaXNOZWdaZXJvKHZhbHVlKSA/ICctMCcgOiBwTnVtYmVyVG9TdHJpbmcuY2FsbCh2YWx1ZSksICdudW1iZXInKTtcbn07XG5cbnZhciBmbXRQcmltaXRpdmUgPSBmdW5jdGlvbiBfZm10UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzTmlsKHZhbHVlKSkge1xuICAgIHZhciBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzdHIsIHN0cik7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdUeXBlKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAkc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKS5yZXBsYWNlKC8nL2csICdcXFxcXFwnJykucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnXFwnJyArIHNpbXBsZSArICdcXCcnLCAnc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoaXNOdW1iZXJUeXBlKHZhbHVlKSkge1xuICAgIHJldHVybiBmbXROdW1iZXIoY3R4LCB2YWx1ZSk7XG4gIH1cblxuICBpZiAoaXNCb29sZWFuVHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUocEJvb2xlYW5Ub1N0cmluZy5jYWxsKHZhbHVlKSwgJ2Jvb2xlYW4nKTtcbiAgfVxuXG4gIC8vIGVzNiBzeW1ib2wgcHJpbWl0aXZlXG4gIGlmIChpc1N5bWJvbFR5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHBTeW1Ub1N0ci5jYWxsKHZhbHVlKSwgJ3N5bWJvbCcpO1xuICB9XG5cbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5cbnZhciBmbXRQcmltTm9Db2xvciA9IGZ1bmN0aW9uIF9mbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlKSB7XG4gIHZhciBzdHlsaXplID0gY3R4LnN0eWxpemU7XG4gIGN0eC5zdHlsaXplID0gc3R5bGl6ZU5vQ29sb3I7XG4gIHZhciBzdHIgPSBmbXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGN0eC5zdHlsaXplID0gc3R5bGl6ZTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbnZhciByZWN1cnNlID0gZnVuY3Rpb24gX3JlY3Vyc2UoZGVwdGgpIHtcbiAgcmV0dXJuIGlzTnVsbChkZXB0aCkgPyBudWxsIDogZGVwdGggLSAxO1xufTtcblxuLypcbnZhciBpc0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSk7XG59O1xuKi9cblxudmFyIGlzRGlnaXRzID0gZnVuY3Rpb24gX2lzRGlnaXRzKGtleSkge1xuICByZXR1cm4gKC9eXFxkKyQvKS50ZXN0KGtleSk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGZtdFByb3AgPSBmdW5jdGlvbiBfZm10UHJvcChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleSwgYXJyKSB7XG4gIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcblxuICAvKlxuICAvLyB0aGlzIGlzIGEgZml4IGZvciBicm9rZW4gRmlyZUZveCwgc2hvdWxkIG5vdCBiZSBuZWVkZWQgd2l0aCBlczYtc2hpbVxuICBpZiAoa2V5ID09PSAnc2l6ZScgJiYgaXNDb2xsZWN0aW9uKHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNpemUpKSB7XG4gICAgZGVzYy52YWx1ZSA9IHZhbHVlLnNpemUoKTtcbiAgfVxuICAqL1xuXG4gIHZhciBuYW1lO1xuICBpZiAoJGluY2x1ZGVzKHZpc2libGVLZXlzLCBrZXkpID09PSBmYWxzZSkge1xuICAgIGlmIChrZXkgPT09IGJwZSAmJiBCb29sZWFuKHZhbHVlW2JwZV0pID09PSBmYWxzZSAmJiBpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YXIgY29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvck9mKHZhbHVlKTtcbiAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBkZXNjLnZhbHVlID0gY29uc3RydWN0b3JbYnBlXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU3ltYm9sVHlwZShrZXkpKSB7XG4gICAgICBuYW1lID0gJ1snICsgY3R4LnN0eWxpemUocFN5bVRvU3RyLmNhbGwoa2V5KSwgJ3N5bWJvbCcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHI7XG4gIGlmIChkZXNjLmdldCkge1xuICAgIHN0ciA9IGN0eC5zdHlsaXplKGRlc2Muc2V0ID8gJ1tHZXR0ZXIvU2V0dGVyXScgOiAnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICB9IGVsc2UgaWYgKGRlc2Muc2V0KSB7XG4gICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBmbXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2UoZGVwdGgpKTtcbiAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgIHZhciByeCA9IGFyciA/IC9cXG4vZyA6IC8oXnxcXG4pL2c7XG4gICAgICB2YXIgclN0ciA9IGFyciA/ICdcXG4gICcgOiAnXFxuICAgJztcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHJ4LCByU3RyKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyICYmIGlzRGlnaXRzKGtleSkpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgbmFtZSA9ICRzdHJpbmdpZnkoa2V5KTtcbiAgICBpZiAoL15cIltcXHckXStcIiQvLnRlc3QobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLnNsaWNlKDEsIC0xKSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCAnXFxcXFxcJycpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKS5yZXBsYWNlKC8oXlwifFwiJCkvZywgJ1xcJycpLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG52YXIgZm10T2JqZWN0ID0gZnVuY3Rpb24gX2ZtdE9iamVjdChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIF9wdXNoZXJGbU9iamVjdChrZXkpIHtcbiAgICBvdXQucHVzaChmbXRQcm9wKGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5LCBmYWxzZSkpO1xuICB9KTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbnZhciBmbXRBcnJheSA9IGZ1bmN0aW9uIF9mbXRBcnJheShjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgdmlzaWJsZUxlbmd0aCA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IHZhbHVlLmxlbmd0aCAmJiB2aXNpYmxlTGVuZ3RoIDwgY3R4Lm1heEFycmF5TGVuZ3RoKSB7XG4gICAgdmFyIGVtcHR5SXRlbXMgPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IHZhbHVlLmxlbmd0aCAmJiBoYXNPd24odmFsdWUsIHBOdW1iZXJUb1N0cmluZy5jYWxsKGluZGV4KSkgPT09IGZhbHNlKSB7XG4gICAgICBlbXB0eUl0ZW1zICs9IDE7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cblxuICAgIGlmIChlbXB0eUl0ZW1zID4gMCkge1xuICAgICAgdmFyIGVuZGluZyA9IGVtcHR5SXRlbXMgPiAxID8gJ3MnIDogJyc7XG4gICAgICB2YXIgbWVzc2FnZSA9ICc8JyArIGVtcHR5SXRlbXMgKyAnIGVtcHR5IGl0ZW0nICsgZW5kaW5nICsgJz4nO1xuICAgICAgb3V0cHV0LnB1c2goY3R4LnN0eWxpemUobWVzc2FnZSwgJ3VuZGVmaW5lZCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goZm10UHJvcChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIHBOdW1iZXJUb1N0cmluZy5jYWxsKGluZGV4KSwgdHJ1ZSkpO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICB9XG5cbiAgICB2aXNpYmxlTGVuZ3RoICs9IDE7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gaW5kZXg7XG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goJy4uLiAnICsgcmVtYWluaW5nICsgJyBtb3JlIGl0ZW0nICsgKHJlbWFpbmluZyA+IDEgPyAncycgOiAnJykpO1xuICB9XG5cbiAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiBfcHVzaGVyRm10QXJyYXkoa2V5KSB7XG4gICAgaWYgKGlzU3ltYm9sVHlwZShrZXkpIHx8IGlzRGlnaXRzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICBvdXRwdXQucHVzaChmbXRQcm9wKGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbnZhciBmbXRUeXBlZEFycmF5ID0gZnVuY3Rpb24gX2ZtdFR5cGVkQXJyYXkoY3R4LCB2YWx1ZSwgZGVwdGgsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBtYXhMZW5ndGggPSBNYXRoLm1pbihNYXRoLm1heCgwLCBjdHgubWF4QXJyYXlMZW5ndGgpLCB2YWx1ZS5sZW5ndGgpO1xuICB2YXIgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICB2YXIgb3V0cHV0ID0gbmV3IEFycmF5KG1heExlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpICs9IDEpIHtcbiAgICBvdXRwdXRbaV0gPSBmbXROdW1iZXIoY3R4LCB2YWx1ZVtpXSk7XG4gIH1cblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKCcuLi4gJyArIHJlbWFpbmluZyArICcgbW9yZSBpdGVtJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpKTtcbiAgfVxuXG4gIGZvckVhY2goa2V5cywgZnVuY3Rpb24gX3B1c2hlckZtdFR5cGVkQXJyYXkoa2V5KSB7XG4gICAgaWYgKGlzU3ltYm9sVHlwZShrZXkpIHx8IGlzRGlnaXRzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICBvdXRwdXQucHVzaChmbXRQcm9wKGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbnZhciBmbXRTZXQgPSBmdW5jdGlvbiBfZm10U2V0KGN0eCwgdmFsdWUsIGRlcHRoLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0ID0gW107XG4gIGNvbGxlY3Rpb25FYWNoKHZhbHVlLCBmdW5jdGlvbiBfcHVzaGVyRm10U2V0MSh2KSB7XG4gICAgb3V0LnB1c2goZm10VmFsdWUoY3R4LCB2LCByZWN1cnNlKGRlcHRoKSkpO1xuICB9KTtcblxuICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIF9wdXNoZXJGbXRTZXQyKGtleSkge1xuICAgIG91dC5wdXNoKGZtdFByb3AoY3R4LCB2YWx1ZSwgZGVwdGgsIHZpc2libGVLZXlzLCBrZXksIGZhbHNlKSk7XG4gIH0pO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xudmFyIGZtdE1hcCA9IGZ1bmN0aW9uIChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBjb2xsZWN0aW9uRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICB2YXIgciA9IHJlY3Vyc2UoZGVwdGgpO1xuICAgIG91dC5wdXNoKGZtdFZhbHVlKGN0eCwgaywgcikgKyAnID0+ICcgKyBmbXRWYWx1ZShjdHgsIHYsIHIpKTtcbiAgfSk7XG5cbiAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgb3V0LnB1c2goZm10UHJvcChjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleSwgZmFsc2UpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbnZhciByZWR1Y2VUb1NpbmdsZVN0cmluZyA9IGZ1bmN0aW9uIF9yZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbGVuZ3RoID0gcmVkdWNlKG91dCwgZnVuY3Rpb24gX3JlZHVjZXIocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICB2YXIgcmVzdWx0O1xuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICAvLyBJZiB0aGUgb3BlbmluZyBcImJyYWNlXCIgaXMgdG9vIGxhcmdlLCBsaWtlIGluIHRoZSBjYXNlIG9mIFwiU2V0IHtcIixcbiAgICAvLyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIG9uIHRoZSBuZXh0IGxpbmUgb3IgdGhlXG4gICAgLy8gaXRlbXMgd2lsbCBub3QgbGluZSB1cCBjb3JyZWN0bHkuXG4gICAgdmFyIGxheW91dEJhc2UgPSBiYXNlID09PSAnJyAmJiBicmFjZXNbMF0ubGVuZ3RoID09PSAxID8gJycgOiBiYXNlICsgJ1xcbiAnO1xuICAgIHJlc3VsdCA9IGJyYWNlc1swXSArIGxheW91dEJhc2UgKyAnICcgKyBvdXQuam9pbignLFxcbiAgJykgKyAnICcgKyBicmFjZXNbMV07XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKHJlU2luZ2xlLCAne30nKTtcbn07XG5cbnZhciBmbXREYXRlID0gZnVuY3Rpb24gX2ZtdERhdGUodmFsdWUpIHtcbiAgcmV0dXJuICRpc05hTih2YWx1ZS5nZXRUaW1lKCkpID8gJ0ludmFsaWQgRGF0ZScgOiB0b0lTT1N0cmluZyh2YWx1ZSk7XG59O1xuXG52YXIgZm10RXJyb3IgPSBmdW5jdGlvbiBfZm10RXJyb3IodmFsdWUpIHtcbiAgdmFyIHN0YWNrID0gdmFsdWUuc3RhY2s7XG4gIGlmIChzdGFjaykge1xuICAgIGlmIChzdXBwb3J0c0NsYXNzZXMpIHtcbiAgICAgIHZhciBzdWJOYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSk7XG4gICAgICBpZiAoc3ViTmFtZSAmJiBzdGFjay5zdGFydHNXaXRoKHN1Yk5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgbXNnID0gdmFsdWUubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnJlcGxhY2UocEVycm9yVG9TdHJpbmcuY2FsbCh2YWx1ZSksIHN1Yk5hbWUgKyAobXNnID8gJzogJyArIG1zZyA6ICcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaXNzaW5nRXJyb3IpIHtcbiAgICAgIHJldHVybiBwRXJyb3JUb1N0cmluZy5jYWxsKHZhbHVlKSArICdcXG4nICsgc3RhY2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YWNrIHx8ICdbJyArIHBFcnJvclRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufTtcblxudmFyIGZpbHRlckRhdGVLZXlzID0gZnVuY3Rpb24gX2ZpbHRlckRhdGVLZXlzKGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAnY29uc3RydWN0b3InO1xufTtcblxudmFyIGZpbHRlckVycm9yS2V5cyA9IGZ1bmN0aW9uIF9maWx0ZXJFcnJvcktleXMoa2V5KSB7XG4gIHJldHVybiAkaW5jbHVkZXMoZXJyUHJvcHMsIGtleSkgPT09IGZhbHNlO1xufTtcblxudmFyIGdldFZpc2libGVLZXlzID0gZnVuY3Rpb24gX2dldFZpc2libGVLZXlzKHZhbHVlKSB7XG4gIHZhciBrZXlzID0gJGtleXModmFsdWUpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHNoaW1tZWREYXRlICYmIGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmaWx0ZXIoa2V5cywgZmlsdGVyRGF0ZUtleXMpO1xuICAgIH1cblxuICAgIGlmIChlcnJQcm9wcy5sZW5ndGggPiAwICYmIGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmlsdGVyKGtleXMsIGZpbHRlckVycm9yS2V5cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgZ2V0RW51bVN5bWJvbHMgPSBmdW5jdGlvbiBfZ2V0RW51bVN5bWJvbHModmFsdWUpIHtcbiAgaWYgKCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gZmlsdGVyKCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLCBmdW5jdGlvbiBfZmlsdGVyRW51bVN5bWJvbEtleXMoa2V5KSB7XG4gICAgICByZXR1cm4gJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIGtleSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gW107XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZm10VmFsdWUgPSBmdW5jdGlvbiBfZm10VmFsdWUoY3R4LCB2YWx1ZSwgZGVwdGgpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmIHZhbHVlKSB7XG4gICAgdmFyIG1heWJlQ3VzdG9tSW5zcGVjdCA9IHZhbHVlW2N1c3RvbUluc3BlY3RTeW1ib2xdIHx8IHZhbHVlLmluc3BlY3Q7XG4gICAgaWYgKGlzRnVuY3Rpb24obWF5YmVDdXN0b21JbnNwZWN0KSkge1xuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0cyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIGlmIChtYXliZUN1c3RvbUluc3BlY3QgIT09IGluc3BlY3QpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3JPZih2YWx1ZSk7XG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICB2YXIgaXNDaXJjdWxhciA9IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWU7XG4gICAgICAgIGlmIChpc0NpcmN1bGFyID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciByZXQgPSBtYXliZUN1c3RvbUluc3BlY3QuY2FsbCh2YWx1ZSwgZGVwdGgsIGN0eCk7XG4gICAgICAgICAgLy8gSWYgdGhlIGN1c3RvbSBpbnNwZWN0aW9uIG1ldGhvZCByZXR1cm5lZCBgdGhpc2AsIGRvbid0IGdvIGludG9cbiAgICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgIGlmIChyZXQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmdUeXBlKHJldCkgPyByZXQgOiBmbXRWYWx1ZShjdHgsIHJldCwgZGVwdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmbXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIgdmlzaWJsZUtleXMgPSBnZXRWaXNpYmxlS2V5cyh2YWx1ZSk7XG4gIHZhciBrZXlzO1xuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gcmVmbGVjdE93bktleXModmFsdWUpO1xuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgaWYgKCRpbmNsdWRlcyh2aXNpYmxlS2V5cywgJ21lc3NhZ2UnKSA9PT0gZmFsc2UgJiYgJGluY2x1ZGVzKGtleXMsICdtZXNzYWdlJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHVuc2hpZnRVbmlxKGtleXMsICdtZXNzYWdlJyk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICBpZiAoaW5jbHVkZXModmlzaWJsZUtleXMsICduYW1lJykgPT09IGZhbHNlICYmIGluY2x1ZGVzKGtleXMsICduYW1lJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHVuc2hpZnRVbmlxKGtleXMsICduYW1lJyk7XG4gICAgICB9XG4gICAgICAqL1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gdmlzaWJsZUtleXMuY29uY2F0KGdldEVudW1TeW1ib2xzKHZhbHVlKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgLy8gZm9yIGJveGVkIFN0cmluZ3MsIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSAwLW4gaW5kZXhlZCBlbnRyaWVzLFxuICAgIC8vIHNpbmNlIHRoZXkganVzdCBub2lzZXkgdXAgdGhlIG91dCBhbmQgYXJlIHJlZHVuZGFudFxuICAgIGZpbHRlckluZGV4ZXMoa2V5cywgdmFsdWUubGVuZ3RoKTtcbiAgICBmaWx0ZXJJbmRleGVzKHZpc2libGVLZXlzLCB2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgZmlsdGVySW5kZXhlcyhrZXlzLCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICBmaWx0ZXJJbmRleGVzKHZpc2libGVLZXlzLCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBuYW1lO1xuICB2YXIgZm9ybWF0dGVkO1xuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFRoaXMgY291bGQgYmUgYSBib3hlZCBwcmltaXRpdmUgKG5ldyBTdHJpbmcoKSwgZXRjLilcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoXG4gICAgICAgICdbJyArIGdldFN1Yk5hbWUodmFsdWUsICdTdHJpbmcnKSArICc6ICcgKyBmbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlLnZhbHVlT2YoKSkgKyAnXScsXG4gICAgICAgICdzdHJpbmcnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcbiAgICAgICAgJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ051bWJlcicpICsgJzogJyArIGZtdFByaW1Ob0NvbG9yKGN0eCwgdmFsdWUudmFsdWVPZigpKSArICddJyxcbiAgICAgICAgJ251bWJlcidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcbiAgICAgICAgJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ0Jvb2xlYW4nKSArICc6ICcgKyBmbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlLnZhbHVlT2YoKSkgKyAnXScsXG4gICAgICAgICdib29sZWFuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoXG4gICAgICAgICdbU3ltYm9sOiAnICsgZm10UHJpbU5vQ29sb3IoY3R4LCBwU3ltVmFsT2YuY2FsbCh2YWx1ZSkpICsgJ10nLFxuICAgICAgICAnc3ltYm9sJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbQXN5bmNGdW5jdGlvbicgKyBnZXROYW1lU2VwKHZhbHVlKSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNHZW5lcmF0b3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0dlbmVyYXRvckZ1bmN0aW9uJyArIGdldE5hbWVTZXAodmFsdWUpICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbJyArIGdldFN1Yk5hbWUodmFsdWUsICdGdW5jdGlvbicpICsgZ2V0TmFtZVNlcCh2YWx1ZSkgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NlcyAmJiBpc0Z1bmN0aW9uKHZhbHVlLCB0cnVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbQ2xhc3MnICsgZ2V0TmFtZVNlcCh2YWx1ZSkgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHBSZWdFeHBUb1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cblxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSk7XG4gICAgICBmb3JtYXR0ZWQgPSBjdHguc3R5bGl6ZShmbXREYXRlKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICAgIGlmIChuYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbJyArIG5hbWUgKyAnOiAnICsgZm9ybWF0dGVkICsgJ10nLCAnZGF0ZScpO1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZtdEVycm9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IHBhdGggZm9yIEFycmF5QnVmZmVyLiBDYW4ndCBkbyB0aGUgc2FtZSBmb3IgRGF0YVZpZXcgYmVjYXVzZSBpdFxuICAgIC8vIGhhcyBhIG5vbi1wcmltaXRpdmUgYnVmZmVyIHByb3BlcnR5IHRoYXQgd2UgbmVlZCB0byByZWN1cnNlIGZvci5cbiAgICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBnZXRTdWJOYW1lKHZhbHVlLCAnQXJyYXlCdWZmZXInKSArICcgeyBieXRlTGVuZ3RoOiAnICsgZm10TnVtYmVyKGN0eCwgdmFsdWUuYnl0ZUxlbmd0aCkgKyAnIH0nO1xuICAgIH1cblxuICAgIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGdldFN1Yk5hbWUodmFsdWUsICdNYXBJdGVyYXRvcicpICsgJyB7fSc7XG4gICAgfVxuXG4gICAgaWYgKGlzU2V0SXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZ2V0U3ViTmFtZSh2YWx1ZSwgJ1NldEl0ZXJhdG9yJykgKyAnIHt9JztcbiAgICB9XG5cbiAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGdldFN1Yk5hbWUodmFsdWUsICdQcm9taXNlJykgKyAnIHt9JztcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnO1xuICB2YXIgZW1wdHkgPSBmYWxzZTtcbiAgdmFyIGJyYWNlcyA9IFsneycsICd9J107XG4gIHZhciBmbXR0ZXIgPSBmbXRPYmplY3Q7XG4gIC8vIFdlIGNhbid0IGNvbXBhcmUgY29uc3RydWN0b3JzIGZvciB2YXJpb3VzIG9iamVjdHMgdXNpbmcgYSBjb21wYXJpc29uXG4gIC8vIGxpa2UgYGNvbnN0cnVjdG9yID09PSBBcnJheWAgYmVjYXVzZSB0aGUgb2JqZWN0IGNvdWxkIGhhdmUgY29tZSBmcm9tIGFcbiAgLy8gZGlmZmVyZW50IGNvbnRleHQgYW5kIHRodXMgdGhlIGNvbnN0cnVjdG9yIHdvbid0IG1hdGNoLiBJbnN0ZWFkIHdlIGNoZWNrXG4gIC8vIHRoZSBjb25zdHJ1Y3RvciBuYW1lcyAoaW5jbHVkaW5nIHRob3NlIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gd2hlcmVcbiAgLy8gbmVlZGVkKSB0byBkZXRlcm1pbmUgb2JqZWN0IHR5cGVzLlxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgLy8gTWFrZSBib3hlZCBwcmltaXRpdmUgU3RyaW5ncyBsb29rIGxpa2Ugc3VjaFxuICAgIGJhc2UgPSAnWycgKyBnZXRTdWJOYW1lKHZhbHVlLCAnU3RyaW5nJykgKyAnOiAnICsgZm10UHJpbU5vQ29sb3IoY3R4LCB2YWx1ZS52YWx1ZU9mKCkpICsgJ10nO1xuICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgIC8vIE1ha2UgYm94ZWQgcHJpbWl0aXZlIE51bWJlcnMgbG9vayBsaWtlIHN1Y2hcbiAgICBiYXNlID0gJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ051bWJlcicpICsgJzogJyArIGZtdFByaW1Ob0NvbG9yKGN0eCwgdmFsdWUudmFsdWVPZigpKSArICddJztcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgLy8gTWFrZSBib3hlZCBwcmltaXRpdmUgQm9vbGVhbnMgbG9vayBsaWtlIHN1Y2hcbiAgICBiYXNlID0gJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ0Jvb2xlYW4nKSArICc6ICcgKyBmbXRQcmltTm9Db2xvcihjdHgsIHZhbHVlLnZhbHVlT2YoKSkgKyAnXSc7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBiYXNlID0gJ1snICsgZ2V0U3ViTmFtZSh2YWx1ZSwgJ0Z1bmN0aW9uJykgKyBnZXROYW1lU2VwKHZhbHVlKSArICddJztcbiAgfSBlbHNlIGlmIChzdXBwb3J0c0NsYXNzZXMgJiYgaXNGdW5jdGlvbih2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBiYXNlID0gJ1tDbGFzcycgKyBnZXROYW1lU2VwKHZhbHVlKSArICddJztcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICAgIC8vIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlLCAnUmVnRXhwJyk7XG4gICAgYmFzZSA9IHBSZWdFeHBUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUpO1xuICAgIGZvcm1hdHRlZCA9IGZtdERhdGUodmFsdWUpO1xuICAgIGlmIChuYW1lID09PSAnRGF0ZScpIHtcbiAgICAgIGJhc2UgPSBmb3JtYXR0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnWycgKyBuYW1lICsgJzogJyArIGZvcm1hdHRlZCArICddJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSk7XG4gICAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICAgIGJhc2UgPSBmbXRFcnJvcih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoJGlzQXJyYXkodmFsdWUpKSB7XG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUpO1xuICAgIC8vIFVuc2V0IHRoZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IFwiQXJyYXkgWy4uLl1cIiBmb3Igb3JkaW5hcnkgYXJyYXlzLlxuICAgIG5hbWUgPSBuYW1lID09PSAnQXJyYXknID8gJycgOiBuYW1lO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gICAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgICB1bnNoaWZ0VW5pcShrZXlzLCAnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgZW1wdHkgPSB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgZm10dGVyID0gZm10QXJyYXk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUsICdTZXQnKTtcbiAgICBmbXR0ZXIgPSBmbXRTZXQ7XG4gICAgLy8gV2l0aCBgc2hvd0hpZGRlbmAsIGBsZW5ndGhgIHdpbGwgZGlzcGxheSBhcyBhIGhpZGRlbiBwcm9wZXJ0eSBmb3JcbiAgICAvLyBhcnJheXMuIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIGRvIHRoZSBzYW1lIGZvciBgc2l6ZWAsIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhpcyBwcm9wZXJ0eSBpc24ndCBzZWxlY3RlZCBieSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLlxuICAgIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgICAgdW5zaGlmdFVuaXEoa2V5cywgJ3NpemUnKTtcbiAgICB9XG5cbiAgICBlbXB0eSA9IHZhbHVlLnNpemUgPT09IDA7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgbmFtZSA9IGdldFN1Yk5hbWUodmFsdWUsICdNYXAnKTtcbiAgICBmbXR0ZXIgPSBmbXRNYXA7XG4gICAgLy8gV2l0aCBgc2hvd0hpZGRlbmAsIGBsZW5ndGhgIHdpbGwgZGlzcGxheSBhcyBhIGhpZGRlbiBwcm9wZXJ0eSBmb3JcbiAgICAvLyBhcnJheXMuIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIGRvIHRoZSBzYW1lIGZvciBgc2l6ZWAsIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhpcyBwcm9wZXJ0eSBpc24ndCBzZWxlY3RlZCBieSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLlxuICAgIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgICAgdW5zaGlmdFVuaXEoa2V5cywgJ3NpemUnKTtcbiAgICB9XG5cbiAgICBlbXB0eSA9IHZhbHVlLnNpemUgPT09IDA7XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSwgJ0FycmF5QnVmZmVyJyk7XG4gICAgdW5zaGlmdFVuaXEoa2V5cywgJ2J5dGVMZW5ndGgnKTtcbiAgICBwdXNoVW5pcSh2aXNpYmxlS2V5cywgJ2J5dGVMZW5ndGgnKTtcbiAgfSBlbHNlIGlmIChpc0RhdGFWaWV3KHZhbHVlKSkge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlLCAnRGF0YVZpZXcnKTtcbiAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnVmZmVyJyk7XG4gICAgdW5zaGlmdFVuaXEoa2V5cywgJ2J5dGVPZmZzZXQnKTtcbiAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnl0ZUxlbmd0aCcpO1xuICAgIHB1c2hVbmlxKHZpc2libGVLZXlzLCAnYnl0ZUxlbmd0aCcpO1xuICAgIHB1c2hVbmlxKHZpc2libGVLZXlzLCAnYnl0ZU9mZnNldCcpO1xuICAgIHB1c2hVbmlxKHZpc2libGVLZXlzLCAnYnVmZmVyJyk7XG4gIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlKTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIGZtdHRlciA9IGZtdFR5cGVkQXJyYXk7XG4gICAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnVmZmVyJyk7XG4gICAgICB1bnNoaWZ0VW5pcShrZXlzLCAnYnl0ZU9mZnNldCcpO1xuICAgICAgdW5zaGlmdFVuaXEoa2V5cywgJ2J5dGVMZW5ndGgnKTtcbiAgICAgIHVuc2hpZnRVbmlxKGtleXMsICdsZW5ndGgnKTtcbiAgICAgIHVuc2hpZnRVbmlxKGtleXMsIGJwZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSwgJ1Byb21pc2UnKTtcbiAgfSBlbHNlIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlLCAnTWFwSXRlcmF0b3InKTtcbiAgICBlbXB0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNTZXRJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICBuYW1lID0gZ2V0U3ViTmFtZSh2YWx1ZSwgJ1NldEl0ZXJhdG9yJyk7XG4gICAgZW1wdHkgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBnZXRTdWJOYW1lKHZhbHVlKTtcbiAgICAvLyBVbnNldCB0aGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBcIk9iamVjdCB7Li4ufVwiIGZvciBvcmRpbmFyeSBvYmplY3RzLlxuICAgIG5hbWUgPSBuYW1lID09PSAnT2JqZWN0JyA/ICcnIDogbmFtZTtcbiAgICBlbXB0eSA9IHRydWU7IC8vIE5vIG90aGVyIGRhdGEgdGhhbiBrZXlzLlxuICB9XG5cbiAgaWYgKGJhc2UpIHtcbiAgICBiYXNlID0gJyAnICsgYmFzZTtcbiAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgLy8gQWRkIGNvbnN0cnVjdG9yIG5hbWUgaWYgYXZhaWxhYmxlXG4gICAgYnJhY2VzWzBdID0gbmFtZSArICcgJyArIGJyYWNlc1swXTtcbiAgfVxuXG4gIGVtcHR5ID0gZW1wdHkgPT09IHRydWUgJiYga2V5cy5sZW5ndGggPT09IDA7XG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKGRlcHRoIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShwUmVnRXhwVG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2UgaWYgKCRpc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbQXJyYXldJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN0eC5zZWVuLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICB9XG5cbiAgY3R4LnNlZW4uYWRkKHZhbHVlKTtcbiAgdmFyIG91dCA9IGZtdHRlcihjdHgsIHZhbHVlLCBkZXB0aCwgdmlzaWJsZUtleXMsIGtleXMpO1xuICBjdHguc2VlblsnZGVsZXRlJ10odmFsdWUpO1xuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0LCBiYXNlLCBicmFjZXMpO1xufTtcblxuaW5zcGVjdCA9IGZ1bmN0aW9uIF9pbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBuZXcgY29sbGVjdGlvbnMuU2V0KCksXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcblxuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMyAmJiBpc1VuZGVmaW5lZChhcmd1bWVudHNbMl0pID09PSBmYWxzZSkge1xuICAgIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQgJiYgaXNVbmRlZmluZWQoYXJndW1lbnRzWzNdKSA9PT0gZmFsc2UpIHtcbiAgICBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfVxuXG4gIC8vIFNldCBkZWZhdWx0IGFuZCB1c2VyLXNwZWNpZmllZCBvcHRpb25zXG4gIGlmIChzdXBwb3J0c0dldFNldCkge1xuICAgIGN0eCA9ICRhc3NpZ24oe30sIGluc3BlY3QuZGVmYXVsdE9wdGlvbnMsIGN0eCwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgY3R4ID0gJGFzc2lnbih7fSwgaW5zcGVjdERlZmF1bHRPcHRpb25zLCBpbnNwZWN0LmRlZmF1bHRPcHRpb25zLCBjdHgsIG9wdHMpO1xuICB9XG5cbiAgaWYgKGN0eC5jb2xvcnMpIHtcbiAgICBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIH1cblxuICBpZiAoaXNOdWxsKGN0eC5tYXhBcnJheUxlbmd0aCkpIHtcbiAgICBjdHgubWF4QXJyYXlMZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIHJldHVybiBmbXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn07XG5cbmlmIChzdXBwb3J0c0dldFNldCkge1xuICBkZWZpbmVQcm9wZXJ0eShpbnNwZWN0LCAnZGVmYXVsdE9wdGlvbnMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBfZ2V0KCkge1xuICAgICAgcmV0dXJuIGluc3BlY3REZWZhdWx0T3B0aW9ucztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gX3NldChvcHRpb25zKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnNcIiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJGFzc2lnbihpbnNwZWN0RGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBkZWZpbmVQcm9wZXJ0aWVzKGluc3BlY3QsIHtcbiAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgdmFsdWU6ICRhc3NpZ24oe30sIGluc3BlY3REZWZhdWx0T3B0aW9ucyksXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59XG5cbmRlZmluZVByb3BlcnRpZXMoaW5zcGVjdCwge1xuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcbiAgY29sb3JzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIGJsYWNrOiBbMzAsIDM5XSxcbiAgICAgIGJsdWU6IFszNCwgMzldLFxuICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgIGN5YW46IFszNiwgMzldLFxuICAgICAgZ3JlZW46IFszMiwgMzldLFxuICAgICAgZ3JleTogWzkwLCAzOV0sXG4gICAgICBpbnZlcnNlOiBbNywgMjddLFxuICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgbWFnZW50YTogWzM1LCAzOV0sXG4gICAgICByZWQ6IFszMSwgMzldLFxuICAgICAgdW5kZXJsaW5lOiBbNCwgMjRdLFxuICAgICAgd2hpdGU6IFszNywgMzldLFxuICAgICAgeWVsbG93OiBbMzMsIDM5XVxuICAgIH1cbiAgfSxcbiAgY3VzdG9tOiB7XG4gICAgdmFsdWU6IGN1c3RvbUluc3BlY3RTeW1ib2xcbiAgfSxcbiAgLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG4gIHN0eWxlczoge1xuICAgIHZhbHVlOiB7XG4gICAgICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAgICAgZGF0ZTogJ21hZ2VudGEnLFxuICAgICAgLy8gbmFtZTogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgJ251bGwnOiAnYm9sZCcsXG4gICAgICBudW1iZXI6ICd5ZWxsb3cnLFxuICAgICAgcmVnZXhwOiAncmVkJyxcbiAgICAgIHNwZWNpYWw6ICdjeWFuJyxcbiAgICAgIHN0cmluZzogJ2dyZWVuJyxcbiAgICAgIHN5bWJvbDogJ2dyZWVuJyxcbiAgICAgIHVuZGVmaW5lZDogJ2dyZXknXG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqIFZhbHVlcyBtYXkgc3VwcGx5IHRoZWlyIG93biBjdXN0b20gYGluc3BlY3QoZGVwdGgsIG9wdHMpYCBmdW5jdGlvbnMsXG4gKiB3aGVuIGNhbGxlZCB0aGV5IHJlY2VpdmUgdGhlIGN1cnJlbnQgZGVwdGggaW4gdGhlIHJlY3Vyc2l2ZSBpbnNwZWN0aW9uLFxuICogYXMgd2VsbCBhcyB0aGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIGBpbnNwZWN0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGluc3BlY3QgPSByZXF1aXJlKCdpbnNwZWN0LXgnKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhpbnNwZWN0KGluc3BlY3QsIHsgc2hvd0hpZGRlbjogdHJ1ZSwgZGVwdGg6IG51bGwgfSkpO1xuICogLy97IFtGdW5jdGlvbjogaW5zcGVjdF1cbiAqIC8vICBbbGVuZ3RoXTogMixcbiAqIC8vICBbbmFtZV06ICdpbnNwZWN0JyxcbiAqIC8vICBbcHJvdG90eXBlXTogaW5zcGVjdCB7IFtjb25zdHJ1Y3Rvcl06IFtDaXJjdWxhcl0gfSxcbiAqIC8vICBbY29sb3JzXTpcbiAqIC8vICAgeyBbYm9sZF06IFsgMSwgMjIsIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2l0YWxpY106IFsgMywgMjMsIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW3VuZGVybGluZV06IFsgNCwgMjQsIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2ludmVyc2VdOiBbIDcsIDI3LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFt3aGl0ZV06IFsgMzcsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFtncmV5XTogWyA5MCwgMzksIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2JsYWNrXTogWyAzMCwgMzksIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW2JsdWVdOiBbIDM0LCAzOSwgW2xlbmd0aF06IDIgXSxcbiAqIC8vICAgICBbY3lhbl06IFsgMzYsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFtncmVlbl06IFsgMzIsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFttYWdlbnRhXTogWyAzNSwgMzksIFtsZW5ndGhdOiAyIF0sXG4gKiAvLyAgICAgW3JlZF06IFsgMzEsIDM5LCBbbGVuZ3RoXTogMiBdLFxuICogLy8gICAgIFt5ZWxsb3ddOiBbIDMzLCAzOSwgW2xlbmd0aF06IDIgXSB9LFxuICogLy8gIFtzdHlsZXNdOlxuICogLy8gICB7IFtzcGVjaWFsXTogJ2N5YW4nLFxuICogLy8gICAgIFtudW1iZXJdOiAneWVsbG93JyxcbiAqIC8vICAgICBbYm9vbGVhbl06ICd5ZWxsb3cnLFxuICogLy8gICAgIFt1bmRlZmluZWRdOiAnZ3JleScsXG4gKiAvLyAgICAgW251bGxdOiAnYm9sZCcsXG4gKiAvLyAgICAgW3N0cmluZ106ICdncmVlbicsXG4gKiAvLyAgICAgW3N5bWJvbF06ICdncmVlbicsXG4gKiAvLyAgICAgW2RhdGVdOiAnbWFnZW50YScsXG4gKiAvLyAgICAgW3JlZ2V4cF06ICdyZWQnIH0gfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG4iLCIvKipcbiAqIEBmaWxlIFNoYW0gZm9yIEVTNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0T1BERmFsbGJhY2s7XG5cbi8vIEVTNSAxNS4yLjMuM1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjNcblxudmFyIGRvZXNHT1BEV29yayA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdHJ5IHtcbiAgICBvYmplY3Quc2VudGluZWwgPSAwO1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgJ3NlbnRpbmVsJykudmFsdWUgPT09IDA7XG4gIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gY2hlY2sgd2hldGhlciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Igd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLCBzaGltIHBhcnRpYWxseS5cbmlmICgkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gIHZhciBnZXRPUERXb3Jrc09uT2JqZWN0ID0gZG9lc0dPUERXb3JrKHt9KTtcbiAgdmFyIGdldE9QRFdvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IGRvZXNHT1BEV29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gIGlmIChnZXRPUERXb3Jrc09uRG9tID09PSBmYWxzZSB8fCBnZXRPUERXb3Jrc09uT2JqZWN0ID09PSBmYWxzZSkge1xuICAgIGdldE9QREZhbGxiYWNrID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgfVxufVxuXG52YXIgdG9PYmplY3Q7XG5pZiAoJGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBCb29sZWFuKGdldE9QREZhbGxiYWNrKSA9PT0gZmFsc2UpIHtcbiAgdHJ5IHtcbiAgICAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKDQyLCAnbmFtZScpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gICAgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b09iamVjdChvYmplY3QpLCBwcm9wZXJ0eSk7XG4gICAgfTtcbiAgfVxufSBlbHNlIGlmIChCb29sZWFuKCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpID09PSBmYWxzZSB8fCBnZXRPUERGYWxsYmFjaykge1xuICB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBvd25zID0gcmVxdWlyZSgnaGFzLW93bi1wcm9wZXJ0eS14Jyk7XG4gIHZhciBwcm90b3R5cGVPZk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvdG90eXBlT2ZPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciBpc0VudW1lcmFibGUgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICB9O1xuXG4gIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxuICB2YXIgbG9va3VwR2V0dGVyO1xuICB2YXIgbG9va3VwU2V0dGVyO1xuICB2YXIgc3VwcG9ydHNBY2Nlc3NvcnMgPSBvd25zKHByb3RvdHlwZU9mT2JqZWN0LCAnX19kZWZpbmVHZXR0ZXJfXycpO1xuICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICB2YXIgbGcgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHZhciBscyA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwU2V0dGVyX187XG4gICAgbG9va3VwR2V0dGVyID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBsZy5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgIH07XG5cbiAgICBsb29rdXBTZXR0ZXIgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGxzLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgfTtcbiAgfVxuXG4gICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHZhciBvYmogPSB0b09iamVjdChvYmplY3QpO1xuXG4gICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgLy8gZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgIGlmIChnZXRPUERGYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdldE9QREZhbGxiYWNrLmNhbGwoT2JqZWN0LCBvYmosIHByb3BlcnR5KTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZXNjcmlwdG9yO1xuXG4gICAgLy8gSWYgb2JqZWN0IGRvZXMgbm90IG93bnMgcHJvcGVydHkgcmV0dXJuIHVuZGVmaW5lZCBpbW1lZGlhdGVseS5cbiAgICBpZiAob3ducyhvYmosIHByb3BlcnR5KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSB0aGVuIGl0J3MgZm9yIHN1cmUgYGNvbmZpZ3VyYWJsZWAsIGFuZFxuICAgIC8vIHByb2JhYmx5IGBlbnVtZXJhYmxlYC4gRGV0ZWN0IGVudW1lcmFiaWxpdHkgdGhvdWdoLlxuICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBpc0VudW1lcmFibGUob2JqLCBwcm9wZXJ0eSlcbiAgICB9O1xuXG4gICAgLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29yIHByb3BlcnRpZXMgdGhlbiBwcm9wZXJ0eSBtYXkgYmUgYVxuICAgIC8vIGdldHRlciBvciBzZXR0ZXIuXG4gICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBhIGdldHRlciBldmVuXG4gICAgICAvLyBpZiBvYmplY3QgaGFzIG93biBub24gZ2V0dGVyIHByb3BlcnR5IGFsb25nIHdpdGggYSBzYW1lIG5hbWVkXG4gICAgICAvLyBpbmhlcml0ZWQgZ2V0dGVyLiBUbyBhdm9pZCBtaXNiZWhhdmlvciB3ZSB0ZW1wb3JhcnkgcmVtb3ZlXG4gICAgICAvLyBgX19wcm90b19fYCBzbyB0aGF0IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBnZXR0ZXIgb25seVxuICAgICAgLy8gaWYgaXQncyBvd25lZCBieSBhbiBvYmplY3QuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cbiAgICAgIHZhciBwcm90b3R5cGUgPSBvYmouX19wcm90b19fO1xuICAgICAgdmFyIG5vdFByb3RvdHlwZU9mT2JqZWN0ID0gb2JqICE9PSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBwcm9ibGVtLCBicmVha2luZyBpbiBPcGVyYSBNaW5pIHdoZW5cbiAgICAgIC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJylcbiAgICAgIC8vIG9yIGFueSBvdGhlciBPYmplY3QucHJvdG90eXBlIGFjY2Vzc29yXG4gICAgICBpZiAobm90UHJvdG90eXBlT2ZPYmplY3QpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGdldHRlciA9IGxvb2t1cEdldHRlcihvYmosIHByb3BlcnR5KTtcbiAgICAgIHZhciBzZXR0ZXIgPSBsb29rdXBTZXR0ZXIob2JqLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChub3RQcm90b3R5cGVPZk9iamVjdCkge1xuICAgICAgICAvLyBPbmNlIHdlIGhhdmUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2UgY2FuIHB1dCB2YWx1ZXMgYmFjay5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgIG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXR0ZXIgfHwgc2V0dGVyKSB7XG4gICAgICAgIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IHNldHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IHdhcyBhY2Nlc3NvciBwcm9wZXJ0eSB3ZSdyZSBkb25lIGFuZCByZXR1cm4gaGVyZVxuICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBhZGRpbmcgYHZhbHVlYCB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHdlIGtub3cgdGhhdCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB0aGF0IGlzXG4gICAgLy8gbm90IGFuIGFjY2Vzc29yIHNvIHdlIHNldCBpdCBhcyBhIHZhbHVlIGFuZCByZXR1cm4gZGVzY3JpcHRvci5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqW3Byb3BlcnR5XTtcbiAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgYW4gb3duIHByb3BlcnR5ICh0aGF0IGlzLFxuICogb25lIGRpcmVjdGx5IHByZXNlbnQgb24gYW4gb2JqZWN0IGFuZCBub3QgaW4gdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbilcbiAqIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCBpbiB3aGljaCB0byBsb29rIGZvciB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0geyp9IHByb3BlcnR5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIGRlc2NyaXB0aW9uIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcHJvcGVydHkgZGVzY3JpcHRvciBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaWYgaXQgZXhpc3RzIG9uIHRoZSBvYmplY3QsIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICogdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJ29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteCcpO1xuICogdmFyIG9iaiA9IHsgYmFyOiA0MiB9O1xuICogdmFyIGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgJ2JhcicpO1xuICogLy8gZCBpcyB7XG4gKiAvLyAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAqIC8vICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAqIC8vICAgdmFsdWU6IDQyLFxuICogLy8gICB3cml0YWJsZTogdHJ1ZVxuICogLy8gfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHR0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIi8qKlxuICogQGZpbGUgRGV0ZWN0IHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBpcyBhbiBBcnJheUJ1ZmZlci5cbiAqIEB2ZXJzaW9uIDEuNy4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1hcnJheS1idWZmZXIteFxuICovXG5cbi8qIGdsb2JhbCBBcnJheUJ1ZmZlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG52YXIgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnaXMtb2JqZWN0LWxpa2UteCcpO1xudmFyIGhhc0FCdWYgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbic7XG52YXIgYkxlbmd0aCA9IGZhbHNlO1xudmFyIHRvU3RyaW5nVGFnO1xudmFyIGFCdWZUYWc7XG5cbmlmIChoYXNBQnVmKSB7XG4gIGlmIChyZXF1aXJlKCdoYXMtdG8tc3RyaW5nLXRhZy14JykpIHtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14Jyk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQXJyYXlCdWZmZXIucHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGlmIChkZXNjcmlwdG9yICYmIHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJlcyA9IGF0dGVtcHQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXMudGhyZXcgPT09IGZhbHNlICYmIGlzT2JqZWN0TGlrZShyZXMudmFsdWUpKSB7XG4gICAgICAgIHJlcyA9IGF0dGVtcHQuY2FsbChyZXMudmFsdWUsIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgYkxlbmd0aCA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgdHlwZW9mIHJlcy52YWx1ZSA9PT0gJ251bWJlcicgJiYgZGVzY3JpcHRvci5nZXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGJMZW5ndGggPT09IGZhbHNlKSB7XG4gICAgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCd0by1zdHJpbmctdGFnLXgnKTtcbiAgICBhQnVmVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBgb2JqZWN0YCBpcyBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYG9iamVjdGAgaXMgYW4gYEFycmF5QnVmZmVyYCxcbiAqICBlbHNlIGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ2lzLWFycmF5LWJ1ZmZlci14Jyk7XG4gKlxuICogaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoNCkpOyAvLyB0cnVlXG4gKiBpc0FycmF5QnVmZmVyKG51bGwpOyAvLyBmYWxzZVxuICogaXNBcnJheUJ1ZmZlcihbXSk7IC8vIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihvYmplY3QpIHtcbiAgaWYgKGhhc0FCdWYgPT09IGZhbHNlIHx8IGlzT2JqZWN0TGlrZShvYmplY3QpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiTGVuZ3RoID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0b1N0cmluZ1RhZyhvYmplY3QpID09PSBhQnVmVGFnO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQuY2FsbChvYmplY3QsIGJMZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0LnRocmV3ID09PSBmYWxzZSAmJiB0eXBlb2YgcmVzdWx0LnZhbHVlID09PSAnbnVtYmVyJztcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFycmF5IGxpa2UuXG4gKiBAdmVyc2lvbiAxLjguMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtYXJyYXktbGlrZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOaWwgPSByZXF1aXJlKCdpcy1uaWwteCcpO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbi14Jyk7XG52YXIgaXNMZW5ndGggPSByZXF1aXJlKCdpcy1sZW5ndGgteCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB2YWx1ZSBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYGxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byAwIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIG9iamVjdCB0byBiZSB0ZXN0ZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgc3ViamVjdCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnaXMtYXJyYXktbGlrZS14Jyk7XG4gKlxuICogaXNBcnJheUxpa2UoWzEsIDIsIDNdKTsgLy8gdHJ1ZVxuICogaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7IC8vIHRydWVcbiAqIGlzQXJyYXlMaWtlKCdhYmMnKTsgLy8gdHJ1ZVxuICogaXNBcnJheUxpa2UoXy5ub29wKTsgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNOaWwodmFsdWUpID09PSBmYWxzZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLCB0cnVlKSA9PT0gZmFsc2UgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIEFycmF5LlxuICogQHZlcnNpb24gMS4yLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWFycmF5LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuYXRpdmVJc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicgJiYgQXJyYXkuaXNBcnJheTtcblxudmFyIHRlc3RSZXMgPSBuYXRpdmVJc0FycmF5ICYmIHJlcXVpcmUoJ2F0dGVtcHQteCcpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZUlzQXJyYXkoW10pID09PSB0cnVlICYmIG5hdGl2ZUlzQXJyYXkoeyBsZW5ndGg6IDAgfSkgPT09IGZhbHNlO1xufSk7XG5cbnZhciAkaXNBcnJheTtcbmlmICh0ZXN0UmVzICYmIHRlc3RSZXMudGhyZXcgPT09IGZhbHNlICYmIHRlc3RSZXMudmFsdWUgPT09IHRydWUpIHtcbiAgJGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5O1xufSBlbHNlIHtcbiAgdmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gICRpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWcob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgaXNBcnJheSgpIGZ1bmN0aW9uIGRldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGhlIG9iamVjdCB0byBiZSBjaGVja2VkLi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBpcyBhbiBBcnJheTsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xuICpcbiAqIGlzQXJyYXkoW10pOyAvLyB0cnVlXG4gKiBpc0FycmF5KHt9KTsgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkaXNBcnJheTtcbiIsIi8qKlxuICogQGZpbGUgRGV0ZXJtaW5lIGlmIGEgZnVuY3Rpb24gaXMgYSBuYXRpdmUgYXluYyBmdW5jdGlvbi5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFzeW5jLWZ1bmN0aW9uLWRlZmluaXRpb25zfDE0LjYgQXN5bmMgRnVuY3Rpb24gRGVmaW5pdGlvbnN9XG4gKiBAdmVyc2lvbiAxLjcuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtYXN5bmMtZnVuY3Rpb24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgbm9ybWFsaXNlID0gcmVxdWlyZSgnbm9ybWFsaXplLXNwYWNlLXgnKS5ub3JtYWxpemVTcGFjZTIwMTg7XG52YXIgaXNGblJlZ2V4ID0gL15hc3luYyBmdW5jdGlvbi87XG52YXIgdGVzdCA9IGlzRm5SZWdleC50ZXN0O1xudmFyIHJlcGxhY2VDb21tZW50cyA9IHJlcXVpcmUoJ3JlcGxhY2UtY29tbWVudHMteCcpO1xudmFyIGZ1bmN0aW9uQ3RyID0gZnVuY3Rpb24gKCkge30uY29uc3RydWN0b3I7XG52YXIgZlRvU3RyaW5nID0gZnVuY3Rpb25DdHIucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2dldC1wcm90b3R5cGUtb2YteCcpO1xudmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcblxudmFyIHRlc3RSZXMgPSBhdHRlbXB0KGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRnZXRQcm90b3R5cGVPZihmdW5jdGlvbkN0cigncmV0dXJuIGFzeW5jIGZ1bmN0aW9uKCkge30nKSgpKTtcbn0pO1xuXG52YXIgc3VwcG9ydHNBc3luYyA9IHRlc3RSZXMudGhyZXcgPT09IGZhbHNlO1xudmFyIGFzeW5jUHJvdG8gPSB0ZXN0UmVzLnZhbHVlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFzeW5jIEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSBmbiAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc0FzeW5jRnVuY3Rpb24gPSByZXF1aXJlKCdpcy0tYXN5bmMtZnVuY3Rpb24teCcpO1xuICpcbiAqIGlzQXN5bmNGdW5jdGlvbigpOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKE51bWJlci5NSU5fVkFMVUUpOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKCdhYmMnKTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbih0cnVlKTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbih7IG5hbWU6ICdhYmMnIH0pOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKGZ1bmN0aW9uICgpIHt9KTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbihuZXcgRnVuY3Rpb24gKCkpOyAvLyBmYWxzZVxuICogaXNBc3luY0Z1bmN0aW9uKGZ1bmN0aW9uKiB0ZXN0MSgpIHt9KTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbihmdW5jdGlvbiB0ZXN0MihhLCBiKSB7fSk7IC8vIGZhbHNlXG4gKiBpc0FzeW5jRnVuY3Rpb24oY2xhc3MgVGVzdCB7fSk7IC8vIGZhbHNlXG4gKiBpc0FzeW5jRnVuY3Rpb24oKHgsIHkpID0+IHtyZXR1cm4gdGhpczt9KTsgLy8gZmFsc2VcbiAqIGlzQXN5bmNGdW5jdGlvbihhc3luYyBmdW5jdGluKCkge30pOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKGZuKSB7XG4gIGlmIChzdXBwb3J0c0FzeW5jID09PSBmYWxzZSB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3RyO1xuICB0cnkge1xuICAgIHN0ciA9IG5vcm1hbGlzZShyZXBsYWNlQ29tbWVudHMoZlRvU3RyaW5nLmNhbGwoZm4pLCAnICcpKTtcbiAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRlc3QuY2FsbChpc0ZuUmVnZXgsIHN0cikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNUb1N0cmluZ1RhZyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdG9TdHJpbmdUYWcoZm4pID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG4gIH1cblxuICByZXR1cm4gJGdldFByb3RvdHlwZU9mKGZuKSA9PT0gYXN5bmNQcm90bztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBib29sVG9TdHIgPSBCb29sZWFuLnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIHRyeUJvb2xlYW5PYmplY3QgPSBmdW5jdGlvbiB0cnlCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0Ym9vbFRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHsgcmV0dXJuIHRydWU7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeUJvb2xlYW5PYmplY3QodmFsdWUpIDogdG9TdHIuY2FsbCh2YWx1ZSkgPT09IGJvb2xDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucHJvdG90eXBlKSB7IHJldHVybiB0cnVlOyB9XG5cdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0cmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzcztcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVjdCB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYSBEYXRhVmlldy5cbiAqIEB2ZXJzaW9uIDEuNi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1kYXRhLXZpZXcteFxuICovXG5cbi8qIGdsb2JhbCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbnZhciBoYXNEVmlldyA9IHR5cGVvZiBEYXRhVmlldyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBnZXRCeXRlTGVuZ3RoID0gZmFsc2U7XG52YXIgbGVnYWN5Q2hlY2s7XG5cbmlmIChoYXNEVmlldykge1xuICB2YXIgcmVzID0gYXR0ZW1wdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoNCkpO1xuICB9KTtcblxuICB2YXIgZGF0YVZpZXcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIGlzT2JqZWN0TGlrZShyZXMudmFsdWUpICYmIHJlcy52YWx1ZTtcblxuICBpZiAoZGF0YVZpZXcgJiYgcmVxdWlyZSgnaGFzLXRvLXN0cmluZy10YWcteCcpKSB7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJ29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteCcpO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKERhdGFWaWV3LnByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKTtcbiAgICBpZiAoZGVzY3JpcHRvciAmJiB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcyA9IGF0dGVtcHQuY2FsbChkYXRhVmlldywgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgZ2V0Qnl0ZUxlbmd0aCA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgdHlwZW9mIHJlcy52YWx1ZSA9PT0gJ251bWJlcicgJiYgZGVzY3JpcHRvci5nZXQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdldEJ5dGVMZW5ndGggPT09IGZhbHNlKSB7XG4gICAgdmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gICAgdmFyIGRWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcbiAgICBpZiAodG9TdHJpbmdUYWcoZGF0YVZpZXcpID09PSBkVmlld1RhZykge1xuICAgICAgbGVnYWN5Q2hlY2sgPSBmdW5jdGlvbiBfbGVnYWN5Q2hlY2sob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZ1RhZyhvYmplY3QpID09PSBkVmlld1RhZztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc0FycmF5QnVmZmVyID0gcmVxdWlyZSgnaXMtYXJyYXktYnVmZmVyLXgnKTtcbiAgICAgIGxlZ2FjeUNoZWNrID0gZnVuY3Rpb24gX2xlZ2FjeUNoZWNrKG9iamVjdCkge1xuICAgICAgICB2YXIgaXNCeXRlTGVuZ3RoID0gdHlwZW9mIG9iamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJztcbiAgICAgICAgdmFyIGlzQnl0ZU9mZnNldCA9IHR5cGVvZiBvYmplY3QuYnl0ZU9mZnNldCA9PT0gJ251bWJlcic7XG4gICAgICAgIHZhciBpc0dldEZsb2F0MzIgPSB0eXBlb2Ygb2JqZWN0LmdldEZsb2F0MzIgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHZhciBpc1NldEZsb2F0NjQgPSB0eXBlb2Ygb2JqZWN0LnNldEZsb2F0NjQgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBpc0J5dGVMZW5ndGggJiYgaXNCeXRlT2Zmc2V0ICYmIGlzR2V0RmxvYXQzMiAmJiBpc1NldEZsb2F0NjQgJiYgaXNBcnJheUJ1ZmZlcihvYmplY3QuYnVmZmVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGBvYmplY3RgIGlzIGFuIGBEYXRhVmlld2AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBgb2JqZWN0YCBpcyBhIGBEYXRhVmlld2AsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNEYXRhVmlldyA9IHJlcXVpcmUoJ2lzLWRhdGEtdmlldy14Jyk7XG4gKiB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gKiB2YXIgZHYgPSBuZXcgRGF0YVZpZXcoYWIpO1xuICpcbiAqIGlzRGF0YVZpZXcoYWIpOyAvLyBmYWxzZVxuICogaXNEYXRhVmlldyh0cnVlKTsgLy8gZmFsc2VcbiAqIGlzRGF0YVZpZXcoZHYpOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEYXRhVmlldyhvYmplY3QpIHtcbiAgaWYgKGhhc0RWaWV3ID09PSBmYWxzZSB8fCBpc09iamVjdExpa2Uob2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVnYWN5Q2hlY2spIHtcbiAgICByZXR1cm4gbGVnYWN5Q2hlY2sob2JqZWN0KTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0LmNhbGwob2JqZWN0LCBnZXRCeXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgdHlwZW9mIHJlc3VsdC52YWx1ZSA9PT0gJ251bWJlcic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RGF5ID0gRGF0ZS5wcm90b3R5cGUuZ2V0RGF5O1xudmFyIHRyeURhdGVPYmplY3QgPSBmdW5jdGlvbiB0cnlEYXRlT2JqZWN0KHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0Z2V0RGF5LmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEYXRlT2JqZWN0KHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlEYXRlT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBkYXRlQ2xhc3M7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSAgRGV0ZWN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBlcnJvci5cbiAqIEB2ZXJzaW9uIDEuNS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1lcnJvci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHJpbmdUYWcgPSByZXF1aXJlKCd0by1zdHJpbmctdGFnLXgnKTtcbnZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCdpcy1vYmplY3QtbGlrZS14Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZ2V0LXByb3RvdHlwZS1vZi14Jyk7XG5cbnZhciBlcnJvckNoZWNrID0gZnVuY3Rpb24gY2hlY2tJZkVycm9yKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59O1xuXG5pZiAoZXJyb3JDaGVjayhFcnJvci5wcm90b3R5cGUpID09PSBmYWxzZSkge1xuICB2YXIgZXJyb3JQcm90byA9IEVycm9yLnByb3RvdHlwZTtcbiAgdmFyIHRlc3RTdHJpbmdUYWcgPSBlcnJvckNoZWNrO1xuICBlcnJvckNoZWNrID0gZnVuY3Rpb24gY2hlY2tJZkVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBlcnJvclByb3RvIHx8IHRlc3RTdHJpbmdUYWcodmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGdpdmVuIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgb2JqZWN0IHRvIGJlIHRlc3RlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAgdHlwZSxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzRXJyb3IgPSByZXF1aXJlKCdpcy1lcnJvci14Jyk7XG4gKlxuICogaXNFcnJvcigpOyAvLyBmYWxzZVxuICogaXNFcnJvcihOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gZmFsc2VcbiAqIGlzRXJyb3IoJ2FiYycpOyAvLyBmYWxzZVxuICogaXNFcnJvcihuZXcgRXJyb3IoKSk7IC8vdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG9iamVjdCA9IHZhbHVlO1xuICB2YXIgbWF4TG9vcCA9IDEwMDtcbiAgd2hpbGUgKG9iamVjdCAmJiBtYXhMb29wID4gLTEpIHtcbiAgICBpZiAoZXJyb3JDaGVjayhvYmplY3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvYmplY3QgPSAkZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBtYXhMb29wIC09IDE7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUZXN0IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgZmFsc2V5LlxuICogQHZlcnNpb24gMS4wLjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWZhbHNleS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9Cb29sZWFuID0gcmVxdWlyZSgndG8tYm9vbGVhbi14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGVzdHMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBmYWxzZXkuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgZmFsc2V5OiBvdGhlcndpc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNGYWxzZXkgPSByZXF1aXJlKCdpcy1mYWxzZXkteCcpO1xuICpcbiAqIGlzRmFsc2V5KCk7IC8vIHRydWVcbiAqIGlzRmFsc2V5KDApOyAvLyB0cnVlXG4gKiBpc0ZhbHNleSgnJyk7IC8vIHRydWVcbiAqIGlzRmFsc2V5KGZhbHNlKTsgLy8gdHJ1ZVxuICogaXNGYWxzZXkobnVsbCk7IC8vIHRydWVcbiAqXG4gKiBpc0ZhbHNleSh0cnVlKTsgLy8gZmFsc2VcbiAqIGlzRmFsc2V5KFtdKTsgLy8gZmFsc2VcbiAqIGlzRmFsc2V5KDEpOyAvLyBmYWxzZVxuICogaXNGYWxzZXkoZnVuY3Rpb24gKCkge30pOyAvLyBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRmFsc2V5KHZhbHVlKSB7XG4gIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpID09PSBmYWxzZTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEVTNi1jb21wbGlhbnQgc2hpbSBmb3IgTnVtYmVyLmlzRmluaXRlLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc2Zpbml0ZXwyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUgKCBudW1iZXIgKX1cbiAqIEB2ZXJzaW9uIDMuMC40XG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1maW5pdGUteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbnZhciBJTkZJTklUWSA9IHJlcXVpcmUoJ2luZmluaXR5LXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSBudW1iZXIgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBmaW5pdGVuZXNzLlxuICogQHJldHVybnMge2Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGZpbml0ZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICogdmFyIG51bUlzRmluaXRlID0gcmVxdWlyZSgnaXMtZmluaXRlLXgnKTtcbiAqXG4gKiBudW1Jc0Zpbml0ZShJbmZpbml0eSk7ICAvLyBmYWxzZVxuICogbnVtSXNGaW5pdGUoTmFOKTsgICAgICAgLy8gZmFsc2VcbiAqIG51bUlzRmluaXRlKC1JbmZpbml0eSk7IC8vIGZhbHNlXG4gKlxuICogbnVtSXNGaW5pdGUoMCk7ICAgICAgICAgLy8gdHJ1ZVxuICogbnVtSXNGaW5pdGUoMmU2NCk7ICAgICAgLy8gdHJ1ZVxuICpcbiAqIG51bUlzRmluaXRlKCcwJyk7ICAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsIGlzRmluaXRlKCcwJylcbiAqIG51bUlzRmluaXRlKG51bGwpOyAgICAgIC8vIGZhbHNlLCB3b3VsZCd2ZSBiZWVuIHRydWUgd2l0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRmluaXRlKG51bWJlcikge1xuICByZXR1cm4gdHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicgJiYgbnVtYmVySXNOYU4obnVtYmVyKSA9PT0gZmFsc2UgJiYgbnVtYmVyICE9PSBJTkZJTklUWSAmJiBudW1iZXIgIT09IC1JTkZJTklUWTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbiBvYmplY3QuXG4gKiBAdmVyc2lvbiAzLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtZnVuY3Rpb24teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbnZhciBmVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgdG9Cb29sZWFuID0gcmVxdWlyZSgndG8tYm9vbGVhbi14Jyk7XG52YXIgaXNGYWxzZXkgPSByZXF1aXJlKCdpcy1mYWxzZXkteCcpO1xudmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG8tc3RyaW5nLXRhZy14Jyk7XG52YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCdpcy1wcmltaXRpdmUnKTtcbnZhciBub3JtYWxpc2UgPSByZXF1aXJlKCdub3JtYWxpemUtc3BhY2UteCcpLm5vcm1hbGl6ZVNwYWNlO1xudmFyIGRlQ29tbWVudCA9IHJlcXVpcmUoJ3JlcGxhY2UtY29tbWVudHMteCcpO1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG52YXIgY3RyUnggPSAvXmNsYXNzIC87XG52YXIgdGVzdCA9IGN0clJ4LnRlc3Q7XG5cbnZhciBoYXNOYXRpdmVDbGFzcyA9IGF0dGVtcHQoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgcmV0dXJuIEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuIGNsYXNzIE15IHt9OycpKCk7XG59KS50aHJldyA9PT0gZmFsc2U7XG5cbnZhciB0ZXN0Q2xhc3NzdHJpbmcgPSBmdW5jdGlvbiBfdGVzdENsYXNzc3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0ZXN0LmNhbGwoY3RyUngsIG5vcm1hbGlzZShkZUNvbW1lbnQoZlRvU3RyaW5nLmNhbGwodmFsdWUpLCAnICcpKSk7XG59O1xuXG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmModmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQodGVzdENsYXNzc3RyaW5nLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgcmVzdWx0LnZhbHVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93Q2xhc3MgLSBXaGV0aGVyIHRvIGZpbHRlciBFUzYgY2xhc3Nlcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogZWxzZSBgZmFsc2VgLlxuICovXG52YXIgdHJ5RnVuY1RvU3RyaW5nID0gZnVuY3Rpb24gZnVuY1RvU3RyaW5nKHZhbHVlLCBhbGxvd0NsYXNzKSB7XG4gIGlmIChoYXNOYXRpdmVDbGFzcyAmJiBhbGxvd0NsYXNzID09PSBmYWxzZSAmJiBpc0VTNkNsYXNzRm4odmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGF0dGVtcHQuY2FsbCh2YWx1ZSwgZlRvU3RyaW5nKS50aHJldyA9PT0gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtib29sZWFufSBbYWxsb3dDbGFzcz1mYWxzZV0gLSBXaGV0aGVyIHRvIGZpbHRlciBFUzYgY2xhc3Nlcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xuICpcbiAqIGlzRnVuY3Rpb24oKTsgLy8gZmFsc2VcbiAqIGlzRnVuY3Rpb24oTnVtYmVyLk1JTl9WQUxVRSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKCdhYmMnKTsgLy8gZmFsc2VcbiAqIGlzRnVuY3Rpb24odHJ1ZSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKHsgbmFtZTogJ2FiYycgfSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKGZ1bmN0aW9uICgpIHt9KTsgLy8gdHJ1ZVxuICogaXNGdW5jdGlvbihuZXcgRnVuY3Rpb24gKCkpOyAvLyB0cnVlXG4gKiBpc0Z1bmN0aW9uKGZ1bmN0aW9uKiB0ZXN0MSgpIHt9KTsgLy8gdHJ1ZVxuICogaXNGdW5jdGlvbihmdW5jdGlvbiB0ZXN0MihhLCBiKSB7fSk7IC8vIHRydWVcbiAqIGlzRnVuY3Rpb24oYXN5bmMgZnVuY3Rpb24gdGVzdDMoKSB7fSk7IC8vIHRydWVcbiAqIGlzRnVuY3Rpb24oY2xhc3MgVGVzdCB7fSk7IC8vIGZhbHNlXG4gKiBpc0Z1bmN0aW9uKGNsYXNzIFRlc3Qge30sIHRydWUpOyAvLyB0cnVlXG4gKiBpc0Z1bmN0aW9uKCh4LCB5KSA9PiB7cmV0dXJuIHRoaXM7fSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaGFzVG9TdHJpbmdUYWcpIHtcbiAgICByZXR1cm4gdHJ5RnVuY1RvU3RyaW5nKHZhbHVlLCB0b0Jvb2xlYW4oYXJndW1lbnRzWzFdKSk7XG4gIH1cblxuICBpZiAoaGFzTmF0aXZlQ2xhc3MgJiYgaXNGYWxzZXkoYXJndW1lbnRzWzFdKSAmJiBpc0VTNkNsYXNzRm4odmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHN0clRhZyA9IHRvU3RyaW5nVGFnKHZhbHVlKTtcbiAgcmV0dXJuIHN0clRhZyA9PT0gZnVuY1RhZyB8fCBzdHJUYWcgPT09IGdlblRhZyB8fCBzdHJUYWcgPT09IGFzeW5jVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDoge307XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZSB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSB6ZXJvIGJhc2VkIGluZGV4LlxuICogQHZlcnNpb24gMS4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWluZGV4LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKCd0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTg7XG52YXIgdG9OdW1iZXIgPSByZXF1aXJlKCd0by1udW1iZXIteCcpLnRvTnVtYmVyMjAxODtcbnZhciBtYXRoQ2xhbXAgPSByZXF1aXJlKCdtYXRoLWNsYW1wLXgnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gcmVxdWlyZSgnbWF4LXNhZmUtaW50ZWdlcicpO1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcbnZhciByeFRlc3QgPSByZUlzVWludC50ZXN0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgemVybyBiYXNlZCBpbmRleC5cbiAqIEphdmFTY3JpcHQgYXJyYXlzIGFyZSB6ZXJvLWluZGV4ZWQ6IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5IGlzIGF0XG4gKiBpbmRleCAwLCBhbmQgdGhlIGxhc3QgZWxlbWVudCBpcyBhdCB0aGUgaW5kZXggZXF1YWwgdG8gdGhlIHZhbHVlIG9mIHRoZVxuICogYXJyYXkncyBsZW5ndGggcHJvcGVydHkgbWludXMgMS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHRlc3RlZCBmb3IgYmVpbmcgYSB6ZXJvIGJhc2VkIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gLSBUaGUgbGVuZ3RoIHRoYXQgc2V0cyB0aGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHZhbHVlIGlzIGFcbiAqIHplcm8gYmFzZWQgaW5kZXggd2l0aGluIGJvdW5kcy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNJbmRleCA9IHJlcXVpcmUoJ2lzLWluZGV4LXgnKTtcbiAqXG4gKiBpc0luZGV4KDApOyAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogaXNJbmRleCgxKTsgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzSW5kZXgoJzEwJyk7ICAgICAgICAgICAgICAgICAvLyB0cnVlXG4gKlxuICogaXNJbmRleCgtMTAwMDAwKTsgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KE1hdGgucG93KDIsIDUzKSk7ICAgICAgLy8gZmFsc2VcbiAqIGlzSW5kZXgoMC4xKTsgICAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNJbmRleChNYXRoLlBJKTsgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KE5hTik7ICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzSW5kZXgoSW5maW5pdHkpOyAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNJbmRleCgtSW5maW5pdHkpOyAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KHRydWUpOyAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzSW5kZXgoZmFsc2UpOyAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNJbmRleChbMV0pOyAgICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc0luZGV4KDEwLCAxMCk7ICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0luZGV4KHZhbHVlKSB7XG4gIHZhciBzdHJpbmcgPSBzYWZlVG9TdHJpbmcodmFsdWUpO1xuICBpZiAocnhUZXN0LmNhbGwocmVJc1VpbnQsIHN0cmluZykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG51bWJlciA9IHRvTnVtYmVyKHN0cmluZyk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBudW1iZXIgPCBtYXRoQ2xhbXAodG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSksIE1BWF9TQUZFX0lOVEVHRVIpO1xuICB9XG5cbiAgcmV0dXJuIG51bWJlciA8IE1BWF9TQUZFX0lOVEVHRVI7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlcm1pbmUgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtaW50ZWdlci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbnVtYmVySXNGaW5pdGUgPSByZXF1aXJlKCdpcy1maW5pdGUteCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJ3RvLWludGVnZXIteCcpLnRvSW50ZWdlcjIwMTg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHRlc3RlZCBmb3IgYmVpbmcgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnaXMtaW50ZWdlci14Jyk7XG4gKlxuICogaXNJbnRlZ2VyKDApOyAgICAgICAgIC8vIHRydWVcbiAqIGlzSW50ZWdlcigxKTsgICAgICAgICAvLyB0cnVlXG4gKiBpc0ludGVnZXIoLTEwMDAwMCk7ICAgLy8gdHJ1ZVxuICpcbiAqIGlzSW50ZWdlcigwLjEpOyAgICAgICAvLyBmYWxzZVxuICogaXNJbnRlZ2VyKE1hdGguUEkpOyAgIC8vIGZhbHNlXG4gKlxuICogaXNJbnRlZ2VyKE5hTik7ICAgICAgIC8vIGZhbHNlXG4gKiBpc0ludGVnZXIoSW5maW5pdHkpOyAgLy8gZmFsc2VcbiAqIGlzSW50ZWdlcigtSW5maW5pdHkpOyAvLyBmYWxzZVxuICogaXNJbnRlZ2VyKCcxMCcpOyAgICAgIC8vIGZhbHNlXG4gKiBpc0ludGVnZXIodHJ1ZSk7ICAgICAgLy8gZmFsc2VcbiAqIGlzSW50ZWdlcihmYWxzZSk7ICAgICAvLyBmYWxzZVxuICogaXNJbnRlZ2VyKFsxXSk7ICAgICAgIC8vIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gIHJldHVybiBudW1iZXJJc0Zpbml0ZSh2YWx1ZSkgJiYgdG9JbnRlZ2VyKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICogQHZlcnNpb24gMi4yLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIGlzLWxlbmd0aC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTYWZlSW50ZWdlciA9IHJlcXVpcmUoJ2lzLXNhZmUtaW50ZWdlci14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNMZW5ndGggPSByZXF1aXJlKCdpcy1sZW5ndGgteCcpO1xuICpcbiAqIGlzTGVuZ3RoKDMpOyAvLyA9PiB0cnVlXG4gKiBpc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsgLy8gPT4gZmFsc2VcbiAqIGlzTGVuZ3RoKEluZmluaXR5KTsgLy8gPT4gZmFsc2VcbiAqIGlzTGVuZ3RoKCczJyk7IC8vID0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIGlzU2FmZUludGVnZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlY3Qgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIGFuIEVTNiBNYXAuXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtbWFwLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0ZhbHNleSA9IHJlcXVpcmUoJ2lzLWZhbHNleS14Jyk7XG52YXIgYXR0ZW1wdDtcbnZhciBpc09iamVjdExpa2U7XG52YXIgaXNMZW5ndGg7XG52YXIgZ2V0U2l6ZTtcblxuaWYgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCdvYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLXgnKShNYXAucHJvdG90eXBlLCAnc2l6ZScpO1xuICBpZiAoZGVzY3JpcHRvciAmJiB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnaXMtb2JqZWN0LWxpa2UteCcpO1xuICAgIHZhciByZXMgPSBhdHRlbXB0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfSk7XG5cbiAgICBpZiAocmVzLnRocmV3ID09PSBmYWxzZSAmJiBpc09iamVjdExpa2UocmVzLnZhbHVlKSkge1xuICAgICAgaXNMZW5ndGggPSByZXF1aXJlKCdpcy1sZW5ndGgteCcpO1xuICAgICAgcmVzID0gYXR0ZW1wdC5jYWxsKHJlcy52YWx1ZSwgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgaWYgKHJlcy50aHJldyA9PT0gZmFsc2UgJiYgaXNMZW5ndGgocmVzLnZhbHVlKSkge1xuICAgICAgICBnZXRTaXplID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYG9iamVjdGAgaXMgYSBgTWFwYC5cbiAqXG4gKiBAcGFyYW0geyp9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGBvYmplY3RgIGlzIGEgYE1hcGAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc01hcCA9IHJlcXVpcmUoJ2lzLW1hcC14Jyk7XG4gKiB2YXIgbSA9IG5ldyBNYXAoKTtcbiAqXG4gKiBpc01hcChbXSk7IC8vIGZhbHNlXG4gKiBpc01hcCh0cnVlKTsgLy8gZmFsc2VcbiAqIGlzTWFwKG0pOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNNYXAob2JqZWN0KSB7XG4gIGlmIChpc0ZhbHNleShnZXRTaXplKSB8fCBpc09iamVjdExpa2Uob2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdC5jYWxsKG9iamVjdCwgZ2V0U2l6ZSk7XG4gIHJldHVybiByZXN1bHQudGhyZXcgPT09IGZhbHNlICYmIGlzTGVuZ3RoKHJlc3VsdC52YWx1ZSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIE51bWJlci5pc05hTiAtIHRoZSBnbG9iYWwgaXNOYU4gcmV0dXJucyBmYWxzZSBwb3NpdGl2ZXMuXG4gKiBAdmVyc2lvbiAxLjAuM1xuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtbmFuLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgTmFOIGFuZCBpdHMgdHlwZSBpc1xuICogYE51bWJlcmAuIEl0IGlzIGEgbW9yZSByb2J1c3QgdmVyc2lvbiBvZiB0aGUgb3JpZ2luYWwsIGdsb2JhbCBpc05hTigpLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBOYU4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBOYU4gYW5kIGl0cyB0eXBlIGlzIE51bWJlcjtcbiAqICBvdGhlcndpc2UsIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIG51bWJlcklzTmFOID0gcmVxdWlyZSgnaXMtbmFuLXgnKTtcbiAqXG4gKiBudW1iZXJJc05hTihOYU4pOyAgICAgICAgLy8gdHJ1ZVxuICogbnVtYmVySXNOYU4oTnVtYmVyLk5hTik7IC8vIHRydWVcbiAqIG51bWJlcklzTmFOKDAgLyAwKTsgICAgICAvLyB0cnVlXG4gKlxuICogLy8gZS5nLiB0aGVzZSB3b3VsZCBoYXZlIGJlZW4gdHJ1ZSB3aXRoIGdsb2JhbCBpc05hTigpXG4gKiBudW1iZXJJc05hTignTmFOJyk7ICAgICAgLy8gZmFsc2VcbiAqIG51bWJlcklzTmFOKHVuZGVmaW5lZCk7ICAvLyBmYWxzZVxuICogbnVtYmVySXNOYU4oe30pOyAgICAgICAgIC8vIGZhbHNlXG4gKiBudW1iZXJJc05hTignYmxhYmxhJyk7ICAgLy8gZmFsc2VcbiAqXG4gKiAvLyBUaGVzZSBhbGwgcmV0dXJuIGZhbHNlXG4gKiBudW1iZXJJc05hTih0cnVlKTtcbiAqIG51bWJlcklzTmFOKG51bGwpO1xuICogbnVtYmVySXNOYU4oMzcpO1xuICogbnVtYmVySXNOYU4oJzM3Jyk7XG4gKiBudW1iZXJJc05hTignMzcuMzcnKTtcbiAqIG51bWJlcklzTmFOKCcnKTtcbiAqIG51bWJlcklzTmFOKCcgJyk7XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxuZGVmaW5lKGltcGxlbWVudGF0aW9uLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTnVtYmVySXNOYU4oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShOdW1iZXIsIHsgaXNOYU46IHBvbHlmaWxsIH0sIHsgaXNOYU46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE51bWJlci5pc05hTiAhPT0gcG9seWZpbGw7IH0gfSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG5cdHJldHVybiBudW1iZXIgPT09IDAgJiYgKDEgLyBudW1iZXIpID09PSAtSW5maW5pdHk7XG59O1xuXG4iLCIvKipcbiAqIEBmaWxlIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqIEB2ZXJzaW9uIDEuNC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1uaWwteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgndmFsaWRhdGUuaW8tdW5kZWZpbmVkJyk7XG52YXIgaXNOdWxsID0gcmVxdWlyZSgnbG9kYXNoLmlzbnVsbCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc05pbCA9IHJlcXVpcmUoJ2lzLW5pbC14Jyk7XG4gKlxuICogaXNOaWwobnVsbCk7IC8vID0+IHRydWVcbiAqIGlzTmlsKHZvaWQgMCk7IC8vID0+IHRydWVcbiAqIGlzTmlsKE5hTik7IC8vID0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVsbCh2YWx1ZSkgfHwgaXNVbmRlZmluZWQodmFsdWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bVRvU3RyID0gTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZztcbnZhciB0cnlOdW1iZXJPYmplY3QgPSBmdW5jdGlvbiB0cnlOdW1iZXJPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRudW1Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbnVtQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHsgcmV0dXJuIHRydWU7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeU51bWJlck9iamVjdCh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gbnVtQ2xhc3M7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBvYmplY3QgbGlrZS5cbiAqIEB2ZXJzaW9uIDEuNy4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1vYmplY3QtbGlrZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGFcbiAqIHByaW1pdGl2ZSBhbmQgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcbiAqXG4gKiBpc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBpc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNQcmltaXRpdmUodmFsdWUpID09PSBmYWxzZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLCB0cnVlKSA9PT0gZmFsc2U7XG59O1xuIiwiLyohXG4gKiBpcy1wcmltaXRpdmUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXByaW1pdGl2ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsID09PSBudWxsO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdmFsICE9PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8qIVxuICogaXMtcHJpbWl0aXZlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wcmltaXRpdmU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL3Rlc3RpbmctdmFsdWUtaXMtcHJpbWl0aXZlLzdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICByZXR1cm4gISFvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcycpO1xudmFyIHJlZ2V4RXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIHRyeVJlZ2V4RXhlY0NhbGwgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgbGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuXHRcdHZhbHVlLmxhc3RJbmRleCA9IDA7XG5cblx0XHRyZWdleEV4ZWMuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0dmFsdWUubGFzdEluZGV4ID0gbGFzdEluZGV4O1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWdleENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7XG5cdH1cblxuXHR2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcblx0dmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzKGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuXHRpZiAoIWhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnlSZWdleEV4ZWNDYWxsKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIElzIHRoaXMgdmFsdWUgYSBKUyByZWdleD9cbiAqIEB2ZXJzaW9uIDIuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1yZWdleHAteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJ2lzLW9iamVjdC1saWtlLXgnKTtcblxudmFyIHRvU3RyaW5nVGFnO1xudmFyIHJlZ2V4Q2xhc3M7XG52YXIgaGFzO1xudmFyIGdPUEQ7XG52YXIgcmVnZXhFeGVjO1xudmFyIGRlZmluZVByb3BlcnR5O1xuXG5pZiAocmVxdWlyZSgnaGFzLXRvLXN0cmluZy10YWcteCcpKSB7XG4gIGhhcyA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xuICBnT1BEID0gcmVxdWlyZSgnb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14Jyk7XG4gIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14Jyk7XG4gIHJlZ2V4RXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbn0gZWxzZSB7XG4gIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxudmFyIHRyeVJlZ2V4RXhlY0NhbGwgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUsIGRlc2NyaXB0b3IpIHtcbiAgdHJ5IHtcbiAgICB2YWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgIHJlZ2V4RXhlYy5jYWxsKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgJ2xhc3RJbmRleCcsIGRlc2NyaXB0b3IpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHRlc3RzIGlmIGEgdmFsdWUgaXMgYSByZWdleC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHZhbHVlIGlzIGEgcmVnZXg7IG90aGVyd2lzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqIHZhciBpc1JlZ2V4ID0gcmVxdWlyZSgnaXMtcmVnZXhwLXgnKTtcbiAqXG4gKiBpc1JlZ2V4KHVuZGVmaW5lZCk7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KG51bGwpOyAvLyBmYWxzZVxuICogaXNSZWdleChmYWxzZSk7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KHRydWUpOyAvLyBmYWxzZVxuICogaXNSZWdleCg0Mik7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KCdmb28nKTsgLy8gZmFsc2VcbiAqIGlzUmVnZXgoZnVuY3Rpb24gKCkge30pOyAvLyBmYWxzZVxuICogaXNSZWdleChbXSk7IC8vIGZhbHNlXG4gKiBpc1JlZ2V4KHt9KSk7IC8vIGZhbHNlXG4gKlxuICogaXNSZWdleCgvYS9nKTsgLy8gdHJ1ZVxuICogaXNSZWdleChuZXcgUmVnRXhwKCdhJywgJ2cnKSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG4gIGlmIChpc09iamVjdExpa2UodmFsdWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0b1N0cmluZ1RhZykge1xuICAgIHJldHVybiB0b1N0cmluZ1RhZyh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7XG4gIH1cblxuICB2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcbiAgdmFyIGhhc0xhc3RJbmRleERhdGFQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgaGFzKGRlc2NyaXB0b3IsICd2YWx1ZScpO1xuICBpZiAoaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5ICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRyeVJlZ2V4RXhlY0NhbGwodmFsdWUsIGRlc2NyaXB0b3IpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgSWYgSXNPYmplY3QodmFsdWUpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXNzZXJ0LWlzLW9iamVjdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2FmZVRvU3RyaW5nID0gcmVxdWlyZSgndG8tc3RyaW5nLXN5bWJvbHMtc3VwcG9ydGVkLXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG4vKipcbiAgICogVGVzdHMgYHZhbHVlYCB0byBzZWUgaWYgaXQgaXMgYW4gb2JqZWN0LCB0aHJvd3MgYSBgVHlwZUVycm9yYCBpZiBpdCBpc1xuICAgKiBub3QuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBgdmFsdWVgLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIGFyZ3VtZW50IHRvIGJlIHRlc3RlZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBUaHJvd3MgaWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgIGlmIGl0IGlzIGFuIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGFzc2VydElzT2JqZWN0ID0gcmVxdWlyZSgnYXNzZXJ0LWlzLW9iamVjdC14Jyk7XG4gICAqIHZhciBwcmltaXRpdmUgPSB0cnVlO1xuICAgKiB2YXIgbXlTeW1ib2wgPSBTeW1ib2woJ215U3ltYm9sJyk7XG4gICAqIHZhciBzeW1PYmogPSBPYmplY3QobXlTeW1ib2wpO1xuICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAqIGZ1bmN0aW9uIGZuICgpIHt9XG4gICAqXG4gICAqIGFzc2VydElzT2JqZWN0KHByaW1pdGl2ZSk7IC8vIFR5cGVFcnJvciAndHJ1ZSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChteVN5bWJvbCk7IC8vIFR5cGVFcnJvciAnU3ltYm9sKG15U3ltYm9sKSBpcyBub3QgYW4gb2JqZWN0J1xuICAgKiBhc3NlcnRJc09iamVjdChzeW1PYmopOyAvLyBSZXR1cm5zIHN5bU9iai5cbiAgICogYXNzZXJ0SXNPYmplY3Qob2JqZWN0KTsgLy8gUmV0dXJucyBvYmplY3QuXG4gICAqIGFzc2VydElzT2JqZWN0KGZuKTsgLy8gUmV0dXJucyBmbi5cbiAgICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzc2VydElzT2JqZWN0KHZhbHVlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFNoYW0gZm9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICogQHZlcnNpb24gNC4xLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG9iamVjdC1kZWZpbmUtcHJvcGVydHkteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbnZhciBpc0ZhbHNleSA9IHJlcXVpcmUoJ2lzLWZhbHNleS14Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCd0by1wcm9wZXJ0eS1rZXkteCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbi14Jyk7XG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCd2YWxpZGF0ZS5pby11bmRlZmluZWQnKTtcbnZhciBhc3NlcnRJc09iamVjdCA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1vYmplY3QteCcpO1xudmFyIG5hdGl2ZURlZlByb3AgPSB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrO1xuXG52YXIgdG9Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBfdG9Qcm9wZXJ0eURlc2NyaXB0b3IoZGVzYykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoZGVzYyk7XG4gIHZhciBkZXNjcmlwdG9yID0ge307XG4gIGlmIChoYXMob2JqZWN0LCAnZW51bWVyYWJsZScpKSB7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gQm9vbGVhbihvYmplY3QuZW51bWVyYWJsZSk7XG4gIH1cblxuICBpZiAoaGFzKG9iamVjdCwgJ2NvbmZpZ3VyYWJsZScpKSB7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSBCb29sZWFuKG9iamVjdC5jb25maWd1cmFibGUpO1xuICB9XG5cbiAgaWYgKGhhcyhvYmplY3QsICd2YWx1ZScpKSB7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IG9iamVjdC52YWx1ZTtcbiAgfVxuXG4gIGlmIChoYXMob2JqZWN0LCAnd3JpdGFibGUnKSkge1xuICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBCb29sZWFuKG9iamVjdC53cml0YWJsZSk7XG4gIH1cblxuICBpZiAoaGFzKG9iamVjdCwgJ2dldCcpKSB7XG4gICAgdmFyIGdldHRlciA9IG9iamVjdC5nZXQ7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGdldHRlcikgPT09IGZhbHNlICYmIGlzRnVuY3Rpb24oZ2V0dGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldHRlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgfVxuXG4gIGlmIChoYXMob2JqZWN0LCAnc2V0JykpIHtcbiAgICB2YXIgc2V0dGVyID0gb2JqZWN0LnNldDtcbiAgICBpZiAoaXNVbmRlZmluZWQoc2V0dGVyKSA9PT0gZmFsc2UgJiYgaXNGdW5jdGlvbihzZXR0ZXIpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2V0dGVyO1xuICB9XG5cbiAgaWYgKChoYXMoZGVzY3JpcHRvciwgJ2dldCcpIHx8IGhhcyhkZXNjcmlwdG9yLCAnc2V0JykpICYmIChoYXMoZGVzY3JpcHRvciwgJ3ZhbHVlJykgfHwgaGFzKGRlc2NyaXB0b3IsICd3cml0YWJsZScpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgZGVzY3JpcHRvci4gQ2Fubm90IGJvdGggc3BlY2lmeSBhY2Nlc3NvcnMgYW5kIGEgdmFsdWUgb3Igd3JpdGFibGUgYXR0cmlidXRlJyk7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbi8vIEVTNSAxNS4yLjMuNlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjZcblxuLy8gUGF0Y2ggZm9yIFdlYktpdCBhbmQgSUU4IHN0YW5kYXJkIG1vZGVcbi8vIERlc2lnbmVkIGJ5IGhheCA8aGF4LmdpdGh1Yi5jb20+XG4vLyByZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzI2lzc3VlLzVcbi8vIElFOCBSZWZlcmVuY2U6XG4vLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjgyOTAwLmFzcHhcbi8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyMjk5MTYuYXNweFxuLy8gV2ViS2l0IEJ1Z3M6XG4vLyAgICAgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTM2NDIzXG5cbnZhciAkZGVmaW5lUHJvcGVydHk7XG4vLyBjaGVjayB3aGV0aGVyIGRlZmluZVByb3BlcnR5IHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSwgc2hpbSBwYXJ0aWFsbHkuXG5pZiAobmF0aXZlRGVmUHJvcCkge1xuICB2YXIgdGVzdFdvcmtzV2l0aCA9IGZ1bmN0aW9uIF90ZXN0V29ya3NXaXRoKG9iamVjdCkge1xuICAgIHZhciB0ZXN0UmVzdWx0ID0gYXR0ZW1wdChuYXRpdmVEZWZQcm9wLCBvYmplY3QsICdzZW50aW5lbCcsIHt9KTtcbiAgICByZXR1cm4gdGVzdFJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgdGVzdFJlc3VsdC52YWx1ZSA9PT0gb2JqZWN0ICYmICdzZW50aW5lbCcgaW4gb2JqZWN0O1xuICB9O1xuXG4gIHZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50O1xuICBpZiAodGVzdFdvcmtzV2l0aCh7fSkgJiYgKGlzRmFsc2V5KGRvYykgfHwgdGVzdFdvcmtzV2l0aChkb2MuY3JlYXRlRWxlbWVudCgnZGl2JykpKSkge1xuICAgICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiBuYXRpdmVEZWZQcm9wKGFzc2VydElzT2JqZWN0KG9iamVjdCksIHRvUHJvcGVydHlLZXkocHJvcGVydHkpLCB0b1Byb3BlcnR5RGVzY3JpcHRvcihkZXNjcmlwdG9yKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrID0gbmF0aXZlRGVmUHJvcDtcbiAgfVxufVxuXG5pZiAoaXNGYWxzZXkobmF0aXZlRGVmUHJvcCkgfHwgZGVmaW5lUHJvcGVydHlGYWxsYmFjaykge1xuICB2YXIgcHJvdG90eXBlT2ZPYmplY3QgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxuICB2YXIgZGVmaW5lR2V0dGVyO1xuICB2YXIgZGVmaW5lU2V0dGVyO1xuICB2YXIgbG9va3VwR2V0dGVyO1xuICB2YXIgbG9va3VwU2V0dGVyO1xuICB2YXIgc3VwcG9ydHNBY2Nlc3NvcnMgPSBoYXMocHJvdG90eXBlT2ZPYmplY3QsICdfX2RlZmluZUdldHRlcl9fJyk7XG4gIGlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cbiAgICBkZWZpbmVHZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fO1xuICAgIGRlZmluZVNldHRlciA9IHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX187XG4gICAgbG9va3VwR2V0dGVyID0gcHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBHZXR0ZXJfXztcbiAgICBsb29rdXBTZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuICB9XG5cbiAgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICAgIGFzc2VydElzT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIHByb3BLZXkgPSB0b1Byb3BlcnR5S2V5KHByb3BlcnR5KTtcbiAgICB2YXIgcHJvcERlc2MgPSB0b1Byb3BlcnR5RGVzY3JpcHRvcihkZXNjcmlwdG9yKTtcblxuICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnR5IGZvciBJRTgncyBET00gZWxlbWVudHMuXG4gICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0LmNhbGwoT2JqZWN0LCBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrLCBvYmplY3QsIHByb3BLZXksIHByb3BEZXNjKTtcbiAgICAgIGlmIChyZXN1bHQudGhyZXcgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgYSBkYXRhIHByb3BlcnR5LlxuICAgIGlmIChoYXMocHJvcERlc2MsICd2YWx1ZScpKSB7XG4gICAgICAvLyBmYWlsIHNpbGVudGx5IGlmICd3cml0YWJsZScsICdlbnVtZXJhYmxlJywgb3IgJ2NvbmZpZ3VyYWJsZScgYXJlIHJlcXVlc3RlZCBidXQgbm90IHN1cHBvcnRlZFxuICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzICYmIChsb29rdXBHZXR0ZXIuY2FsbChvYmplY3QsIHByb3BLZXkpIHx8IGxvb2t1cFNldHRlci5jYWxsKG9iamVjdCwgcHJvcEtleSkpKSB7XG4gICAgICAgIC8vIEFzIGFjY2Vzc29ycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gZW5naW5lcyBpbXBsZW1lbnRpbmdcbiAgICAgICAgLy8gYF9fcHJvdG9fX2Agd2UgY2FuIHNhZmVseSBvdmVycmlkZSBgX19wcm90b19fYCB3aGlsZSBkZWZpbmluZ1xuICAgICAgICAvLyBhIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGhpdCBhbiBpbmhlcml0ZWQgYWNjZXNzb3IuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgIHZhciBwcm90b3R5cGUgPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgIC8vIERlbGV0aW5nIGEgcHJvcGVydHkgYW55d2F5IHNpbmNlIGdldHRlciAvIHNldHRlciBtYXkgYmUgZGVmaW5lZCBvbiBvYmplY3QgaXRzZWxmLlxuICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BLZXldO1xuICAgICAgICBvYmplY3RbcHJvcEtleV0gPSBwcm9wRGVzYy52YWx1ZTtcbiAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W3Byb3BLZXldID0gcHJvcERlc2MudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycyA9PT0gZmFsc2UgJiYgKHByb3BEZXNjLmdldCB8fCBwcm9wRGVzYy5zZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldHRlcnMgJiBzZXR0ZXJzIGNhbiBub3QgYmUgZGVmaW5lZCBvbiB0aGlzIGphdmFzY3JpcHQgZW5naW5lJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGdvdCB0aGF0IGZhciB0aGVuIGdldHRlcnMgYW5kIHNldHRlcnMgY2FuIGJlIGRlZmluZWQgISFcbiAgICAgIGlmIChwcm9wRGVzYy5nZXQpIHtcbiAgICAgICAgZGVmaW5lR2V0dGVyLmNhbGwob2JqZWN0LCBwcm9wS2V5LCBwcm9wRGVzYy5nZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcERlc2Muc2V0KSB7XG4gICAgICAgIGRlZmluZVNldHRlci5jYWxsKG9iamVjdCwgcHJvcEtleSwgcHJvcERlc2Muc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlZmluZXMgYSBuZXcgcHJvcGVydHkgZGlyZWN0bHkgb24gYW4gb2JqZWN0LCBvciBtb2RpZmllcyBhblxuICogZXhpc3RpbmcgcHJvcGVydHkgb24gYW4gb2JqZWN0LCBhbmQgcmV0dXJucyB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIGRlZmluZSB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgZGVmaW5lZCBvciBtb2RpZmllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIC0gVGhlIGRlc2NyaXB0b3IgZm9yIHRoZSBwcm9wZXJ0eSBiZWluZyBkZWZpbmVkIG9yIG1vZGlmaWVkLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ29iamVjdC1kZWZpbmUtcHJvcGVydHkteCcpO1xuICpcbiAqIHZhciBvID0ge307IC8vIENyZWF0ZXMgYSBuZXcgb2JqZWN0XG4gKlxuICogZGVmaW5lUHJvcGVydHkobywgJ2EnLCB7XG4gKiAgIHZhbHVlOiAzNyxcbiAqICAgd3JpdGFibGU6IHRydWVcbiAqIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWZpbmVQcm9wZXJ0eTtcbiIsIi8qKlxuICogQGZpbGUgRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHNhZmUgaW50ZWdlci5cbiAqIEB2ZXJzaW9uIDEuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1zYWZlLWludGVnZXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJ2lzLWludGVnZXIteCcpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSByZXF1aXJlKCdtYXgtc2FmZS1pbnRlZ2VyJyk7XG52YXIgTUlOX1NBRkVfSU5URUdFUiA9IC1NQVhfU0FGRV9JTlRFR0VSO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIENhbiBiZSBleGFjdGx5IHJlcHJlc2VudGVkIGFzIGFuIElFRUUtNzU0IGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyLCBhbmRcbiAqIHdob3NlIElFRUUtNzU0IHJlcHJlc2VudGF0aW9uIGNhbm5vdCBiZSB0aGUgcmVzdWx0IG9mIHJvdW5kaW5nIGFueSBvdGhlclxuICogaW50ZWdlciB0byBmaXQgdGhlIElFRUUtNzU0IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgdGVzdGVkIGZvciBiZWluZyBhIHNhZmUgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYVxuICogIHNhZmUgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgaXNTYWZlSW50ZWdlciA9IHJlcXVpcmUoJ2lzLXNhZmUtaW50ZWdlci14Jyk7XG4gKlxuICogaXNTYWZlSW50ZWdlcigwKTsgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqIGlzU2FmZUludGVnZXIoMSk7ICAgICAgICAgICAgICAgICAgICAvLyB0cnVlXG4gKiBpc1NhZmVJbnRlZ2VyKC0xMDAwMDApOyAgICAgICAgICAgICAgLy8gdHJ1ZVxuICpcbiAqIGlzU2FmZUludGVnZXIoTWF0aC5wb3coMiwgNTMpKTsgICAgICAvLyBmYWxzZVxuICogaXNTYWZlSW50ZWdlcigwLjEpOyAgICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc1NhZmVJbnRlZ2VyKE1hdGguUEkpOyAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqXG4gKiBpc1NhZmVJbnRlZ2VyKE5hTik7ICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzU2FmZUludGVnZXIoSW5maW5pdHkpOyAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNTYWZlSW50ZWdlcigtSW5maW5pdHkpOyAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc1NhZmVJbnRlZ2VyKCcxMCcpOyAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqIGlzU2FmZUludGVnZXIodHJ1ZSk7ICAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICogaXNTYWZlSW50ZWdlcihmYWxzZSk7ICAgICAgICAgICAgICAgIC8vIGZhbHNlXG4gKiBpc1NhZmVJbnRlZ2VyKFsxXSk7ICAgICAgICAgICAgICAgICAgLy8gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IE1JTl9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVjdCB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYW4gRVM2IFNFVC5cbiAqIEB2ZXJzaW9uIDEuNS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBpcy1zZXQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRmFsc2V5ID0gcmVxdWlyZSgnaXMtZmFsc2V5LXgnKTtcbnZhciBhdHRlbXB0O1xudmFyIGlzT2JqZWN0TGlrZTtcbnZhciBpc0xlbmd0aDtcbnZhciBnZXRTaXplO1xuXG5pZiAodHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJ29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteCcpKFNldC5wcm90b3R5cGUsICdzaXplJyk7XG4gIGlmIChkZXNjcmlwdG9yICYmIHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCdpcy1vYmplY3QtbGlrZS14Jyk7XG4gICAgdmFyIHJlcyA9IGF0dGVtcHQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICB9KTtcblxuICAgIGlmIChyZXMudGhyZXcgPT09IGZhbHNlICYmIGlzT2JqZWN0TGlrZShyZXMudmFsdWUpKSB7XG4gICAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJ2lzLWxlbmd0aC14Jyk7XG4gICAgICByZXMgPSBhdHRlbXB0LmNhbGwocmVzLnZhbHVlLCBkZXNjcmlwdG9yLmdldCk7XG4gICAgICBpZiAocmVzLnRocmV3ID09PSBmYWxzZSAmJiBpc0xlbmd0aChyZXMudmFsdWUpKSB7XG4gICAgICAgIGdldFNpemUgPSBkZXNjcmlwdG9yLmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBgb2JqZWN0YCBpcyBhIGBTZXRgLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYG9iamVjdGAgaXMgYSBgU2V0YCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzU2V0ID0gcmVxdWlyZSgnaXMtc2V0LXgnKTtcbiAqIHZhciBzID0gbmV3IFNldCgpO1xuICpcbiAqIGlzU2V0KFtdKTsgLy8gZmFsc2VcbiAqIGlzU2V0KHRydWUpOyAvLyBmYWxzZVxuICogaXNTZXQocyk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1NldChvYmplY3QpIHtcbiAgaWYgKGlzRmFsc2V5KGdldFNpemUpIHx8IGlzT2JqZWN0TGlrZShvYmplY3QpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0LmNhbGwob2JqZWN0LCBnZXRTaXplKTtcbiAgcmV0dXJuIHJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgaXNMZW5ndGgocmVzdWx0LnZhbHVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJWYWx1ZSA9IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZjtcbnZhciB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRzdHJWYWx1ZS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc3RyQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHRydWU7IH1cblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeVN0cmluZ09iamVjdCh2YWx1ZSkgOiB0b1N0ci5jYWxsKHZhbHVlKSA9PT0gc3RyQ2xhc3M7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUZXN0cyBpZiAyIGNoYXJhY3RlcnMgdG9nZXRoZXIgYXJlIGEgc3Vycm9nYXRlIHBhaXIuXG4gKiBAdmVyc2lvbiAxLjQuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgaXMtc3Vycm9nYXRlLXBhaXIteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHR3byBjaGFyYWN0ZXIgYXJndW1lbnRzIGNvbWJpbmVkIGFyZSBhIHZhbGlkIFVURi0xNlxuICogc3Vycm9nYXRlIHBhaXIuXG4gKlxuICogQHBhcmFtIHsqfSBjaGFyMSAtIFRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdXNwZWN0ZWQgc3Vycm9nYXRlIHBhaXIuXG4gKiBAcGFyYW0geyp9IGNoYXIyIC0gVGhlIHNlY29uZCBjaGFyYWN0ZXIgb2YgYSBzdXNwZWN0ZWQgc3Vycm9nYXRlIHBhaXIuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gY2hhcmFjdGVycyBjcmVhdGUgYSB2YWxpZFxuICogICdVVEYtMTYnIHN1cnJvZ2F0ZSBwYWlyOyBvdGhlcndpc2UgZmFsc2UuXG4gKiBAZXhhbXBsZVxuICogdmFyIGlzU3Vycm9nYXRlUGFpciA9IHJlcXVpcmUoJ2lzLXN1cnJvZ2F0ZS1wYWlyLXgnKTtcbiAqXG4gKiB2YXIgdGVzdDEgPSAnYSc7XG4gKiB2YXIgdGVzdDIgPSAn8KCunyc7XG4gKlxuICogaXNTdXJyb2dhdGVQYWlyKHRlc3QxLmNoYXJBdCgwKSwgdGVzdDEuY2hhckF0KDEpKTsgLy8gZmFsc2VcbiAqIGlzU3Vycm9nYXRlUGFpcih0ZXN0Mi5jaGFyQXQoMCksIHRlc3QyLmNoYXJBdCgxKSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoY2hhcjEsIGNoYXIyKSB7XG4gIGlmIChpc1N0cmluZyhjaGFyMSkgJiYgY2hhcjEubGVuZ3RoID09PSAxICYmIGlzU3RyaW5nKGNoYXIyKSAmJiBjaGFyMi5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgY29kZTEgPSBjaGFyMS5jaGFyQ29kZUF0KCk7XG4gICAgaWYgKGNvZGUxID49IDB4RDgwMCAmJiBjb2RlMSA8PSAweERCRkYpIHtcbiAgICAgIHZhciBjb2RlMiA9IGNoYXIyLmNoYXJDb2RlQXQoKTtcbiAgICAgIGlmIChjb2RlMiA+PSAweERDMDAgJiYgY29kZTIgPD0gMHhERkZGKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxuaWYgKGhhc1N5bWJvbHMpIHtcblx0dmFyIHN5bVRvU3RyID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHN5bVN0cmluZ1JlZ2V4ID0gL15TeW1ib2xcXCguKlxcKSQvO1xuXHR2YXIgaXNTeW1ib2xPYmplY3QgPSBmdW5jdGlvbiBpc1JlYWxTeW1ib2xPYmplY3QodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YoKSAhPT0gJ3N5bWJvbCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHN5bVN0cmluZ1JlZ2V4LnRlc3Qoc3ltVG9TdHIuY2FsbCh2YWx1ZSkpO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0b1N0ci5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcbn0gZWxzZSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuXHRcdC8vIHRoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTeW1ib2xzLlxuXHRcdHJldHVybiBmYWxzZSAmJiB2YWx1ZTtcblx0fTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG52YXIgdHlwZWRBcnJheXMgPSB7XG5cdEZsb2F0MzJBcnJheTogdHJ1ZSxcblx0RmxvYXQ2NEFycmF5OiB0cnVlLFxuXHRJbnQ4QXJyYXk6IHRydWUsXG5cdEludDE2QXJyYXk6IHRydWUsXG5cdEludDMyQXJyYXk6IHRydWUsXG5cdFVpbnQ4QXJyYXk6IHRydWUsXG5cdFVpbnQ4Q2xhbXBlZEFycmF5OiB0cnVlLFxuXHRVaW50MTZBcnJheTogdHJ1ZSxcblx0VWludDMyQXJyYXk6IHRydWVcbn07XG5cbnZhciBzbGljZSA9IFN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKF8sIHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdsb2JhbFt0eXBlZEFycmF5XSgpO1xuXHRcdGlmICghKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXZhbEVycm9yKCd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArIHR5cGVkQXJyYXkgKyAnIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuJyk7XG5cdFx0fVxuXHRcdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdHZhciBzdXBlclByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0fVxuXHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5VHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiAhIXR5cGVkQXJyYXlzW3NsaWNlLmNhbGwodG9TdHIuY2FsbCh2YWx1ZSksIDgsIC0xKV07IH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS43LjAgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bGwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bGwodm9pZCAwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc01hcCA9IHJlcXVpcmUoJy4vaXNNYXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1NldCA9IHJlcXVpcmUoJy4vaXNTZXQnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWFwO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVmFsdWVzO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAqIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICovXG5mdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3VzdG9tT21pdENsb25lO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpLFxuICAgIHZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmNsdWRlcztcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Vycm9yO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bGwobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bGwodm9pZCAwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdWxsO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlSXNTZXQgPSByZXF1aXJlKCcuL19iYXNlSXNTZXQnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyksXG4gICAgYmFzZVVuc2V0ID0gcmVxdWlyZSgnLi9fYmFzZVVuc2V0JyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgY3VzdG9tT21pdENsb25lID0gcmVxdWlyZSgnLi9fY3VzdG9tT21pdENsb25lJyksXG4gICAgZmxhdFJlc3QgPSByZXF1aXJlKCcuL19mbGF0UmVzdCcpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2InOiAnMicgfVxuICovXG52YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSk7XG4gIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gb21pdDtcbiIsInZhciBiYXNlUGljayA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrJyksXG4gICAgZmxhdFJlc3QgPSByZXF1aXJlKCcuL19mbGF0UmVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGljaztcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG4iLCJ2YXIgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbnRlZ2VyO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi9fYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWVzO1xuIiwiLyoqXG4gKiBAZmlsZSBDbGFtcCBhIG51bWJlciB0byBsaW1pdHMuXG4gKiBAdmVyc2lvbiAxLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgbWF0aC1jbGFtcC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9OdW1iZXIgPSByZXF1aXJlKCd0by1udW1iZXIteCcpLnRvTnVtYmVyMjAxODtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjbGFtcCBhIG51bWJlciB0byBtaW4gYW5kIG1heCBsaW1pdHMgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gYmUgY2xhbXBlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIC0gVGhlIG1pbmltdW0gbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIG51bWJlci5cbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIG1pbiA+IG1heC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNsYW1wZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqIHZhciBtYXRoQ2xhbXAgPSByZXF1aXJlKCdtYXRoLWNsYW1wLXgnKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbGFtcCh2YWx1ZSkge1xuICB2YXIgbnVtYmVyID0gdG9OdW1iZXIodmFsdWUpO1xuICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChhcmdzTGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICB2YXIgbWluID0gdG9OdW1iZXIoYXJndW1lbnRzWzFdKTtcbiAgdmFyIG1heDtcbiAgaWYgKGFyZ3NMZW5ndGggPCAzKSB7XG4gICAgbWF4ID0gbWluO1xuICAgIG1pbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbWF4ID0gdG9OdW1iZXIoYXJndW1lbnRzWzJdKTtcbiAgfVxuXG4gIGlmIChtaW4gPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJtaW5cIiBtdXN0IGJlIGxlc3MgdGhhbiBcIm1heFwiJyk7XG4gIH1cblxuICBpZiAobnVtYmVyIDwgbWluKSB7XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuXG4gIGlmIChudW1iZXIgPiBtYXgpIHtcbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgcmV0dXJuIG51bWJlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IDkwMDcxOTkyNTQ3NDA5OTE7XG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQS1JTVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUFkZGl0aW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1DaGFyc2V0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtRGF0ZXRpbWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImluZm9ybWF0aW9uYWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MDg5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjRdW1JGQzc2OTQsIFNlY3Rpb24gM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1GZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy41XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUxhbmd1YWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LVBhdGNoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1Nzg5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LVBvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicGVybS9hY2NlcHQtcG9zdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2h0dHBzOi8vd3d3LnczLm9yZy9UUi9sZHAvXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LVJhbmdlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDIuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsbG93XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy40LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBTFBOXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MzksIFNlY3Rpb24gMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsc28tQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTg0OV1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsdC1TdmNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzgzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsdC1Vc2VkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc4MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHRlcm5hdGUtUmVjaXBpZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWx0ZXJuYXRlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFwcGx5LVRvLVJlZGlyZWN0LVJlZlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDQzN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFwcHJvdmVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcmNoaXZlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcmNoaXZlZC1BdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTA2NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFydGljbGUtTmFtZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzE4NDldW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcnRpY2xlLVVwZGF0ZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzE4NDldW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRoZW50aWNhdGlvbi1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJleHBlcmltZW50YWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDUzLCBTZWN0aW9uIDRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRoZW50aWNhdGlvbi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MTUsIFNlY3Rpb24gM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhlbnRpY2F0aW9uLVJlc3VsdHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYwMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhvcml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRvLVN1Ym1pdHRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMzODM0IHNlY3Rpb24gNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dG9mb3J3YXJkZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRvc3VibWl0dGVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQmFzZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTgwOF1bUkZDMjA2OCBTZWN0aW9uIDE0LjExXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQmNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJCb2R5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJub25lXCIsXG4gICAgXCJTdGF0dXNcIjogXCJyZXNlcnZlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYwNjhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDLUV4dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkMtTWFuXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQy1PcHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDLVBFUFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkMtUEVQLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYWNoZS1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FsREFWLVRpbWV6b25lc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3ODA5LCBTZWN0aW9uIDcuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNhbmNlbC1LZXlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODMxNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNhbmNlbC1Mb2NrXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgzMTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2xvc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInJlc2VydmVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA4LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb21tZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29tbWVudHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbm5lY3Rpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA2LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUFsdGVybmF0aXZlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1CYXNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMyMDY4XVtSRkMyNjE2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1CYXNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMyMTEwXVtSRkMyNTU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1EZXNjcmlwdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjI2Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUR1cmF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDMuMS4yLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LWZlYXR1cmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUlkZW50aWZpZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUxhbmd1YWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDMuMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1Mb2NhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDMuMS40LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUxvY2F0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1NRDVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LU1ENVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtUmFuZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMywgU2VjdGlvbiA0LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVJldHVyblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtU2NyaXB0LVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVN0eWxlLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1UcmFuc2xhdGlvbi1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgyNTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuMS41XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnZlcnNpb24tV2l0aC1Mb3NzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29va2llXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb29raWUyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMyOTY1XVtSRkM2MjY1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiREFTTFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiREFWXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJETC1FeHBhbnNpb24tSGlzdG9yeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuMS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGF0ZS1SZWNlaXZlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMDg1MF1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlZmF1bHQtU3R5bGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZWZlcnJlZC1EZWxpdmVyeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlbGl2ZXJ5LURhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZWx0YS1CYXNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVwdGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlcml2ZWQtRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlc3RpbmF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaWZmZXJlbnRpYWwtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaWdlc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaXNjYXJkZWQtWDQwMC1JUE1TLUV4dGVuc2lvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaXNjYXJkZWQtWDQwMC1NVFMtRXh0ZW5zaW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc2Nsb3NlLVJlY2lwaWVudHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEaXNwb3NpdGlvbi1Ob3RpZmljYXRpb24tT3B0aW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc3Bvc2l0aW9uLU5vdGlmaWNhdGlvbi1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc3RyaWJ1dGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiREtJTS1TaWduYXR1cmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjM3Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtQmNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1DY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtRGlzcG9zaXRpb24tTm90aWZpY2F0aW9uLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1GaW5hbC1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtSW4tUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtTWFpbC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1NZXNzYWdlLUlkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLU9yaWdpbmFsLVJlY2lwaWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SY3B0LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZWZlcmVuY2VzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXNlbnQtQmNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXNlbnQtQ2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXNlbnQtUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1TZW5kZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmV0dXJuLVBhdGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFYXJseS1EYXRhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzg0NzBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVuY3J5cHRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVUYWdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAyLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBlY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjEuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwaXJ5LURhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGb2xsb3d1cC1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRm9yd2FyZGVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS41LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzY4NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJHZW5lcmF0ZS1EZWxpdmVyeS1SZXBvcnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJHZXRQcm9maWxlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSG9iYXJlZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZXhwZXJpbWVudGFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzQ4NiwgU2VjdGlvbiA2LjEuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkhvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA1LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJIVFRQMi1TZXR0aW5nc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NTQwLCBTZWN0aW9uIDMuMi4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSU1cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtTWF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLU5vbmUtTWF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1SYW5nZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLVNjaGVkdWxlLVRhZy1NYXRjaFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NjM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtVW5tb2RpZmllZC1TaW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkltcG9ydGFuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbi1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW5jbHVkZS1SZWZlcnJlZC1Ub2tlbi1CaW5kaW5nLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXRva2JpbmQtaHR0cHMtMThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmNvbXBsZXRlLUNvcHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmplY3Rpb24tRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW5qZWN0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIktlZXAtQWxpdmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJLZXl3b3Jkc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiS2V5d29yZHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxhYmVsXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMYXN0LU1vZGlmaWVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMi4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGF0ZXN0LURlbGl2ZXJ5LVRpbWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaW5lc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzM5NzddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaW5rXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgyODhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LUFyY2hpdmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LUhlbHBcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1Pd25lclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtUG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtU3Vic2NyaWJlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1VbnN1YnNjcmliZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwZXJtL2xpc3QtdW5zdWJzY3JpYmVcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtVW5zdWJzY3JpYmUtUG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDU4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTG9jYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxvY2stVG9rZW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1hblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1heC1Gb3J3YXJkc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVtZW50by1EYXRldGltZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiaW5mb3JtYXRpb25hbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcwODldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXNzYWdlLUNvbnRleHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXNzYWdlLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1JTUUtVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBBcHBlbmRpeCBBLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNSU1FLVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUV4ZW1wdGVkLUFkZHJlc3NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4xIGFuZCBBcHBlbmRpeCBCLjEwNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtRXh0ZW5kZWQtQXV0aG9yaXNhdGlvbi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMiBhbmQgQXBwZW5kaXggQi4xMDZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLVN1YmplY3QtSW5kaWNhdG9yLUNvZGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMyBhbmQgQXBwZW5kaXggQi4xMDddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUhhbmRsaW5nLUluc3RydWN0aW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjQgYW5kIEFwcGVuZGl4IEIuMTA4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1NZXNzYWdlLUluc3RydWN0aW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjUgYW5kIEFwcGVuZGl4IEIuMTA5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1Db2RyZXNzLU1lc3NhZ2UtSW5kaWNhdG9yXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuNiBhbmQgQXBwZW5kaXggQi4xMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU9yaWdpbmF0b3ItUmVmZXJlbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuNyBhbmQgQXBwZW5kaXggQi4xMTFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLVByaW1hcnktUHJlY2VkZW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjggYW5kIEFwcGVuZGl4IEIuMTAxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1Db3B5LVByZWNlZGVuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS45IGFuZCBBcHBlbmRpeCBCLjEwMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtTWVzc2FnZS1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMTAgYW5kIEFwcGVuZGl4IEIuMTAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1PdGhlci1SZWNpcGllbnRzLUluZGljYXRvci1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjEyIGFuZCBBcHBlbmRpeCBCLjExM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtT3RoZXItUmVjaXBpZW50cy1JbmRpY2F0b3ItQ0NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4xMiBhbmQgQXBwZW5kaXggQi4xMTNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUFjcDEyNy1NZXNzYWdlLUlkZW50aWZpZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4xNCBhbmQgQXBwZW5kaXggQi4xMTZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU9yaWdpbmF0b3ItUExBRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjE1IGFuZCBBcHBlbmRpeCBCLjExN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ULVByaW9yaXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY3NThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJOZWdvdGlhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJOZXdzZ3JvdXBzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJOTlRQLVBvc3RpbmctRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5OVFAtUG9zdGluZy1Ib3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMyOTgwXVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT2Jzb2xldGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3B0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3B0aW9uYWwtV1dXLUF1dGhlbnRpY2F0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZXhwZXJpbWVudGFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODA1MywgU2VjdGlvbiAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JkZXJpbmctVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JnYW5pemF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJpbmZvcm1hdGlvbmFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzY4MV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yZ2FuaXphdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1FbmNvZGVkLUluZm9ybWF0aW9uLVR5cGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NzAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLVJlY2lwaWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwZXJtL29yaWdpbmFsLXJlY2lwaWVudFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzM3OThdW1JGQzUzMzddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1TZW5kZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmF0b3ItUmV0dXJuLUFkZHJlc3NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1TdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU3MDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPdmVyd3JpdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlAzUFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBhdGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBFUFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBJQ1MtTGFiZWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQSUNTLUxhYmVsXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUGVwLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQb3NpdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUG9zdGluZy1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMwODUwXVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJhZ21hXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJlZmVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyNDBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmVmZXJlbmNlLUFwcGxpZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI0MF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByZXZlbnQtTm9uRGVsaXZlcnktUmVwb3J0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJpb3JpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm9maWxlT2JqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJvdG9jb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm90b2NvbC1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJvdG9jb2wtUXVlcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm90b2NvbC1SZXF1ZXN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktQXV0aGVudGljYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktQXV0aGVudGljYXRpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjE1LCBTZWN0aW9uIDRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1BdXRob3JpemF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktRmVhdHVyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1JbnN0cnVjdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlB1YmxpY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlB1YmxpYy1LZXktUGluc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDY5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHVibGljLUtleS1QaW5zLVJlcG9ydC1Pbmx5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSYW5nZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDMuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlY2VpdmVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzUzMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWNlaXZlZC1TUEZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIwOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZGlyZWN0LVJlZlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDQzN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZW5jZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZW5jZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlbGF5LVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzA4NTBdW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXBseS1CeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVxdWlyZS1SZWNpcGllbnQtVmFsaWQtU2luY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI5M11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1CY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1DY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LURhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzY4NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LVJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXRyeS1BZnRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmV0dXJuLVBhdGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNhZmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTY2hlZHVsZS1SZXBseVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NjM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2NoZWR1bGUtVGFnXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY2MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtVG9rZW4tQmluZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMtaWV0Zi10b2tiaW5kLWh0dHBzLTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1BY2NlcHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1LZXlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1XZWJTb2NrZXQtUHJvdG9jb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1XZWJTb2NrZXQtVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjdXJpdHktU2NoZW1lXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VlLUFsc29cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzE4NDldW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZW5kZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2Vuc2l0aXZpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZXJ2ZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNldC1Db29raWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjI2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNldC1Db29raWUyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMyOTY1XVtSRkM2MjY1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2V0UHJvZmlsZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNMVUdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTAyM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNvYXBBY3Rpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTb2xpY2l0YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzM4NjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdGF0dXMtVVJJXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2Nzk3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3ViamVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3ViamVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3VtbWFyeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3VwZXJzZWRlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1cGVyc2VkZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMjE1Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1cnJvZ2F0ZS1DYXBhYmlsaXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3Vycm9nYXRlLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUQ05cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJURVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDQuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRpbWVvdXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRMUy1SZXBvcnQtRG9tYWluXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXV0YS1zbXRwLXRsc3JwdC0yM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRMUy1SZXBvcnQtU3VibWl0dGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXV0YS1zbXRwLXRsc3JwdC0yM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUb3BpY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDMwLCBTZWN0aW9uIDUuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRyYWlsZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA0LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUcmFuc2Zlci1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDMuMy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVFRMXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVXJnZW5jeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDMwLCBTZWN0aW9uIDUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVSSVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVwZ3JhZGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA2LjddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVc2VyLUFnZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS41LjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVc2VyLUFnZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzI2MTZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWYXJpYW50LVZhcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWYXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWQlItSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVmlhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNS43LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJXV1ctQXV0aGVudGljYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiV2FudC1EaWdlc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJXYXJuaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS41XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1Db250ZW50LUlkZW50aWZpZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLUNvbnRlbnQtUmV0dXJuXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1Db250ZW50LVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLU1UUy1JZGVudGlmaWVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1PcmlnaW5hdG9yXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1SZWNlaXZlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtUmVjaXBpZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtVHJhY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLUNvbnRlbnQtVHlwZS1PcHRpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2h0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyN4LWNvbnRlbnQtdHlwZS1vcHRpb25zLWhlYWRlcl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtRnJhbWUtT3B0aW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiaW5mb3JtYXRpb25hbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcwMzRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYcmVmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtYWxsb3ctY3JlZGVudGlhbHNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtYWxsb3ctaGVhZGVyc1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1hbGxvdy1tZXRob2RzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtYWxsb3ctb3JpZ2luXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtTWF4LUFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLW1heC1hZ2VcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQU1QLUNhY2hlLVRyYW5zZm9ybVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbaHR0cHM6Ly9naXRodWIuY29tL2FtcHByb2plY3QvYW1waHRtbC9ibG9iL21hc3Rlci9zcGVjL2FtcC1jYWNoZS10cmFuc2Zvcm0ubWRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcHBhcmVudGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYXBwYXJlbnRseS10b1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMyMDc2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQVJDLUF1dGhlbnRpY2F0aW9uLVJlc3VsdHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hcmMtYXV0aGVudGljYXRpb24tcmVzdWx0c1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1pZXRmLWRtYXJjLWFyYy1wcm90b2NvbF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFSQy1NZXNzYWdlLVNpZ25hdHVyZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FyYy1tZXNzYWdlLXNpZ25hdHVyZVwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1pZXRmLWRtYXJjLWFyYy1wcm90b2NvbF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFSQy1TZWFsXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYXJjLXNlYWxcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbZHJhZnQtaWV0Zi1kbWFyYy1hcmMtcHJvdG9jb2xdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb21wbGlhbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFRElJTlQtRmVhdHVyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYwMTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFRElJTlQtRmVhdHVyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYwMTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFZXNzdC1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjgxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXJyb3JzLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvZXJyb3JzLXRvXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzIwNzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGb3JtLVN1YlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbZHJhZnQtbGV2aW5lLW1haWxib21iLWhlYWRlcl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkphYmJlci1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2phYmJlci1pZFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjU5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSmFiYmVyLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvamFiYmVyLWlkXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyNTldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWV0aG9kLUNoZWNrXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvbWV0aG9kLWNoZWNrXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ldGhvZC1DaGVjay1FeHBpcmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvbWV0aG9kLWNoZWNrLWV4cGlyZXNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1BdXRob3JpemluZy1Vc2Vyc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzkxMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5vbi1Db21wbGlhbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3B0aW9uYWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcml2aWNvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbZHJhZnQta29lbmlnLXByaXZpY29uc11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZXItUm9vdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3JlZmVyZXItcm9vdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNvbHV0aW9uLUhpbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNvbHZlci1Mb2NhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNJTy1MYWJlbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzQ0NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNJTy1MYWJlbC1IaXN0b3J5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDQ0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3ViT0tcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJzdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRpdGxlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVUEtQ29sb3JcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVQS1NZWRpYVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVBLVBpeGVsc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVBLVJlc29sdXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVQS1XaW5kb3dwaXhlbHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1BcmNoaXZlZC1BdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtYXJjaGl2ZWQtYXRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLUFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1hcmNoaXZlZC1hdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTA2NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtRGV2aWNlLUFjY2VwdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLWFjY2VwdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgTW9iaWxlIFdlYiBCZXN0IFByYWN0aWNlcyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1EZXZpY2UtQWNjZXB0LUNoYXJzZXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWRldmljZS1hY2NlcHQtY2hhcnNldFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgTW9iaWxlIFdlYiBCZXN0IFByYWN0aWNlcyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1EZXZpY2UtQWNjZXB0LUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1kZXZpY2UtYWNjZXB0LWVuY29kaW5nXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBNb2JpbGUgV2ViIEJlc3QgUHJhY3RpY2VzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLURldmljZS1BY2NlcHQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWRldmljZS1hY2NlcHQtbGFuZ3VhZ2VcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIE1vYmlsZSBXZWIgQmVzdCBQcmFjdGljZXMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtRGV2aWNlLVVzZXItQWdlbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWRldmljZS11c2VyLWFnZW50XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBNb2JpbGUgV2ViIEJlc3QgUHJhY3RpY2VzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLU1pdHRlbnRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MTA5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1QR1AtU2lnXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1wZ3Atc2lnXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2Z0cDovL2Z0cC5pc2Mub3JnL3B1Yi9wZ3Bjb250cm9sL0ZPUk1BVF1baHR0cHM6Ly9mdHAuaXNjLm9yZy9wdWIvcGdwY29udHJvbC9GT1JNQVRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVJpY2V2dXRhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MTA5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1SaWZlcmltZW50by1NZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MTA5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1UaXBvUmljZXZ1dGFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVRyYXNwb3J0b1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtVmVyaWZpY2FTaWN1cmV6emFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfVxuXSIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaW5lc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzM5NzddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ldGhvZC1DaGVja1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L21ldGhvZC1jaGVja1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXRob2QtQ2hlY2stRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L21ldGhvZC1jaGVjay1leHBpcmVzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZXItUm9vdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3JlZmVyZXItcm9vdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLUFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1hcmNoaXZlZC1hdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTA2NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWFyY2hpdmVkLWF0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH1cbl0iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxsOiByZXF1aXJlKCcuL2FsbC5qc29uJyksXG4gIHBlcm1hbmVudDogcmVxdWlyZSgnLi9wZXJtYW5lbnQuanNvbicpLFxuICBwcm92aXNpb25hbDogcmVxdWlyZSgnLi9wcm92aXNpb25hbC5qc29uJyksXG4gIHN0YW5kYXJkOiByZXF1aXJlKCcuL3N0YW5kYXJkLmpzb24nKSxcbiAgZGVwcmVjYXRlZDogcmVxdWlyZSgnLi9kZXByZWNhdGVkLmpzb24nKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBLUlNXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtQWRkaXRpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUNoYXJzZXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1EYXRldGltZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiaW5mb3JtYXRpb25hbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcwODldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuNF1bUkZDNzY5NCwgU2VjdGlvbiAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUZlYXR1cmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUxhbmd1YWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4zLjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtUGF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU3ODldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtUG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwZXJtL2FjY2VwdC1wb3N0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbaHR0cHM6Ly93d3cudzMub3JnL1RSL2xkcC9dXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtUmFuZ2VzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gMi4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWxsb3dcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjQuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFMUE5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYzOSwgU2VjdGlvbiAyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWxzby1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMxODQ5XVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWx0LVN2Y1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3ODM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWx0LVVzZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzgzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFsdGVybmF0ZS1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHRlcm5hdGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXBwbHktVG8tUmVkaXJlY3QtUmVmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0NDM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXBwcm92ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcmNoaXZlZC1BdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXJ0aWNsZS1OYW1lc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTg0OV1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFydGljbGUtVXBkYXRlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTg0OV1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhlbnRpY2F0aW9uLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImV4cGVyaW1lbnRhbFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwNTMsIFNlY3Rpb24gNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dGhlbnRpY2F0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYxNSwgU2VjdGlvbiAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0aGVudGljYXRpb24tUmVzdWx0c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjAxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0aG9yaXphdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM1LCBTZWN0aW9uIDQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dG8tU3VibWl0dGVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzM4MzQgc2VjdGlvbiA1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0b2ZvcndhcmRlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkF1dG9zdWJtaXR0ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJCYXNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMxODA4XVtSRkMyMDY4IFNlY3Rpb24gMTQuMTFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJCY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkJvZHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5vbmVcIixcbiAgICBcIlN0YXR1c1wiOiBcInJlc2VydmVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjA2OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkMtRXh0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQy1NYW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDLU9wdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkMtUEVQXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQy1QRVAtSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYWxEQVYtVGltZXpvbmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc4MDksIFNlY3Rpb24gNy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FuY2VsLUtleVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MzE1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FuY2VsLUxvY2tcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODMxNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDbG9zZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwicmVzZXJ2ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDguMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbW1lbnRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb21tZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29ubmVjdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDYuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtQWx0ZXJuYXRpdmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUJhc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzIwNjhdW1JGQzI2MTZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUJhc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzIxMTBdW1JGQzI1NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LURlc2NyaXB0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1EaXNwb3NpdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MjY2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1EaXNwb3NpdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtRHVyYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjIuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtZmVhdHVyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtSWRlbnRpZmllclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTGVuZ3RoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gMy4zLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUxvY2F0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTG9jYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LU1ENVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJNSU1FXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1SYW5nZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtUmV0dXJuXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1TY3JpcHQtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtU3R5bGUtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVRyYW5zbGF0aW9uLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODI1NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDMuMS4xLjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIk1JTUVcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb252ZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udmVyc2lvbi1XaXRoLUxvc3NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb29raWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjI2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvb2tpZTJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzI5NjVdW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEQVNMXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEQVZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRMLUV4cGFuc2lvbi1IaXN0b3J5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS4xLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlLVJlY2VpdmVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkMwODUwXVtSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVmYXVsdC1TdHlsZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlZmVycmVkLURlbGl2ZXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVsaXZlcnktRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlbHRhLUJhc2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZXB0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVyaXZlZC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGVzdGluYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpZmZlcmVudGlhbC1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpZ2VzdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc2NhcmRlZC1YNDAwLUlQTVMtRXh0ZW5zaW9uc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc2NhcmRlZC1YNDAwLU1UUy1FeHRlbnNpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzY2xvc2UtUmVjaXBpZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRpc3Bvc2l0aW9uLU5vdGlmaWNhdGlvbi1PcHRpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzcG9zaXRpb24tTm90aWZpY2F0aW9uLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzdHJpYnV0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJES0lNLVNpZ25hdHVyZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2Mzc2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1CY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1EaXNwb3NpdGlvbi1Ob3RpZmljYXRpb24tVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLUZpbmFsLVJlY2lwaWVudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1Jbi1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1NYWlsLUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLU1lc3NhZ2UtSWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtT3JpZ2luYWwtUmVjaXBpZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY4NTcgU2VjdGlvbiAzLjEuMTBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJjcHQtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlZmVyZW5jZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1CY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1DY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MDRdW1JGQzY4NTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEb3duZ3JhZGVkLVJlc2VudC1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVzZW50LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1SZXR1cm4tUGF0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTA0XVtSRkM2ODU3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUwNF1bUkZDNjg1N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVhcmx5LURhdGFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODQ3MF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRW5jcnlwdGVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRVRhZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDIuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFeHBpcnktRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZvbGxvd3VwLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGb3J3YXJkZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkdlbmVyYXRlLURlbGl2ZXJ5LVJlcG9ydFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkdldFByb2ZpbGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJIb2JhcmVnXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJleHBlcmltZW50YWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDg2LCBTZWN0aW9uIDYuMS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDUuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkhUVFAyLVNldHRpbmdzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc1NDAsIFNlY3Rpb24gMy4yLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJTVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1NYXRjaFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLU1vZGlmaWVkLVNpbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtTm9uZS1NYXRjaFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLVJhbmdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtU2NoZWR1bGUtVGFnLU1hdGNoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY2MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1Vbm1vZGlmaWVkLVNpbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW1wb3J0YW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluLVJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmNsdWRlLVJlZmVycmVkLVRva2VuLUJpbmRpbmctSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdG9rYmluZC1odHRwcy0xOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluY29tcGxldGUtQ29weVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkluamVjdGlvbi1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmplY3Rpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiS2VlcC1BbGl2ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIktleXdvcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJLZXl3b3Jkc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGFiZWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxhc3QtTW9kaWZpZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAyLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMYXRlc3QtRGVsaXZlcnktVGltZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpbmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMzk3N11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpbmtcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODI4OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtQXJjaGl2ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtSGVscFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LU93bmVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1Qb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1TdWJzY3JpYmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMaXN0LVVuc3Vic2NyaWJlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInBlcm0vbGlzdC11bnN1YnNjcmliZVwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGlzdC1VbnN1YnNjcmliZS1Qb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwNThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJMb2NhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTG9jay1Ub2tlblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWFuXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWF4LUZvcndhcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS4xLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZW1lbnRvLURhdGV0aW1lXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJpbmZvcm1hdGlvbmFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzA4OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtQ29udGV4dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ldGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTUlNRS1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIEFwcGVuZGl4IEEuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1JTUUtVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtRXhlbXB0ZWQtQWRkcmVzc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjEgYW5kIEFwcGVuZGl4IEIuMTA1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1FeHRlbmRlZC1BdXRob3Jpc2F0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4yIGFuZCBBcHBlbmRpeCBCLjEwNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtU3ViamVjdC1JbmRpY2F0b3ItQ29kZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4zIGFuZCBBcHBlbmRpeCBCLjEwN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtSGFuZGxpbmctSW5zdHJ1Y3Rpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuNCBhbmQgQXBwZW5kaXggQi4xMDhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU1lc3NhZ2UtSW5zdHJ1Y3Rpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuNSBhbmQgQXBwZW5kaXggQi4xMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUNvZHJlc3MtTWVzc2FnZS1JbmRpY2F0b3JcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS42IGFuZCBBcHBlbmRpeCBCLjExMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtT3JpZ2luYXRvci1SZWZlcmVuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS43IGFuZCBBcHBlbmRpeCBCLjExMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtUHJpbWFyeS1QcmVjZWRlbmNlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuOCBhbmQgQXBwZW5kaXggQi4xMDFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUNvcHktUHJlY2VkZW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjkgYW5kIEFwcGVuZGl4IEIuMTAyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1NZXNzYWdlLVR5cGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NzddW0FDUDEyMyBBcHBlbmRpeCBBMS4xMCBhbmQgQXBwZW5kaXggQi4xMDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLU90aGVyLVJlY2lwaWVudHMtSW5kaWNhdG9yLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMTIgYW5kIEFwcGVuZGl4IEIuMTEzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTU1IUy1PdGhlci1SZWNpcGllbnRzLUluZGljYXRvci1DQ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjEyIGFuZCBBcHBlbmRpeCBCLjExM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtQWNwMTI3LU1lc3NhZ2UtSWRlbnRpZmllclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ3N11bQUNQMTIzIEFwcGVuZGl4IEExLjE0IGFuZCBBcHBlbmRpeCBCLjExNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1NSFMtT3JpZ2luYXRvci1QTEFEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDc3XVtBQ1AxMjMgQXBwZW5kaXggQTEuMTUgYW5kIEFwcGVuZGl4IEIuMTE3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTVQtUHJpb3JpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjc1OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5lZ290aWF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5ld3Nncm91cHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk5OVFAtUG9zdGluZy1EYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJvYnNvbGV0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTk5UUC1Qb3N0aW5nLUhvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzI5ODBdW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPYnNvbGV0ZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcHRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcHRpb25hbC1XV1ctQXV0aGVudGljYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJleHBlcmltZW50YWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDUzLCBTZWN0aW9uIDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmRlcmluZy1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmdhbml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcImluZm9ybWF0aW9uYWxcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjgxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JnYW5pemF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjQ1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLUVuY29kZWQtSW5mb3JtYXRpb24tVHlwZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU3MDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmlnaW5hbC1NZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtUmVjaXBpZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInBlcm0vb3JpZ2luYWwtcmVjaXBpZW50XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMzc5OF1bUkZDNTMzN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYXRvci1SZXR1cm4tQWRkcmVzc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLVN1YmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTcwM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk92ZXJ3cml0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUDNQXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUGF0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUEVQXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUElDUy1MYWJlbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBJQ1MtTGFiZWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQZXAtSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlBvc2l0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQb3N0aW5nLVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzA4NTBdW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmFnbWFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmVmZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI0MF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByZWZlcmVuY2UtQXBwbGllZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjQwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJldmVudC1Ob25EZWxpdmVyeS1SZXBvcnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmlvcml0eVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb2ZpbGVPYmplY3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm90b2NvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3RvY29sLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm90b2NvbC1RdWVyeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3RvY29sLVJlcXVlc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1BdXRoZW50aWNhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1BdXRoZW50aWNhdGlvbi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MTUsIFNlY3Rpb24gNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUF1dGhvcml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcm94eS1GZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUluc3RydWN0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHVibGljXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHVibGljLUtleS1QaW5zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQdWJsaWMtS2V5LVBpbnMtUmVwb3J0LU9ubHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzQ2OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJhbmdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzMsIFNlY3Rpb24gMy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVjZWl2ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNTMyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlY2VpdmVkLVNQRlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjA4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVkaXJlY3QtUmVmXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0NDM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuNS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVsYXktVmVyc2lvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMDg1MF1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcGx5LUJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXF1aXJlLVJlY2lwaWVudC1WYWxpZC1TaW5jZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjkzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUJjY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LUZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1NZXNzYWdlLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzY4NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJldHJ5LUFmdGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXR1cm4tUGF0aFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2FmZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNjaGVkdWxlLVJlcGx5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY2MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTY2hlZHVsZS1UYWdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjYzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1Ub2tlbi1CaW5kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXRva2JpbmQtaHR0cHMtMThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUFjY2VwdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUtleVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1Qcm90b2NvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWN1cml0eS1TY2hlbWVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWUtQWxzb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwib2Jzb2xldGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMTg0OV1bUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VuZGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZW5zaXRpdml0eVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlcnZlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2V0LUNvb2tpZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MjY1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2V0LUNvb2tpZTJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIm9ic29sZXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzI5NjVdW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZXRQcm9maWxlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU0xVR1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU29hcEFjdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNvbGljaXRhdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMzg2NV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN0YXR1cy1VUklcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY3OTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdW1tYXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdXBlcnNlZGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3VwZXJzZWRlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkMyMTU2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU3Vycm9nYXRlLUNhcGFiaWxpdHlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdXJyb2dhdGUtQ29udHJvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRDTlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRFXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNC4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVGltZW91dFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVExTLVJlcG9ydC1Eb21haW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdXRhLXNtdHAtdGxzcnB0LTIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVExTLVJlcG9ydC1TdWJtaXR0ZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDLWlldGYtdXRhLXNtdHAtdGxzcnB0LTIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRvcGljXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVHJhaWxlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDQuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRyYW5zZmVyLUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gMy4zLjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUVExcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODAzMCwgU2VjdGlvbiA1LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVcmdlbmN5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVVJJXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVXBncmFkZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDYuN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVzZXItQWdlbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVzZXItQWdlbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDMjYxNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZhcmlhbnQtVmFyeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZhcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZCUi1JbmZvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWaWFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA1LjcuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNSwgU2VjdGlvbiA0LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJXYW50LURpZ2VzdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIldhcm5pbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLUNvbnRlbnQtSWRlbnRpZmllclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtQ29udGVudC1SZXR1cm5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLUNvbnRlbnQtVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlg0MDAtTVRTLUlkZW50aWZpZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLU9yaWdpbmF0b3JcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQwMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYNDAwLVJlY2VpdmVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1SZWNpcGllbnRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MDIxXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWDQwMC1UcmFjZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDAyMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQ29udGVudC1UeXBlLU9wdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3gtY29udGVudC10eXBlLW9wdGlvbnMtaGVhZGVyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1GcmFtZS1PcHRpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJpbmZvcm1hdGlvbmFsXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzAzNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlhyZWZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9XG5dIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2xcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1hbGxvdy1jcmVkZW50aWFsc1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FjY2Vzcy1jb250cm9sLWFsbG93LW1ldGhvZHNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1hbGxvdy1vcmlnaW5cIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtbWF4LWFnZVwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBTVAtQ2FjaGUtVHJhbnNmb3JtXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltodHRwczovL2dpdGh1Yi5jb20vYW1wcHJvamVjdC9hbXBodG1sL2Jsb2IvbWFzdGVyL3NwZWMvYW1wLWNhY2hlLXRyYW5zZm9ybS5tZF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFwcGFyZW50bHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hcHBhcmVudGx5LXRvXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzIwNzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBUkMtQXV0aGVudGljYXRpb24tUmVzdWx0c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L2FyYy1hdXRoZW50aWNhdGlvbi1yZXN1bHRzXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2RyYWZ0LWlldGYtZG1hcmMtYXJjLXByb3RvY29sXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQVJDLU1lc3NhZ2UtU2lnbmF0dXJlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvYXJjLW1lc3NhZ2Utc2lnbmF0dXJlXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW2RyYWZ0LWlldGYtZG1hcmMtYXJjLXByb3RvY29sXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQVJDLVNlYWxcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9hcmMtc2VhbFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1pZXRmLWRtYXJjLWFyYy1wcm90b2NvbF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbXBsaWFuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVESUlOVC1GZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjAxN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVESUlOVC1GZWF0dXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjAxN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkVlc3N0LVZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2ODFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJFcnJvcnMtVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9lcnJvcnMtdG9cIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMjA3Nl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZvcm0tU3ViXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1sZXZpbmUtbWFpbGJvbWItaGVhZGVyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSmFiYmVyLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvamFiYmVyLWlkXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyNTldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJKYWJiZXItSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9qYWJiZXItaWRcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI1OV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNZXRob2QtQ2hlY2tcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9tZXRob2QtY2hlY2tcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiZGVwcmVjYXRlZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBXZWIgQXBwbGljYXRpb24gRm9ybWF0cyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWV0aG9kLUNoZWNrLUV4cGlyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi9tZXRob2QtY2hlY2stZXhwaXJlc1wiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIFdlYiBBcHBsaWNhdGlvbiBGb3JtYXRzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJNTUhTLUF1dGhvcml6aW5nLVVzZXJzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3OTEyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTm9uLUNvbXBsaWFuY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcHRpb25hbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByaXZpY29uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltkcmFmdC1rb2VuaWctcHJpdmljb25zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVmZXJlci1Sb290XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YvcmVmZXJlci1yb290XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgV2ViIEFwcGxpY2F0aW9uIEZvcm1hdHMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc29sdXRpb24tSGludFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc29sdmVyLUxvY2F0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU0lPLUxhYmVsXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDQ0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU0lPLUxhYmVsLUhpc3RvcnlcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NDRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJPS1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlN1YnN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVGl0bGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVQS1Db2xvclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVBLU1lZGlhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVUEtUGl4ZWxzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVUEtUmVzb2x1dGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVBLVdpbmRvd3BpeGVsc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDIyOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlZlcnNpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLUFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1hcmNoaXZlZC1hdFwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJkZXByZWNhdGVkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTA2NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQXJjaGl2ZWQtQXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWFyY2hpdmVkLWF0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcImRlcHJlY2F0ZWRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1EZXZpY2UtQWNjZXB0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInByb3YveC1kZXZpY2UtYWNjZXB0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBNb2JpbGUgV2ViIEJlc3QgUHJhY3RpY2VzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLURldmljZS1BY2NlcHQtQ2hhcnNldFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLWFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1czQyBNb2JpbGUgV2ViIEJlc3QgUHJhY3RpY2VzIFdvcmtpbmcgR3JvdXBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLURldmljZS1BY2NlcHQtRW5jb2RpbmdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LWRldmljZS1hY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIE1vYmlsZSBXZWIgQmVzdCBQcmFjdGljZXMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtRGV2aWNlLUFjY2VwdC1MYW5ndWFnZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLWFjY2VwdC1sYW5ndWFnZVwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltXM0MgTW9iaWxlIFdlYiBCZXN0IFByYWN0aWNlcyBXb3JraW5nIEdyb3VwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1EZXZpY2UtVXNlci1BZ2VudFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJwcm92L3gtZGV2aWNlLXVzZXItYWdlbnRcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbVzNDIE1vYmlsZSBXZWIgQmVzdCBQcmFjdGljZXMgV29ya2luZyBHcm91cF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtTWl0dGVudGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVBHUC1TaWdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwicHJvdi94LXBncC1zaWdcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbZnRwOi8vZnRwLmlzYy5vcmcvcHViL3BncGNvbnRyb2wvRk9STUFUXVtodHRwczovL2Z0cC5pc2Mub3JnL3B1Yi9wZ3Bjb250cm9sL0ZPUk1BVF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtUmljZXZ1dGFcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVJpZmVyaW1lbnRvLU1lc3NhZ2UtSURcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcIlwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYxMDldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJYLVRpcG9SaWNldnV0YVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtVHJhc3BvcnRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MTA5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWC1WZXJpZmljYVNpY3VyZXp6YVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwiXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjEwOV1cIlxuICB9XG5dIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQWNjZXB0LUNoYXJzZXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMy40XVtSRkM3Njk0LCBTZWN0aW9uIDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBY2NlcHQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjMuNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1Qb3N0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInBlcm0vYWNjZXB0LXBvc3RcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltodHRwczovL3d3dy53My5vcmcvVFIvbGRwL11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFjY2VwdC1SYW5nZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMywgU2VjdGlvbiAyLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbGxvd1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuNC4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQUxQTlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjM5LCBTZWN0aW9uIDJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHQtU3ZjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc4MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBbHQtVXNlZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3ODM4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXBwcm92ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkFyY2hpdmVkLUF0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwNjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBcmNoaXZlZC1BdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MDY0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0aGVudGljYXRpb24tSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NjE1LCBTZWN0aW9uIDNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRoZW50aWNhdGlvbi1SZXN1bHRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc2MDFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQXV0by1TdWJtaXR0ZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMzgzNCBzZWN0aW9uIDVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJCY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzNCwgU2VjdGlvbiA1LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDYWxEQVYtVGltZXpvbmVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc4MDksIFNlY3Rpb24gNy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FuY2VsLUtleVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MzE1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ2FuY2VsLUxvY2tcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODMxNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNjXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb21tZW50c1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29tbWVudHNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbm5lY3Rpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA2LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYyNjZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjIuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiAzLjMuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtTG9jYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiAzLjEuNC4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1SYW5nZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDQuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRlbnQtVHJhbnNsYXRpb24tVHlwZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiTUlNRVwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MjU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gMy4xLjEuNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvbnRyb2xcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkNvb2tpZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2MjY1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiREFTTFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiREFWXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjEuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRlcHRoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJEZXN0aW5hdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0OTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRGlzdHJpYnV0aW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJES0lNLVNpZ25hdHVyZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2Mzc2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1GaW5hbC1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtSW4tUmVwbHktVG9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtTWVzc2FnZS1JZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRG93bmdyYWRlZC1PcmlnaW5hbC1SZWNpcGllbnRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjg1NyBTZWN0aW9uIDMuMS4xMF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkRvd25ncmFkZWQtUmVmZXJlbmNlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2ODU3IFNlY3Rpb24gMy4xLjEwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRWFybHktRGF0YVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4NDcwXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRVRhZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDIuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMS4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiRXhwaXJlc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZvbGxvd3VwLVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJGb3J3YXJkZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzOV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkZyb21cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkhvc3RcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA1LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJIVFRQMi1TZXR0aW5nc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NTQwLCBTZWN0aW9uIDMuMi4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLU1hdGNoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtTW9kaWZpZWQtU2luY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1Ob25lLU1hdGNoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzIsIFNlY3Rpb24gMy4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSWYtUmFuZ2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMywgU2VjdGlvbiAzLjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJZi1TY2hlZHVsZS1UYWctTWF0Y2hcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjYzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIklmLVVubW9kaWZpZWQtU2luY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMiwgU2VjdGlvbiAzLjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbi1SZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW5jbHVkZS1SZWZlcnJlZC1Ub2tlbi1CaW5kaW5nLUlEXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXRva2JpbmQtaHR0cHMtMThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJJbmplY3Rpb24tRGF0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiSW5qZWN0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIktleXdvcmRzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJLZXl3b3Jkc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTGFzdC1Nb2RpZmllZFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMyLCBTZWN0aW9uIDIuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpbmtcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDODI4OF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxpc3QtVW5zdWJzY3JpYmUtUG9zdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDU4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTG9jYXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA3LjEuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIkxvY2stVG9rZW5cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1heC1Gb3J3YXJkc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDUuMS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiTUlNRS1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIEFwcGVuZGl4IEEuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk1ULVByaW9yaXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY3NThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJOZXdzZ3JvdXBzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmRlcmluZy1UeXBlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQyMjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJPcmdhbml6YXRpb25cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtRnJvbVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NzAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtUmVjaXBpZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcInBlcm0vb3JpZ2luYWwtcmVjaXBpZW50XCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDMzc5OF1bUkZDNTMzN11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIk9yaWdpbmFsLVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM3XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3JpZ2luYWwtU3ViamVjdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NzAzXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiT3ZlcndyaXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzQ5MThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQYXRoXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQb3NpdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM0MjI5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJhZ21hXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzQsIFNlY3Rpb24gNS40XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJlZmVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyNDBdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJQcmVmZXJlbmNlLUFwcGxpZWRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI0MF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUF1dGhlbnRpY2F0ZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM1LCBTZWN0aW9uIDQuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlByb3h5LUF1dGhlbnRpY2F0aW9uLUluZm9cIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzYxNSwgU2VjdGlvbiA0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHJveHktQXV0aG9yaXphdGlvblwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM1LCBTZWN0aW9uIDQuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlB1YmxpYy1LZXktUGluc1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3NDY5XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUHVibGljLUtleS1QaW5zLVJlcG9ydC1Pbmx5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzc0NjldXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSYW5nZVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMzLCBTZWN0aW9uIDMuMV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlY2VpdmVkXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzUzMjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZWNlaXZlZC1TUEZcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIwOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZW5jZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZW5jZXNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm5ldG5ld3NcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTUzNl1bUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlZmVyZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMSwgU2VjdGlvbiA1LjUuMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlcGx5LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXBseS1Ub1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVxdWlyZS1SZWNpcGllbnQtVmFsaWQtU2luY2VcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzI5M11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1CY2NcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1DY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LURhdGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlJlc2VudC1Gcm9tXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdW1JGQzY4NTRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXNlbnQtTWVzc2FnZS1JRFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LVNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1MzIyXVtSRkM2ODU0XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmVzZW50LVRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJSZXRyeS1BZnRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMxLCBTZWN0aW9uIDcuMS4zXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiUmV0dXJuLVBhdGhcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNjaGVkdWxlLVJlcGx5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY2MzhdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTY2hlZHVsZS1UYWdcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNjYzOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlYy1Ub2tlbi1CaW5kaW5nXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXRva2JpbmQtaHR0cHMtMThdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUFjY2VwdFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZWMtV2ViU29ja2V0LUtleVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1Qcm90b2NvbFwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM2NDU1XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VjLVdlYlNvY2tldC1WZXJzaW9uXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY0NTVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZW5kZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcIm1haWxcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNTMyMl1bUkZDNjg1NF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlNlbmRlclwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVtSRkM1MzIyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiU2VydmVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy40LjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTZXQtQ29va2llXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzYyNjVdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTTFVHXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUwMjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzY3OTddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdWJqZWN0XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdW1tYXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJTdXBlcnNlZGVzXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzIxNTZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJURVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDQuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRpbWVvdXRcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNDkxOF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRMUy1SZXBvcnQtRG9tYWluXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXV0YS1zbXRwLXRsc3JwdC0yM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRMUy1SZXBvcnQtU3VibWl0dGVyXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQy1pZXRmLXV0YS1zbXRwLXRsc3JwdC0yM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRvXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJtYWlsXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzUzMjJdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUb3BpY1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDMwLCBTZWN0aW9uIDUuNF1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlRyYWlsZXJcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA0LjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJUcmFuc2Zlci1FbmNvZGluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjMwLCBTZWN0aW9uIDMuMy4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVFRMXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzgwMzAsIFNlY3Rpb24gNS4yXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVXJnZW5jeVwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM4MDMwLCBTZWN0aW9uIDUuM11cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlVwZ3JhZGVcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbUkZDNzIzMCwgU2VjdGlvbiA2LjddXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVc2VyLUFnZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNS41LjNdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJVc2VyLUFnZW50XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJuZXRuZXdzXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzU1MzZdW1JGQzI2MTZdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWYXJ5XCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzEsIFNlY3Rpb24gNy4xLjRdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJWQlItSW5mb1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibWFpbFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTE4XVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiVmlhXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzAsIFNlY3Rpb24gNS43LjFdXCJcbiAgfSxcbiAge1xuICAgIFwiSGVhZGVyIEZpZWxkIE5hbWVcIjogXCJXV1ctQXV0aGVudGljYXRlXCIsXG4gICAgXCJUZW1wbGF0ZVwiOiBcIlwiLFxuICAgIFwiUHJvdG9jb2xcIjogXCJodHRwXCIsXG4gICAgXCJTdGF0dXNcIjogXCJzdGFuZGFyZFwiLFxuICAgIFwiUmVmZXJlbmNlXCI6IFwiW1JGQzcyMzUsIFNlY3Rpb24gNC4xXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiV2FybmluZ1wiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwiaHR0cFwiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM3MjM0LCBTZWN0aW9uIDUuNV1cIlxuICB9LFxuICB7XG4gICAgXCJIZWFkZXIgRmllbGQgTmFtZVwiOiBcIlgtQ29udGVudC1UeXBlLU9wdGlvbnNcIixcbiAgICBcIlRlbXBsYXRlXCI6IFwiXCIsXG4gICAgXCJQcm90b2NvbFwiOiBcImh0dHBcIixcbiAgICBcIlN0YXR1c1wiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJSZWZlcmVuY2VcIjogXCJbaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3gtY29udGVudC10eXBlLW9wdGlvbnMtaGVhZGVyXVwiXG4gIH0sXG4gIHtcbiAgICBcIkhlYWRlciBGaWVsZCBOYW1lXCI6IFwiWHJlZlwiLFxuICAgIFwiVGVtcGxhdGVcIjogXCJcIixcbiAgICBcIlByb3RvY29sXCI6IFwibmV0bmV3c1wiLFxuICAgIFwiU3RhdHVzXCI6IFwic3RhbmRhcmRcIixcbiAgICBcIlJlZmVyZW5jZVwiOiBcIltSRkM1NTM2XVwiXG4gIH1cbl0iLCIvKipcbiAqIEBmaWxlIFRoZSBjb25zdGFudCBOYU4gZGVyaXZlZCBtYXRoZW1hdGljYWxseSBieSAwIC8gMC5cbiAqIEB2ZXJzaW9uIDEuMC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBuYW4teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgY29uc3RhbnQgTmFOIGRlcml2ZWQgbWF0aGVtYXRpY2FsbHkgYnkgMCAvIDAuXG4gKlxuICogQHR5cGUgbnVtYmVyXG4gKiBAZXhhbXBsZVxuICogdmFyIE5BTiA9IHJlcXVpcmUoJ25hbi14Jyk7XG4gKlxuICogTkFOICE9PSBOQU47IC8vIHRydWVcbiAqIE5BTiA9PT0gTkFOOyAvLyBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IDAgLyAwO1xuIiwiLyoqXG4gKiBAZmlsZSBUcmltcyBhbmQgcmVwbGFjZXMgc2VxdWVuY2VzIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBieSBhIHNpbmdsZSBzcGFjZS5cbiAqIEB2ZXJzaW9uIDMuMC4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBub3JtYWxpemUtc3BhY2UteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYlRyaW0gPSByZXF1aXJlKCd0cmltLXgnKTtcbnZhciB0cmltMjAxNiA9IGxpYlRyaW0udHJpbTIwMTY7XG52YXIgdHJpbTIwMTggPSBsaWJUcmltLnRyaW0yMDE4O1xudmFyIFJ4ID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuUmVnRXhwO1xudmFyIGxpYldoaXRlU3BhY2UgPSByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jyk7XG52YXIgcmVOb3JtYWxpemUyMDE2ID0gbmV3IFJ4KCdbJyArIGxpYldoaXRlU3BhY2Uuc3RyaW5nMjAxNiArICddKycsICdnJyk7XG52YXIgcmVOb3JtYWxpemUyMDE4ID0gbmV3IFJ4KCdbJyArIGxpYldoaXRlU3BhY2Uuc3RyaW5nMjAxOCArICddKycsICdnJyk7XG52YXIgcmVwbGFjZSA9ICcnLnJlcGxhY2U7XG5cbnZhciAkbm9ybWFsaXplU3BhY2UyMDE2ID0gZnVuY3Rpb24gbm9ybWFsaXplU3BhY2UyMDE2KHN0cmluZykge1xuICByZXR1cm4gcmVwbGFjZS5jYWxsKHRyaW0yMDE2KHN0cmluZyksIHJlTm9ybWFsaXplMjAxNiwgJyAnKTtcbn07XG5cbnZhciAkbm9ybWFsaXplU3BhY2UyMDE4ID0gZnVuY3Rpb24gbm9ybWFsaXplU3BhY2UyMDE4KHN0cmluZykge1xuICByZXR1cm4gcmVwbGFjZS5jYWxsKHRyaW0yMDE4KHN0cmluZyksIHJlTm9ybWFsaXplMjAxOCwgJyAnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIG5vcm1hbGl6ZVNwYWNlMjAxOC5cbiAgICovXG4gIG5vcm1hbGl6ZVNwYWNlOiAkbm9ybWFsaXplU3BhY2UyMDE4LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzdHJpcHMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGUtc3BhY2UgZnJvbSBhIHN0cmluZyxcbiAgICogcmVwbGFjZXMgc2VxdWVuY2VzIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBieSBhIHNpbmdsZSBzcGFjZSxcbiAgICogYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBzdHJpbmcuIChFUzIwMTYpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGJlIG5vcm1hbGl6ZWQuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIG5vcm1hbGl6ZVNwYWNlID0gcmVxdWlyZSgnbm9ybWFsaXplLXNwYWNlLXgnKTtcbiAgICpcbiAgICogbm9ybWFsaXplU3BhY2UoJyBcXHRcXG5hIFxcdFxcbmIgXFx0XFxuJykgPT09ICdhIGInOyAvLyB0cnVlXG4gICAqL1xuICBub3JtYWxpemVTcGFjZTIwMTY6ICRub3JtYWxpemVTcGFjZTIwMTYsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHN0cmlwcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZS1zcGFjZSBmcm9tIGEgc3RyaW5nLFxuICAgKiByZXBsYWNlcyBzZXF1ZW5jZXMgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGJ5IGEgc2luZ2xlIHNwYWNlLFxuICAgKiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHN0cmluZy4gKEVTMjAxOClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gYmUgbm9ybWFsaXplZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgbm9ybWFsaXplU3BhY2UgPSByZXF1aXJlKCdub3JtYWxpemUtc3BhY2UteCcpO1xuICAgKlxuICAgKiBub3JtYWxpemVTcGFjZSgnIFxcdFxcbmEgXFx0XFxuYiBcXHRcXG4nKSA9PT0gJ2EgYic7IC8vIHRydWVcbiAgICovXG4gIG5vcm1hbGl6ZVNwYWNlMjAxODogJG5vcm1hbGl6ZVNwYWNlMjAxOFxufTtcbiIsIi8qKlxuICogQGZpbGUgVXNlZCB0byBjb3B5IHRoZSB2YWx1ZXMgb2YgYWxsIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyB0byBhIHRhcmdldCBvYmplY3QuXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgb2JqZWN0LWFzc2lnbi14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cy14Jyk7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uLXgnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdhcnJheS1yZWR1Y2UteCcpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCdnZXQtb3duLXByb3BlcnR5LW5hbWVzLXgnKTtcbnZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCdpcy1vYmplY3QtbGlrZS14Jyk7XG52YXIgbmF0aXZlQXNzaWduID0gaXNGdW5jdGlvbihPYmplY3QuYXNzaWduKSAmJiBPYmplY3QuYXNzaWduO1xuXG52YXIgd29ya2luZ05hdGl2ZUFzc2lnbiA9IGZ1bmN0aW9uIF9uYXRpdmVXb3JrcygpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgcmVzID0gYXR0ZW1wdChuYXRpdmVBc3NpZ24sIG9iaiwgeyAwOiAxIH0sIHsgMTogMiB9KTtcbiAgcmV0dXJuIHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSBvYmogJiYgb2JqZWN0S2V5cyhvYmopLmxlbmd0aCA9PT0gMiAmJiBvYmpbMF0gPT09IDEgJiYgb2JqWzFdID09PSAyO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxudmFyIGxhY2tzUHJvcGVyRW51bWVyYXRpb25PcmRlciA9IGZ1bmN0aW9uIF9lbnVtT3JkZXIoKSB7XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcbiAgdmFyIHRlc3QxID0gT2JqZWN0KCdhYmMnKTtcbiAgdGVzdDFbNV0gPSAnZGUnO1xuICBpZiAoZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHN0ck51bXMgPSAnMDEyMzQ1Njc4OSc7XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcbiAgdmFyIHRlc3QyID0gcmVkdWNlKHN0ck51bXMuc3BsaXQoJycpLCBmdW5jdGlvbiAoYWNjLCBpZ25vcmUsIGluZGV4KSB7XG4gICAgYWNjWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaW5kZXgpXSA9IGluZGV4O1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICB2YXIgb3JkZXIgPSByZWR1Y2UoZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MiksIGZ1bmN0aW9uIChhY2MsIG5hbWUpIHtcbiAgICByZXR1cm4gYWNjICsgdGVzdDJbbmFtZV07XG4gIH0sICcnKTtcblxuICBpZiAob3JkZXIgIT09IHN0ck51bXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcbiAgdmFyIGxldHRlcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICB2YXIgdGVzdDMgPSByZWR1Y2UobGV0dGVycy5zcGxpdCgnJyksIGZ1bmN0aW9uIChhY2MsIGxldHRlcikge1xuICAgIGFjY1tsZXR0ZXJdID0gbGV0dGVyO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChuYXRpdmVBc3NpZ24sIHt9LCB0ZXN0Myk7XG4gIHJldHVybiByZXN1bHQudGhyZXcgPT09IGZhbHNlICYmIG9iamVjdEtleXMocmVzdWx0LnZhbHVlKS5qb2luKCcnKSAhPT0gbGV0dGVycztcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbnZhciBhc3NpZ25IYXNQZW5kaW5nRXhjZXB0aW9ucyA9IGZ1bmN0aW9uIF9leGNlcHRpb25zKCkge1xuICBpZiAoaXNGdW5jdGlvbihPYmplY3QucHJldmVudEV4dGVuc2lvbnMpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggMzcgc3RpbGwgaGFzIFwicGVuZGluZyBleGNlcHRpb25cIiBsb2dpYyBpbiBpdHMgT2JqZWN0LmFzc2lnbiBpbXBsZW1lbnRhdGlvbixcbiAgLy8gd2hpY2ggaXMgNzIlIHNsb3dlciB0aGFuIG91ciBzaGltLCBhbmQgRmlyZWZveCA0MCdzIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zLCB7IDE6IDIgfSk7XG4gIGlmIChyZXN1bHQudGhyZXcgfHwgaXNPYmplY3RMaWtlKHJlc3VsdC52YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRocm93ZXIgPSByZXN1bHQudmFsdWU7XG4gIHJlc3VsdCA9IGF0dGVtcHQobmF0aXZlQXNzaWduLCB0aHJvd2VyLCAneHknKTtcbiAgcmV0dXJuIHJlc3VsdC50aHJldyA/IHRocm93ZXJbMV0gPT09ICd5JyA6IGZhbHNlO1xufTtcblxudmFyIHNob3VsZEltcGxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gIGlmIChuYXRpdmVBc3NpZ24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAod29ya2luZ05hdGl2ZUFzc2lnbigpID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGxhY2tzUHJvcGVyRW51bWVyYXRpb25PcmRlcigpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYXNzaWduSGFzUGVuZGluZ0V4Y2VwdGlvbnMoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSgpKTtcblxudmFyICRhc3NpZ247XG5pZiAoc2hvdWxkSW1wbGVtZW50KSB7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJ3RvLW9iamVjdC14Jyk7XG4gIHZhciBzbGljZSA9IHJlcXVpcmUoJ2FycmF5LXNsaWNlLXgnKTtcbiAgdmFyIGlzTmlsID0gcmVxdWlyZSgnaXMtbmlsLXgnKTtcbiAgdmFyIGdldE9FUFMgPSByZXF1aXJlKCdnZXQtb3duLWVudW1lcmFibGUtcHJvcGVydHktc3ltYm9scy14Jyk7XG4gIHZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG4gIC8vIDE5LjEuMy4xXG4gICRhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgcmV0dXJuIHJlZHVjZShzbGljZShhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiBfYXNzaWduU291cmNlcyh0Z3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzTmlsKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRndDtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iamVjdCA9IE9iamVjdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIHJlZHVjZShjb25jYXQuY2FsbChvYmplY3RLZXlzKG9iamVjdCksIGdldE9FUFMob2JqZWN0KSksIGZ1bmN0aW9uIF9hc3NpZ25Ubyh0YXIsIGtleSkge1xuICAgICAgICB0YXJba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gdGFyO1xuICAgICAgfSwgdGd0KTtcbiAgICB9LCB0b09iamVjdCh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gICRhc3NpZ24gPSBuYXRpdmVBc3NpZ247XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjb3B5IHRoZSB2YWx1ZXMgb2YgYWxsIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgdG8gYSB0YXJnZXQgb2JqZWN0LiBJdCB3aWxsIHJldHVybiB0aGUgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBbLi4uc291cmNlXSAtIFRoZSBzb3VyY2Ugb2JqZWN0KHMpLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGFyZ2V0IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbi14Jyk7XG4gKlxuICogdmFyIG9iaiA9IHsgYTogMSB9O1xuICogdmFyIGNvcHkgPSBhc3NpZ24oe30sIG9iaik7XG4gKiBjb25zb2xlLmxvZyhjb3B5KTsgLy8geyBhOiAxIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkYXNzaWduO1xuIiwiLyoqXG4gKiBAZmlsZSBSZWR1Y2UgYW4gYXJyYXkgKGZyb20gbGVmdCB0byByaWdodCkgdG8gYSBzaW5nbGUgdmFsdWUuXG4gKiBAdmVyc2lvbiAyLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgYXJyYXktcmVkdWNlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYWNoZWRDdHJzID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14Jyk7XG52YXIgQXJyYXlDdHIgPSBjYWNoZWRDdHJzLkFycmF5O1xudmFyIGNhc3RPYmplY3QgPSBjYWNoZWRDdHJzLk9iamVjdDtcbnZhciBuYXRpdmVSZWR1Y2UgPSB0eXBlb2YgQXJyYXlDdHIucHJvdG90eXBlLnJlZHVjZSA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheUN0ci5wcm90b3R5cGUucmVkdWNlO1xuXG4vLyBFUzUgMTUuNC40LjIxXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjFcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlXG52YXIgaXNXb3JraW5nO1xuaWYgKG5hdGl2ZVJlZHVjZSkge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICBpc1dvcmtpbmcgPSBhdHRlbXB0LmNhbGwoW10sIG5hdGl2ZVJlZHVjZSwgZnVuY3Rpb24gKGFjYykge1xuICAgIHJldHVybiBhY2M7XG4gIH0pLnRocmV3O1xuXG4gIHZhciByZXM7XG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoY2FzdE9iamVjdCgnYWJjJyksIG5hdGl2ZVJlZHVjZSwgZnVuY3Rpb24gKGFjYywgYykge1xuICAgICAgcmV0dXJuIGFjYyArIGM7XG4gICAgfSwgJ3gnKTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSAneGFiYyc7XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgcmVzID0gYXR0ZW1wdC5jYWxsKChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgIH0oMSwgMiwgMykpLCBuYXRpdmVSZWR1Y2UsIGZ1bmN0aW9uIChhY2MsIGFyZykge1xuICAgICAgcmV0dXJuIGFjYyArIGFyZztcbiAgICB9LCAxKTtcblxuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlID09PSA3O1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbCh7XG4gICAgICAwOiAxLFxuICAgICAgMTogMixcbiAgICAgIDM6IDMsXG4gICAgICA0OiA0LFxuICAgICAgbGVuZ3RoOiA0XG4gICAgfSwgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjLCBhcmcpIHtcbiAgICAgIHJldHVybiBhY2MgKyBhcmc7XG4gICAgfSwgMik7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gODtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudDtcbiAgICBpZiAoZG9jKSB7XG4gICAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICByZXMgPSBhdHRlbXB0LmNhbGwoZnJhZ21lbnQuY2hpbGROb2RlcywgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgICAgIGFjY1thY2MubGVuZ3RoXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBbXSk7XG5cbiAgICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlLmxlbmd0aCA9PT0gMSAmJiByZXMudmFsdWVbMF0gPT09IGRpdjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNXb3JraW5nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwoJ2FiJywgbmF0aXZlUmVkdWNlLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSk7XG5cbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHR5cGVvZiByZXMudmFsdWUgPT09ICdvYmplY3QnO1xuICB9XG59XG5cbnZhciAkcmVkdWNlO1xuaWYgKG5hdGl2ZVJlZHVjZSAmJiBpc1dvcmtpbmcpIHtcbiAgJHJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShhcnJheSwgY2FsbEJhY2sgLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICB2YXIgYXJncyA9IFtjYWxsQmFja107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBhcmdzWzFdID0gYXJndW1lbnRzWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVSZWR1Y2UuYXBwbHkoYXJyYXksIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gQ2hlY2sgZmFpbHVyZSBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMgKElFIDwgOSlcbiAgLy8gYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbiAgdmFyIHNwbGl0SWZCb3hlZEJ1ZyA9IHJlcXVpcmUoJ3NwbGl0LWlmLWJveGVkLWJ1Zy14Jyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJ3RvLWxlbmd0aC14JykudG9MZW5ndGgyMDE4O1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xuICB2YXIgYXNzZXJ0SXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1mdW5jdGlvbi14Jyk7XG5cbiAgJHJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShhcnJheSwgY2FsbEJhY2sgLyogLCBpbml0aWFsVmFsdWUqLykge1xuICAgIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxCYWNrKTtcbiAgICB2YXIgaXRlcmFibGUgPSBzcGxpdElmQm94ZWRCdWcob2JqZWN0KTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUgYW5kIGFuIGVtcHR5IGFycmF5XG4gICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBhcmdzTGVuZ3RoIDwgMykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChhcmdzTGVuZ3RoID4gMikge1xuICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpIGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmIChpID49IGxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAodHJ1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpIGluIGl0ZXJhYmxlKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxCYWNrKHJlc3VsdCwgaXRlcmFibGVbaV0sIGksIG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGFwcGxpZXMgYSBmdW5jdGlvbiBhZ2FpbnN0IGFuIGFjY3VtdWxhdG9yIGFuZCBlYWNoIGVsZW1lbnQgaW4gdGhlXG4gKiBhcnJheSAoZnJvbSBsZWZ0IHRvIHJpZ2h0KSB0byByZWR1Y2UgaXQgdG8gYSBzaW5nbGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbEJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIC0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3RcbiAqICBjYWxsIG9mIHRoZSBjYWxsYmFjay4gSWYgbm8gaW5pdGlhbCB2YWx1ZSBpcyBzdXBwbGllZCwgdGhlIGZpcnN0IGVsZW1lbnQgaW5cbiAqICB0aGUgYXJyYXkgd2lsbCBiZSB1c2VkLiBDYWxsaW5nIHJlZHVjZSBvbiBhbiBlbXB0eSBhcnJheSB3aXRob3V0IGFuIGluaXRpYWxcbiAqICB2YWx1ZSBpcyBhbiBlcnJvci5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJyYXkgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGNhbGxCYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBjYWxsZWQgb24gYW4gZW1wdHkgYXJyYXkgd2l0aG91dCBhbiBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciByZWR1Y2UgPSByZXF1aXJlKCdhcnJheS1yZWR1Y2UteCcpO1xuICpcbiAqIHZhciBzdW0gPSByZWR1Y2UoWzAsIDEsIDIsIDNdLCBmdW5jdGlvbiAoYSwgYikge1xuICogICByZXR1cm4gYSArIGI7XG4gKiB9LCAwKTtcbiAqIC8vIHN1bSBpcyA2XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJHJlZHVjZTtcbiIsIi8qKlxuICogQGZpbGUgQ3JlYXRlcyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyAoZW51bWVyYWJsZSBvciBub3QpIGZvdW5kIGRpcmVjdGx5IHVwb24gYSBnaXZlbiBvYmplY3QuXG4gKiBAdmVyc2lvbiAyLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIG5hdGl2ZUdPUE4gPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5cbnZhciBnZXRPUE47XG5pZiAobmF0aXZlR09QTikge1xuICB2YXIgYXR0ZW1wdCA9IHJlcXVpcmUoJ2F0dGVtcHQteCcpO1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5LXgnKTtcbiAgdmFyIGlzQ29ycmVjdFJlcyA9IGZ1bmN0aW9uIF9pc0NvcnJlY3RSZXMociwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHIudGhyZXcgPT09IGZhbHNlICYmIGlzQXJyYXkoci52YWx1ZSkgJiYgci52YWx1ZS5sZW5ndGggPT09IGxlbmd0aDtcbiAgfTtcblxuICB2YXIgZWl0aGVyID0gZnVuY3Rpb24gX2VpdGhlcihyLCBhLCBiKSB7XG4gICAgdmFyIHggPSByLnZhbHVlWzBdO1xuICAgIHZhciB5ID0gci52YWx1ZVsxXTtcbiAgICByZXR1cm4gKHggPT09IGEgJiYgeSA9PT0gYikgfHwgKHggPT09IGIgJiYgeSA9PT0gYSk7XG4gIH07XG5cbiAgdmFyIHJlcyA9IGF0dGVtcHQobmF0aXZlR09QTiwgJ2ZvJyk7XG4gIGlmIChpc0NvcnJlY3RSZXMocmVzLCAzKSAmJiBlaXRoZXIocmVzLCAnMCcsICcxJykgJiYgcmVzLnZhbHVlWzJdID09PSAnbGVuZ3RoJykge1xuICAgIGdldE9QTiA9IG5hdGl2ZUdPUE47XG4gIH0gZWxzZSB7XG4gICAgcmVzID0gYXR0ZW1wdChuYXRpdmVHT1BOLCB7IGE6IDEsIGI6IDIgfSk7XG4gICAgaWYgKGlzQ29ycmVjdFJlcyhyZXMsIDIpICYmIGVpdGhlcihyZXMsICdhJywgJ2InKSkge1xuICAgICAgdmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gICAgICB2YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJ2FycmF5LXNsaWNlLXgnKTtcbiAgICAgIHZhciB3aW4gPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3c7XG4gICAgICB2YXIgY2FjaGVkV2luZG93TmFtZXMgPSB3aW4gPyBuYXRpdmVHT1BOKHdpbikgOiBbXTtcblxuICAgICAgZ2V0T1BOID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICAgICAgdmFyIHZhbCA9IHRvT2JqZWN0KG9iaik7XG4gICAgICAgIC8vIElFIGJ1ZyB3aGVyZSBsYXlvdXQgZW5naW5lIGNhbGxzIHVzZXJsYW5kIGdPUE4gZm9yIGNyb3NzLWRvbWFpbiBgd2luZG93YCBvYmplY3RzXG4gICAgICAgIGlmICh3aW4gJiYgd2luICE9PSB3aW5kb3cgJiYgdG9TdHJpbmdUYWcodmFsKSA9PT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChuYXRpdmVHT1BOLCB2YWwpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQudGhyZXcgPyBhcnJheVNsaWNlKGNhY2hlZFdpbmRvd05hbWVzKSA6IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYXRpdmVHT1BOKHZhbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIGdldE9QTiAhPT0gJ2Z1bmN0aW9uJykge1xuICB2YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzLXgnKTtcbiAgZ2V0T1BOID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICByZXR1cm4gb2JqZWN0S2V5cyhvYmopO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgKGVudW1lcmFibGUgb3Igbm90KSBmb3VuZFxuICogZGlyZWN0bHkgdXBvbiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBvd25cbiAqICBwcm9wZXJ0aWVzIGFyZSB0byBiZSByZXR1cm5lZC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGFyZ2V0IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgcHJvcGVydGllcyBmb3VuZFxuICogIGRpcmVjdGx5IHVwb24gdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2V0T3duUHJvcGVydHlOYW1lID0gcmVxdWlyZSgnZ2V0LW93bi1wcm9wZXJ0eS1uYW1lLXgnKTtcbiAqXG4gKiBnZXRPd25Qcm9wZXJ0eU5hbWVzKCdmb28nKTsgLy8gW1wiMFwiLCBcIjFcIiwgXCIyXCIsIFwibGVuZ3RoXCJdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZ2V0T1BOO1xuIiwiLyoqXG4gKiBAZmlsZSBBbiBFUzYgT2JqZWN0LmtleXMgc2hpbS5cbiAqIEB2ZXJzaW9uIDIuNS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBvYmplY3Qta2V5cy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIG5hdGl2ZUtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXM7XG5cbnZhciBpc1dvcmtpbmc7XG52YXIgdGhyb3dzV2l0aE51bGw7XG52YXIgd29ya3NXaXRoUHJpbTtcbnZhciB3b3Jrc1dpdGhSZWdleDtcbnZhciB3b3Jrc1dpdGhBcmdzO1xudmFyIHdvcmtzV2l0aFN0cjtcbmlmIChuYXRpdmVLZXlzKSB7XG4gIHZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXkteCcpO1xuICB2YXIgaXNDb3JyZWN0UmVzID0gZnVuY3Rpb24gX2lzQ29ycmVjdFJlcyhyLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gci50aHJldyA9PT0gZmFsc2UgJiYgaXNBcnJheShyLnZhbHVlKSAmJiByLnZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoO1xuICB9O1xuXG4gIHZhciBlaXRoZXIgPSBmdW5jdGlvbiBfZWl0aGVyKHIsIGEsIGIpIHtcbiAgICB2YXIgeCA9IHIudmFsdWVbMF07XG4gICAgdmFyIHkgPSByLnZhbHVlWzFdO1xuICAgIHJldHVybiAoeCA9PT0gYSAmJiB5ID09PSBiKSB8fCAoeCA9PT0gYiAmJiB5ID09PSBhKTtcbiAgfTtcblxuICB2YXIgdGVzdE9iaiA9IHsgYTogMSwgYjogMiB9O1xuICB2YXIgcmVzID0gYXR0ZW1wdChuYXRpdmVLZXlzLCB0ZXN0T2JqKTtcbiAgaXNXb3JraW5nID0gaXNDb3JyZWN0UmVzKHJlcywgMikgJiYgZWl0aGVyKHJlcywgJ2EnLCAnYicpO1xuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB0ZXN0T2JqID0gT2JqZWN0KCdhJyk7XG4gICAgdGVzdE9iai55ID0gMTtcbiAgICByZXMgPSBhdHRlbXB0KG5hdGl2ZUtleXMsIHRlc3RPYmopO1xuICAgIGlzV29ya2luZyA9IGlzQ29ycmVjdFJlcyhyZXMsIDIpICYmIGVpdGhlcihyZXMsICcwJywgJ3knKTtcbiAgfVxuXG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICB0aHJvd3NXaXRoTnVsbCA9IGF0dGVtcHQobmF0aXZlS2V5cywgbnVsbCkudGhyZXc7XG4gICAgd29ya3NXaXRoUHJpbSA9IGlzQ29ycmVjdFJlcyhhdHRlbXB0KG5hdGl2ZUtleXMsIDQyKSwgMCk7XG4gICAgd29ya3NXaXRoUmVnZXggPSBhdHRlbXB0KG5hdGl2ZUtleXMsIC9hL2cpLnRocmV3ID09PSBmYWxzZTtcblxuICAgIHJlcyA9IGF0dGVtcHQobmF0aXZlS2V5cywgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHM7XG4gICAgfSgxLCAyKSkpO1xuXG4gICAgd29ya3NXaXRoQXJncyA9IGlzQ29ycmVjdFJlcyhyZXMsIDIpICYmIGVpdGhlcihyZXMsICcwJywgJzEnKTtcblxuICAgIHJlcyA9IGF0dGVtcHQobmF0aXZlS2V5cywgT2JqZWN0KCdhYicpKTtcbiAgICB3b3Jrc1dpdGhTdHIgPSBpc0NvcnJlY3RSZXMocmVzLCAyKSAmJiBlaXRoZXIocmVzLCAnMCcsICcxJyk7XG4gIH1cbn1cblxudmFyIG9iamVjdEtleXM7XG5pZiAoaXNXb3JraW5nKSB7XG4gIGlmICh0aHJvd3NXaXRoTnVsbCAmJiB3b3Jrc1dpdGhQcmltICYmIHdvcmtzV2l0aFJlZ2V4ICYmIHdvcmtzV2l0aEFyZ3MgJiYgd29ya3NXaXRoU3RyKSB7XG4gICAgb2JqZWN0S2V5cyA9IG5hdGl2ZUtleXM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlzQXJndW1lbnRzID0gd29ya3NXaXRoQXJncyAhPT0gdHJ1ZSAmJiByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbiAgICB2YXIgYXJyYXlTbGljZSA9IGlzQXJndW1lbnRzICYmIHJlcXVpcmUoJ2FycmF5LWxpa2Utc2xpY2UteCcpO1xuICAgIHZhciBzcGxpdElmQm94ZWQgPSB3b3Jrc1dpdGhTdHIgIT09IHRydWUgJiYgcmVxdWlyZSgnc3BsaXQtaWYtYm94ZWQtYnVnLXgnKTtcbiAgICB2YXIgaXNTdHJpbmcgPSBzcGxpdElmQm94ZWQgJiYgcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG4gICAgdmFyIGlzUmVnZXhwID0gd29ya3NXaXRoUmVnZXggIT09IHRydWUgJiYgcmVxdWlyZSgnaXMtcmVnZXhwLXgnKTtcbiAgICB2YXIgaGFzID0gaXNSZWdleHAgJiYgcmVxdWlyZSgnaGFzLW93bi1wcm9wZXJ0eS14Jyk7XG5cbiAgICBvYmplY3RLZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHZhciBvYmogPSB0b09iamVjdCA/IHRvT2JqZWN0KG9iamVjdCkgOiBvYmplY3Q7XG4gICAgICBpZiAoaXNBcmd1bWVudHMgJiYgaXNBcmd1bWVudHMob2JqKSkge1xuICAgICAgICBvYmogPSBhcnJheVNsaWNlKG9iaik7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nICYmIGlzU3RyaW5nKG9iaikpIHtcbiAgICAgICAgb2JqID0gc3BsaXRJZkJveGVkKG9iaik7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVnZXhwICYmIGlzUmVnZXhwKG9iaikpIHtcbiAgICAgICAgdmFyIHJlZ2V4S2V5cyA9IFtdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoaGFzKG9iaiwgaykpIHtcbiAgICAgICAgICAgIHJlZ2V4S2V5c1tyZWdleEtleXMubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4S2V5cztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICB2YXIgb2JqS2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG4gIG9iamVjdEtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgIHJldHVybiBvYmpLZXlzKHRvT2JqZWN0KG9iamVjdCkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2YgYSBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhhdCBwcm92aWRlZCBieSBhIGZvci4uLmluIGxvb3AgKHRoZSBkaWZmZXJlbmNlIGJlaW5nXG4gKiB0aGF0IGEgZm9yLWluIGxvb3AgZW51bWVyYXRlcyBwcm9wZXJ0aWVzIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gYXMgd2VsbCkuXG4gKlxuICogQHBhcmFtIHsqfSBvYmogVGhlIG9iamVjdCBvZiB3aGljaCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBhcmUgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHJlcHJlc2VudCBhbGwgdGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMteCcpO1xuICpcbiAqIHZhciBvYmogPSB7XG4gKiAgIGFycjogW10sXG4gKiAgIGJvb2w6IHRydWUsXG4gKiAgICdudWxsJzogbnVsbCxcbiAqICAgbnVtOiA0MixcbiAqICAgb2JqOiB7IH0sXG4gKiAgIHN0cjogJ2JveicsXG4gKiAgIHVuZGVmaW5lZDogdm9pZCAwXG4gKiB9O1xuICpcbiAqIG9iamVjdEtleXMob2JqKTsgLy8gWydhcnInLCAnYm9vbCcsICdudWxsJywgJ251bScsICdvYmonLCAnc3RyJywgJ3VuZGVmaW5lZCddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0S2V5cztcbiIsIi8qKlxuICogQGZpbGUgU2hhbSBmb3IgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAqIEB2ZXJzaW9uIDIuMC40XG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBvYmplY3QtZGVmaW5lLXByb3BlcnRpZXMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdhcnJheS1mb3ItZWFjaC14Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cy14Jyk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS14Jyk7XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2s7XG5cbi8vIEVTNSAxNS4yLjMuNlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjZcblxuLy8gUGF0Y2ggZm9yIFdlYktpdCBhbmQgSUU4IHN0YW5kYXJkIG1vZGVcbi8vIERlc2lnbmVkIGJ5IGhheCA8aGF4LmdpdGh1Yi5jb20+XG4vLyByZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzI2lzc3VlLzVcbi8vIElFOCBSZWZlcmVuY2U6XG4vLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjgyOTAwLmFzcHhcbi8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyMjk5MTYuYXNweFxuLy8gV2ViS2l0IEJ1Z3M6XG4vLyAgICAgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTM2NDIzXG5cbnZhciBkb2VzRGVmaW5lUHJvcGVydHlXb3JrID0gZnVuY3Rpb24gX2RvZXNEZWZpbmVQcm9wZXJ0eVdvcmsob2JqZWN0KSB7XG4gIHRyeSB7XG4gICAgJGRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3NlbnRpbmVsJywge30pO1xuICAgIHJldHVybiAnc2VudGluZWwnIGluIG9iamVjdDtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBjaGVjayB3aGV0aGVyIGRlZmluZVByb3BlcnR5IHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSxcbi8vIHNoaW0gcGFydGlhbGx5LlxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaWQtbGVuZ3RoXG4gIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgPSBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKHt9KTtcbiAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbkRvbSA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZG9lc0RlZmluZVByb3BlcnR5V29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gIGlmIChkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgPT09IGZhbHNlIHx8IGRlZmluZVByb3BlcnR5V29ya3NPbkRvbSA9PT0gZmFsc2UpIHtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2sgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbiAgfVxufVxuXG4vLyBFUzUgMTUuMi4zLjdcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy43XG5pZiAoQm9vbGVhbigkZGVmaW5lUHJvcGVydGllcykgPT09IGZhbHNlIHx8IGRlZmluZVByb3BlcnRpZXNGYWxsYmFjaykge1xuICAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZGVmaW5lUHJvcGVydGllc1xuICAgIGlmIChkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2spIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydGllcyk7XG4gICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3JFYWNoKCRrZXlzKHByb3BlcnRpZXMpLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSAhPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgJGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHByb3BlcnRpZXNbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlZmluZXMgbmV3IG9yIG1vZGlmaWVzIGV4aXN0aW5nIHByb3BlcnRpZXMgZGlyZWN0bHkgb24gYW5cbiAqIG9iamVjdCwgcmV0dXJuaW5nIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIG9yIG1vZGlmeSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBBbiBvYmplY3Qgd2hvc2Ugb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICogIGNvbnN0aXR1dGUgZGVzY3JpcHRvcnMgZm9yIHRoZVxuICogcHJvcGVydGllcyB0byBiZSBkZWZpbmVkIG9yIG1vZGlmaWVkLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLXgnKTtcbiAqXG4gKiB2YXIgb2JqID0ge307XG4gKiBkZWZpbmVQcm9wZXJ0aWVzKG9iaiwge1xuICogICAncHJvcGVydHkxJzoge1xuICogICAgIHZhbHVlOiB0cnVlLFxuICogICAgIHdyaXRhYmxlOiB0cnVlXG4gKiAgIH0sXG4gKiAgICdwcm9wZXJ0eTInOiB7XG4gKiAgICAgdmFsdWU6ICdIZWxsbycsXG4gKiAgICAgd3JpdGFibGU6IHRydWVcbiAqICAgfVxuICogICAvLyBldGMuIGV0Yy5cbiAqIH0pO1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuIiwiLyoqXG4gKiBAZmlsZSBTaGFtIGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAqIEB2ZXJzaW9uIDIuMS4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBvYmplY3QtZGVmaW5lLXByb3BlcnR5LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xudmFyIG93bnMgPSByZXF1aXJlKCdoYXMtb3duLXByb3BlcnR5LXgnKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBwcm90b3R5cGVPZk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgZGVmaW5lUHJvcGVydHlGYWxsYmFjaztcbi8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxudmFyIGRlZmluZUdldHRlcjtcbnZhciBkZWZpbmVTZXR0ZXI7XG52YXIgbG9va3VwR2V0dGVyO1xudmFyIGxvb2t1cFNldHRlcjtcbnZhciBzdXBwb3J0c0FjY2Vzc29ycyA9IG93bnMocHJvdG90eXBlT2ZPYmplY3QsICdfX2RlZmluZUdldHRlcl9fJyk7XG5pZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuICBkZWZpbmVHZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fO1xuICBkZWZpbmVTZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZVNldHRlcl9fO1xuICBsb29rdXBHZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fO1xuICBsb29rdXBTZXR0ZXIgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cbn1cblxuLy8gRVM1IDE1LjIuMy42XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuNlxuXG4vLyBQYXRjaCBmb3IgV2ViS2l0IGFuZCBJRTggc3RhbmRhcmQgbW9kZVxuLy8gRGVzaWduZWQgYnkgaGF4IDxoYXguZ2l0aHViLmNvbT5cbi8vIHJlbGF0ZWQgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMjaXNzdWUvNVxuLy8gSUU4IFJlZmVyZW5jZTpcbi8vICAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZGQyODI5MDAuYXNweFxuLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDIyOTkxNi5hc3B4XG4vLyBXZWJLaXQgQnVnczpcbi8vICAgICBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY0MjNcblxudmFyIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsgPSBmdW5jdGlvbiBfZG9lc0RlZmluZVByb3BlcnR5V29yayhvYmplY3QpIHtcbiAgdHJ5IHtcbiAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2VudGluZWwnLCB7fSk7XG4gICAgcmV0dXJuICdzZW50aW5lbCcgaW4gb2JqZWN0O1xuICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIGNoZWNrIHdoZXRoZXIgZGVmaW5lUHJvcGVydHkgd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLFxuLy8gc2hpbSBwYXJ0aWFsbHkuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbiAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCA9IGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoe30pO1xuICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgaWYgKGRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCA9PT0gZmFsc2UgfHwgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID09PSBmYWxzZSkge1xuICAgIGRlZmluZVByb3BlcnR5RmFsbGJhY2sgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIH1cbn1cblxuaWYgKEJvb2xlYW4oJGRlZmluZVByb3BlcnR5KSA9PT0gZmFsc2UgfHwgZGVmaW5lUHJvcGVydHlGYWxsYmFjaykge1xuICB2YXIgRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiA9ICdQcm9wZXJ0eSBkZXNjcmlwdGlvbiBtdXN0IGJlIGFuIG9iamVjdDogJztcbiAgdmFyIEVSUl9OT05fT0JKRUNUX1RBUkdFVCA9ICdPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3Q6ICc7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbiAgdmFyIEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCA9ICdnZXR0ZXJzICYgc2V0dGVycyBjYW4gbm90IGJlIGRlZmluZWQgb24gdGhpcyBqYXZhc2NyaXB0IGVuZ2luZSc7XG5cbiAgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUX1RBUkdFVCArIG9iamVjdCk7XG4gICAgfVxuICAgIGlmIChpc1ByaW1pdGl2ZShkZXNjcmlwdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9ERVNDUklQVE9SICsgZGVzY3JpcHRvcik7XG4gICAgfVxuICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnR5XG4gICAgLy8gZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgIGlmIChkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHlGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBpdCdzIGEgZGF0YSBwcm9wZXJ0eS5cbiAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICAvLyBmYWlsIHNpbGVudGx5IGlmICd3cml0YWJsZScsICdlbnVtZXJhYmxlJywgb3IgJ2NvbmZpZ3VyYWJsZSdcbiAgICAgIC8vIGFyZSByZXF1ZXN0ZWQgYnV0IG5vdCBzdXBwb3J0ZWRcbiAgICAgIC8qXG4gICAgICAvLyBhbHRlcm5hdGUgYXBwcm9hY2g6XG4gICAgICBpZiAoIC8vIGNhbid0IGltcGxlbWVudCB0aGVzZSBmZWF0dXJlczsgYWxsb3cgZmFsc2UgYnV0IG5vdCB0cnVlXG4gICAgICAgICAgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci53cml0YWJsZSkgfHxcbiAgICAgICAgICAoJ2VudW1lcmFibGUnIGluIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkgfHxcbiAgICAgICAgICAoJ2NvbmZpZ3VyYWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpXG4gICAgICApKVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgJ1RoaXMgaW1wbGVtZW50YXRpb24gb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5IGRvZXMgbm90IHN1cHBvcnQgY29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBvciB3cml0YWJsZS4nXG4gICAgICAgICAgKTtcbiAgICAgICovXG5cbiAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycyAmJiAobG9va3VwR2V0dGVyLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgfHwgbG9va3VwU2V0dGVyLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpKSB7XG4gICAgICAgIC8vIEFzIGFjY2Vzc29ycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gZW5naW5lcyBpbXBsZW1lbnRpbmdcbiAgICAgICAgLy8gYF9fcHJvdG9fX2Agd2UgY2FuIHNhZmVseSBvdmVycmlkZSBgX19wcm90b19fYCB3aGlsZSBkZWZpbmluZ1xuICAgICAgICAvLyBhIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGhpdCBhbiBpbmhlcml0ZWRcbiAgICAgICAgLy8gYWNjZXNzb3IuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgIHZhciBwcm90b3R5cGUgPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgIC8vIERlbGV0aW5nIGEgcHJvcGVydHkgYW55d2F5IHNpbmNlIGdldHRlciAvIHNldHRlciBtYXkgYmVcbiAgICAgICAgLy8gZGVmaW5lZCBvbiBvYmplY3QgaXRzZWxmLlxuICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIC8vIFNldHRpbmcgb3JpZ2luYWwgYF9fcHJvdG9fX2AgYmFjayBub3cuXG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGFzR2V0dGVyID0gJ2dldCcgaW4gZGVzY3JpcHRvcjtcbiAgICAgIHZhciBoYXNTZXR0ZXIgPSAnc2V0JyBpbiBkZXNjcmlwdG9yO1xuICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzID09PSBmYWxzZSAmJiAoaGFzR2V0dGVyIHx8IGhhc1NldHRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZ290IHRoYXQgZmFyIHRoZW4gZ2V0dGVycyBhbmQgc2V0dGVycyBjYW4gYmUgZGVmaW5lZCAhIVxuICAgICAgaWYgKGhhc0dldHRlcikge1xuICAgICAgICBkZWZpbmVHZXR0ZXIuY2FsbChvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yLmdldCk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzU2V0dGVyKSB7XG4gICAgICAgIGRlZmluZVNldHRlci5jYWxsKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZWZpbmVzIGEgbmV3IHByb3BlcnR5IGRpcmVjdGx5IG9uIGFuIG9iamVjdCwgb3IgbW9kaWZpZXMgYW4gZXhpc3RpbmcgcHJvcGVydHkgb24gYW4gb2JqZWN0LFxuICogYW5kIHJldHVybnMgdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0byBkZWZpbmUgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIGRlZmluZWQgb3IgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciAtIFRoZSBkZXNjcmlwdG9yIGZvciB0aGUgcHJvcGVydHkgYmVpbmcgZGVmaW5lZCBvciBtb2RpZmllZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCdvYmplY3QtZGVmaW5lLXByb3BlcnR5LXgnKTtcbiAqXG4gKiB2YXIgbyA9IHt9OyAvLyBDcmVhdGVzIGEgbmV3IG9iamVjdFxuICpcbiAqIGRlZmluZVByb3BlcnR5KG8sICdhJywge1xuICogICB2YWx1ZTogMzcsXG4gKiAgIHdyaXRhYmxlOiB0cnVlXG4gKiB9KTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAkZGVmaW5lUHJvcGVydHk7XG4iLCIvKipcbiAqIEBmaWxlIFNoYW0gZm9yIEVTNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gKiBAdmVyc2lvbiAzLjIuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCd0by1wcm9wZXJ0eS1rZXkteCcpO1xudmFyIGlzRmFsc2V5ID0gcmVxdWlyZSgnaXMtZmFsc2V5LXgnKTtcbnZhciBhdHRlbXB0ID0gcmVxdWlyZSgnYXR0ZW1wdC14Jyk7XG5cbnZhciBuYXRpdmVHT1BEID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRPUERGYWxsYmFjazE7XG52YXIgZ2V0T1BERmFsbGJhY2syO1xuXG4vLyBFUzUgMTUuMi4zLjNcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4zXG5cbnZhciBkb2VzR09QRFdvcmsgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wKSB7XG4gIG9iamVjdFt0b1Byb3BlcnR5S2V5KHByb3ApXSA9IDA7XG4gIHZhciB0ZXN0UmVzdWx0ID0gYXR0ZW1wdChuYXRpdmVHT1BELCBvYmplY3QsIHByb3ApO1xuICByZXR1cm4gdGVzdFJlc3VsdC50aHJldyA9PT0gZmFsc2UgJiYgdGVzdFJlc3VsdC52YWx1ZS52YWx1ZSA9PT0gMDtcbn07XG5cbi8vIGNoZWNrIHdoZXRoZXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSwgc2hpbSBwYXJ0aWFsbHkuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmIChuYXRpdmVHT1BEKSB7XG4gIHZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50O1xuICB2YXIgZ2V0T1BEV29ya3NPbkRvbSA9IGRvYyA/IGRvZXNHT1BEV29yayhkb2MuY3JlYXRlRWxlbWVudCgnZGl2JyksICdzZW50aW5lbCcpIDogdHJ1ZTtcbiAgaWYgKGdldE9QRFdvcmtzT25Eb20pIHtcbiAgICB2YXIgcmVzID0gYXR0ZW1wdChuYXRpdmVHT1BELCBPYmplY3QoJ2FiYycpLCAxKTtcbiAgICB2YXIgd29ya3NXaXRoU3RyID0gcmVzLnRocmV3ID09PSBmYWxzZSAmJiByZXMudmFsdWUgJiYgcmVzLnZhbHVlLnZhbHVlID09PSAnYic7XG4gICAgaWYgKHdvcmtzV2l0aFN0cikge1xuICAgICAgdmFyIGdldE9QRFdvcmtzT25PYmplY3QgPSBkb2VzR09QRFdvcmsoe30sICdzZW50aW5lbCcpO1xuICAgICAgaWYgKGdldE9QRFdvcmtzT25PYmplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtzV2l0aFByaW0gPSBhdHRlbXB0KG5hdGl2ZUdPUEQsIDQyLCAnbmFtZScpLnRocmV3ID09PSBmYWxzZTtcbiAgICAgICAgdmFyIHdvcmtzV2l0aE9ialN5bSA9IHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14JykgJiYgZG9lc0dPUERXb3JrKHt9LCBPYmplY3QoU3ltYm9sKCcnKSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgIGlmICh3b3Jrc1dpdGhPYmpTeW0pIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgaWYgKHdvcmtzV2l0aFByaW0pIHtcbiAgICAgICAgICAgICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBuYXRpdmVHT1BEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUdPUEQodG9PYmplY3Qob2JqZWN0KSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod29ya3NXaXRoUHJpbSkge1xuICAgICAgICAgICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUdPUEQob2JqZWN0LCB0b1Byb3BlcnR5S2V5KHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVHT1BEKHRvT2JqZWN0KG9iamVjdCksIHRvUHJvcGVydHlLZXkocHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRPUERGYWxsYmFjazEgPSBuYXRpdmVHT1BEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnZXRPUERGYWxsYmFjazIgPSBuYXRpdmVHT1BEO1xuICAgIH1cbiAgfVxufVxuXG5pZiAoaXNGYWxzZXkoJGdldE93blByb3BlcnR5RGVzY3JpcHRvcikgfHwgZ2V0T1BERmFsbGJhY2sxIHx8IGdldE9QREZhbGxiYWNrMikge1xuICB2YXIgb3ducyA9IHJlcXVpcmUoJ2hhcy1vd24tcHJvcGVydHkteCcpO1xuICB2YXIgaXNQcmltaXRpdmUgPSByZXF1aXJlKCdpcy1wcmltaXRpdmUnKTtcbiAgdmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnaXMtc3RyaW5nJyk7XG4gIHZhciBpc0luZGV4ID0gcmVxdWlyZSgnaXMtaW5kZXgteCcpO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSByZXF1aXJlKCdwcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLXgnKTtcbiAgdmFyIHByb3RvdHlwZU9mT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvLyBJZiBKUyBlbmdpbmUgc3VwcG9ydHMgYWNjZXNzb3JzIGNyZWF0aW5nIHNob3J0Y3V0cy5cbiAgdmFyIGxvb2t1cEdldHRlcjtcbiAgdmFyIGxvb2t1cFNldHRlcjtcbiAgdmFyIHN1cHBvcnRzQWNjZXNzb3JzID0gb3ducyhwcm90b3R5cGVPZk9iamVjdCwgJ19fZGVmaW5lR2V0dGVyX18nKTtcbiAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgdmFyIGxnID0gcHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBHZXR0ZXJfXztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICB2YXIgbHMgPSBwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fO1xuICAgIGxvb2t1cEdldHRlciA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gbGcuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgICB9O1xuXG4gICAgbG9va3VwU2V0dGVyID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBscy5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgIH07XG4gIH1cblxuICAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB2YXIgb2JqID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgcHJvcEtleSA9IHRvUHJvcGVydHlLZXkocHJvcGVydHkpO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgIGlmIChnZXRPUERGYWxsYmFjazEpIHtcbiAgICAgIHJlc3VsdCA9IGF0dGVtcHQuY2FsbChPYmplY3QsIGdldE9QREZhbGxiYWNrMSwgb2JqLCBwcm9wS2V5KTtcbiAgICAgIGlmIChyZXN1bHQudGhyZXcgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgIH1cblxuICAgIHZhciBpc1N0cmluZ0luZGV4ID0gaXNTdHJpbmcob2JqKSAmJiBpc0luZGV4KHByb3BLZXksIG9iai5sZW5ndGgpO1xuICAgIGlmIChnZXRPUERGYWxsYmFjazIgJiYgaXNTdHJpbmdJbmRleCA9PT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdCA9IGF0dGVtcHQuY2FsbChPYmplY3QsIGdldE9QREZhbGxiYWNrMiwgb2JqLCBwcm9wS2V5KTtcbiAgICAgIGlmIChyZXN1bHQudGhyZXcgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgIH1cblxuICAgIHZhciBkZXNjcmlwdG9yO1xuICAgIC8vIElmIG9iamVjdCBkb2VzIG5vdCBvd25zIHByb3BlcnR5IHJldHVybiB1bmRlZmluZWQgaW1tZWRpYXRlbHkuXG4gICAgaWYgKGlzU3RyaW5nSW5kZXggPT09IGZhbHNlICYmIG93bnMob2JqLCBwcm9wS2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSB0aGVuIGl0J3MgZm9yIHN1cmUgYGNvbmZpZ3VyYWJsZWAsIGFuZFxuICAgIC8vIHByb2JhYmx5IGBlbnVtZXJhYmxlYC4gRGV0ZWN0IGVudW1lcmFiaWxpdHkgdGhvdWdoLlxuICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICBjb25maWd1cmFibGU6IGlzUHJpbWl0aXZlKG9iamVjdCkgPT09IGZhbHNlICYmIGlzU3RyaW5nSW5kZXggPT09IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogcHJvcGVydHlJc0VudW1lcmFibGUob2JqLCBwcm9wS2V5KVxuICAgIH07XG5cbiAgICAvLyBJZiBKUyBlbmdpbmUgc3VwcG9ydHMgYWNjZXNzb3IgcHJvcGVydGllcyB0aGVuIHByb3BlcnR5IG1heSBiZSBhXG4gICAgLy8gZ2V0dGVyIG9yIHNldHRlci5cbiAgICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAgIC8vIFVuZm9ydHVuYXRlbHkgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGEgZ2V0dGVyIGV2ZW5cbiAgICAgIC8vIGlmIG9iamVjdCBoYXMgb3duIG5vbiBnZXR0ZXIgcHJvcGVydHkgYWxvbmcgd2l0aCBhIHNhbWUgbmFtZWRcbiAgICAgIC8vIGluaGVyaXRlZCBnZXR0ZXIuIFRvIGF2b2lkIG1pc2JlaGF2aW9yIHdlIHRlbXBvcmFyeSByZW1vdmVcbiAgICAgIC8vIGBfX3Byb3RvX19gIHNvIHRoYXQgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGdldHRlciBvbmx5XG4gICAgICAvLyBpZiBpdCdzIG93bmVkIGJ5IGFuIG9iamVjdC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b1xuICAgICAgdmFyIHByb3RvdHlwZSA9IG9iai5fX3Byb3RvX187XG4gICAgICB2YXIgbm90UHJvdG90eXBlT2ZPYmplY3QgPSBvYmogIT09IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgLy8gYXZvaWQgcmVjdXJzaW9uIHByb2JsZW0sIGJyZWFraW5nIGluIE9wZXJhIE1pbmkgd2hlblxuICAgICAgLy8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnKVxuICAgICAgLy8gb3IgYW55IG90aGVyIE9iamVjdC5wcm90b3R5cGUgYWNjZXNzb3JcbiAgICAgIGlmIChub3RQcm90b3R5cGVPZk9iamVjdCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG9cbiAgICAgICAgb2JqLl9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZ2V0dGVyID0gbG9va3VwR2V0dGVyKG9iaiwgcHJvcEtleSk7XG4gICAgICB2YXIgc2V0dGVyID0gbG9va3VwU2V0dGVyKG9iaiwgcHJvcEtleSk7XG5cbiAgICAgIGlmIChub3RQcm90b3R5cGVPZk9iamVjdCkge1xuICAgICAgICAvLyBPbmNlIHdlIGhhdmUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2UgY2FuIHB1dCB2YWx1ZXMgYmFjay5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgIG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXR0ZXIgfHwgc2V0dGVyKSB7XG4gICAgICAgIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IHNldHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IHdhcyBhY2Nlc3NvciBwcm9wZXJ0eSB3ZSdyZSBkb25lIGFuZCByZXR1cm4gaGVyZVxuICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBhZGRpbmcgYHZhbHVlYCB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHdlIGtub3cgdGhhdCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB0aGF0IGlzXG4gICAgLy8gbm90IGFuIGFjY2Vzc29yIHNvIHdlIHNldCBpdCBhcyBhIHZhbHVlIGFuZCByZXR1cm4gZGVzY3JpcHRvci5cbiAgICBpZiAoaXNTdHJpbmdJbmRleCkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG9iai5jaGFyQXQocHJvcEtleSk7XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBvYmpbcHJvcEtleV07XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgYW4gb3duIHByb3BlcnR5ICh0aGF0IGlzLFxuICogb25lIGRpcmVjdGx5IHByZXNlbnQgb24gYW4gb2JqZWN0IGFuZCBub3QgaW4gdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbilcbiAqIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gVGhlIG9iamVjdCBpbiB3aGljaCB0byBsb29rIGZvciB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0geyp9IHByb3BlcnR5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIGRlc2NyaXB0aW9uIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcHJvcGVydHkgZGVzY3JpcHRvciBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaWYgaXQgZXhpc3RzIG9uIHRoZSBvYmplY3QsIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICogdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJ29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IteCcpO1xuICogdmFyIG9iaiA9IHsgYmFyOiA0MiB9O1xuICogdmFyIGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgJ2JhcicpO1xuICogLy8gZCBpcyB7XG4gKiAvLyAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAqIC8vICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAqIC8vICAgdmFsdWU6IDQyLFxuICogLy8gICB3cml0YWJsZTogdHJ1ZVxuICogLy8gfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4iLCIvKipcbiAqIEBmaWxlIEFuIEVTNiBPYmplY3Qua2V5cyBzaGltLlxuICogQHZlcnNpb24gMS4zLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIG9iamVjdC1rZXlzLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblxudHJ5IHtcbiAgdmFyIGFyciA9IG9yaWdpbmFsS2V5cyh7IGE6IDEsIGI6IDIgfSk7XG4gIGlmIChhcnIubGVuZ3RoICE9PSAyIHx8IGFyclswXSAhPT0gJ2EnIHx8IGFyclsxXSAhPT0gJ2InKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQga2V5cycpO1xuICB9XG59IGNhdGNoIChpZ25vcmUpIHtcbiAgb3JpZ2luYWxLZXlzID0gcmVxdWlyZSgnb2JqZWN0LWtleXMnKTtcbn1cblxudmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBTYWZhcmkgNS4wIGJ1Z1xuICByZXR1cm4gb3JpZ2luYWxLZXlzKGFyZ3VtZW50cykubGVuZ3RoID09PSAyO1xufSgxLCAyKSk7XG5cbnZhciBrZXlzSGFzQXJndW1lbnRzTGVuZ3RoQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ0tleXMgPSBvcmlnaW5hbEtleXMoYXJndW1lbnRzKTtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5c1swXSAhPT0gMTtcbn0oMSkpO1xuXG52YXIgb2JqZWN0S2V5cztcbmlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cyB8fCBrZXlzSGFzQXJndW1lbnRzTGVuZ3RoQnVnKSB7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICBvYmplY3RLZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICB2YXIgb2JqID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICBpZiAoaXNBcmd1bWVudHMob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhhcnJheVNsaWNlLmNhbGwob2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhvYmopO1xuICB9O1xufSBlbHNlIHtcbiAgb2JqZWN0S2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsS2V5cyh0b09iamVjdChvYmplY3QpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGFycmF5IG9mIGEgZ2l2ZW4gb2JqZWN0J3Mgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyxcbiAqIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoYXQgcHJvdmlkZWQgYnkgYSBmb3IuLi5pbiBsb29wICh0aGUgZGlmZmVyZW5jZSBiZWluZ1xuICogdGhhdCBhIGZvci1pbiBsb29wIGVudW1lcmF0ZXMgcHJvcGVydGllcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFzIHdlbGwpLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIFRoZSBvYmplY3Qgb2Ygd2hpY2ggdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgYXJlIHRvIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnQgYWxsIHRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzLXgnKTtcbiAqXG4gKiB2YXIgb2JqID0ge1xuICogICBhcnI6IFtdLFxuICogICBib29sOiB0cnVlLFxuICogICAnbnVsbCc6IG51bGwsXG4gKiAgIG51bTogNDIsXG4gKiAgIG9iajogeyB9LFxuICogICBzdHI6ICdib3onLFxuICogICB1bmRlZmluZWQ6IHZvaWQgMFxuICogfTtcbiAqXG4gKiBvYmplY3RLZXlzKG9iaik7IC8vIFsnYXJyJywgJ2Jvb2wnLCAnbnVsbCcsICdudW0nLCAnb2JqJywgJ3N0cicsICd1bmRlZmluZWQnXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdEtleXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbnZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xudmFyIGRvbnRFbnVtcyA9IFtcblx0J3RvU3RyaW5nJyxcblx0J3RvTG9jYWxlU3RyaW5nJyxcblx0J3ZhbHVlT2YnLFxuXHQnaGFzT3duUHJvcGVydHknLFxuXHQnaXNQcm90b3R5cGVPZicsXG5cdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdCdjb25zdHJ1Y3Rvcidcbl07XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xufTtcbnZhciBleGNsdWRlZEtleXMgPSB7XG5cdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHQkY29uc29sZTogdHJ1ZSxcblx0JGV4dGVybmFsOiB0cnVlLFxuXHQkZnJhbWU6IHRydWUsXG5cdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdCRmcmFtZXM6IHRydWUsXG5cdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0JGlubmVyV2lkdGg6IHRydWUsXG5cdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0JG91dGVyV2lkdGg6IHRydWUsXG5cdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHQkcGFyZW50OiB0cnVlLFxuXHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0JHNjcm9sbFg6IHRydWUsXG5cdCRzY3JvbGxZOiB0cnVlLFxuXHQkc2VsZjogdHJ1ZSxcblx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHQkd2luZG93OiB0cnVlXG59O1xudmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59KCkpO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHR9XG5cblx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGVLZXlzO1xufTtcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0cmV0dXJuIChPYmplY3Qua2V5cyhhcmd1bWVudHMpIHx8ICcnKS5sZW5ndGggPT09IDI7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIDxodHRwczovL2xhY2tlLm1uL3JlZHVjZS15b3VyLWJ1bmRsZS1qcy1maWxlLXNpemUvPlxuLy8gLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvYmFiZWwtcGx1Z2luLWxvZGFzaC9pc3N1ZXMvMjIxPlxudmFyIGlzRXJyb3IgPSByZXF1aXJlKCdsb2Rhc2gvaXNFcnJvcicpO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5Jyk7XG5cbnZhciBpc0VtcHR5ID0gcmVxdWlyZSgnbG9kYXNoL2lzRW1wdHknKTtcblxudmFyIHBpY2sgPSByZXF1aXJlKCdsb2Rhc2gvcGljaycpO1xuXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Z1bmN0aW9uJyk7IC8vIHdlIHdhbnQgdG8gc3VwcG9ydCBwYXJzaW5nIG90aGVyIGZpZWxkcyB0aGFuIHRoZSBzdGFuZGFyZDpcbi8vIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnM+XG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL3N0cmlwZS9zdHJpcGUtbm9kZS9ibG9iLzNjMDdkODUxY2Y4OTc0OTBkOGI5M2RkNDQ1N2RkYTBjNGM4ZTY2N2YvbGliL0Vycm9yLmpzI0wzMz5cblxuXG52YXIgcGFyc2VFcnIgPSBmdW5jdGlvbiBwYXJzZUVycihlcnIpIHtcbiAgdmFyIGZpZWxkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIGlmICghaXNFcnJvcihlcnIpKSB0aHJvdyBuZXcgRXJyb3IoJ2BlcnJgIG11c3QgYmUgYW4gRXJyb3InKTtcbiAgaWYgKCFpc0FycmF5KGZpZWxkcykpIHRocm93IG5ldyBFcnJvcignYGZpZWxkc2AgbXVzdCBiZSBhbiBBcnJheScpO1xuICB2YXIga2V5cyA9IHt9O1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKSkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNGdW5jdGlvbihlcnJba2V5XSkpIGtleXNba2V5XSA9IGVycltrZXldO1xuICB9KTtcbiAgaWYgKCFrZXlzLm5hbWUgJiYgZXJyLmNvbnN0cnVjdG9yLm5hbWUpIGtleXMubmFtZSA9IGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICByZXR1cm4gaXNBcnJheShmaWVsZHMpICYmICFpc0VtcHR5KGZpZWxkcykgPyBwaWNrKGtleXMsIGZpZWxkcykgOiBrZXlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUVycjsiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBAZmlsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzIGVudW1lcmFibGUuXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgcHJvcGVydHktaXMtZW51bWVyYWJsZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJ3RvLXByb3BlcnR5LWtleS14Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCd0by1vYmplY3QteCcpO1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzXG4gKiBlbnVtZXJhYmxlLiBEb2VzIG5vdCBhdHRlbXB0IHRvIGZpeCBidWdzIGluIElFPDkgb3Igb2xkIE9wZXJhLCBvdGhlcndpc2UgaXRcbiAqIGRvZXMgRVM2aWZ5IHRoZSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIHRlc3QgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd8U3ltYm9sfSBwcm9wZXJ0eSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byB0ZXN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzXG4gKiAgZW51bWVyYWJsZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSByZXF1aXJlKCdwcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLXgnKTtcbiAqXG4gKiB2YXIgbyA9IHt9O1xuICogdmFyIGEgPSBbXTtcbiAqIG8ucHJvcCA9ICdpcyBlbnVtZXJhYmxlJztcbiAqIGFbMF0gPSAnaXMgZW51bWVyYWJsZSc7XG4gKlxuICogcHJvcGVydHlJc0VudW1lcmFibGUobywgJ3Byb3AnKTsgLy8gdHJ1ZVxuICogcHJvcGVydHlJc0VudW1lcmFibGUoYSwgMCk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHJldHVybiBwcm9wSXNFbnVtZXJhYmxlLmNhbGwodG9PYmplY3Qob2JqZWN0KSwgdG9Qcm9wZXJ0eUtleShwcm9wZXJ0eSkpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgU2hhbSBmb3IgUmVmbGVjdC5vd25LZXlzXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgcmVmbGVjdC1vd24ta2V5cy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzUmVmbGVjdCA9IHJlcXVpcmUoJ2hhcy1yZWZsZWN0LXN1cHBvcnQteCcpO1xudmFyIHJlZmxlY3RPd25LZXlzID0gaGFzUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXM7XG5cbmlmIChyZWZsZWN0T3duS2V5cykge1xuICB0cnkge1xuICAgIHZhciBrID0gcmVmbGVjdE93bktleXMoeyBhOiAxLCBiOiAyIH0pLnNvcnQoKTtcbiAgICBpZiAoay5sZW5ndGggIT09IDIgfHwga1swXSAhPT0gJ2EnIHx8IGtbMV0gIT09ICdiJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgIHJlZmxlY3RPd25LZXlzID0gbnVsbDtcbiAgfVxufVxuXG5pZiAoQm9vbGVhbihyZWZsZWN0T3duS2V5cykgPT09IGZhbHNlKSB7XG4gIHZhciBhc3NlcnRJc09iamVjdCA9IHJlcXVpcmUoJ2Fzc2VydC1pcy1vYmplY3QteCcpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJ2dldC1vd24tcHJvcGVydHktbmFtZXMteCcpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLXgnKTtcbiAgdmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG5cbiAgcmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICAgIGFzc2VydElzT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuIGNvbmNhdC5jYWxsKGdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHRhcmdldCBvYmplY3QncyBvd24gcHJvcGVydHkga2V5cy5cbiAqIEl0cyByZXR1cm4gdmFsdWUgaXMgZXF1aXZhbGVudCB0b1xuICogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKS5cbiAqXG4gKiBAcGFyYW0geyp9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBvd24ga2V5cy5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGFyZ2V0IGlzIG5vdCBhbiBPYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBBcnJheSBvZiB0aGUgdGFyZ2V0IG9iamVjdCdzIG93biBwcm9wZXJ0eSBrZXlzLlxuICogQGV4YW1wbGVcbiAqIHZhciByZWZsZWN0T3duS2V5cyA9IHJlcXVpcmUoJ3JlZmxlY3Qtb3duLWtleXMteCcpO1xuICogcmVmbGVjdE93bktleXMoeyBhOiAxLCBiOiAyIH0pOyAvLyBbJ2EnLCAnYiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdE93bktleXM7XG4iLCIvKipcbiAqIEBmaWxlIFJlcGxhY2UgdGhlIGNvbW1lbnRzIGluIGEgc3RyaW5nLlxuICogQHZlcnNpb24gMi4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHJlcGxhY2UtY29tbWVudHMteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gcmVxdWlyZSgndG8tc3RyaW5nLXgnKTtcbnZhciByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcgPSByZXF1aXJlKCdyZXF1aXJlLWNvZXJjaWJsZS10by1zdHJpbmcteCcpO1xudmFyIFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xudmFyIHJlcGxhY2UgPSAnJy5yZXBsYWNlO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJlcGxhY2VzIGNvbW1lbnRzIGluIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGJlIHN0cmlwcGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtyZXBsYWNlbWVudF0gLSBUaGUgc3RyaW5nIHRvIGJlIHVzZWQgYXMgYSByZXBsYWNlbWVudC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHJlcGxhY2VtZW50IGlzIG5vdCBjb2VyY2libGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmV3IHN0cmluZyB3aXRoIHRoZSBjb21tZW50cyByZXBsYWNlZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcmVwbGFjZUNvbW1lbnRzID0gcmVxdWlyZSgncmVwbGFjZS1jb21tZW50cy14Jyk7XG4gKlxuICogcmVwbGFjZUNvbW1lbnRzKHRlc3Q7LyogdGVzdCAqIC8sICcnKSwgLy8gJ3Rlc3Q7J1xuICogcmVwbGFjZUNvbW1lbnRzKHRlc3Q7IC8vIHRlc3QsICcnKSwgLy8gJ3Rlc3Q7J1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2VDb21tZW50cyhzdHJpbmcpIHtcbiAgcmV0dXJuIHJlcGxhY2UuY2FsbChyZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoc3RyaW5nKSwgU1RSSVBfQ09NTUVOVFMsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdG9TdHIoYXJndW1lbnRzWzFdKSA6ICcnKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFJlcXVpcmVzIGFuIGFyZ3VtZW50IGlzIGNvcmVjaWJsZSB0aGVuIGNvbnZlcnRzIHVzaW5nIFRvU3RyaW5nLlxuICogQHZlcnNpb24gMS4wLjJcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHJlcXVpcmUtY29lcmNpYmxlLXRvLXN0cmluZy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS14Jyk7XG52YXIgdG9TdHIgPSByZXF1aXJlKCd0by1zdHJpbmcteCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJlcXVpcmVzIGFuIGFyZ3VtZW50IGlzIGNvcmVjaWJsZSB0aGVuIGNvbnZlcnRzIHVzaW5nIFRvU3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydGVkIHRvIGEgc3RyaW5nLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2YWx1ZSBhcyBhIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nID0gcmVxdWlyZSgncmVxdWlyZS1jb2VyY2libGUtdG8tc3RyaW5nLXgnKTtcbiAqXG4gKiByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoKTsgLy8gVHlwZUVycm9yXG4gKiByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcobnVsbCk7IC8vIFR5cGVFcnJvclxuICogcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKFN5bWJvbCgnJykpOyAvLyBUeXBlRXJyb3JcbiAqIHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyhPYmplY3QuY3JlYXRlKG51bGwpKTsgLy8gVHlwZUVycm9yXG4gKiByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoMSk7IC8vICcxJ1xuICogcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKHRydWUpOyAvLyAndHJ1ZSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyKHJlcXVpcmVPYmplY3RDb2VyY2libGUodmFsdWUpKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEVTNi1jb21wbGlhbnQgc2hpbSBmb3IgUmVxdWlyZU9iamVjdENvZXJjaWJsZS5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlfDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUgKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMS40LjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHJlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOaWwgPSByZXF1aXJlKCdpcy1uaWwteCcpO1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdCBvcGVyYXRpb24gUmVxdWlyZU9iamVjdENvZXJjaWJsZSB0aHJvd3MgYW4gZXJyb3IgaWYgYXJndW1lbnRcbiAqIGlzIGEgdmFsdWUgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGFuIE9iamVjdCB1c2luZyBUb09iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIGB2YWx1ZWAgdG8gY2hlY2suXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgUmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS14Jyk7XG4gKlxuICogUmVxdWlyZU9iamVjdENvZXJjaWJsZSgpOyAvLyBUeXBlRXJyb3JcbiAqIFJlcXVpcmVPYmplY3RDb2VyY2libGUobnVsbCk7IC8vIFR5cGVFcnJvclxuICogUmVxdWlyZU9iamVjdENvZXJjaWJsZSgnYWJjJyk7IC8vICdhYmMnXG4gKiBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRydWUpOyAvLyB0cnVlXG4gKiBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKFN5bWJvbCgnZm9vJykpOyAvLyBTeW1ib2woJ2ZvbycpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVxdWlyZU9iamVjdENvZXJjaWJsZSh2YWx1ZSkge1xuICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgbWV0aG9kIG9uICcgKyB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBMaWtlIEVTNiBUb1N0cmluZyBidXQgaGFuZGxlcyBTeW1ib2xzIHRvby5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9Yb3RpYzc1MC90by1zdHJpbmcteHx0by1zdHJpbmcteH1cbiAqIEB2ZXJzaW9uIDEuNS4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzYWZlLXRvLXN0cmluZy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcbnZhciBwVG9TdHJpbmcgPSByZXF1aXJlKCdoYXMtc3ltYm9sLXN1cHBvcnQteCcpICYmIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IG9wZXJhdGlvbiBgc2FmZVRvU3RyaW5nYCBjb252ZXJ0cyBhIGBTeW1ib2xgIGxpdGVyYWwgb3JcbiAqIG9iamVjdCB0byBgU3ltYm9sKClgIGluc3RlYWQgb2YgdGhyb3dpbmcgYSBgVHlwZUVycm9yYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29udmVydGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIHZhciBzYWZlVG9TdHJpbmcgPSByZXF1aXJlKCdzYWZlLXRvLXN0cmluZy14Jyk7XG4gKlxuICogc2FmZVRvU3RyaW5nKCk7IC8vICd1bmRlZmluZWQnXG4gKiBzYWZlVG9TdHJpbmcobnVsbCk7IC8vICdudWxsJ1xuICogc2FmZVRvU3RyaW5nKCdhYmMnKTsgLy8gJ2FiYydcbiAqIHNhZmVUb1N0cmluZyh0cnVlKTsgLy8gJ3RydWUnXG4gKiBzYWZlVG9TdHJpbmcoU3ltYm9sKCdmb28nKSk7IC8vICdTeW1ib2woZm9vKSdcbiAqIHNhZmVUb1N0cmluZyhTeW1ib2wuaXRlcmF0b3IpOyAvLyAnU3ltYm9sKFN5bWJvbC5pdGVyYXRvciknXG4gKiBzYWZlVG9TdHJpbmcoT2JqZWN0KFN5bWJvbC5pdGVyYXRvcikpOyAvLyAnU3ltYm9sKFN5bWJvbC5pdGVyYXRvciknXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2FmZVRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBwVG9TdHJpbmcgJiYgaXNTeW1ib2wodmFsdWUpID8gcFRvU3RyaW5nLmNhbGwodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIERldGVybWluZXMgd2hldGhlciB0d28gdmFsdWVzIGFyZSB0aGUgc2FtZSB2YWx1ZS5cbiAqIEB2ZXJzaW9uIDEuMC4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzYW1lLXZhbHVlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IHJlcXVpcmUoJ2lzLW5hbi14Jyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgdGhlIGNvbXBhcmlzb24gYWJzdHJhY3Qgb3BlcmF0aW9uIFNhbWVWYWx1ZSh4LCB5KSwgd2hlcmUgeFxuICogYW5kIHkgYXJlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdmFsdWVzLCBwcm9kdWNlcyB0cnVlIG9yIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUxIC0gVGhlIGZpcnN0IHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IHZhbHVlMiAtIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIGFyZ3VtZW50cyBhcmVcbiAqICB0aGUgc2FtZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnc2FtZS12YWx1ZS14Jyk7XG4gKlxuICogc2FtZVZhbHVlKDEsIDEpOyAvLyB0cnVlXG4gKiBzYW1lVmFsdWUodHJ1ZSwgdHJ1ZSk7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZShOYU4sIE5hTik7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZSh0cnVlLCBmYWxzZSk7IC8vIGZhbHNlXG4gKiBzYW1lVmFsdWUoMCwgLTApOyAvLyBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhbWVWYWx1ZSh2YWx1ZTEsIHZhbHVlMikge1xuICBpZiAodmFsdWUxID09PSAwICYmIHZhbHVlMiA9PT0gMCkge1xuICAgIHJldHVybiAxIC8gdmFsdWUxID09PSAxIC8gdmFsdWUyO1xuICB9XG5cbiAgaWYgKHZhbHVlMSA9PT0gdmFsdWUyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gbnVtYmVySXNOYU4odmFsdWUxKSAmJiBudW1iZXJJc05hTih2YWx1ZTIpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgRVM2LWNvbXBsaWFudCBzaGltIGZvciBTYW1lVmFsdWVaZXJvLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm98Ny4yLjEwIFNhbWVWYWx1ZVplcm8oeCwgeSl9XG4gKiBAdmVyc2lvbiAxLjMuMlxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgc2FtZS12YWx1ZS16ZXJvLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCdzYW1lLXZhbHVlLXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgdmFsdWUuXG4gKiBTYW1lVmFsdWVaZXJvIGRpZmZlcnMgZnJvbSBTYW1lVmFsdWUgKGBPYmplY3QuaXNgKSBvbmx5IGluIGl0cyB0cmVhdG1lbnRcbiAqIG9mICswIGFuZCAtMC5cbiAqXG4gKiBAcGFyYW0geyp9IHggLSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0geSAtIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIGFyZ3VtZW50c1xuICogYXJlIHRoZSBzYW1lIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIHZhciBzYW1lVmFsdWVaZXJvID0gcmVxdWlyZSgnc2FtZS12YWx1ZS16ZXJvLXgnKTtcbiAqIHNhbWVWYWx1ZVplcm8oMCwgMCk7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZVplcm8oLTAsIC0wKTsgLy8gdHJ1ZVxuICogc2FtZVZhbHVlWmVybygwLCAtMCk7IC8vIHRydWVcbiAqIHNhbWVWYWx1ZVplcm8oTmFOLCBOYU4pOyAvL3RydWVcbiAqIHNhbWVWYWx1ZVplcm8oSW5maW5pdHksIEluZmluaXR5KTsgLy8gdHJ1ZVxuICogc2FtZVZhbHVlWmVybygtSW5maW5pdHksIC1JbmZpbml0eSk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzYW1lVmFsdWVaZXJvKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgfHwgc2FtZVZhbHVlKHgsIHkpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB3aXRoIHRoZSBib3hlZCBidWc7IHNwbGl0cyB0byBhbiBhcnJheS5cbiAqIEB2ZXJzaW9uIDEuMS4xXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzcGxpdC1pZi1ib3hlZC1idWcteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0clNwbGl0O1xudmFyIGlzU3RyaW5nO1xuaWYgKHJlcXVpcmUoJ2hhcy1ib3hlZC1zdHJpbmcteCcpID09PSBmYWxzZSkge1xuICBzdHJTcGxpdCA9ICcnLnNwbGl0O1xuICBpc1N0cmluZyA9IHR5cGVvZiBzdHJTcGxpdCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1aXJlKCdpcy1zdHJpbmcnKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0ZXN0cyBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIHdpdGggdGhlIGJveGVkIGJ1Zzsgc3BsaXRzIHRvIGFuXG4gKiBhcnJheSBmb3IgaXRlcmF0aW9uOyBvdGhlcndpc2UgcmV0dXJucyB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWQuXG4gKiBAcmV0dXJucyB7Kn0gQW4gYXJyYXkgb3IgY2hhcmFjdGVycyBpZiB2YWx1ZSB3YXMgYSBzdHJpbmcgd2l0aCB0aGUgYm94ZWQgYnVnO1xuICogIG90aGVyd2lzZSB0aGUgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHNwbGl0SWZCb3hlZEJ1ZyA9IHJlcXVpcmUoJ3NwbGl0LWlmLWJveGVkLWJ1Zy14Jyk7XG4gKlxuICogLy8gTm8gYm94ZWQgYnVnXG4gKiBzcGxpdElmQm94ZWRCdWcoJ2FiYycpOyAvLyAnYWJjJ1xuICpcbiAqIC8vIEJveGVkIGJ1Z1xuICogc3BsaXRJZkJveGVkQnVnKCdhYmMnKTsgLy8gWydhJywgJ2InLCAnYyddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3BsaXRJZkJveGVkQnVnKHZhbHVlKSB7XG4gIHJldHVybiBpc1N0cmluZyAmJiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJTcGxpdC5jYWxsKHZhbHVlLCAnJykgOiB2YWx1ZTtcbn07XG5cbiIsIi8qKlxuICogQGZpbGUgUGFkcyBhIHN0cmluZyB3aXRoIGFub3RoZXIgc3RyaW5nIChyZXBlYXRlZCwgaWYgbmVlZGVkKS5cbiAqIEB2ZXJzaW9uIDEuMi4wXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSBzdHJpbmctcGFkLXN0YXJ0LXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgncmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLXgnKTtcbnZhciB0b1N0ciA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCd0by1sZW5ndGgteCcpLnRvTGVuZ3RoMjAxODtcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xudmFyIHN0clNsaWNlID0gU3RyaW5nLnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBwYWRzIHRoZSBjdXJyZW50IHN0cmluZyB3aXRoIGFub3RoZXIgc3RyaW5nIChyZXBlYXRlZCwgaWYgbmVlZGVkKVxuICogc28gdGhhdCB0aGUgcmVzdWx0aW5nIHN0cmluZyByZWFjaGVzIHRoZSBnaXZlbiBsZW5ndGguIFRoZSBwYWRkaW5nIGlzIGFwcGxpZWRcbiAqIGZyb20gdGhlIHN0YXJ0IChsZWZ0KSBvZiB0aGUgY3VycmVudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gcGFkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0TGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHN0cmluZyBvbmNlIHRoZVxuICogIGN1cnJlbnQgc3RyaW5nIGhhcyBiZWVuIHBhZGRlZC4gSWYgdGhlIHZhbHVlIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAqICBzdHJpbmcncyBsZW5ndGgsIHRoZSBjdXJyZW50IHN0cmluZyB3aWxsIGJlIHJldHVybmVkIGFzIGlzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYWRTdHJpbmddIC0gVGhlIHN0cmluZyB0byBwYWQgdGhlIGN1cnJlbnQgc3RyaW5nIHdpdGguIElmXG4gKiAgdGhpcyBzdHJpbmcgaXMgdG9vIGxvbmcgdG8gc3RheSB3aXRoaW4gdGhlIHRhcmdldCBsZW5ndGgsIGl0IHdpbGwgYmVcbiAqICB0cnVuY2F0ZWQgYW5kIHRoZSBsZWZ0LW1vc3QgcGFydCB3aWxsIGJlIGFwcGxpZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzXG4gKiAgcGFyYW1ldGVyIGlzIFwiIFwiIChVKzAwMjApLlxuICogQHJldHVybnMge3N0cmluZ30gQSBTdHJpbmcgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGggd2l0aCB0aGUgcGFkIHN0cmluZ1xuICogIGFwcGxpZWQgZnJvbSB0aGUgc3RhcnQuXG4gKiBAZXhhbXBsZVxuICogdmFyIHBhZFN0YXJ0ID0gcmVxdWlyZSgnc3RyaW5nLXBhZC1zdGFydC14Jyk7XG4gKlxuICogcGFkU3RhcnQoJ2EnLCAzLCAnYicpOyAvLyAnYmJhJ1xuICogcGFkU3RhcnQoJ2EnLCAzKTsgLy8gJyAgYSdcbiAqIHBhZFN0YXJ0KCdhJywgMiwgJ2JjJyk7IC8vICdiYSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIHRhcmdldExlbmd0aCkge1xuICB2YXIgc3RyID0gdG9TdHIocmVxdWlyZU9iamVjdENvZXJjaWJsZShzdHJpbmcpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IHRvTGVuZ3RoKHN0ci5sZW5ndGgpO1xuICB2YXIgZmlsbFN0cmluZztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgZmlsbFN0cmluZyA9IGFyZ3VtZW50c1syXTtcbiAgfVxuXG4gIHZhciBmaWxsZXIgPSBpc1VuZGVmaW5lZChmaWxsU3RyaW5nKSA/ICcnIDogdG9TdHIoZmlsbFN0cmluZyk7XG4gIGlmIChmaWxsZXIgPT09ICcnKSB7XG4gICAgZmlsbGVyID0gJyAnO1xuICB9XG5cbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKHRhcmdldExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICB3aGlsZSAoZmlsbGVyLmxlbmd0aCA8IGZpbGxMZW4pIHtcbiAgICB2YXIgZkxlbiA9IGZpbGxlci5sZW5ndGg7XG4gICAgdmFyIHJlbWFpbmluZ0NvZGVVbml0cyA9IGZpbGxMZW4gLSBmTGVuO1xuICAgIGZpbGxlciArPSBmTGVuID4gcmVtYWluaW5nQ29kZVVuaXRzID8gc3RyU2xpY2UuY2FsbChmaWxsZXIsIDAsIHJlbWFpbmluZ0NvZGVVbml0cykgOiBmaWxsZXI7XG4gIH1cblxuICB2YXIgdHJ1bmNhdGVkU3RyaW5nRmlsbGVyID0gZmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4gPyBzdHJTbGljZS5jYWxsKGZpbGxlciwgMCwgZmlsbExlbikgOiBmaWxsZXI7XG5cbiAgcmV0dXJuIHRydW5jYXRlZFN0cmluZ0ZpbGxlciArIHN0cjtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2YgdHlwZSBCb29sZWFuLlxuICogQHZlcnNpb24gMS4wLjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLWJvb2xlYW4teFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIFRvQm9vbGVhbiBjb252ZXJ0cyBhcmd1bWVudCB0byBhIHZhbHVlIG9mIHR5cGUgQm9vbGVhbi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSAndHJ1ZScgaWYgdmFsdWUgaXMgdHJ1dGh5OyBvdGhlcndpc2UgJ2ZhbHNlJy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9Cb29sZWFuID0gcmVxdWlyZSgndG8tYm9vbGVhbi14Jyk7XG4gKlxuICogdG9Cb29sZWFuKG51bGwpOyAvLyBmYWxzZVxuICogdG9Cb29sZWFuKCcnKTsgLy8gZmFsc2VcbiAqIHRvQm9vbGVhbigxKTsgLy8gdHJ1ZVxuICogdG9Cb29sZWFuKCcwJyk7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBDcm9zcy1icm93c2VyIHRvSVNPU3RyaW5nIHN1cHBvcnQuXG4gKiBAdmVyc2lvbiAxLjUuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8taXNvLXN0cmluZy14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmF0aXZlVG9JU09TdHJpbmcgPSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBpc1dvcmtpbmc7XG5pZiAobmF0aXZlVG9JU09TdHJpbmcpIHtcbiAgdmFyIGF0dGVtcHQgPSByZXF1aXJlKCdhdHRlbXB0LXgnKTtcbiAgdmFyIHJlcyA9IGF0dGVtcHQuY2FsbChuZXcgRGF0ZSgwKSwgbmF0aXZlVG9JU09TdHJpbmcpO1xuICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gJzE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwWic7XG4gIGlmIChpc1dvcmtpbmcpIHtcbiAgICByZXMgPSBhdHRlbXB0LmNhbGwobmV3IERhdGUoLTYyMTk4NzU1MjAwMDAwKSwgbmF0aXZlVG9JU09TdHJpbmcpO1xuICAgIGlzV29ya2luZyA9IHJlcy50aHJldyA9PT0gZmFsc2UgJiYgcmVzLnZhbHVlLmluZGV4T2YoJy0wMDAwMDEnKSA+IC0xO1xuICB9XG5cbiAgaWYgKGlzV29ya2luZykge1xuICAgIHJlcyA9IGF0dGVtcHQuY2FsbChuZXcgRGF0ZSgtMSksIG5hdGl2ZVRvSVNPU3RyaW5nKTtcbiAgICBpc1dvcmtpbmcgPSByZXMudGhyZXcgPT09IGZhbHNlICYmIHJlcy52YWx1ZSA9PT0gJzE5NjktMTItMzFUMjM6NTk6NTkuOTk5Wic7XG4gIH1cbn1cblxudmFyICR0b0lTT1N0cmluZztcbmlmIChpc1dvcmtpbmcpIHtcbiAgJHRvSVNPU3RyaW5nID0gZnVuY3Rpb24gdG9JU09TdHJpbmcoZGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVUb0lTT1N0cmluZy5jYWxsKGRhdGUpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG4gIHZhciBwYWRTdGFydCA9IHJlcXVpcmUoJ3N0cmluZy1wYWQtc3RhcnQteCcpO1xuICB2YXIgbWFwID0gcmVxdWlyZSgnYXJyYXktbWFwLXgnKTtcbiAgdmFyIGFycmF5U2xpY2UgPSByZXF1aXJlKCdhcnJheS1zbGljZS14Jyk7XG4gIHZhciBqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG5cbiAgJHRvSVNPU3RyaW5nID0gZnVuY3Rpb24gdG9JU09TdHJpbmcoZGF0ZSkge1xuICAgIGlmIChpc0RhdGUoZGF0ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0lTT1N0cmluZyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyLicpO1xuICAgIH1cblxuICAgIGlmIChpc0Zpbml0ZShkYXRlKSA9PT0gZmFsc2UgfHwgaXNGaW5pdGUoZGF0ZS5nZXRUaW1lKCkpID09PSBmYWxzZSkge1xuICAgICAgLy8gQWRvcGUgUGhvdG9zaG9wIHJlcXVpcmVzIHRoZSBzZWNvbmQgY2hlY2suXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgdmFyIHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgIHllYXIgKz0gKG1vbnRoIC8gMTIpID4+IDA7IC8vIGZsb29yXG4gICAgbW9udGggPSAoKG1vbnRoICUgMTIpICsgMTIpICUgMTI7XG5cbiAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICB2YXIgcGFydHMgPSBbXG4gICAgICBtb250aCArIDEsXG4gICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKClcbiAgICBdO1xuXG4gICAgdmFyIHNpZ247XG4gICAgaWYgKHllYXIgPCAwKSB7XG4gICAgICBzaWduID0gJy0nO1xuICAgIH0gZWxzZSBpZiAoeWVhciA+IDk5OTkpIHtcbiAgICAgIHNpZ24gPSAnKyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ24gPSAnJztcbiAgICB9XG5cbiAgICB5ZWFyID0gc2lnbiArIHBhZFN0YXJ0KE1hdGguYWJzKHllYXIpLCBzaWduID8gNiA6IDQsICcwJyk7XG4gICAgdmFyIHJlc3VsdCA9IG1hcChwYXJ0cywgZnVuY3Rpb24gX21hcHBlcihpdGVtKSB7XG4gICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d28gZGlnaXRzLlxuICAgICAgcmV0dXJuIHBhZFN0YXJ0KGl0ZW0sIDIsICcwJyk7XG4gICAgfSk7XG5cbiAgICB2YXIgZGF0ZVN0ciA9IHllYXIgKyAnLScgKyBqb2luLmNhbGwoYXJyYXlTbGljZShyZXN1bHQsIDAsIDIpLCAnLScpO1xuICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgdmFyIG1zU3RyID0gcGFkU3RhcnQoZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoZGF0ZSksIDMsICcwJyk7XG4gICAgdmFyIHRpbWVTdHIgPSBqb2luLmNhbGwoYXJyYXlTbGljZShyZXN1bHQsIDIpLCAnOicpICsgJy4nICsgbXNTdHI7XG5cbiAgICByZXR1cm4gZGF0ZVN0ciArICdUJyArIHRpbWVTdHIgKyAnWic7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBpbiBzaW1wbGlmaWVkIGV4dGVuZGVkIElTTyBmb3JtYXQgKElTTyA4NjAxKSxcbiAqIHdoaWNoIGlzIGFsd2F5cyAyNCBvciAyNyBjaGFyYWN0ZXJzIGxvbmcgKFlZWVktTU0tRERUSEg6bW06c3Muc3NzWiBvclxuICogwrFZWVlZWVktTU0tRERUSEg6bW06c3Muc3NzWiwgcmVzcGVjdGl2ZWx5KS4gVGhlIHRpbWV6b25lIGlzIGFsd2F5cyB6ZXJvIFVUQ1xuICogb2Zmc2V0LCBhcyBkZW5vdGVkIGJ5IHRoZSBzdWZmaXggXCJaXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGUgQSBEYXRlIG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgZGF0ZSBpcyBub3QgYSBEYXRlIG9iamVjdC5cbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGRhdGUgaXMgaW52YWxpZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gR2l2ZW4gZGF0ZSBpbiB0aGUgSVNPIDg2MDEgZm9ybWF0IGFjY29yZGluZyB0byB1bml2ZXJzYWwgdGltZS5cblxuICogQGV4YW1wbGVcbiAqIHZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJ3RvLWlzby1zdHJpbmcteCcpO1xuICogdG9JU09TdHJpbmcobmV3IERhdGUoMCkpOyAvLyAnMTk3MC0wMS0wMVQwMDowMDowMC4wMDBaJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9ICR0b0lTT1N0cmluZztcbiIsIi8qKlxuICogQGZpbGUgRVM2LWNvbXBsaWFudCBzaGltIGZvciBUb09iamVjdC5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b29iamVjdHw3LjEuMTMgVG9PYmplY3QgKCBhcmd1bWVudCApfVxuICogQHZlcnNpb24gMS41LjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLW9iamVjdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJ3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS14Jyk7XG52YXIgY2FzdE9iamVjdCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLk9iamVjdDtcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIFRvT2JqZWN0IGNvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2ZcbiAqIHR5cGUgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgYHZhbHVlYCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICogQHJldHVybnMgeyFPYmplY3R9IFRoZSBgdmFsdWVgIGNvbnZlcnRlZCB0byBhbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIFRvT2JqZWN0ID0gcmVxdWlyZSgndG8tb2JqZWN0LXgnKTtcbiAqXG4gKiBUb09iamVjdCgpOyAvLyBUeXBlRXJyb3JcbiAqIFRvT2JqZWN0KG51bGwpOyAvLyBUeXBlRXJyb3JcbiAqIFRvT2JqZWN0KCdhYmMnKTsgLy8gT2JqZWN0KCdhYmMnKVxuICogVG9PYmplY3QodHJ1ZSk7IC8vIE9iamVjdCh0cnVlKVxuICogVG9PYmplY3QoU3ltYm9sKCdmb28nKSk7IC8vIE9iamVjdChTeW1ib2woJ2ZvbycpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjYXN0T2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUodmFsdWUpKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYSBwcmltaXRpdmUgdmFsdWUuXG4gKiBAdmVyc2lvbiAxLjEuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8tcHJpbWl0aXZlLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbC1zdXBwb3J0LXgnKTtcbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xudmFyIGlzRGF0ZSA9IHJlcXVpcmUoJ2lzLWRhdGUtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCdpcy1zeW1ib2wnKTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24teCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCdyZXF1aXJlLW9iamVjdC1jb2VyY2libGUteCcpO1xudmFyIGlzTmlsID0gcmVxdWlyZSgnaXMtbmlsLXgnKTtcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xudmFyIHN5bVRvUHJpbWl0aXZlID0gaGFzU3ltYm9scyAmJiBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgc3ltVmFsdWVPZiA9IGhhc1N5bWJvbHMgJiYgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mO1xuXG52YXIgdG9TdHJpbmdPcmRlciA9IFsndG9TdHJpbmcnLCAndmFsdWVPZiddO1xudmFyIHRvTnVtYmVyT3JkZXIgPSBbJ3ZhbHVlT2YnLCAndG9TdHJpbmcnXTtcbnZhciBvcmRlckxlbmd0aCA9IDI7XG5cbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gX29yZGluYXJ5VG9QcmltaXRpdmUoTywgaGludCkge1xuICByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKE8pO1xuICBpZiAodHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnIHx8IChoaW50ICE9PSAnbnVtYmVyJyAmJiBoaW50ICE9PSAnc3RyaW5nJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiJyk7XG4gIH1cblxuICB2YXIgbWV0aG9kTmFtZXMgPSBoaW50ID09PSAnc3RyaW5nJyA/IHRvU3RyaW5nT3JkZXIgOiB0b051bWJlck9yZGVyO1xuICB2YXIgbWV0aG9kO1xuICB2YXIgcmVzdWx0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBtZXRob2QgPSBPW21ldGhvZE5hbWVzW2ldXTtcbiAgICBpZiAoaXNGdW5jdGlvbihtZXRob2QpKSB7XG4gICAgICByZXN1bHQgPSBtZXRob2QuY2FsbChPKTtcbiAgICAgIGlmIChpc1ByaW1pdGl2ZShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gZGVmYXVsdCB2YWx1ZScpO1xufTtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIF9nZXRNZXRob2QoTywgUCkge1xuICB2YXIgZnVuYyA9IE9bUF07XG4gIGlmIChpc05pbChmdW5jKSA9PT0gZmFsc2UpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihmdW5jKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZnVuYyArICcgcmV0dXJuZWQgZm9yIHByb3BlcnR5ICcgKyBQICsgJyBvZiBvYmplY3QgJyArIE8gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cblxuICByZXR1cm4gdm9pZCAwO1xufTtcblxuLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvcHJpbWl0aXZlXG5cbi8qKlxuICogVGhpcyBtZXRob2QgY29udmVydHMgYSBKYXZhU2NyaXB0IG9iamVjdCB0byBhIHByaW1pdGl2ZSB2YWx1ZS5cbiAqIE5vdGU6IFdoZW4gdG9QcmltaXRpdmUgaXMgY2FsbGVkIHdpdGggbm8gaGludCwgdGhlbiBpdCBnZW5lcmFsbHkgYmVoYXZlcyBhc1xuICogaWYgdGhlIGhpbnQgd2VyZSBOdW1iZXIuIEhvd2V2ZXIsIG9iamVjdHMgbWF5IG92ZXItcmlkZSB0aGlzIGJlaGF2aW91ciBieVxuICogZGVmaW5pbmcgYSBAQHRvUHJpbWl0aXZlIG1ldGhvZC4gT2YgdGhlIG9iamVjdHMgZGVmaW5lZCBpbiB0aGlzIHNwZWNpZmljYXRpb25cbiAqIG9ubHkgRGF0ZSBvYmplY3RzIChzZWUgMjAuMy40LjQ1KSBhbmQgU3ltYm9sIG9iamVjdHMgKHNlZSAxOS40LjMuNCkgb3Zlci1yaWRlXG4gKiB0aGUgZGVmYXVsdCBUb1ByaW1pdGl2ZSBiZWhhdmlvdXIuIERhdGUgb2JqZWN0cyB0cmVhdCBubyBoaW50IGFzIGlmIHRoZSBoaW50XG4gKiB3ZXJlIFN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyp9IGlucHV0IC0gVGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge2NvbnN0cnVjdG9yfSBbcHJlZmZlcmVkdHlwZV0gLSBUaGUgcHJlZmZlcmVkIHR5cGUgKFN0cmluZyBvciBOdW1iZXIpLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB1bmFibGUgdG8gY29udmVydCBpbnB1dCB0byBhIHByaW1pdGl2ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSBUaGUgY29udmVydGVkIGlucHV0IGFzIGEgcHJpbWl0aXZlLlxuICogQGV4YW1wbGVcbiAqIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ3RvLXByaW1pdGl2ZS14Jyk7XG4gKlxuICogdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAqIHRvUHJpbWl0aXZlKGRhdGUpKTsgLy8gVGh1IEphbiAwMSAxOTcwIDAxOjAwOjAwIEdNVCswMTAwIChDRVQpXG4gKiB0b1ByaW1pdGl2ZShkYXRlLCBTdHJpbmcpKTsgLy8gVGh1IEphbiAwMSAxOTcwIDAxOjAwOjAwIEdNVCswMTAwIChDRVQpXG4gKiB0b1ByaW1pdGl2ZShkYXRlLCBOdW1iZXIpKTsgLy8gMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvUHJpbWl0aXZlKGlucHV0LCBwcmVmZXJyZWRUeXBlKSB7XG4gIGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICB2YXIgaGludCA9ICdkZWZhdWx0JztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKHByZWZlcnJlZFR5cGUgPT09IFN0cmluZykge1xuICAgICAgaGludCA9ICdzdHJpbmcnO1xuICAgIH0gZWxzZSBpZiAocHJlZmVycmVkVHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICBoaW50ID0gJ251bWJlcic7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV4b3RpY1RvUHJpbTtcbiAgaWYgKGhhc1N5bWJvbHMpIHtcbiAgICBpZiAoc3ltVG9QcmltaXRpdmUpIHtcbiAgICAgIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgc3ltVG9QcmltaXRpdmUpO1xuICAgIH0gZWxzZSBpZiAoaXNTeW1ib2woaW5wdXQpKSB7XG4gICAgICBleG90aWNUb1ByaW0gPSBzeW1WYWx1ZU9mO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZChleG90aWNUb1ByaW0pID09PSBmYWxzZSkge1xuICAgIHZhciByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgaGludCk7XG4gICAgaWYgKGlzUHJpbWl0aXZlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5hYmxlIHRvIGNvbnZlcnQgZXhvdGljIG9iamVjdCB0byBwcmltaXRpdmUnKTtcbiAgfVxuXG4gIGlmIChoaW50ID09PSAnZGVmYXVsdCcgJiYgKGlzRGF0ZShpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSkge1xuICAgIGhpbnQgPSAnc3RyaW5nJztcbiAgfVxuXG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSAnZGVmYXVsdCcgPyAnbnVtYmVyJyA6IGhpbnQpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgQ29udmVydHMgYXJndW1lbnQgdG8gYSB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcHJvcGVydHkga2V5LlxuICogQHZlcnNpb24gMi4wLjJcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLXByb3BlcnR5LWtleS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2wtc3VwcG9ydC14Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCd0by1wcmltaXRpdmUteCcpO1xudmFyIHRvU3RyID0gcmVxdWlyZSgndG8tc3RyaW5nLXgnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBDb252ZXJ0cyBhcmd1bWVudCB0byBhIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBwcm9wZXJ0eSBrZXkuXG4gKlxuICogQHBhcmFtIHsqfSBhcmd1bWVudCAtIFRoZSBhcmd1bWVudCB0byBvbnZlcnQgdG8gYSBwcm9wZXJ0eSBrZXkuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50IGlzIG5vdCBhIHN5bWJvbCBhbmQgaXMgbm90IGNvZXJjaWJsZSB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBUaGUgY29udmVydGVkIGFyZ3VtZW50LlxuICogQGV4YW1wbGVcbiAqIHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgndG8tcHJvcGVydHkta2V5LXgnKTtcbiAqXG4gKiB0b1Byb3BlcnR5S2V5KCk7IC8vICd1bmRlZmluZWQnXG4gKiB0b1Byb3BlcnR5S2V5KDEpOyAvLyAnMSdcbiAqIHRvUHJvcGVydHlLZXkodHJ1ZSk7IC8vICd0cnVlJ1xuICpcbiAqIHZhciBzeW1ib2wgPSBTeW1ib2woJ2EnKTtcbiAqIHRvUHJvcGVydHlLZXkoc3ltYm9sKTsgLy8gc3ltYm9sXG4gKlxuICogdG9Qcm9wZXJ0eUtleShPYmplY3QuY3JlYXRlKG51bGwpKTsgLy8gVHlwZUVycm9yXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIFN0cmluZyk7XG4gIHJldHVybiBoYXNTeW1ib2xzICYmIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnID8ga2V5IDogdG9TdHIoa2V5KTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEVTNiBhYnN0cmFjdCBUb1N0cmluZyB3aXRoIFN5bWJvbCBjb252ZXJzaW9uIHN1cHBvcnQuXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9zdHJpbmd8Ny4xLjEyIFRvU3RyaW5nICggYXJndW1lbnQgKX1cbiAqIEB2ZXJzaW9uIDEuMC4yXG4gKiBAYXV0aG9yIFhvdGljNzUwIDxYb3RpYzc1MEBnbWFpbC5jb20+XG4gKiBAY29weXJpZ2h0ICBYb3RpYzc1MFxuICogQGxpY2Vuc2Uge0BsaW5rIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD4gTUlUfVxuICogQG1vZHVsZSB0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhc3RTdHJpbmcgPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5TdHJpbmc7XG52YXIgcFRvU3RyaW5nID0gcmVxdWlyZSgnaGFzLXN5bWJvbC1zdXBwb3J0LXgnKSAmJiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzU3ltYm9sID0gdHlwZW9mIHBUb1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1aXJlKCdpcy1zeW1ib2wnKTtcblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Qgb3BlcmF0aW9uIFRvU3RyaW5nIGNvbnZlcnRzIGFyZ3VtZW50IHRvIGEgdmFsdWUgb2YgdHlwZSBTdHJpbmcsXG4gKiBob3dldmVyIHRoZSBzcGVjaWZpY2F0aW9uIHN0YXRlcyB0aGF0IGlmIHRoZSBhcmd1bWVudCBpcyBhIFN5bWJvbCB0aGVuIGFcbiAqICdUeXBlRXJyb3InIGlzIHRocm93bi4gVGhpcyB2ZXJzaW9uIGFsc28gYWxsb3dzIFN5bWJvbHMgYmUgY29udmVydGVkIHRvXG4gKiBhIHN0cmluZy4gT3RoZXIgdW5jb2VyY2libGUgZXhvdGljcyB3aWxsIHN0aWxsIHRocm93IHRob3VnaC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29udmVydGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIHZhciB0b1N0cmluZ1N5bWJvbHNTdXBwb3J0ZWQgPSByZXF1aXJlKCd0by1zdHJpbmctc3ltYm9scy1zdXBwb3J0ZWQteCcpO1xuICpcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZCgpOyAvLyAndW5kZWZpbmVkJ1xuICogdG9TdHJpbmdTeW1ib2xzU3VwcG9ydGVkKG51bGwpOyAvLyAnbnVsbCdcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZCgnYWJjJyk7IC8vICdhYmMnXG4gKiB0b1N0cmluZ1N5bWJvbHNTdXBwb3J0ZWQodHJ1ZSk7IC8vICd0cnVlJ1xuICogdG9TdHJpbmdTeW1ib2xzU3VwcG9ydGVkKFN5bWJvbCgnZm9vJykpOyAvLyAnU3ltYm9sKCdmb28nKSdcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZChPYmplY3QoU3ltYm9sKCdmb28nKSkpOyAvLyAnU3ltYm9sKCdmb28nKSdcbiAqIHRvU3RyaW5nU3ltYm9sc1N1cHBvcnRlZChPYmplY3QuY3JlYXRlKG51bGwpKTsgLy8gVHlwZUVycm9yXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9TdHJpbmdTeW1ib2xzU3VwcG9ydGVkKHZhbHVlKSB7XG4gIHJldHVybiBpc1N5bWJvbCAmJiBpc1N5bWJvbCh2YWx1ZSkgPyBwVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiBjYXN0U3RyaW5nKHZhbHVlKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIEdldCBhbiBvYmplY3QncyBFUzYgQEB0b1N0cmluZ1RhZy5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nfDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKCApfVxuICogQHZlcnNpb24gMS40LjNcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRvLXN0cmluZy10YWcteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzTnVsbCA9IHJlcXVpcmUoJ2xvZGFzaC5pc251bGwnKTtcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLmlvLXVuZGVmaW5lZCcpO1xudmFyIHRvU3RyID0ge30udG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGB0b1N0cmluZ1RhZ2AgbWV0aG9kIHJldHVybnMgXCJbb2JqZWN0IHR5cGVdXCIsIHdoZXJlIHR5cGUgaXMgdGhlXG4gKiBvYmplY3QgdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIG9iamVjdCBvZiB3aGljaCB0byBnZXQgdGhlIG9iamVjdCB0eXBlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBvYmplY3QgdHlwZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRvU3RyaW5nVGFnID0gcmVxdWlyZSgndG8tc3RyaW5nLXRhZy14Jyk7XG4gKlxuICogdmFyIG8gPSBuZXcgT2JqZWN0KCk7XG4gKiB0b1N0cmluZ1RhZyhvKTsgLy8gcmV0dXJucyAnW29iamVjdCBPYmplY3RdJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKHZhbHVlKSB7XG4gIGlmIChpc051bGwodmFsdWUpKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0IE51bGxdJztcbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG4gIH1cblxuICByZXR1cm4gdG9TdHIuY2FsbCh2YWx1ZSk7XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBFUzYtY29tcGxpYW50IHNoaW0gZm9yIFRvU3RyaW5nLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvc3RyaW5nfDcuMS4xMiBUb1N0cmluZyAoIGFyZ3VtZW50ICl9XG4gKiBAdmVyc2lvbiAxLjQuNVxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdG8tc3RyaW5nLXhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXN0U3RyaW5nID0gcmVxdWlyZSgnY2FjaGVkLWNvbnN0cnVjdG9ycy14JykuU3RyaW5nO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnaXMtc3ltYm9sJyk7XG5cbi8qKlxuICogVGhlIGFic3RyYWN0IG9wZXJhdGlvbiBUb1N0cmluZyBjb252ZXJ0cyBhcmd1bWVudCB0byBhIHZhbHVlIG9mIHR5cGUgU3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIFN5bWJvbC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb252ZXJ0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogdmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJ3RvLXN0cmluZy14Jyk7XG4gKlxuICogJHRvU3RyaW5nKCk7IC8vICd1bmRlZmluZWQnXG4gKiAkdG9TdHJpbmcobnVsbCk7IC8vICdudWxsJ1xuICogJHRvU3RyaW5nKCdhYmMnKTsgLy8gJ2FiYydcbiAqICR0b1N0cmluZyh0cnVlKTsgLy8gJ3RydWUnXG4gKiAkdG9TdHJpbmcoU3ltYm9sKCdmb28nKSk7IC8vIFR5cGVFcnJvclxuICogJHRvU3RyaW5nKFN5bWJvbC5pdGVyYXRvcik7IC8vIFR5cGVFcnJvclxuICogJHRvU3RyaW5nKE9iamVjdChTeW1ib2wuaXRlcmF0b3IpKTsgLy8gVHlwZUVycm9yXG4gKiAkdG9TdHJpbmcoT2JqZWN0LmNyZWF0ZShudWxsKSk7IC8vIFR5cGVFcnJvclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFRvU3RyaW5nKHZhbHVlKSB7XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICB9XG5cbiAgcmV0dXJuIGNhc3RTdHJpbmcodmFsdWUpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgZW5kIG9mIGEgc3RyaW5nLlxuICogQHZlcnNpb24gMy4wLjBcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRyaW0tbGVmdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nID0gcmVxdWlyZSgncmVxdWlyZS1jb2VyY2libGUtdG8tc3RyaW5nLXgnKTtcbnZhciBSeCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLlJlZ0V4cDtcbnZhciByZUxlZnQyMDE2ID0gbmV3IFJ4KCdeWycgKyByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jykuc3RyaW5nMjAxNiArICddKycpO1xudmFyIHJlTGVmdDIwMTggPSBuZXcgUngoJ15bJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcyMDE4ICsgJ10rJyk7XG52YXIgcmVwbGFjZSA9ICcnLnJlcGxhY2U7XG5cbnZhciAkdHJpbUxlZnQyMDE2ID0gZnVuY3Rpb24gdHJpbUxlZnQyMDE2KHN0cmluZykge1xuICByZXR1cm4gcmVwbGFjZS5jYWxsKHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyhzdHJpbmcpLCByZUxlZnQyMDE2LCAnJyk7XG59O1xuXG52YXIgJHRyaW1MZWZ0MjAxOCA9IGZ1bmN0aW9uIHRyaW1MZWZ0MjAxOChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlcGxhY2UuY2FsbChyZXF1aXJlQ29lcmNpYmxlVG9TdHJpbmcoc3RyaW5nKSwgcmVMZWZ0MjAxOCwgJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byBsZWZ0VHJpbTIwMTguXG4gICAqL1xuICB0cmltTGVmdDogJHRyaW1MZWZ0MjAxOCxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgZW5kIG9mIGEgc3RyaW5nLiAoRVMyMDE2KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byB0cmltIHRoZSBsZWZ0IGVuZCB3aGl0ZXNwYWNlIGZyb20uXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBsZWZ0IHRyaW1tZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdHJpbUxlZnQgPSByZXF1aXJlKCd0cmltLWxlZnQteCcpLnRyaW1MZWZ0MjAxNjtcbiAgICpcbiAgICogdHJpbUxlZnQoJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSBcXHRcXG4nOyAvLyB0cnVlXG4gICAqL1xuICB0cmltTGVmdDIwMTY6ICR0cmltTGVmdDIwMTYsXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGVuZCBvZiBhIHN0cmluZy4gKEVTMjAxOClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgbGVmdCBlbmQgd2hpdGVzcGFjZSBmcm9tLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHN0cmluZyBpcyBudWxsIG9yIHVuZGVmaW5lZCBvciBub3QgY29lcmNpYmxlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbGVmdCB0cmltbWVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRyaW1MZWZ0ID0gcmVxdWlyZSgndHJpbS1sZWZ0LXgnKS50cmltTGVmdDIwMTg7XG4gICAqXG4gICAqIHRyaW1MZWZ0KCcgXFx0XFxuYSBcXHRcXG4nKSA9PT0gJ2EgXFx0XFxuJzsgLy8gdHJ1ZVxuICAgKi9cbiAgdHJpbUxlZnQyMDE4OiAkdHJpbUxlZnQyMDE4XG59O1xuIiwiLyoqXG4gKiBAZmlsZSBUaGlzIG1ldGhvZCByZW1vdmVzIHdoaXRlc3BhY2UgZnJvbSB0aGUgcmlnaHQgZW5kIG9mIGEgc3RyaW5nLlxuICogQHZlcnNpb24gMi4wLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRyaW0tcmlnaHQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVDb2VyY2libGVUb1N0cmluZyA9IHJlcXVpcmUoJ3JlcXVpcmUtY29lcmNpYmxlLXRvLXN0cmluZy14Jyk7XG52YXIgUnggPSByZXF1aXJlKCdjYWNoZWQtY29uc3RydWN0b3JzLXgnKS5SZWdFeHA7XG52YXIgcmVSaWdodCA9IG5ldyBSeCgnWycgKyByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jykuc3RyaW5nICsgJ10rJCcpO1xudmFyIHJlcGxhY2UgPSAnJy5yZXBsYWNlO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgcmlnaHQgZW5kIHdoaXRlc3BhY2UgZnJvbS5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgc3RyaW5nIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIG5vdCBjb2VyY2libGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmlnaHQgdHJpbW1lZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogdmFyIHRyaW1SaWdodCA9IHJlcXVpcmUoJ3RyaW0tcmlnaHQteCcpO1xuICpcbiAqIHRyaW1SaWdodCgnIFxcdFxcbmEgXFx0XFxuJykgPT09ICcgXFx0XFxuYSc7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmltUmlnaHQoc3RyaW5nKSB7XG4gIHJldHVybiByZXBsYWNlLmNhbGwocmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKHN0cmluZyksIHJlUmlnaHQsICcnKTtcbn07XG4iLCIvKipcbiAqIEBmaWxlIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gKiBAdmVyc2lvbiAyLjAuMlxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdHJpbS14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJpbUxlZnQgPSByZXF1aXJlKCd0cmltLWxlZnQteCcpO1xudmFyIHRyaW1SaWdodCA9IHJlcXVpcmUoJ3RyaW0tcmlnaHQteCcpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgd2hpdGVzcGFjZSBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBlbmQgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmltbWVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0teCcpO1xuICpcbiAqIHRyaW0oJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSc7IC8vIHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmltKHN0cmluZykge1xuICByZXR1cm4gdHJpbUxlZnQodHJpbVJpZ2h0KHN0cmluZykpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgVGhpcyBtZXRob2QgcmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gdGhlIGxlZnQgZW5kIG9mIGEgc3RyaW5nLlxuICogQHZlcnNpb24gMi4wLjFcbiAqIEBhdXRob3IgWG90aWM3NTAgPFhvdGljNzUwQGdtYWlsLmNvbT5cbiAqIEBjb3B5cmlnaHQgIFhvdGljNzUwXG4gKiBAbGljZW5zZSB7QGxpbmsgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPiBNSVR9XG4gKiBAbW9kdWxlIHRyaW0tbGVmdC14XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nID0gcmVxdWlyZSgncmVxdWlyZS1jb2VyY2libGUtdG8tc3RyaW5nLXgnKTtcbnZhciBSeCA9IHJlcXVpcmUoJ2NhY2hlZC1jb25zdHJ1Y3RvcnMteCcpLlJlZ0V4cDtcbnZhciByZUxlZnQgPSBuZXcgUngoJ15bJyArIHJlcXVpcmUoJ3doaXRlLXNwYWNlLXgnKS5zdHJpbmcgKyAnXSsnKTtcbnZhciByZXBsYWNlID0gJycucmVwbGFjZTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZW1vdmVzIHdoaXRlc3BhY2UgZnJvbSB0aGUgbGVmdCBlbmQgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBzdHJpbmcgdG8gdHJpbSB0aGUgbGVmdCBlbmQgd2hpdGVzcGFjZSBmcm9tLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBzdHJpbmcgaXMgbnVsbCBvciB1bmRlZmluZWQgb3Igbm90IGNvZXJjaWJsZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBsZWZ0IHRyaW1tZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqIHZhciB0cmltTGVmdCA9IHJlcXVpcmUoJ3RyaW0tbGVmdC14Jyk7XG4gKlxuICogdHJpbUxlZnQoJyBcXHRcXG5hIFxcdFxcbicpID09PSAnYSBcXHRcXG4nOyAvLyB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJpbUxlZnQoc3RyaW5nKSB7XG4gIHJldHVybiByZXBsYWNlLmNhbGwocmVxdWlyZUNvZXJjaWJsZVRvU3RyaW5nKHN0cmluZyksIHJlTGVmdCwgJycpO1xufTtcbiIsIi8qKlxuICogQGZpbGUgQW4gaW1wbGVtZW50YXRpb24gb2Ygbm9kZSdzIHV0aWwuZm9ybWF0XG4gKiBAdmVyc2lvbiAxLjMuMFxuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgdXRpbC1mb3JtYXQteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCdpbnNwZWN0LXgnKTtcbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG52YXIgc2FmZVRvU3RyaW5nID0gcmVxdWlyZSgnc2FmZS10by1zdHJpbmcteCcpO1xudmFyIGlzTnVsbCA9IHJlcXVpcmUoJ2xvZGFzaC5pc251bGwnKTtcblxudmFyIENJUkNVTEFSX0VSUk9SX01FU1NBR0U7XG52YXIgdHJ5U3RyaW5naWZ5ID0gZnVuY3Rpb24gX3RyeVN0cmluZ2lmeShhcmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTjMuc3RyaW5naWZ5KGFyZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFBvcHVsYXRlIHRoZSBjaXJjdWxhciBlcnJvciBtZXNzYWdlIGxhemlseVxuICAgIGlmICghQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGEgPSB7fTtcbiAgICAgICAgYS5hID0gYTtcbiAgICAgICAgSlNPTjMuc3RyaW5naWZ5KGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFID0gZS5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgZXJyLm1lc3NhZ2UgPT09IENJUkNVTEFSX0VSUk9SX01FU1NBR0UpIHtcbiAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxudmFyIGZvcm1hdCA9IGZ1bmN0aW9uIF9mb3JtYXQoZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIG9iamVjdHNbaW5kZXhdID0gaW5zcGVjdChhcmd1bWVudHNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgYSA9IDE7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmLmxlbmd0aDspIHtcbiAgICBpZiAoZi5jaGFyQ29kZUF0KGkpID09PSAzNy8qICclJyovICYmIGkgKyAxIDwgZi5sZW5ndGgpIHtcbiAgICAgIGlmIChmLmNoYXJDb2RlQXQoaSArIDEpICE9PSAzNy8qICclJyovICYmIGEgPj0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGYuY2hhckNvZGVBdChpICsgMSkpIHtcbiAgICAgIGNhc2UgMTAwOiAvLyAnZCdcbiAgICAgICAgaWYgKGxhc3RQb3MgPCBpKSB7XG4gICAgICAgICAgc3RyICs9IGYuc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gTnVtYmVyKGFyZ3VtZW50c1thXSk7XG4gICAgICAgIGEgKz0gMTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDU6IC8vICdpJ1xuICAgICAgICBpZiAobGFzdFBvcyA8IGkpIHtcbiAgICAgICAgICBzdHIgKz0gZi5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBwYXJzZUludChhcmd1bWVudHNbYV0sIDEwKTtcbiAgICAgICAgYSArPSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMjogLy8gJ2YnXG4gICAgICAgIGlmIChsYXN0UG9zIDwgaSkge1xuICAgICAgICAgIHN0ciArPSBmLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IHBhcnNlRmxvYXQoYXJndW1lbnRzW2FdKTtcbiAgICAgICAgYSArPSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwNjogLy8gJ2onXG4gICAgICAgIGlmIChsYXN0UG9zIDwgaSkge1xuICAgICAgICAgIHN0ciArPSBmLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IHRyeVN0cmluZ2lmeShhcmd1bWVudHNbYV0pO1xuICAgICAgICBhICs9IDE7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTE1OiAvLyAncydcbiAgICAgICAgaWYgKGxhc3RQb3MgPCBpKSB7XG4gICAgICAgICAgc3RyICs9IGYuc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gc2FmZVRvU3RyaW5nKGFyZ3VtZW50c1thXSk7XG4gICAgICAgIGEgKz0gMTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNzogLy8gJyUnXG4gICAgICAgIGlmIChsYXN0UG9zIDwgaSkge1xuICAgICAgICAgIHN0ciArPSBmLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9ICclJztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gYW55IG90aGVyIGNoYXJhY3RlciBpcyBub3QgYSBjb3JyZWN0IHBsYWNlaG9sZGVyXG4gICAgICAgIGlmIChsYXN0UG9zIDwgaSkge1xuICAgICAgICAgIHN0ciArPSBmLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9ICclJztcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBsYXN0UG9zID0gaTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMjtcbiAgICAgIGxhc3RQb3MgPSBpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIH1cblxuICAgIGkgKz0gMTtcbiAgfVxuXG4gIGlmIChsYXN0UG9zID09PSAwKSB7XG4gICAgc3RyID0gZjtcbiAgfSBlbHNlIGlmIChsYXN0UG9zIDwgZi5sZW5ndGgpIHtcbiAgICBzdHIgKz0gZi5zbGljZShsYXN0UG9zKTtcbiAgfVxuXG4gIHdoaWxlIChhIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzW2FdO1xuICAgIGEgKz0gMTtcblxuICAgIGlmIChpc051bGwoeCkgfHwgKHR5cGVvZiB4ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgeCAhPT0gJ3N5bWJvbCcpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogVGhlIGZvcm1hdCgpIG1ldGhvZCByZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyB1c2luZyB0aGUgZmlyc3QgYXJndW1lbnQgYXMgYVxuICogcHJpbnRmLWxpa2UgZm9ybWF0LlxuICpcbiAqIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBjb250YWluaW5nIHplcm8gb3IgbW9yZSBwbGFjZWhvbGRlciB0b2tlbnMuXG4gKiBFYWNoIHBsYWNlaG9sZGVyIHRva2VuIGlzIHJlcGxhY2VkIHdpdGggdGhlIGNvbnZlcnRlZCB2YWx1ZSBmcm9tIHRoZVxuICogY29ycmVzcG9uZGluZyBhcmd1bWVudC4gU3VwcG9ydGVkIHBsYWNlaG9sZGVycyBhcmU6XG4gKlxuICogJXMgLSBTdHJpbmcuXG4gKiAlZCAtIE51bWJlciAoaW50ZWdlciBvciBmbG9hdGluZyBwb2ludCB2YWx1ZSkuXG4gKiAlaSAtIEludGVnZXIuXG4gKiAlZiAtIEZsb2F0aW5nIHBvaW50IHZhbHVlLlxuICogJWogLSBKU09OLiBSZXBsYWNlZCB3aXRoIHRoZSBzdHJpbmcgJ1tDaXJjdWxhcl0nIGlmIHRoZSBhcmd1bWVudCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLlxuICogJSUgLSBzaW5nbGUgcGVyY2VudCBzaWduICgnJScpLiBUaGlzIGRvZXMgbm90IGNvbnN1bWUgYW4gYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGYgLSBUZW1wbGF0ZS5cbiAqIEBwYXJhbSB7Kn0gWy4uLmFyZ3NdIC0gVmFsdWVzLlxuICogQHJldHVybnMgeyp9IFRoZSB0YXJnZXQuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZvcm1hdCA9IHJlcXVpcmUoJ3V0aWwtZm9ybWF0LXgnKTtcbiAqXG4gKiAvLyBJZiB0aGUgcGxhY2Vob2xkZXIgZG9lcyBub3QgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgYXJndW1lbnQsXG4gKiAvLyB0aGUgcGxhY2Vob2xkZXIgaXMgbm90IHJlcGxhY2VkLlxuICogZm9ybWF0KCclczolcycsICdmb28nKTsgLy8gUmV0dXJuczogJ2ZvbzolcydcbiAqXG4gKiAvLyBJZiB0aGVyZSBhcmUgbW9yZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmb3JtYXQoKSBtZXRob2QgdGhhbiB0aGUgbnVtYmVyXG4gKiAvLyBvZiBwbGFjZWhvbGRlcnMsIHRoZSBleHRyYSBhcmd1bWVudHMgYXJlIGNvZXJjZWQgaW50byBzdHJpbmdzIChmb3Igb2JqZWN0c1xuICogLy8gYW5kIHN5bWJvbHMsIGluc3BlY3QoKSBpcyB1c2VkKSB0aGVuIGNvbmNhdGVuYXRlZCB0byB0aGUgcmV0dXJuZWRcbiAqIC8vIHN0cmluZywgZWFjaCBkZWxpbWl0ZWQgYnkgYSBzcGFjZS5cbiAqIGZvcm1hdCgnJXM6JXMnLCAnZm9vJywgJ2JhcicsICdiYXonKTsgLy8gJ2ZvbzpiYXIgYmF6J1xuICpcbiAqIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBub3QgYSBmb3JtYXQgc3RyaW5nIHRoZW4gZm9ybWF0KCkgcmV0dXJucyBhXG4gKiAvLyBzdHJpbmcgdGhhdCBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgYXJndW1lbnRzIHNlcGFyYXRlZCBieSBzcGFjZXMuXG4gKiAvLyBFYWNoIGFyZ3VtZW50IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyB1c2luZyBpbnNwZWN0KCkuXG4gKiBmb3JtYXQoMSwgMiwgMyk7IC8vICcxIDIgMydcbiAqXG4gKiAvLyBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWQgdG8gZm9ybWF0KCksIGl0IGlzIHJldHVybmVkIGFzIGl0IGlzXG4gKiAvL3dpdGhvdXQgYW55IGZvcm1hdHRpbmcuXG4gKiBmb3JtYXQoJyUlICVzJyk7IC8vICclJSAlcydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXQ7XG4iLCIvKipcbipcbipcdFZBTElEQVRFOiB1bmRlZmluZWRcbipcbipcbipcdERFU0NSSVBUSU9OOlxuKlx0XHQtIFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZC5cbipcbipcbipcdE5PVEVTOlxuKlx0XHRbMV1cbipcbipcbipcdFRPRE86XG4qXHRcdFsxXVxuKlxuKlxuKlx0TElDRU5TRTpcbipcdFx0TUlUXG4qXG4qXHRDb3B5cmlnaHQgKGMpIDIwMTQuIEF0aGFuIFJlaW5lcy5cbipcbipcbipcdEFVVEhPUjpcbipcdFx0QXRoYW4gUmVpbmVzLiBrZ3J5dGVAZ21haWwuY29tLiAyMDE0LlxuKlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiogRlVOQ1RJT046IGlzVW5kZWZpbmVkKCB2YWx1ZSApXG4qXHRWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWQuXG4qXG4qIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWRcbiogQHJldHVybnMge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHZhbHVlIGlzIHVuZGVmaW5lZFxuKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKCB2YWx1ZSApIHtcblx0cmV0dXJuIHZhbHVlID09PSB2b2lkIDA7XG59IC8vIGVuZCBGVU5DVElPTiBpc1VuZGVmaW5lZCgpXG5cblxuLy8gRVhQT1JUUyAvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVW5kZWZpbmVkO1xuIiwiLyoqXG4gKiBAZmlsZSBMaXN0IG9mIEVDTUFTY3JpcHQ1IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMuXG4gKiBAdmVyc2lvbiAyLjAuM1xuICogQGF1dGhvciBYb3RpYzc1MCA8WG90aWM3NTBAZ21haWwuY29tPlxuICogQGNvcHlyaWdodCAgWG90aWM3NTBcbiAqIEBsaWNlbnNlIHtAbGluayA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+IE1JVH1cbiAqIEBtb2R1bGUgd2hpdGUtc3BhY2UteFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBbiBhcnJheSBvZiB0aGUgRVM1IHdoaXRlc3BhY2UgY2hhciBjb2Rlcywgc3RyaW5nLCBhbmQgdGhlaXIgZGVzY3JpcHRpb25zLlxuICpcbiAqIEBuYW1lIGxpc3RcbiAqIEB0eXBlIEFycmF5LjxPYmplY3Q+XG4gKiBAZXhhbXBsZVxuICogdmFyIHdoaXRlU3BhY2UgPSByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jyk7XG4gKiB3aGl0ZVNwYWNlcy5saXN0LmZvcmVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAqICAgY29uc29sZS5sb2cobGliLmRlc2NyaXB0aW9uLCBpdGVtLmNvZGUsIGl0ZW0uc3RyaW5nKTtcbiAqIH0pO1xuICovXG52YXIgbGlzdCA9IFtcbiAge1xuICAgIGNvZGU6IDB4MDAwOSxcbiAgICBkZXNjcmlwdGlvbjogJ1RhYicsXG4gICAgc3RyaW5nOiAnXFx1MDAwOSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAwYSxcbiAgICBkZXNjcmlwdGlvbjogJ0xpbmUgRmVlZCcsXG4gICAgc3RyaW5nOiAnXFx1MDAwYSdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAwYixcbiAgICBkZXNjcmlwdGlvbjogJ1ZlcnRpY2FsIFRhYicsXG4gICAgc3RyaW5nOiAnXFx1MDAwYidcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAwYyxcbiAgICBkZXNjcmlwdGlvbjogJ0Zvcm0gRmVlZCcsXG4gICAgc3RyaW5nOiAnXFx1MDAwYydcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAwZCxcbiAgICBkZXNjcmlwdGlvbjogJ0NhcnJpYWdlIFJldHVybicsXG4gICAgc3RyaW5nOiAnXFx1MDAwZCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MDAyMCxcbiAgICBkZXNjcmlwdGlvbjogJ1NwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUwMDIwJ1xuICB9LFxuICAvKlxuICB7XG4gICAgY29kZTogMHgwMDg1LFxuICAgIGRlc2NyaXB0aW9uOiAnTmV4dCBsaW5lIC0gTm90IEVTNSB3aGl0ZXNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUwMDg1J1xuICB9XG4gICovXG4gIHtcbiAgICBjb2RlOiAweDAwYTAsXG4gICAgZGVzY3JpcHRpb246ICdOby1icmVhayBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MDBhMCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MTY4MCxcbiAgICBkZXNjcmlwdGlvbjogJ09naGFtIHNwYWNlIG1hcmsnLFxuICAgIHN0cmluZzogJ1xcdTE2ODAnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDE4MGUsXG4gICAgZGVzY3JpcHRpb246ICdNb25nb2xpYW4gdm93ZWwgc2VwYXJhdG9yJyxcbiAgICBzdHJpbmc6ICdcXHUxODBlJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDAwLFxuICAgIGRlc2NyaXB0aW9uOiAnRW4gcXVhZCcsXG4gICAgc3RyaW5nOiAnXFx1MjAwMCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwMSxcbiAgICBkZXNjcmlwdGlvbjogJ0VtIHF1YWQnLFxuICAgIHN0cmluZzogJ1xcdTIwMDEnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDIsXG4gICAgZGVzY3JpcHRpb246ICdFbiBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjAwMidcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAwMyxcbiAgICBkZXNjcmlwdGlvbjogJ0VtIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDAzJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA0LFxuICAgIGRlc2NyaXB0aW9uOiAnVGhyZWUtcGVyLWVtIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDA0J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA1LFxuICAgIGRlc2NyaXB0aW9uOiAnRm91ci1wZXItZW0gc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTIwMDUnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDYsXG4gICAgZGVzY3JpcHRpb246ICdTaXgtcGVyLWVtIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDA2J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA3LFxuICAgIGRlc2NyaXB0aW9uOiAnRmlndXJlIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDA3J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDA4LFxuICAgIGRlc2NyaXB0aW9uOiAnUHVuY3R1YXRpb24gc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTIwMDgnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMDksXG4gICAgZGVzY3JpcHRpb246ICdUaGluIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDA5J1xuICB9LFxuICB7XG4gICAgY29kZTogMHgyMDBhLFxuICAgIGRlc2NyaXB0aW9uOiAnSGFpciBzcGFjZScsXG4gICAgc3RyaW5nOiAnXFx1MjAwYSdcbiAgfSxcbiAgLypcbiAge1xuICAgIGNvZGU6IDB4MjAwYixcbiAgICBkZXNjcmlwdGlvbjogJ1plcm8gd2lkdGggc3BhY2UgLSBOb3QgRVM1IHdoaXRlc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTIwMGInXG4gIH0sXG4gICovXG4gIHtcbiAgICBjb2RlOiAweDIwMjgsXG4gICAgZGVzY3JpcHRpb246ICdMaW5lIHNlcGFyYXRvcicsXG4gICAgc3RyaW5nOiAnXFx1MjAyOCdcbiAgfSxcbiAge1xuICAgIGNvZGU6IDB4MjAyOSxcbiAgICBkZXNjcmlwdGlvbjogJ1BhcmFncmFwaCBzZXBhcmF0b3InLFxuICAgIHN0cmluZzogJ1xcdTIwMjknXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwMmYsXG4gICAgZGVzY3JpcHRpb246ICdOYXJyb3cgbm8tYnJlYWsgc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTIwMmYnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweDIwNWYsXG4gICAgZGVzY3JpcHRpb246ICdNZWRpdW0gbWF0aGVtYXRpY2FsIHNwYWNlJyxcbiAgICBzdHJpbmc6ICdcXHUyMDVmJ1xuICB9LFxuICB7XG4gICAgY29kZTogMHgzMDAwLFxuICAgIGRlc2NyaXB0aW9uOiAnSWRlb2dyYXBoaWMgc3BhY2UnLFxuICAgIHN0cmluZzogJ1xcdTMwMDAnXG4gIH0sXG4gIHtcbiAgICBjb2RlOiAweGZlZmYsXG4gICAgZGVzY3JpcHRpb246ICdCeXRlIE9yZGVyIE1hcmsnLFxuICAgIHN0cmluZzogJ1xcdWZlZmYnXG4gIH1cbl07XG5cbnZhciBzdHJpbmcgPSAnJztcbnZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbmZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgc3RyaW5nICs9IGxpc3RbaV0uc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgc3RyaW5nIG9mIHRoZSBFUzUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICpcbiAqIEBuYW1lIHN0cmluZ1xuICogQHR5cGUgc3RyaW5nXG4gKiBAZXhhbXBsZVxuICogdmFyIHdoaXRlU3BhY2UgPSByZXF1aXJlKCd3aGl0ZS1zcGFjZS14Jyk7XG4gKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAqICAgJ1xcdTAwMDknLFxuICogICAnXFx1MDAwYScsXG4gKiAgICdcXHUwMDBiJyxcbiAqICAgJ1xcdTAwMGMnLFxuICogICAnXFx1MDAwZCcsXG4gKiAgICdcXHUwMDIwJyxcbiAqICAgJ1xcdTAwYTAnLFxuICogICAnXFx1MTY4MCcsXG4gKiAgICdcXHUxODBlJyxcbiAqICAgJ1xcdTIwMDAnLFxuICogICAnXFx1MjAwMScsXG4gKiAgICdcXHUyMDAyJyxcbiAqICAgJ1xcdTIwMDMnLFxuICogICAnXFx1MjAwNCcsXG4gKiAgICdcXHUyMDA1JyxcbiAqICAgJ1xcdTIwMDYnLFxuICogICAnXFx1MjAwNycsXG4gKiAgICdcXHUyMDA4JyxcbiAqICAgJ1xcdTIwMDknLFxuICogICAnXFx1MjAwYScsXG4gKiAgICdcXHUyMDI4JyxcbiAqICAgJ1xcdTIwMjknLFxuICogICAnXFx1MjAyZicsXG4gKiAgICdcXHUyMDVmJyxcbiAqICAgJ1xcdTMwMDAnLFxuICogICAnXFx1ZmVmZidcbiAqIF07XG4gKiB2YXIgd3MgPSBjaGFyYWN0ZXJzLmpvaW4oJycpO1xuICogdmFyIHJlMSA9IG5ldyBSZWdFeHAoJ15bJyArIHdoaXRlU3BhY2Uuc3RyaW5nICsgJ10rJCknKTtcbiAqIHJlMS50ZXN0KHdzKTsgLy8gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGlzdDogbGlzdCxcbiAgc3RyaW5nOiBzdHJpbmdcbn07XG4iLCJjb25zdCBmb3JtYXQgPSByZXF1aXJlKCd1dGlsLWZvcm1hdC14Jyk7XG5jb25zdCBzdXBlcmFnZW50ID0gcmVxdWlyZSgnQGxhZGpzL3N1cGVyYWdlbnQnKTtcbmNvbnN0IGN1aWQgPSByZXF1aXJlKCdjdWlkJyk7XG5jb25zdCBwYXJzZUVyciA9IHJlcXVpcmUoJ3BhcnNlLWVycicpO1xuY29uc3Qgc2FmZVN0cmluZ2lmeSA9IHJlcXVpcmUoJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknKTtcbi8vIDxodHRwczovL2xhY2tlLm1uL3JlZHVjZS15b3VyLWJ1bmRsZS1qcy1maWxlLXNpemUvPlxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvYmFiZWwtcGx1Z2luLWxvZGFzaC9pc3N1ZXMvMjIxPlxuY29uc3QgaXNFcnJvciA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Vycm9yJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc09iamVjdCcpO1xuY29uc3QgaXNTdHJpbmcgPSByZXF1aXJlKCdsb2Rhc2gvaXNTdHJpbmcnKTtcbmNvbnN0IGluY2x1ZGVzID0gcmVxdWlyZSgnbG9kYXNoL2luY2x1ZGVzJyk7XG5jb25zdCBvbWl0ID0gcmVxdWlyZSgnbG9kYXNoL29taXQnKTtcbmNvbnN0IGlzRW1wdHkgPSByZXF1aXJlKCdsb2Rhc2gvaXNFbXB0eScpO1xuY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5jb25zdCBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1VuZGVmaW5lZCcpO1xuY29uc3QgaXNOdWxsID0gcmVxdWlyZSgnbG9kYXNoL2lzTnVsbCcpO1xuY29uc3QgYm9vbGVhbiA9IHJlcXVpcmUoJ2Jvb2xlYW4nKTtcbmNvbnN0IHsgc3RhbmRhcmQgfSA9IHJlcXVpcmUoJ21lc3NhZ2UtaGVhZGVycycpO1xuY29uc3QgZm9ybWF0U3BlY2lmaWVycyA9IHJlcXVpcmUoJ2Zvcm1hdC1zcGVjaWZpZXJzJyk7XG5cbmNvbnN0IHN0YW5kYXJkSGVhZGVycyA9IHN0YW5kYXJkLm1hcChvID0+IG9bJ0hlYWRlciBGaWVsZCBOYW1lJ10udG9Mb3dlckNhc2UoKSk7XG5cbmNvbnN0IGhhc1dpbmRvdyA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVuYXNzaWduZWQtaW1wb3J0XG5yZXF1aXJlKCdjb25zb2xlLXBvbHlmaWxsJyk7XG5cbmNvbnN0IGxldmVscyA9IFsndHJhY2UnLCAnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ2ZhdGFsJ107XG5jb25zdCBlbmRwb2ludCA9ICdodHRwczovL2FwaS5jYWJpbmpzLmNvbSc7XG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xuXG5jbGFzcyBBeGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAga2V5OiAnJyxcbiAgICAgIGVuZHBvaW50LFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgcmV0cnk6IDMsXG4gICAgICBzaG93U3RhY2s6IGJvb2xlYW4ocHJvY2Vzcy5lbnYuU0hPV19TVEFDSyB8fCBlbnYgIT09ICdwcm9kdWN0aW9uJyksXG4gICAgICBzaG93TWV0YTogYm9vbGVhbihwcm9jZXNzLmVudi5TSE9XX01FVEEpLFxuICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgIGxvZ2dlcjogY29uc29sZSxcbiAgICAgIGxldmVsczogWydpbmZvJywgJ3dhcm4nLCAnZXJyb3InLCAnZmF0YWwnXSxcbiAgICAgIGNhcHR1cmU6IGVudiA9PT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb21pdCh0aGlzLmNvbmZpZy5sb2dnZXIsIFsnY29uZmlnJywgJ2xvZyddKSk7XG5cbiAgICAvLyB3ZSBjb3VsZCBoYXZlIHVzZWQgYGF1dG8tYmluZGAgYnV0IGl0J3Mgbm90IGNvbXBpbGVkIGZvciBicm93c2VyXG4gICAgdGhpcy5sb2cgPSB0aGlzLmxvZy5iaW5kKHRoaXMpO1xuXG4gICAgLy8gYmluZCBoZWxwZXIgZnVuY3Rpb25zIGZvciBlYWNoIGxvZyBsZXZlbFxuICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIHRoaXNbbGV2ZWxdID0gKC4uLmFyZ3MpID0+XG4gICAgICAgIHRoaXMubG9nKC4uLltsZXZlbF0uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICB9KTtcblxuICAgIC8vIGFsaWFzZXNcbiAgICB0aGlzLmVyciA9IHRoaXMuZXJyb3I7XG4gICAgdGhpcy53YXJuaW5nID0gdGhpcy53YXJuO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgbG9nKGxldmVsLCBtZXNzYWdlLCBtZXRhLCAuLi5hcmdzKSB7XG4gICAgbGV0IG9yaWdpbmFsQXJncyA9IFtsZXZlbCwgbWVzc2FnZV07XG4gICAgaWYgKCFpc1VuZGVmaW5lZChtZXRhKSkgb3JpZ2luYWxBcmdzLnB1c2gobWV0YSk7XG4gICAgb3JpZ2luYWxBcmdzID0gb3JpZ2luYWxBcmdzLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gdGhpcztcbiAgICBsZXQgbW9kaWZpZXIgPSAwO1xuXG4gICAgaWYgKGxldmVsID09PSAnd2FybmluZycpIGxldmVsID0gJ3dhcm4nO1xuICAgIGlmIChsZXZlbCA9PT0gJ2VycicpIGxldmVsID0gJ2Vycm9yJztcblxuICAgIGlmIChpc0Vycm9yKGxldmVsKSkge1xuICAgICAgbWV0YSA9IG1lc3NhZ2U7XG4gICAgICBtZXNzYWdlID0gbGV2ZWw7XG4gICAgICBsZXZlbCA9ICdlcnJvcic7XG4gICAgfSBlbHNlIGlmICghaXNTdHJpbmcobGV2ZWwpIHx8ICFpbmNsdWRlcyhsZXZlbHMsIGxldmVsKSkge1xuICAgICAgbWV0YSA9IG1lc3NhZ2U7XG4gICAgICBtZXNzYWdlID0gbGV2ZWw7XG4gICAgICBsZXZlbCA9ICdpbmZvJztcbiAgICAgIG1vZGlmaWVyID0gLTE7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgYXJlIGZvdXIgb3IgbW9yZSBhcmdzXG4gICAgLy8gdGhlbiBpbmZlciB0byB1c2UgdXRpbC5mb3JtYXQgb24gZXZlcnl0aGluZ1xuICAgIGlmIChvcmlnaW5hbEFyZ3MubGVuZ3RoID49IDQgKyBtb2RpZmllcikge1xuICAgICAgbWVzc2FnZSA9IGZvcm1hdCguLi5vcmlnaW5hbEFyZ3Muc2xpY2UoMSArIG1vZGlmaWVyKSk7XG4gICAgICBtZXRhID0ge307XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9yaWdpbmFsQXJncy5sZW5ndGggPT09IDMgKyBtb2RpZmllciAmJlxuICAgICAgaXNTdHJpbmcobWVzc2FnZSkgJiZcbiAgICAgIGZvcm1hdFNwZWNpZmllcnMuc29tZSh0ID0+IGluY2x1ZGVzKG1lc3NhZ2UsIHQpKVxuICAgICkge1xuICAgICAgLy8gb3RoZXJ3aXNlIGlmIHRoZXJlIGFyZSB0aHJlZSBhcmdzIGFuZCBpZiB0aGUgYG1lc3NhZ2VgIGNvbnRhaW5zXG4gICAgICAvLyBhIHBsYWNlaG9sZGVyIHRva2VuIChlLmcuICclcycgb3IgJyVkJyAtIHNlZSBhYm92ZSBgZm9ybWF0U3BlY2lmaWVyc2AgdmFyaWFibGUpXG4gICAgICAvLyB0aGVuIHdlIGNhbiBpbmZlciB0aGF0IHRoZSBgbWV0YWAgYXJnIHBhc3NlZCBpcyB1c2VkIGZvciBmb3JtYXR0aW5nXG4gICAgICBtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIG1ldGEpO1xuICAgICAgbWV0YSA9IHt9O1xuICAgIH0gZWxzZSBpZiAoIWlzRXJyb3IobWVzc2FnZSkpIHtcbiAgICAgIGlmIChpc0Vycm9yKG1ldGEpKSB7XG4gICAgICAgIG1ldGEgPSB7IGVycjogcGFyc2VFcnIobWV0YSkgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzUGxhaW5PYmplY3QobWV0YSkgJiYgIWlzVW5kZWZpbmVkKG1ldGEpICYmICFpc051bGwobWV0YSkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGBtZXRhYCB2YXJpYWJsZSBwYXNzZWQgd2FzIG5vdCBhbiBPYmplY3QgdGhlbiBjb252ZXJ0IGl0XG4gICAgICAgIG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgbWV0YSk7XG4gICAgICAgIG1ldGEgPSB7fTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKG1lc3NhZ2UpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBtZXNzYWdlIGlzIG5vdCBhIHN0cmluZyB0aGVuIHdlIHNob3VsZCBydW4gYHV0aWwuZm9ybWF0YCBvbiBpdFxuICAgICAgICAvLyBhc3N1bWluZyB3ZSdyZSBmb3JtYXR0aW5nIGl0IGxpa2UgaXQgd2FzIGFub3RoZXIgYXJndW1lbnRcbiAgICAgICAgLy8gKGFzIG9wcG9zZWQgdG8gdXNpbmcgc29tZXRoaW5nIGxpa2UgZmFzdC1qc29uLXN0cmluZ2lmeSlcbiAgICAgICAgbWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QobWV0YSkpIG1ldGEgPSB7fTtcblxuICAgIGxldCBlcnI7XG4gICAgaWYgKGlzRXJyb3IobWVzc2FnZSkpIHtcbiAgICAgIGVyciA9IG1lc3NhZ2U7XG4gICAgICBpZiAoIWlzT2JqZWN0KG1ldGEuZXJyKSkgbWV0YS5lcnIgPSBwYXJzZUVycihlcnIpO1xuICAgICAgKHsgbWVzc2FnZSB9ID0gbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgbGV2ZWwgb24gbWV0YVxuICAgIG1ldGEubGV2ZWwgPSBsZXZlbDtcblxuICAgIC8vIHNldCB0aGUgYm9keSB1c2VkIGZvciByZXR1cm5pbmcgd2l0aCBhbmQgc2VuZGluZyBsb2dzXG4gICAgLy8gKGFuZCBhbHNvIHJlbW92ZSBjaXJjdWxhciByZWZlcmVuY2VzKVxuICAgIGNvbnN0IGJvZHkgPSBzYWZlU3RyaW5naWZ5KHsgbWVzc2FnZSwgbWV0YSB9KTtcblxuICAgIC8vIHNlbmQgdG8gQ2FiaW4gb3Igb3RoZXIgbG9nZ2luZyBzZXJ2aWNlIGhlcmUgdGhlIGBtZXNzYWdlYCBhbmQgYG1ldGFgXG4gICAgaWYgKFxuICAgICAgY29uZmlnLmNhcHR1cmUgJiZcbiAgICAgIGluY2x1ZGVzKGNvbmZpZy5sZXZlbHMsIGxldmVsKSAmJlxuICAgICAgKCFpc0Vycm9yKGVycikgfHwgIWVyci5fY2FwdHVyZUZhaWxlZClcbiAgICApIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGRpZG4ndCBzcGVjaWZ5IGEga2V5XG4gICAgICAvLyBhbmQgdGhleSBhcmUgdXNpbmcgdGhlIGRlZmF1bHQgZW5kcG9pbnRcbiAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIHRocm93IGFuIGVycm9yIHRvIHRoZW1cbiAgICAgIGlmIChjb25maWcuZW5kcG9pbnQgPT09IGVuZHBvaW50ICYmICFjb25maWcua2V5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYWJpbiBBUEkga2V5IHJlcXVpcmVkIChlLmcuIGB7IGtleTogJ1lPVVItQ0FCSU4tQVBJLUtFWScgfSlgKVxcbjxodHRwczovL2NhYmluanMuY29tPlwiXG4gICAgICAgICk7XG5cbiAgICAgIC8vIGNhcHR1cmUgdGhlIGxvZyBvdmVyIEhUVFBcbiAgICAgIGNvbnN0IHJlcSA9IHN1cGVyYWdlbnRcbiAgICAgICAgLnBvc3QoY29uZmlnLmVuZHBvaW50KVxuICAgICAgICAuc2V0KCdYLVJlcXVlc3QtSWQnLCBjdWlkKCkpXG4gICAgICAgIC50aW1lb3V0KGNvbmZpZy50aW1lb3V0KTtcblxuICAgICAgLy8gYmFzaWMgYXV0aCAoZS5nLiBDYWJpbiBBUEkga2V5KVxuICAgICAgaWYgKGNvbmZpZy5rZXkpIHJlcS5hdXRoKGNvbmZpZy5rZXkpO1xuXG4gICAgICAvLyBzZXQgaGVhZGVycyBpZiBhbnlcbiAgICAgIGlmICghaXNFbXB0eShjb25maWcuaGVhZGVycykpIHtcbiAgICAgICAgbGV0IHsgaGVhZGVycyB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoaGFzV2luZG93KVxuICAgICAgICAgIGhlYWRlcnMgPSBPYmplY3Qua2V5cyhjb25maWcuaGVhZGVycykucmVkdWNlKChtZW1vLCBoZWFkZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIWluY2x1ZGVzKHN0YW5kYXJkSGVhZGVycywgY29uZmlnLmhlYWRlcnNbaGVhZGVyXS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBtZW1vW2hlYWRlcl0gPSBjb25maWcuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICByZXEuc2V0KGhlYWRlcnMpO1xuICAgICAgfVxuXG4gICAgICByZXFcbiAgICAgICAgLnJldHJ5KGNvbmZpZy5yZXRyeSlcbiAgICAgICAgLnNlbmQoYm9keSlcbiAgICAgICAgLmVuZChlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5fY2FwdHVyZUZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5sb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN1cHByZXNzIGxvZ3MgaWYgaXQgd2FzIHNpbGVudFxuICAgIGlmIChjb25maWcuc2lsZW50KSByZXR1cm4gYm9keTtcblxuICAgIC8vIGlmIHRoZXJlIHdhcyBtZXRhIGluZm9ybWF0aW9uIHRoZW4gb3V0cHV0IGl0XG4gICAgY29uc3Qgb21pdHRlZCA9IG9taXQobWV0YSwgWydsZXZlbCcsICdlcnInXSk7XG5cbiAgICAvLyBmYXRhbCBzaG91bGQgdXNlIGVycm9yIChlLmcuIGluIGJyb3dzZXIpXG4gICAgaWYgKGxldmVsID09PSAnZmF0YWwnKSBsZXZlbCA9ICdlcnJvcic7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgcGFzcyBhIGxldmVsIGFzIGEgbWV0aG9kXG4gICAgLy8gKGUuZy4gY29uc29sZS5pbmZvKSwgdGhlbiB3ZSBzaG91bGQgc3RpbGxcbiAgICAvLyB1c2UgdGhlIGxvZ2dlcidzIGBsb2dgIG1ldGhvZCB0byBvdXRwdXRcbiAgICBpZiAobW9kaWZpZXIgPT09IC0xKSBsZXZlbCA9ICdsb2cnO1xuXG4gICAgLy8gc2hvdyBzdGFjayB0cmFjZSBpZiBuZWNlc3NhcnkgKGFsb25nIHdpdGggYW55IG1ldGFkYXRhKVxuICAgIGlmIChsZXZlbCA9PT0gJ2Vycm9yJyAmJiBpc0Vycm9yKGVycikgJiYgY29uZmlnLnNob3dTdGFjaykge1xuICAgICAgaWYgKCFjb25maWcuc2hvd01ldGEgfHwgaXNFbXB0eShvbWl0dGVkKSkgdGhpcy5jb25maWcubG9nZ2VyLmVycm9yKGVycik7XG4gICAgICBlbHNlIHRoaXMuY29uZmlnLmxvZ2dlci5lcnJvcihlcnIsIG9taXR0ZWQpO1xuICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5zaG93TWV0YSB8fCBpc0VtcHR5KG9taXR0ZWQpKSB7XG4gICAgICB0aGlzLmNvbmZpZy5sb2dnZXJbbGV2ZWxdKG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbmZpZy5sb2dnZXJbbGV2ZWxdKG1lc3NhZ2UsIG9taXR0ZWQpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgcGFyc2VkIGJvZHkgaW4gY2FzZSB3ZSBuZWVkIGl0XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBeGU7XG4iXX0=
